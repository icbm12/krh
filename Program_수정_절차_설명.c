
나보다 땀을 많이 흘렸다면 금메달을 가져가도 좋다.
If you more shed sweat than me that you may take the gold medal

[1]	C언어 핵심 요약
1. 상수를 이용한 프로그램
1)변환 문자열
Printf(“ “)할 때
변환 문자열			의미
 %d				부호가 있는 10진수 형태로 출력
 %u				무부호 10진수 형태로 출력
 %o				8진수
 %x				16진수
 %f				실수(소수점형식)
 %e				실수(지수형식)
 %g				%f와 %e중 짧고 보기 좋은 형태로 출력

cf) 문자열의 마지막에는 NULL이 들어가서 문자열의 마지막을 알림
	위와 같이 문자열의 끝에, '여기 까지가 문자열이였습니다' 라고 알려주는 종료 문자를 넣은 것입니다. 
	이 종료 문자는 아스키 값이 0 이고, '\0' 라고도 나타냅니다. 절대 문자 '0' 하고 헷깔리면 안됩니다. 
	문자 0 은 아스키 코드 값이 0 이 아니라 48 입니다. 흔히, 이 종료 문자를 가리켜서 널(Null) 이라고 부릅니다. 
	이제, 널 종료 문자라는 말의 의미를 알겠죠? 말그대로, 널로 끝나는 문자 라는 의미 입니다.  
	이것이 바로, C 언어의 문자열의 기본적인 형태 입니다. 

	널 문자가 들어갈 공간이 있어야 하기 때문에 3 글자라고 해도, 배열은 4 칸이 필요하게 됩니다. 
	위와 같이 s[4] 처럼요. 그럼, 위와 같이 널 종료 문자가 편리한 이유는 컴퓨터가 문자열의 끝을 쉽게 구할 수 있기 때문입니다. 
	우리가 굳이 '이 s 문자열은 3 문자인데, 출력해죠' 라고 말할 필요 없이, 's 문자열을 출력해' 란 말만 해주어도 
	컴퓨터가 알아서 '음, 널이 나올때 까지 출력해야지' 라고 출력한다는 것입니다.
 
2) 문자 상수''	!=	문자열 상수""
 %c				문자 형태로 출력
 %s				문자열 형태로 출력
 
3) 열거형 상수 
enum months(JAN, FEB, MAF, APR, MAY, JUN, JUL, AUG=100, SEP, OCT, NOV, DEC) mon;
mon = JUL;
cf) JAN = 0, FEB = 1, ... AUG = 100, SEP = 101,...

ex)
enum test2
{ 
	ONE  = 105,
	TWO
};  
는 #define ONE  105, #define TWO 106와 같은 결과를 가진다.

4) 고정소수점 데이터형 (정수)
Int , long int, unsigned int  - 4
short int, - 2

5) 부동소수점 데이터형 (실수)
float  - 4
double  - 8
long double  -??

6) <string.h>
strcpy(s, t)  - t를 s에 복사 

7) 데이터형 이름 바꾸기
typedef unsigned int u_int;
u_int i;	-> unsigned int i;

8) const :값을 변경할 수 없는 변수 지정

9) cast
char ch = 'a';
int i = 256;
ch + i  -> 자동으로 형변환!!  
강제 변환도 가능  int i = 7; float j; j = (float) i;

10) continue
반복문의 현재 반복을 멈추고 다음 반복을 하게 한다. (반복문의 처음으로 돌아가게 함)
For(i=1; i<=30; i++) {
	if (i%5)
		continue;      //for문의 다음 반복을 실행
    printf(“%d”, i);
}
11)	조건 ? 참일 때 값 : 거짓일 때 값

2. 배열
1) 2차원 배열
int a[3][2];

2) 배열 초기화
int a[100]={0};		// 이런 식으로 해서 [0]~[99]까지 0 되게 하거든요.

int a[3][2] = {1,2,3,4,5};
1		2		a[0][0] a[0][1]
3		4		a[1][0] a[1][1]
5				a[2][0] a[2][1] 

char arry[4][3] = {{1,2,3},{4,5,6},{7,8,9},{10,11,12}};
strcpy(arry[0], "ab");
strcpy(arry[1], "cd");
strcpy(arry[2], "ef");
strcpy(arry[3], "gh");

cf) int ar[5];
ar = {1, 2, 3, 4, 5} -> 이것은 안됨(오류 발생)

3) 배열의 크기
char buffer[25];
int len;

len = sizeof(buffer);			// 25
len = sizeof(buffer[3]);		// 1
###	cf)	[C++]배열 사이즈 구하기(int iTemp5_2 = sizeof(TestList[0]);	// 16(아주중요, 반드시 본 sizeof(TestList[0])로 계산해줘야 함))
2013.12.27 09:52 from Test Code/C++    
선언된 배열의 개수 구하기
#include <iostream>
#include <string>

using namespace std;

int main()
{
	int iCnt = 0;

	// int 배열
	const int iArr[] = {1,2,3,4,5};
	iCnt = sizeof(iArr)/sizeof(int);
	cout << "iArr 배열 사이즈 = " << iCnt << endl;

	// double 배열
	const double dArr[] = {12.25, 25.15, 45.3};
	iCnt = sizeof(dArr)/sizeof(double);
	cout << "dArr 배열 사이즈 = " << iCnt << endl;

	// char* 배열
	const char* szArr[] = {"사과","배","바나나"};
	iCnt = sizeof(szArr)/sizeof(char*);
	cout << "szArr 배열 사이즈 = " << iCnt << endl;

	// string 배열
//	const string strArr[] = {"보리","옥수수","감자","고구마"};
//	iCnt = sizeof(strArr)/sizeof(string);
//	cout << "strArr 배열 사이즈 = " << iCnt << endl;
	// string 배열
	string strArr[] = { "보리","옥호호hoho수수","감자","고구마" };

	int iTemp1 = sizeof(strArr);			// 160
	int iTemp2 = sizeof(string);			// 40
	int iTemp2_2 = sizeof(strArr[0]);		// 40
	int iTemp3 = iTemp1 / iTemp2;			// 4(제대로 된 개수로 계산해 줌)

	String TestList[] = { "./SampleImage/Genuine0.jpg",
						"./SampleImage/Genuine1.jpg",	"./SampleImage/Genuine2.jpg",	"./SampleImage/Genuine3.jpg",	"./SampleImage/Genuine4.jpg",	"./SampleImage/Genuine5.jpg",	"./SampleImage/Genuine6.jpg",	"./SampleImage/Genuine7.jpg",	"./SampleImage/Genuine8.jpg",	"./SampleImage/Genuine9.jpg",	"./SampleImage/Genuine10.jpg",
						"./SampleImage/Genuine11.jpg",	"./SampleImage/Genuine12.jpg",	"./SampleImage/Genuine13.jpg",	"./SampleImage/Genuine14.jpg",	"./SampleImage/Genuine15.jpg",	"./SampleImage/Genuine16.jpg",	"./SampleImage/Genuine17.jpg",	"./SampleImage/Genuine18.jpg",	"./SampleImage/Genuine19.jpg",	"./SampleImage/Genuine20.jpg",
						"./SampleImage/Genuine21.jpg",	"./SampleImage/Genuine22.jpg",	"./SampleImage/Genuine23.jpg",	"./SampleImage/Genuine24.jpg",	"./SampleImage/Genuine25.jpg",	"./SampleImage/Genuine26.jpg",	"./SampleImage/Genuine27.jpg",	"./SampleImage/Genuine28.jpg",	"./SampleImage/Genuine29.jpg",	"./SampleImage/Genuine30.jpg",
						"./SampleImage/Genuine31.jpg",	"./SampleImage/Genuine32.jpg",	"./SampleImage/Genuine33.jpg",	"./SampleImage/Genuine34.jpg",	"./SampleImage/Genuine35.jpg",	"./SampleImage/Genuine36.jpg",	"./SampleImage/Genuine37.jpg",	"./SampleImage/Genuine38.jpg",	"./SampleImage/Genuine39.jpg",	"./SampleImage/Genuine40.jpg",
						"./SampleImage/Genuine41.jpg",	"./SampleImage/Genuine42.jpg",	"./SampleImage/Genuine43.jpg",	"./SampleImage/Genuine44.jpg" };
	int iTemp4 = sizeof(TestList);		// 720
	int iTemp5 = sizeof(string);			// 40
	int iTemp5_2 = sizeof(TestList[0]);	// 16(아주중요, 반드시 본 sizeof(TestList[0])로 계산해줘야 함)
	int iTemp6 = iTemp4 / iTemp5;			// 18(엉뚱한 개수로 계산해 줌)
	int iTemp6_2 = iTemp4 / iTemp5_2;	// 45(제대로 된 개수로 계산해 줌)

	string strArr2[] = { "보리","만어라님어라ㅣㅁㅇ너리ㅏㅁㄴ어리ㅏㅁㅁㅇ너리ㅏㄴㅇ멀ㅇ나ㅣㅁ옥호호hoho수수","감자","고구마" };

	int iTemp7 = sizeof(strArr2);			// 160
	int iTemp8 = sizeof(string);			// 40
	int iTemp8_2 = sizeof(strArr2[0]);	// 40
	int iTemp9 = iTemp7 / iTemp8;			// 4(제대로 된 개수로 계산해 줌)

	return 0;
}

초기화하려는 값이 0인 경우는 있지만 그 외의 값은 없습니다. 특정 값으로 초기화해주려면 for문을 돌거나 일일이 지정해줘야 합니다.
1. 전부 지정해주기
int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };

2. 일부만 지정한경우 - 나머지는 0으로 채워짐
int myArray[10] = { 1, 2 }; -> 인덱스 2부터 9까지는 0값을 가집니다

3. 전부 0으로 지정하고 싶은 경우
int myArray[10] = { 0 };        -> 본 경우는 전부 0으로 초기화 되지만
cf) int myArray[10] = { 1 };    -> 이 경우는 myArray[0]만 1로 초기화 되고 나머지는 0으로 초기화 됨
cf) int myArray[10];            -> 이렇게 아무 초기화 명령도 없으면 배열은 엉뚱한 값으로 들어가 있게 됨
cf) int array[100] = {-1};
    이 코드는 배열 전체를 -1로 초기화하는 게 아니라 "배열 첫 번째 원소만 -1로 만들고 나머지 지정하지 않은 원소는 다 0으로 초기화해달라"는 뜻입니다.
    배열 전체를 같은 값으로 초기화하는 코드는 C, C++이 조금 씩 다르기 때문에 따로 적어놓겠습니다.
    우선 C언어는 [C 배열을 초기화하는 방법]을 보시면 될 것 같고,

    그 외에 GCC를 쓰신다면 
    int array[100] = { [0 ... 99] = -1 }; 가 가능합니다.

    C++에서만 쓸 수 있는 대표적인 코드는 헤더의 std::fill_n입니다.
    std::fill_n(array, 100, -1);
    ->  나의 결론 : memset 명령을 사용하자.

4. 0으로 지정하는 다른 방법(C++에서만 가능)
int myArray[10] = {};

5. static으로 선언하기 - 전부 0으로 초기화
static int myArray[10]

여기서 말하는 0은 메모리공간의 처음부터 끝까지 전부 0으로 설정된다는 의미는 아니기 때문에(char는 \0등) memset()과는 좀 다른 의미입니다.

3. 포인터
변수의 주소 확인 -> &
주소를 저장하는 변수 -> 포인터 변수
int i = 10;
int *ptr;

ptr = &i;
(*ptr)++;               //ptr이 가리키는 곳의 내용을 의미하므로!!
printf("%d\n", i);             -> 11 출력


예제)
	char buff[10] = {10,11,12,13,14,15,16,17,18,19};
	char buff2[10] = {0};
	char *pBuff = buff;

	int i = 0;

	for(i = 0; i<10; i++)
	{
//		buff2[i] = *(pBuff++);				// 이 경우도 buff2에 buff와 똑같은 10 ~ 19의 값이 들어 감, cf) ++ 명령이 마지막에 실행 됨
		buff2[i] = *pBuff++;				// buff2에 buff와 똑같은 10 ~ 19의 값이 들어 감
	}

cf)	포인터 / 배열 관계
	// 정수배열과 포인터의 관계
	#include <stdio.h>
	
	int main() 
	{
		int a[5] = {10, 20, 30, 40, 50};
		int n = sizeof(a)/sizeof(int);
		int i;
		int* p = a; 
		
		printf(" a = %d, p = %d  \n\n", a, p);
		
		for( i=0; i<n; i++ )
		{
//		printf(" a[%d]  ==> %d 주소 ==> %d \n", i, a[i], &a[i]);
			printf(" p[%d]  ==> %d 주소 ==> %d \n", i, p[i], &p[i]);
//		printf(" *(a+%d)  ==> %d 주소 ==> %d \n", i, *(a+i), a+i);
//		printf(" *(p+%d)  ==> %d 주소 ==> %d \n", i, *(p+i), p+i);
		}
					 		 
		return 0;
	}

	->	실행결과
  a = -1359319816, p = -1359319816  

	p[0]  ==> 10 주소 ==> -1359319816 
	p[1]  ==> 20 주소 ==> -1359319812 
	p[2]  ==> 30 주소 ==> -1359319808 
	p[3]  ==> 40 주소 ==> -1359319804 
	p[4]  ==> 50 주소 ==> -1359319800 

	->	최종 배열/포인터 관계 설명
	배열식		포인터식		배열식		포인터식
	a[i]	==	*(a+i)	==	p[i]	==	*(p+i)
	&a[i]	==	a+i			==	&p[i]	==	p+i

4. 외부 변수, 함수 -> 외부에서 사용 가능. extern으로 재정의!!
   정적 변수, 함수 -> 외부에서 호출 또는 사용 불가

5. 구조체
서로 다른 데이터형의 변수들을 하나로 묶어 놓은 모임
1) 구조체의 개념 
? 2개 이상의 원소들로 구성된 통합자료 형으로, 배열과 달리 각 원소는 자신의 자료형을 갖는다.(배열의 각 원소는 같은 자료형을 가짐). 
? 서로 다른 몇 개의 자료형을 단일 명칭 하에서 한데 묶은 형틀. 
? 구조체 형틀 자체는 어떤 변수나 배열 등을 실제로 메모리에 만드는 것이 아니라 구조체설계하는 지침만을 컴파일러에게 알려줌 
? 구조체의 변수가 선언이 되어야 비로소 메모리에 할당 됨 

2) 구조체 변수의 사용 
 구조체 변수 안에는 한개 이상의 멤버변수가 들어있다. 구조체 변수를 사용한다는 말은 그 멤버변수를 사용한다는 말이 된다. 
사용은 다음과 같다. 

 구조체 변수. 멤버변수 = 값; 
 변수 = 구조체 변수. 멤버 변수; 

예를 들어 Student라는 구조체의 변수를 
struct Student s;
이렇게 선언했다고 하고 이 구조체 변수의 멤버 변수중 Class에 5를 넣으려면, 
s. Class = 5;
이렇게 하면 되고, Name 이라는 멤버 변수에 “AAA"를 넣으려면 
strcpy(s.Name,"AAA");
이렇게 하면 된다. 

3) 구조체 변수의 초기값 
 구조체 변수에도 초기값을 줄수 있다. 방법은 배열에 초기값 주는 것과 비슷하다. 
struct 구조체 이름 구조체 변수 = {첫번째 멤버변수의 초기값, 두 번째 멤버변수의 초기값, ....}; 

예를 들면 다음과 같다. 
 struct Student 
 { 
  int Grade; 
  int Class; 
  int Number; 
  char Nace[16]; 
  int Age; 
  char Phone[16]; 
 };

이런 구조체가 있을 때 s라는 구조체 변수를 초기값을 주어 선언하면, 
struct Student s = {1, 5, 10, "AAA", 14, "000-0000"};
이렇게 한다. 이때에 s.Grade에는 1이 , s.Class에는 5가, s.Number에는 10이, s.Name에는 “AAA", s.Age에는 14, s.Phone에는 ”000-0000“이 들어가게 되는 것이다. 

cf)
struct str_r
{
char a[10];
char b[10];
int c;
} str;

1. memset((char *)&str, 0x00, sizeof(struct str_r));
2. memset(&str, 0x00, sizeof(str));

4) 구조체 포인터 사용 
 구조체 포인터도 역시 다른 포인터 들과 똑같은 형식으로 선언해 주면 된다. 
struct 구조체이름*구조체포인터명;

Student라는 구조체의 포인터로 이름이 spointer 인 것은 
struct Student* spointer;
이렇게 선언한다. 구조체 포인터의 사용은 일반 포인터와 비슷하다. 예를 들어 다음과 같이 구조체 변수와 구조체 포인터를 선언했다고 하자. 

 struct Student s; 
 struct Student *spointer;
이때 spointer 라는 구조체 포인터에 s라는 구조체 변수의 주소를 넣을 때에는 주소연산자를 사용하여 
spointer=&s;
이렇게 해주면 된다. 

 spointer에 저장되어 있는 구조체 변수의 주소에 기억된 내용들을 사용할 때에는 다음과 같다 
(*spointer).Grade=1; 
(*spointer).Class=5;
이렇게 해주면 된다. 그런데 이렇게 쓰는 것은 좀 복잡한데 이걸 좀 편하게 쓰기 위한 연산자가 있다. 바로 -> 이다. 사용방법은 다음과 같다. 

구조체 포인터 -> 멤버변수 = 값; 
변수 = 구조체 포인터 -> 멤버변수;

예를들어 위에 나온 것들을 바꿔주면 
 spointer -> Grade = 1; 
 spointer -> Class = 5;
이렇게 해주면 더 간단해 지게 된다. 

5) struct 구조체 변수를 리턴값으로 사용
#include <stdio.h>

struct point {
 int x;
 int y;
};

void show(struct point ts);
struct point pointadd(struct point s1, struct point s2);

int main(void)
{
 struct point s1={1, 2};
 struct point s2={3, 4};
 struct point result;
 
 result=pointadd(s1, s2);

 show(result);


 return 0;
}

void show(struct point ts)
{
 printf("x좌표 : %d , y좌표 %d \n", ts.x, ts.y);
}

struct point pointadd(struct point s1, struct point s2)
{
 struct point sum={(s1.x)+(s2.x), (s1.y)+(s2.y)};
 return sum;
}

6. 공용체
같은 메모리를 공유하는 구조체 
기억장소 절약.
둘중에 하나만 사용할 수 있다.

7. 파일 삽입하기
#include <파일이름>    //해당파일을 시스템 디렉토리에서 찾음
#include “파일이름”     //현재 작업 디렉토리 -> 없으면 시스템 디렉토리

8. 조건부 컴파일
#if 수식1      
	실행부분1			//수식1이 참일 때 실행
#elif 수식2   
	실행부분2			//수식2가 참일 때 실행
#else
	실행부분 n			//모든 수식이 거짓일때 실행
#endif

#ifdef 매크로
	실행부분			//해당 매크로가 있을 때 수행
#endif

#ifndef 매크로			//해당 매크로가 정의 되어 있지 않으면 실행 부분 컴파일 
	실행부분
#endif 

9. 문자와 문자열 처리 함수
< CType.h> 
isalnum					// 영문자 또는 수치 문자인지 판별
isalpha					// 영문자인지 판별
isascii					// ASCII 문자인지 판별
isblank					// 빈 공백(공백 or  탭)인지 판별
iscntrl                 // 제어 문자인지 판별
isdigit					// 수치문자인지 판별
isgraph					//프린트 가능 문자(공백제외)인지 판별
islower					//소문자인지 판별
isprint                 // 프린트 가능 문자(공백 포함)인지 판별
ispunct					// 구획문자(공백, 영, 수치 문자가 아니면서 출력 가능 문자)인지 판별
isspace					// \n \f \t \v \r인지 판별
isupper					// 대문자인지 판별
isxdigit                // 16진수 수치 문자인지 판별

toupper					// 대문자로
tolower					// 소문자로

<string.h>
문자열 연결 함수 
strcat                  // 문자열 src를 문자열 desc 끝에 연결한다.
                        //  char *strcat(char *dest, const char *src);
                        //  연결시킨 문자열 반환, dest가 src보다 커야!!!
                        //  복사 시, dest끝에 NULL이 있는 경우 NULL은 제거하고 바로 src를 붙여 넣는다.(dest 마지막에 NULL을 붙임)
strncat               	// 문자열 src중 n문자를 문자열 dest 끝에 연결
                        //  char *strncat(char *dest, const char *src, size_t n);
                        //  연결시킨 문자열 반환, dest가 src보다 커야!!!

문자열 비교 함수
strcmp                	// 문자열 비교
                        // int strcmp(const char *s1, const char *s2);		//s1 >s2 : 양수(return), s1 == s2 :0(return), s1 <s2 : 음수(return)
                        // ex) abc와 abd의 경우 ab는 같고 c와 d를 비교하며 c가 d 보다 작기 때문에 return 값은 -1
                        // ex) aaab와 aaa의 경우 마지막 4번째 b와 null을 비교하며 b가 null 보다 크기 때문에 return 값은 1
                        	int main()
                        	{
                        		char str1[20] = "Hello";
                        		char str2[20] = "Hello";
                        		char str3[20] = "HEllow";
                        		
                        		printf("%d \n", strcmp(str1, str2));
                        		printf("%d \n", strcmp(str1, str3));
                        		
                        		return 0;
                        	}
                        	-> 결과
                        	0
                        	1
                        		
strncmp              	// 두 문자열의 n개의 문자 비교, 전체 문자열이 아닌 문자열의 앞쪽 몇 글자만 비교해 보고 싶을 때 이 함수를 사용
						// 본 함수의 return 값은 -1,0,1일수도 ex)-5,0,3일수도 있다, cf) strcmp함수는 어떤 경우나 -1,0,1의 return 값을 가짐
						// - ex)3개의 문자 비교일 경우 마지막 3번째 문자만 다를 경우는 마지막 문자에 대한 ascii값의 차이가 return값으로 출력되며(ex)-5,0,3)
						// - 그 이외의 경우는 ex)-1,0,1의 return값을 가짐
						// ex) strncmp(Name, "김", 2) 함수를 사용하면 이 사람의 성이 김가인지 아닌지를 알 수 있다.
							int main()
							{
								char str1[20] = "Hello";
								char str2[20] = "Hellotoo";
								char str3[20] = "Hellowoo";

								printf("%d \n", strncmp(str1, str3, 5));
								printf("%d \n", strncmp(str1, str3, 6));
								printf("%d \n", strncmp(str1, str3, 7));
								printf("%d \n", strncmp(str1, str3, 8));

								printf("%d \n", strncmp(str2, str3, 5));
								printf("%d \n", strncmp(str2, str3, 6));
								printf("%d \n", strncmp(str2, str3, 7));
								printf("%d \n", strncmp(str2, str3, 8));

								return 0;
							}
							-> 결과
							0							// 앞에서 5개 까지인 "Hello"가 서로 같기 때문
							-119
							-119
							-119
							0
							-3
							-3
							-3
strcasecmp        		// 대소문자 구별 않고 두 문자열 비교
strncasecmp      		// 대소문자 구별 않고 두 문자열의 n문자 비교
 
문자열 복사 함수
strcpy                 	// 문자열복사, 주의해서 사용할 것.
                        //	char *strcpy(char *dest, const char *src);   
						//	-dest :복사할 위치, src : 원본 위치
						//	복사한 문자열 반환
						// 1. src에 복사될 때 '\0' 까지 복사됨으로 문자열이 겹쳐지지는 않는다.
						//    이때 dest는 src를 모두 복사 받을 수 있을 정도로 충분히 커야 한다.
						//    strcpy()는 목적지 배열의 크기가 충분히 크지 않을 경우 어떤 일이 발생될지 알 수 없다.
						//    운이 좋으면 세그먼트폴트 에러와 함께 죽겠지만, 그렇지 않고 알 수 없는 작동을 할 수도 있다.
						//    이는 흔히 말하는 버퍼 오버 플로우 크래커 기술에 매우 취약하다.
						//    strcpy()를 쓰기 전에는 반드시 복사할 문자열의 크기를 검사해 주어야 한다.
						//    또는 strncpy()를 써야 한다.
						// 2. strcpy와 memcpy
						//    strcpy는 string 관점/char 관점이고 memcpy는 memory 관점이라는 차이가 있음
						//    strcpy는 byte by byte로 NULL까지 모두 복사하고 중단하며
						//    memcpy는 함수의 시작 시점에 이미 사이즈를 알고 메모리를 버스 단위로 복사 하며
						//    일반 바이너리 자료까지 모두 복사가 가능하고, strcpy보다 속도가 좀 더 빠를 수 있습니다.
						//    cf) memcpy 함수는 NULL까지도 포함하는 복사를 가능하게 함
						//
						//    char a[10] = "aaaa\0dddd";
						//    char b[10] = "";
						//    strcpy(b, a);
						//    printf("%c\n", b[5]);				// 아무것도 출력 없음
						//    memcpy(b, a, sizeof(b));
						//    printf("%c\n", b[5]);				// 'd' 출력
						
strncpy               	// n개의 문자열 복사
                        // 	char *strncpy(char *dest, const char *src, size_t n);
                        // 	복사한 문자열 반환
                        // 1. src가 가르키는 문자열을 dest가 가르키는 배열에 복사한다. src에서 복사될 때 '\0'까지 복사됨으로
                        //    문자열이 겹쳐지지는 않는다. 이때 dest는 src를 모두 복사 받을 수 있을 정도로 충분히 커야 한다.
                        //    strncpy()는 n을 이용해서 복사할 문자열의 크기를 정할 수 있으므로 버퍼 오버 플로우에 좀 더 안전하다.
                        //    만약 src의 길이가 n 보다 작다면 dest의 남는 공간은 NULL로 채워진다.
                        //    반환값 : 목적지 문자열 dest에 대한 포인터를 반환한다.
                        // 예)
                        // char buffer[25];
                        // strncpy(buffer, "hello world", 25);
                        // printf("%s\n", buffer);					// hello world 출력(strncpy 명령으로 25개를 복사하라고 했지만 src의 크기가 25이하이기 때문에 더 복사하고 싶어도 복사할 데이터가 없음)
                        // memset(buffer, 0x00, sizeof(buffer));
                        // strncpy(buffer, "naver blog", 3);		// nav 출력
                        // printf("%s\n", buffer);

/* 아주중요(결론)
string을 복사할 일이 있을 때는 strncpy명령을 사용하며 아래와 같이 사용하는 것이 가장 안전하겠다.
char src[25];
char dest[20];

strncpy(dest, src, sizeof(dest));		// sizeof(dest)로 최대로 복사될 크기를 지정해 줬기 때문에 dest[20] 배열의 크기를 넘어서 복사될 가능성이 아예 없고
										// src가 sizeof(dest) 크기 보다 작을 경우는 src 크기 까지만 복사 되기 때문에 쓸데 없는 쓰레기 데이터가 복사되는 것을 걱정할 필요 없음 */


strdup                 	// 문자열에 대한 메모리를 할당하고 포인터 반환       
						//	-char *strdup(const char*s);

문자열 길이 계산 함수
strlen                  // 문자열 길이 계산 (단위는 바이트)
                        //  size_t strlen(const char *s);
                        //  문자열의 길이를 반환. 단위는 바이트.
                        // strlen은 할당 받은 메모리에 바인딩된 문자열에서 NULL값을 제외한 문자열의 길이이고 
                        // sizeof는 데이터가 할당 받은 메모리 바이트의 크기입니다.
                        // 예)
                        // char a[10] = "abcd";
                        // int len;
                        // len = strlen(a);			// 4
                        // len = sizeof(a);			// 10


문자열 검색 함수 
strchr                 	// 문자가 처음으로 발견된 위치 검색  
						//	char *strchr(const char *s, int c)
						//	찾은 문자에 대한 포인터 반환. 찾지 못하면 NULL 반환
						//	char *str =”ABCDEFG”;
						//	strchr(str,’D’);
						//	결과-> DEFG 출력
strrchr                	// 문자가 마지막으로 발견된 위치  
						//	char *strchr(const char *s, int c)
						//	찾은 문자에 대한 포인터 반환. 찾지 못하면 NULL 반환
strstr                  // 임의의 문자열 검색
                        // 	char *strstr(const char *haystack, const char *needle);
                        // 	haystack:문자열  needle:문자열
                        // 	찾은 문자열의 시작 포인터 반환, 없으면 NULL반환
strspn                 	// 특정 문자들로 이루어진 초기 문자열 길이 검색
						// ex)	s1이"8906299", s2가"78940"일때 -> strspn(s1, s2)의 리턴 값은 3(이유, s1에 s2 문자가(1개 단위) 총 3개 포함되어 있기 때문)
strcspn               	// 특정 문자들이 아닌 문자들로 이루어진 초기 문자열의 길이 검색
strpbrk                	// 문자열에서 특정 문자들 중 일치하는 첫 번째 문자를 검색

문자열을 단어로 자르는 함수
strtok                  // 문자열에서 구분자와 일치하는 문자가 나오면 단어로 자른다
                        // 	char *strtok(char *s, const char *delim);
						//	단어의 첫 문자의 포인터 반환, 없으면 NULL반환

예제1)	strchr, strrchr
	char *str = "HELLO WORLD!";
	char *ptr1, *ptr2;

	ptr1 = strchr(str, 'L');
	ptr2 = strrchr(str, 'L');

	if(ptr1)
		printf("L의 첫번째 위치 %d\n", ptr1-str);			// ptr1-str 의 뜻은 문자열에서 찾고자 하는 문자를 찾기 위해 함수가 돌려주는 값에서 문자열 포인터를 뺀 것임
	if(ptr2)
		printf("L의 마지막 위치 %d\n", ptr2-str);

	-> 출력결과
	L의 첫번째 위치 2
	L의 마지막 위치 9

예제2)
#include<stdio.h>
#include<string.h>

int main()
{
	char word[] = "ABCD DEF 123";
	char *inum;
	
	inum = strchr(word, 'E');
	printf("%s\n", inum);
	
	return 0;
}

->	결과 : EF 123


10. 데이터 진수 변환 함수
<stdlib.h>
고급 변환 함수
atoi					//문자열을 10진 정수(int)로 변환, cf) 문자열이 숫자로 시작하지 않으면 에러 처리하며 이때 return값은 0임
						//-	문자열이 숫자로 시작하지 않은 경우
						//	ex) "<50.00 ng/mL", ">600.00 ng/mL", "Negative", "Positive", 0x00
						//-	문자열이 숫자로 시작한 경우
						//	ex) "582.52 ng/mL"
atol                    // 정수(long)
atof                    //실수(double), cf) 문자열이 숫자로 이루어지지 않으면(ex, 0x00 or "TEST") 에러 처리하며 이때 return값은 0.00000000임, cf) sscanf 명령을 사용해서 문자열을 -> 실수로 바꿔도 됨(하지만, sscanf 명령은 문자열이 숫자로 이루어져 있지 않은 경우 아예 sscanf 명령을 실행하지 않음)
strtol                  //특정 진수 형태의 문자열을 정수(long)로 변환
                        // i = strtol (“3579”, NUL, 10)
strtoul                 // 특정 진수 형태의 문자열을 정수(unsigned long)으로 변환, Destination(long) = strtoul(Source(String), EndPtr, 진수)
						// unsigned long nC = strtoul(strCompany, NULL, 2);	// 2진수 문자열 -> 정수형 변환
strtod                  // 실수 형태의 문자열을 실수(double)로 변환

#include<stdio.h> 
int main(void)
{
	char x1[] = "200";
	char x2[] = "36.5";
	char buffer[100];
	
	int i;
	double f;
	double result;
	
	sscanf(x1, "%d", &i);
	sscanf(x2, "%lf", &f);	//double형 변수는 입력받을땐 %lf, 출력땐 %f를 씁니다.
	
	result = i + f;
	sprintf(buffer, "%f", result); // result에 저장된 값을 buffer에 문자열 형태로 저장합니다.
	
    printf("연산 결과는 %s입니다.\n", buffer); // 문자열 buffer을 출력합니다.

	return 0;
} 
문자열에 관련된 함수인데 #include<string.h>가 필요하지 않다는 것 또한 알아두면 좋겠네요.
설명을 덧붙이자면 sscanf는 문자열 x1, x2를 i, f의 주소에 저장합니다.
x1의 문자열 >> %d : int형 변수로 변환해서 입력받고 >> i의 주소에 저장
x2의 문자열 >> %lf : double형 변수로 변환해서 입력받고 >> f의 주소에 저장

sprintf는 거꾸로 result라는 double형 변수  >> buffer에 문자열 형태로 전환해 저장!

다른 방법도 있습니다.
이 경우엔 새로운 라이브러리 선언이 필요합니다.
#include<stdlib.h> 
바로 이 라이브러리 입니다.

함수 소개
char s1[] = "100";
char s2[] = "40.99"; // 라는 char형 문자열이 있다고 치면
 
int i;
double d;
double result; //라는 변수도 있다고 치면
 
i = atoi(s1); // sscanf(s1, "%d", &i)와 같은 뜻을 지닌 함수
d = atof(s2); // sscanf(s2, "%lf", &d)와 같은 뜻을 지닌 함수
 
//atoi(s1) = sscanf(s1, "%d", &i);
//atof(s2) = sscanf(s2, "lf", &d); 

atoi와 atof를 쓰면 비교적으로 쉽게 함수 작성이 가능하겠죠
sscanf는 아무래도 쓰는 시간이 좀 걸리니까요.

#include <stdio.h>
#include <stdlib.h>

int main()
{
	char su[] = "155";
	char *end;
	long a = strtol(su, &end, 16); // 16진수
	long b = strtol(su, &end, 8); // 8진수
	long c = strtol(su, &end, 10); // 8진수

	printf("%ld\n", a);
	printf("%ld\n", b);
	printf("%ld\n", c);
	return 0;
}
->	결과
341
109
155

cf)	Hex char to int conversion
strtol works on a string, ch is a char, so convert this char to a valid string
char str[2] = {0};
char chr = 'a';
str[0] = chr;

long num = strtol(str, NULL, 16);	// and use strtol with base 16:
printf("%ld\n", num);

cf)	Hex char to int conversion, 테스트
	char chArray[2] = { 0 };
	char chArray2[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f' };
	int iCnt = sizeof(chArray2);
	int iConvert = 0;

	for (int i = 0; i < iCnt; i++)
	{
		chArray[0] = chArray2[i];
		iConvert = (int)strtol(chArray, 0, 16);
		TRACE("chArray2[%d] = %c = %d\n", i, chArray2[i], iConvert);
	}

	// 출력 결과
	chArray2[0] = 0 = 0
	chArray2[1] = 1 = 1
	chArray2[2] = 2 = 2
	chArray2[3] = 3 = 3
	chArray2[4] = 4 = 4
	chArray2[5] = 5 = 5
	chArray2[6] = 6 = 6
	chArray2[7] = 7 = 7
	chArray2[8] = 8 = 8
	chArray2[9] = 9 = 9
	chArray2[10] = A = 10
	chArray2[11] = B = 11
	chArray2[12] = C = 12
	chArray2[13] = D = 13
	chArray2[14] = E = 14
	chArray2[15] = F = 15
	chArray2[16] = a = 10
	chArray2[17] = b = 11
	chArray2[18] = c = 12
	chArray2[19] = d = 13
	chArray2[20] = e = 14
	chArray2[21] = f = 15

cf)	[c언어] 숫자를 2진수 또는 16진수 문자열로 변환하는 함수(itoa, ltoa) | 공부/c언어 2011. 5. 7. 20:01  
숫자를 다른 진수 문자열로 변환하는 함수(itoa, ltoa)에 대해 알아보는 프로그램
	cf)	_itoa_s 명령어의 특징(10진수 -> 2진수 변환)(_itoa_s(nCheckSum, aCheckSum, sizeof(aCheckSum), 2);)
			0x00의 경우 0, 0x01의 경우 1, 0x02의 경우 10 등 앞자리에 '0'이 자동으로 붙지는 않음
	cf)	숫자를 문자열로 바꿔서 저장해준다. atoi 의 반대 기능이다. atoi 의 반대 개념으로 itoa 함수도 있는데 희한하게 atoi 는 표준함수인데
			itoa 는 표준함수가 아닌 win32api 이다. 그래서 itoa 대신에 표준함수인 sprintf 를 공부해서 써야겠다.
			cf)	근데 우선 itoa는 표준함수가 아닙니다. 멀티플랫폼 개발을 하시는 분들은 사용해서는 안되는 함수인 것이죠.

예제0)
자동으로 되는 것은 없습니다.
단지 쉽게 구현할 수 있다는 것만 알려드리져....
정수형이면 비씨에서는 4바이트 이니까...
00000000 00000000 00000000 11111111  -- 이게 255 이겠져... ^^
255를 이진수로 쓰기... 뭐 정수면 아무거나 다 되겠져...

int result[32] = {0};
int aaa = 255;

for(int i=0; i<32; i++)
{
 int bbb = aaa>>i;
 if(bbb & 0x01)
   result[i] = 1;  
 else 
   result[i] = 0;
}

예제1)
	char aCheckSum[4+1] = { 0 };
//	memset(aCheckSum, 0, sizeof(aCheckSum));

	int nCheckSum = 0;
	int nCheckSum_MSB = 0;

	for (nCheckSum = 0; nCheckSum < 16; nCheckSum++)
	{
		nCheckSum = nCheckSum & 0x0f;			// 하위nibble만 처리

		for (int i = 0; i < 4; i++)				// 하위nibble 4비트만 2진수 처리
		{
			nCheckSum_MSB = nCheckSum << i;		// 우측으로 Shift시키면서 최상위 bit값을 체크할 수 있도록 함

			if (nCheckSum_MSB & 0x08)			// 하위nibble 중에서 최상위 비트값(3번째 bit)이 1인지 0인지 판단
				aCheckSum[i] = '1';				// 최상위 비트값이 1이기 때문에 '1'로 입력
			else
				aCheckSum[i] = '0';				// 최상위 비트값이 0이기 때문에 '0'로 입력
		}

		TRACE("nCheckSum = %d, aCheckSum = %s\n", nCheckSum, aCheckSum);
	}

-> 실행결과
nCheckSum = 0, aCheckSum = 0000
nCheckSum = 1, aCheckSum = 0001
nCheckSum = 2, aCheckSum = 0010
nCheckSum = 3, aCheckSum = 0011
nCheckSum = 4, aCheckSum = 0100
nCheckSum = 5, aCheckSum = 0101
nCheckSum = 6, aCheckSum = 0110
nCheckSum = 7, aCheckSum = 0111
nCheckSum = 8, aCheckSum = 1000
nCheckSum = 9, aCheckSum = 1001
nCheckSum = 10, aCheckSum = 1010
nCheckSum = 11, aCheckSum = 1011
nCheckSum = 12, aCheckSum = 1100
nCheckSum = 13, aCheckSum = 1101
nCheckSum = 14, aCheckSum = 1110
nCheckSum = 15, aCheckSum = 1111

예제2)	itoa
#include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
     int num1=14;
     long num2=512;
     char s[25];
     itoa(num1, s, 2);
     printf("정수:%d, 2진수문자열:%s\n", num1, s);
     ltoa(num2, s, 16);
     printf("정수:%ld, 16진수문자열:%s\n", num2, s);
     return 0;
 }

-> 실행결과
정수:14, 2진수문자열:1110
정수:512, 16진수문자열:200

예제3)
	int nCheckSum = 0;
	char aCheckSum[8 + 1] = { '0', };
	memset(aCheckSum, '0', sizeof(aCheckSum));

	for (nCheckSum = 0; nCheckSum < 16; nCheckSum++)
	{
		nCheckSum = nCheckSum & 0x0f;
		memset(aCheckSum, '0', sizeof(aCheckSum));

		_itoa_s(nCheckSum, aCheckSum, sizeof(aCheckSum), 2);

		TRACE("aCheckSum = %s\n", aCheckSum);
	}

-> 실행결과
0
1
10
11
100
101
110
111
1000
1001
1010
1011
1100
1101
1110
1111

cf)	상기 실행결과 중 0인 경우 aCheckSum 배열의 값
aCheckSum[0] = 48								// 48 = '0'
aCheckSum[1] = 0								// 0 = null
aCheckSum[2] = -2(dummy data)
aCheckSum[3] = -2(dummy data)
.............................

11. 메모리 관리 함수
동적 메모리 할당과 해제 함수
malloc                	//메모리를 동적으로 할당              - void *malloc(size_t size)
                        // 특정 데이터에 국한하지 않기 위해 (void *)형으로.
calloc                 	// 메모리를 동적으로 할당하고 0으로 초기화
             			//  -void *calloc(할당을 원하는 요소의 수, 한 요소의 크기)
free                    // 할당된 메모리 해제                    - void free(void *ptr)

메모리 크기 변경 함수
realloc                 //동적 메모리 영역의 크기 변경
                        // void *realloc(void *ptr, 변경되길 원하는 크기)

<string.h>
메모리 초기화 함수
memset              	//메모리 영역을 초기화
                        // void *memset(void *s, int 초기화 값, 초기화 되길 원하는 크기)

////////////////////////////////////////////////////////////////////////////////////
// ysoftman
// memset() 를 사용한 초기화시 유념해야 할 것들
// memset 함수는 for 문에 비해 굉장히 빠르고 간편한다.
// 하지만 처리 단위가 byte 이기 때문에 int, float 와 같은 타입의 경우는
// 0이 아닌 값으로 초기화 할때는 정수가 아닌 헥사(16진수)값으로 설정해야 한다.

// memset은 그냥 0으로 초기화 시킬 때만 쓰는 것이 좋은
// 1이외의 값으로 초기화 시킬 때는 변수의 형식(int, float, double)에 따라서
// 엉뚱한 값이 들어 가는 현상 발생하기 때문
////////////////////////////////////////////////////////////////////////////////////
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main()
{
 // 다음의 경우 1 값으로 초기화 된다.
 char *pCh = new char[100];
 memset(pCh, 1, 100*sizeof(char));

 // 다음의 경우 1 값이 아닌 16843009 값으로 초기화 된다.
 // pNum[0] = [00000001000000010000000100000001] 으로 16843009 값이 되버린다.
 int *pNum1 = new int[100];
 memset(pNum1, 1, 100*sizeof(int));

 // 다음의 경우 1 값으로 초기화 된다.
 // ASCII 코드 문자 1 은 10진수로 49 16진수로 31 이다. 따라서 0x31 로 설정하여 1 값으로 초기화 한다.
 int *pNum2 = new int[100];
 memset(pNum2, 0x31, 100*sizeof(int));

 delete[] pCh;
 delete[] pNum1;
 delete[] pNum2;
}

메모리 영역 복사 함수 
memcpy                  // 메모리 영역을 복사, 덮어쓰기 안됨, memcpy 사용하기 전에 memset 명령을 사용해야 한다.
                        //  void *memcpy(void *dest, const void *src, 복사할 내용의 바이트 수)

memset과 memcpy를 같이 쓰는 이유는.

사용하기 전에 사용할 부분을 걔끗하게 지우는 것입니다. 그냥 한다는 표현은 그렇지만 변수를 사용하기 전에 깨끗하게 지우는 것이 좋다는 사람을 많이 보았습니다. 
기본적으로 메모리를 할당받거나 하면 Debug에서 "0xCD" or "0xCC" 로 Release에서는 Gabage값이 그대로 남아있게 됩니다.

// *** 바로 아래 설명은 잘못된 설명임 memcpy 함수는 0x00(null)도 복사 함
//또 다른 이유는 memcpy를 할때는 Teminate String인 0x00이 복사 되지 않습니다. 즉 memcpy로 문자열을 복사여 그대로 사용하면 0x00까지 복사하는 함수들을 사용할때. 
//해당 변수의 범위를 넘어서서 에러를 발생시킬 수 있습니다. memset을 이용하여 미리 0x00으로 설정을 해두면. memcpy의 원본이 사본의 영역을 넘어서지
//않는한 안전합니다.

//다시 한번 설명하면 위에서 
//  memcpy( g_ClientID, tempID, strlen(tempID));
//를 memset없이 사용할경우, tempID를 "Guest"라고 하고, g_ClientID의 길이를 32라고 할때, g_ClientID의 영역에 는 어떤 값이 있을지 알 수 없습니다. 
//그래서 g_ClientID에 "Guest"가 복사되고 난 다음바이트에 0x00없는 경우가 생길 수 있습니다. 이때 그 다음명령인 temp(CString으로 예상되는)에 g_ClientID를 넣을때. 
//0x00를 g_ClientID의 크기인 32바이트에서 찾지 못하면 계속 수Mbyte라도 복사하려 시도할 수 있으며. 이때 다른 부분의 메모리를 건드려서 Access Violation을 발생시킬 수 있습니다.

위에서 설명한 2가지가 memset과 memcpy를 사용하는 이유입니다.

예제)
struct PATIENT_DATA
{
  unsigned short Index;
  char OperaterID[9];
  char PatientID[9];  
  char Date[17];     
  char Marker[5];    
  float Result;
  //char Result[8];     
  char IsNegative[4];   
  // unsigned short IsNegative;
  PATIENT_DATA *pNext; 
  //total byte : 56byte
};

	PATIENT_DATA g_stPatientDB;

	char buff[17] = {0};
	char *buff2;

	buff2 = g_stPatientDB.Date;

	sscanf("3 6 8 1 3 5 7 8 9 10", "%d %d %d %d %d %d %d %d %d %d", buff2, buff2+1, buff2+2, buff2+3, buff2+4, buff2+5, buff2+6, buff2+7, buff2+8, buff2+9);

	memcpy(buff, g_stPatientDB.Date, sizeof(g_stPatientDB.Date)); -> 이렇게 구조체 배열 앞에 &를 사용하거나 안 하거나 데이터는 제대로 옮겨짐
	memcpy(buff, &g_stPatientDB.Date, sizeof(g_stPatientDB.Date));

예제)
// 메모리 복사하기(memcpy).
/*
원형   void* memcpy(void* dest, const void* src, unsigned int count);
       dest는 복사될 버퍼, src는 복사할 버퍼, count는 복사할 src의 메모리 크기
    자료형이 없으므로 포인터주소를 사용하여 복사만이 가능하다.
*/

#include<stdio.h>
#include<string.h>

struct tagM1     // 구조체 선언.
{
 int x;
 int y;
 char buffer[30];
};

void main()
{
 struct tagM1 x1, x2;  // 변수 선언.

 x1.x=5;   // 구조체 변수 x1을 초기화.
 x1.y=10;
 strcpy(x1.buffer, "memory copy");   // 문자열 카피함수를 사용하여 x1.buffer에 "memory copy"문자열 복사.
 
 //strcpy(x2.buffer, x1.buffer); 구조체 멤버간의 복사만 가능하다.
 memcpy(&x2, &x1, sizeof(x1));  // sizeof(x1)의 크기만큼 복사.
 /* 구조체를 통째로 복사한다. 만약 구조체를 strcpy()함수를 사용하여 복사하고자 한다면,
    strcpy()함수는 NULL(0)까지만 복사하기 떄문에 제대로 복사되지 않는다. */

 puts(x2.buffer);
}

// strcpy()함수는 문자열을 복사하는 함수이고, memcpy()함수는 메모리를 복사하는 함수이다.


메모리 영역 검색과 비교 함수
memchr					// 메모리 영역에서 임의의 문자 검색
						//  void *memchr(const void *s, 검색하고자 하는 문자, 검색할 영역의 크기_바이트
memcmp            		//메모리 영역에 저장된 내용 비교
                        //  int memcmp(const void *s1, const void *s2, 비교할 영역의 크기_바이트)

12. 입출력 함수
<stdio.h>
표준 입출력 장치로 한 문자를 입출력하는 함수
getchar					// 표준 입력을 통한 한 문자씩 입력 받음
                        //  int getchar(void) , 입력받은 문자 반환

putchar              	// 표준 출력에 한 문자를 출력
                        //  int putchar(int 출력할 문자), 출력할 문자 반환
표준 입출력 장치로 한 행의 문자열을 입출력하는 함수 
gets                    // 표준 입력을 통한  한 행의 문자열 입력 받음
                        //  char *gets(char *s), 문자열 s에 대한 포인터 반환
puts                    // 표준 출력에 한 행의 문자열을 출력
                        //  int puts(const char *s), 음수가 아닌 값을 반환
표준 입출력 장치로 서식을 갖춘 데이터를 입출력하는 함수
scanf                  	// 표준 입력을 통해 서식을 갖춘 데이터를 입력받음
                        //  int scanf(const char *서식문자열, 값을 저장할 변수들의 주소), 
						//	입력된 항목 수 반환
	%o              8진 정수
	%d              10진 정수
	%ld             long형 10진 정수
	%x              16진 정수 
	%f				float형식
	%lf             double
	%c              문자 형식으로 입력
	%s              문자열 형식으로 입력

printf					// 데이터를 서식화하여 표준 출력으로 출력
                        //  int printf(const char *서식문자열, 출력할 변수들)
	%o				8진 정수
	%d              10진 정수
	%ld             long형 10진 정수
	%x              16진 정수 
	%u              부호 없는 10진 정수 형식
	%f              float형식
	%lf             double					-> sprintf 함수에서는 %lf 사용해도 소수점 6자리 까지만 표현 됨, 소수점 6자리 이상 표현 하려면 ex) %.10f 와 같이 사용해야 함, ex) sprintf( jigDataInfo.dataName,  "%.10f", gs_pInterView->m_fSingleMeterCode_a);
	%c              문자 형식으로 입력
	%s              문자열 형식으로 입력
	%e %E        	지수 형식
	%g %G        	%e와 %f 중 짧은 쪽, 소수점에 이어지는 0은 생략

	printf("%d\r\n", 123);						// ->123
	printf("%5d\r\n", 123);						// ->  123
	printf("%05d\r\n", 123);					// ->00123				// 앞자리가 0으로 채워짐
	printf("%-5d\r\n", 123);					// ->123  // 123뒤로 2자리 띄어쓰기  
	printf("%f\r\n", 1.234567);					// ->1.234567
	printf("%.4f\r\n", 1.234567);				// ->1.2346
	printf("%7.2f\r\n", 1.234567);				// ->   1.23            // 전체 7자리(실수+소수점+소수 포함 7자리), 소수2자리
	printf("%07.2f\r\n", 1.234567);				// ->0001.23            // 전체 7자리(실수+소수점+소수 포함 7자리), 소수2자리
	printf("%07.2f\r\n", 1.2);					// ->0001.20            // 전체 7자리(실수+소수점+소수 포함 7자리), 소수2자리
	printf("%6.2f\r\n", 1234.23);				// ->1234.23            // 지정 폭이 좁아도 전체 출력
	printf("%s\r\n", "hello, linux");			// ->hello, linux
	printf("%10s\r\n", "hello, linux");			// ->hello, linux		// 지정 폭이 좁아도 전체 출력
	printf("%015s\r\n", "hello, linux");		// ->000hello, linux	// 앞자리가 0으로 채워짐
	printf("%15s\r\n", "hello, linux");			// ->   hello, linux	// 앞자리가 빈 공간으로 채워짐

->	ex1)unsigned char chTemp = 255;
		char szTemp[128] = {0};

		sprintf(szTemp, "%3d", chTemp);							// szTemp[0] = 0x32, szTemp[1] = 0x35, szTemp[2] = 0x35
		sprintf(szTemp, "%2d", chTemp);							// szTemp[0] = 0x32, szTemp[1] = 0x35, szTemp[2] = 0x35	-> "%2d"로 자리수는 2자리 이지만 chTemp가 3자리 이기 때문에 szTemp에 3자리로 복사 됨

	ex2)unsigned char chTemp = 25;
		char szTemp[128] = {0};

		sprintf(szTemp, "%3d", chTemp);							// szTemp[0] = 0x20, szTemp[1] = 0x32, szTemp[2] = 0x35
		sprintf(szTemp, "%2d", chTemp);							// szTemp[0] = 0x32, szTemp[1] = 0x35					-> "%2d"로 자리수가 2자리이고 chTemp도 2자리 이기 때문에 szTemp 2자리를 차지 함

	ex3)unsigned char chTemp = 25;
		char szTemp[128] = {0};

		sprintf(szTemp, "%2X", chTemp);							// szTemp[0] = 0x31, szTemp[1] = 0x39

	ex4)unsigned char chTemp = 5;
		char szTemp[128] = {0};

		sprintf(szTemp, "%2X", chTemp);							// szTemp[0] = 0x20, szTemp[1] = 0x35
		
	ex5)char szTemp[128] = {0};
		double m_fTemp = -12.123456789123;

		sprintf(szTemp, "%.9f", m_fTemp);
			// szTemp[0] = 45 = 0x2d = '-'
			// szTemp[1] = 49 = 0x31 = '1'
			// szTemp[2] = 50 = 0x32 = '2'
			// szTemp[3] = 46 = 0x2e = '.'
			// szTemp[4] = 49 = 0x31 = '1'
			// szTemp[5] = 50 = 0x32 = '2'
			// szTemp[6] = 51 = 0x33 = '3'
			// szTemp[7] = 52 = 0x34 = '4'
			// szTemp[8] = 53 = 0x35 = '5'
			// szTemp[9] = 54 = 0x36 = '6'
			// szTemp[10] = 55 = 0x37 = '7'
			// szTemp[11] = 56 = 0x38 = '8'
			// szTemp[12] = 57 = 0x39 = '9'
			// szTemp[0] = 0			
			// szTemp[0] = 0

printf(“%.10s”, “hello, linux”);        -> hello, lin    	//10자리만 출력
printf(“%-15s”, “hello, linux”);        -> hello, linux		//왼쪽으로 붙여 10자리 출력
printf(“%10.10s”, “hello, linux”);     	-> hello, lin		//전체 15자리, 10자리만 출력
메모리를 통해 서식을 갖춘 데이터를 입출력하는 함수
sscanf					//메모리 영역을 통해 서식을 갖춘 데이터를 입력받는다.	cf) 키보드로 입력받는 대신 문자열로 입력을 받는다. cf) sscanf 명령은 문자열이 숫자로 이루어져 있지 않은 경우 아예 sscanf 명령을 실행하지 않음
                        // int sscanf(const char *str, const char *format, 값을 저장할 변수들의 주소)
						// 입력된 항목의 수를 반환
원형  :  int sscanf(const char *buffer, const char *buffer, [,address..]); 
헤더 파일 : stdio.h
scanf의 기능과 유사하되 stdin(키보드)로부터 직접 입력 받지 않고 문자열에서 입력을 받는다. 
두번째 인수인 format이 지시하는 서식대로 입력을 받아 세번째 이후의 인수에 저장하되 입력을 받는 대상은 buffer번지의 문자열이다. 
scanf와 마찬가지로 format내의 서식 개수와 뒤따르는 인수의 개수가 같아야 하며 데이터형도 같아야 한다.
이 함수가 사용하는 서식과 입력 형식은 scanf와 동일
#include<stdio.h>
#include <string.h>
void main
{
     int i;
     char str[128];

     strcpy(str, "3");
     sscanf(str, "%d", &i);
     printf("i is %s", i);
}

sprintf					//데이터를 서식화하여 메모리 영역으로 출력, cf) 모니터로 출력하는 대신에 문자열로 출력한다.
						// int sprintf(char *str, const char *format, 출력할 변수들)

#include <stdio.h>

int main(void)
{
	char str[20];
	int num1;
	float num2;
	
	sscanf("Hi! 55 3.141592", "%s %d %g", str, &num1, &num2);
	printf("문자열 추출 데이터 : %s %d %g \n\n", str, num1, num2);
	
	printf("문자열 입력 : ");
	scanf("%s %d %g", str, &num1, &num2);
	printf("키보드 추출 데이터 : %s %d %g \n", str, num1, num2);
	
	return 0;
}

<파일 입출력 함수>
<stdio.h>
fopen		// 파일을 연다.
            // FILE *fopen(const char *path, const char *mode)
            //  path:파일이름      mode :사용형태
			//  mode a “r” 읽기 전용, “w”쓰기전용, “a” 추가용 “rb”바이너리 읽기 전용 “wb”바이너리 쓰기전용, “ab”바이너리 파일 추가용 “r+”읽기와 쓰기용  “w+”쓰기와 읽기용
fclose    	// 파일을 닫는다
            // int fclose(FILE *stream);
            //  stream :닫고자 하는 파일 포인터, 0을 반환, 오류면 EOF반환
fgetc      	// 파일을 통해 한 문자를 입력받음
            // int fgets(FILE *stream)      stream:파일 포인터
            //  입력받은 문자 반환, 파일의 끝이면 EOF반환
fputc       // 파일에 한 문자를 출력
            //  int fputs(int c, FILE *stream);         c:출력할 문자, 입력받은 문자 반환

파일을 통해 한 행의 문자열을 입출력하는 함수
fgets      	//char *fgets(char *s, int size, FILE *stream); s에 대한 포인터 변환, 오류시 EOF출력
fputs      	//int fputs(const char *s, FILE *stream); 음수가 아닌값 반환, 오류면 EOF출력

파일을 통해 서식을 갖춘 데이터를 입출력하는 함수
fscanf    	//int fscanf(FILE *stream, const char *format,…); 입력된 항목 수를 반환 오류면 -1 반환
fprintf     //int fprintf(FILE *stream. const char *format. …); 출력한 문자 수를 반환 오류면 -1 반환

파일을 통해 데이터를 한꺼번에 입출력하는 함수
fread     	//size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
            // 입력받은 문자열에 대한 포인터, 데이터 크기, 입력 받을 데이터 수, 파일 포인터
            // 입력된 데이터 수를 반환, 오류면 -1 반환
fwrite     	//위와 같음

방금 읽은 문자를 파일로 되돌리는 함수
ungetc 		//int ungetc(int c, FILE *stream),   되돌릴 문자를 반환, 오류면 -1반환

<기타 입출력 함수>
파일 오류 관련 함수
feof        //int feof(FILE *stream);    파일의 끝이면 참인 값을 반환하고, 끝이 아니면 0을 반환
feffor      //int ferror(FILE *stream); 파일이 오류면 참, 오류가 아니면 0반환
clearerr 	//void clearerr(FILE *stream); 파일의 끝과 오류 정보를 초기화

파일 읽기/쓰기 위치 관련 함수
ftell       //long ftell(FILE *stream); 읽기/쓰기 포인터 값을 반환, 오류면 -1 반환
rewind   	//void rewind(FILE *stream); 파일의 읽기/쓰기 포인터를 처음으로 되돌린다
fseek     	//int fseek(FILE   *STREAM, long offset, int whence);
          	/* 파일 포인터, 이동할 바이트 수, 시작 시점
				0을 반환, 오류면 -1 반환
			 	whence값 
				-SEEK_SET     파일의 시작
				-SEEK_CUR        현재 읽기/쓰기의 포인터 위치
				-SEEK_END        파일 끝	*/

13. 수학함수
<stdlib.h>
절대값 함수
abs       	//int abs(int j)     				int형
labs       	//long int labs(long int j);    	long형
<math.h>
fabs       	//double fabs(double x);        	double형
나머지 함수
<stdlib.h>
idv         //int 형 나눗셈의 몫과 나머지
			/*	div_t div(int 분자, int 분모)    div_t형 데이터 반환
             		typedef struct{
            			int quot;    -몫 저장
                    	int rem;  -나머지 저장
            	}div_t; */
ldiv        //long형 나눗셈의 몫과 나머지
			/*	ldiv_t ldiv(long int 분자, long int 분모);
					typedef struct{
                       long int quot;    -몫 저장
                       long int rem;       -나머지 저장
             	}ldiv_t; */

<math.h>
fmod      	//double형 나눗셈의 나머지를 구한다.
			//double fmod(double x, double y);
ceil        // 올림 (double) 올림한 값 반환
floor       //내림(double), 버린 값 반환
modf      	//double modf(double x, double *iptr);       정수부와 소수부로 분할
            // x:데이터, iptr:정수부를 가리키는 포인터, 소수부를 반환
난수 함수
<stdlib.h>
rand      	//int rand(void)   난수를 반환
			// ex) rand()%10; // 0~9영역의 난수 생성
srand    	//void srand(unsigned int seed) //rand를 초기화
			// seed:초기값 

cf)	완벽하게 난수생성 방법
	TRACE("%d\n", rand());
	TRACE("%d\n", rand());
	TRACE("%d\n", rand());
	TRACE("%d\n", rand());
	TRACE("%d\n", rand());

	srand(rand());
	TRACE("%d\n", rand());
	srand(rand());
	TRACE("%d\n", rand());
	srand(rand());
	TRACE("%d\n", rand());
	srand(rand());
	TRACE("%d\n", rand());
	srand(rand());
	TRACE("%d\n", rand());

	srand((unsigned int)time(NULL));
	for (int i = 0; i < 5; i++)
	{
		TRACE("%d\n", rand());
	}

	/*	최종 결과값 분석
	1.	상단으로 부터 5개명령 & 5개명령은 프로그램 시작할때 마다 하기와 같이 완전히 동일한 값이 나오는 문제가 있음
	2.	상단으로 부터 마지막 5개명령은 하기와 같이 프로그램 시작할때 마다 완전히 다른 값이 나옴(진정한 난수로 결과가 나옴)

	ex1) 프로그램 1번째 시작
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14315) : atlTraceGeneral - 41
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14316) : atlTraceGeneral - 18467
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14317) : atlTraceGeneral - 6334
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14318) : atlTraceGeneral - 26500
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14319) : atlTraceGeneral - 19169
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14322) : atlTraceGeneral - 18618
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14324) : atlTraceGeneral - 3245
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14326) : atlTraceGeneral - 30635
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14328) : atlTraceGeneral - 4861
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14330) : atlTraceGeneral - 10926
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 1485
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 1964
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 3806
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 13512
	E : \Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 10937

	ex2) ex1) 실행 후 -> 프로그램 종료한 다음 -> 다시 프로그램 시작시킴
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14315) : atlTraceGeneral - 41
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14316) : atlTraceGeneral - 18467
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14317) : atlTraceGeneral - 6334
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14318) : atlTraceGeneral - 26500
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14319) : atlTraceGeneral - 19169
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14322) : atlTraceGeneral - 18618
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14324) : atlTraceGeneral - 3245
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14326) : atlTraceGeneral - 30635
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14328) : atlTraceGeneral - 4861
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14330) : atlTraceGeneral - 10926
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 1697
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 12482
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 18097
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 4763
	E:\Project\ImageTag\Program\TagAnalyzer\TagAnalyzer\TagDecoderDlg.cpp(14335) : atlTraceGeneral - 26024	*/


거듭 제곱과 제곱근 함수
<math.h>
pow       	//x의 y승을 반환(제곱)		cf) 2의3승은 = 8, cf) != 2^3(XOR연산)
            // double pow(double x, double y)
			1) 10의 2제곱을 구한다고 했을 때.
			-> pow(10, 2)
			// 암묵적 형변환에 의해서 10은 (float)10 이런식으로 들어갈 것 입니다.
			2) 2.2의 3.3 제곱을 구한다고 했을 때.
			-> pow(2.2, 3.3)

sqrt       	//x의 제곱근 반환
           	// double sqrt(double x)

기타 수학 함수
sin       	//double sin(double x)
cos       	//double cos(double x)
tan         //double tan(double x)
exp        	//double exp(double x)   	E의 x승을 반환
log        	//double log(double x)    	자연 대수 값을 반환
log10     	//double log10(double x) 	상용대수값 반환
frexp      	//double 형 데이터를 가수부와 지수부로 나눈다
           	// double frexp(double x, int *exp); x:데이터 exp:지수부를 가리키는 포인터
ldexp     	//가수부와 지수부로부터 double형 데이터를 구한다
           	// double ldexp(double x, int exp) x;가수부 exp:지수부

<탐색과 정렬 함수>
선형 탐색 함수
<search.h>
lsearch 	//테이블에서 데이터를 선형 탐색한다. 찾지 못하면 테이블에 추가
			// void lsearch(const void *key, void *base, size_t *nmemb, size_t size, int(*compar)(const void *, const void *));
			//	key:찾고자 하는 데이터, base:테이블의 첫 번째 데이터, nmemb:데이터 개수, size:데이터 크기 compare:비교함수, 같으면 0, 다르면 0이 아닌 값
lfind       //테이블에서 데이터를 선형 탐색. 발견 못하면 NULL리턴
			// void *lfind(const void *key, const void *base, size_t size, int (*compar)(const void *, const void *));
			//	key:찾고자 하는 데이터, base:테이블의 첫 번째 데이터, nmemb:데이터의 개수, size : 데이터의 크기 compare:두 데이터 비교 함수 같으면 0, 다르면 0아닌 값
이진 탐색 함수
bsearch     // 테이블은 반드시 정렬되어 있어야 한다.
			// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
			//	key :찾고자 하는 데이터, base:테이블의 첫 번째 데이터, nmemb:데이터의 개수, size:데이터의 크기, compare:비교함수 같으면 0, 아니면 0아닌 값
이진 트리 관리
tsearch 	//이진 트리에서 데이터를 탐색, 정렬 안해도 됨.
			//찾은 데이터에 대한 포인터 반환, 발견 못하면 트리에 추가, 추가한 데이터 포인터 반환
			// void *tsearch(const void *key, void **rootp, int(*compar)(const void*, const void *));
			//  key:찾고자 하는 데이터, rootp:이진 트리에 대한 포인터 compar:비교함수
tfind       //이진 트리에서 데이터 탐색. 발견 못하면 null, 위랑 같음
tdelete   	//데이터 삭제, 위랑 같음. 삭제한 데이터의 부모 노드에 대한 포인터 반환
twalk      	//이진트리 방문
			// void twalk(const void *root, void (*action)(const void *nodep, const VISIT which, const int depth));
			//  root : 이진 트리에 대한 포인터
			//  action:구체적 동작을 하는 함수
해시 테이블 관리
hcreate 	//해시 테이블 만든다
			// int hcreate(unsigned nel);             nel:저장할 데이터 개수, 생성못하면 null반환
hsearch    	//해시 테이블에서 데이터 탐색
			// ENTRY *hsearch(ENTRY item, ACTION action); item:찾고자 하는 데이터
            // ACTION : FIND ?발견 못하면 NULL반환, 
			// ENTER-발견못하면 삽입, 삽입한 데이터 포인터 반환
hdestroy    //해시 테이블 제거
			// void hdestroy(void)
퀵 정렬 함수
qsort     	//퀵정렬을 한다.
			// void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *));
            // base:정렬할 테이블의 첫 번째 데이터, nmemg:데이터 개수,..
날짜와 시간 함수
시간 표시 함수
<time.h>
time       	//초 단위의 현재 시간 정보를 얻음.
           	// time_t time(time_t *t); t:시간 정보에 대한 포인터. 시간 정보 반환 오류면 -1 리턴
ctime     	//time_t형 시간 정보를 문자열로 변환
          	// char *ctime(const time_t *timep);  timep:time_t형 시간 정보에 대한 포인터
형식 변환 함수
localtime   //time_t형 시간 정보를 struct tm형 지역 시간으로 변환




[2]	C언어 설명

제 1 장 C언어의 개요
1. C언어의 배경
·ALGOL 60 : 국제 위원회에서 설계
·CPL : 영국 캠브리지와 런던 대학에서 설계
·B : BELL 연구소에서 설계
·C : BELL 연구소에서 설계

▼ C언어의 구성
main() 함수부터 실행이 시작
·반드시 하나 이상의 main() 함수가 있어야 한다.
·함수의 시작과 끝은 {,} 안에 기입한다.
·일반적으로 프로그램은 소문자로 작성하며, 대문자와 소문자는 구분됨
·설명문은 /*와 */ 범위 내에 기입
·한문장의 끝은 ; 로 구분

2. 상수와 변수
▼ 상수(constant)
1)문자형 상수
·단일 문자 : apostrophe(') 내에 표현
·문자열(복수 문자) : quotation-mark(") 내에 표현
☞ 예 "korea", "Hong G. D"

2)수치형 상수
·정수형
.10진 정수 : 0-9, 부호로 구성
.8진 정수 : O으로 시작하며, 0-7로 구성
.16진 정수 : Ox로 시작하며, 0-F로 구성
·실수형 : 0-9, 부호, 소수점, 지수 표현()으로 구성
cf)	숫자(number)에는 다양한 구분이 있습니다.
정수(integer)는 .... -3, -2, -1, 0, 1, 2, 3, ... 과 같은 숫자를 의미하는 데, (-)가 붙은 값과 0도 포함합니다.
실수(real number)는 정수(integer)에 소수점이 있는 값까지 포함합니다. 예를들어 1/2, 1/3, ... 을 포함하는 데, 실수는 일반적으로 생각할 수 있는 모든 값이 실수(real number)입니다.
참고로, 숫자는 실수와 허수로 구성되는 데, 허수라는 것은 일반적으로 생각할 수 있는 숫자는 아니고 개념적인 숫자입니다.

▼ 식별자(identifier)의 규칙
·A-Z, a-z, 0-9, 밑줄(_)로 구성
·변수명은 일반적으로 소문자를 사용
·첫 글자는 영문자 또는 밑줄로 시작
·8자 이내로 구성
·예약어 사용 불가능

3.형 선언
분 류	형 선 언				기 능  
문자형  char            		1byte 단일 문자 또는 문자열		-128 ~ 127(unsigned로0~255 -> signed로0~127~-128~-1)(-128은 unsigned로 128, -1은 unsigned로 255)
문자형  unsigned char   		1byte 단일 문자 또는 문자열		0 ~ 256(=0xff;1byte;8bits)
정수형  short (int)				2byte 정수   					-32,768 ~ 32,767
정수형  unsigned short (int)	2byte 정수						0 ~ 65,535(=0xffff;2bytes;16bits),				cf)VR3511F는 unsigned short 가 2byte임(0xffff, 실제 확인 결과).
정수형  int						4byte 정수                      -2,147,483,648 ~ 2,147,483,647					cf)-2,147,483,648 == 0x80000000, 2,147,483,647 == 0x7fffffff
정수형	unsigned int			4byte 정수						0 ~ 4,294,967,295(=0xffffffff;4bytes;32bits),	cf)VR3511F는 unsigned int 가 4byte임(0xffffffff, 실제 확인 결과).
정수형  long(long int)			4byte 정수						-2,147,483,648 ~ 2,147,483,647
정수형  unsigned long			4byte 정수						0 ~ 4,294,967,295
실수형  float           		4byte							-1.7E38 ~ 1.7E38        cf) 소수점 6자리 까지만 유효, E38 = 10의 38제곱, 2E-05 = 2 x 10의 -05승 = 0.00002
																						cf) float 은 현재 32비트이다.. 4바이트(1비트의 부호비트와 8비트의 지수부, 23비트의 소수부를 가진다.)
실수형  double          		8byte							-3.4E308 ~ 3.4E308		cf) 소수점 15자리 까지만 유효, VR3511F는 double 가 8byte임(실제확인, VR3511F는 지수부가 1자리 인 경우 소수 15 자리까지 유효 함).


cf)	자바의 경우
분 류	형 선 언				기 능  
정수	byte            		1byte(8bit)						-128 ~ 127
정수	char            		2byte(16bit)					0~65535
정수	short					2byte(16bit)					-32,768 ~ 32,767
정수	int						4byte(32bit)					-2,147,483,648 ~ 2,147,483,647
정수	long					8byte(64bit)					-2^63 ~ (2^63-1)		ex)	long var = 10 // ok, long var = 20L // ok, long var = 1000000000000 // 컴파일 에러(int 범위를 넘어섰는데 L을 붙이지 않았기 때문),
																							long var = 1000000000000L // ok
실수	float           		4byte(32bit)					(+/-)1.4E-45 ~ (+/-)3.4028235E38
실수	double          		8byte(64bit)					(+/-)4.9E-324 ~ (+/-)1.7976931348623157E308
논리	boolean					1byte(8bit)						true, false

cf)	자바는 unsigned 가 없다 따라서 하기와 같이 처리해줘야 함
	int iValue = 0xff000000;
	long LValue1 = (long)iValue;
	long LValue2 = iValue & 0xffffffffL;
	long LValue3 = 0xff000000;
	long LValue4 = 0xff000000L;

	System.out.println("int iValue = " + iValue);
	System.out.println("(long)iValue = " + (long)iValue);
	System.out.println("long LValue1 = " + LValue1);
	System.out.println("long LValue2 = " + LValue2);
	System.out.println("long LValue3 = " + LValue3);
	System.out.println("long LValue4 = " + LValue4);

->	int iValue = -16777216
	(long)iValue = -16777216
	long LValue1 = -16777216
	long LValue2 = 4278190080
	long LValue3 = -16777216
	long LValue4 = 4278190080


cf)	char
	-128	=	0x80
	-127	=	0x81
	-100	=	0x9C
	-99		=	0x9D
	-10		=	0xF6
	-1		=	0xFF
	0		=	0x00
	1		=	0x01
	10		=	0x0A
	99		=	0x63
	100		=	0x64
	127		=	0x7F	
																						cf) double 형은 8바이트이다.. 64비트(1비트의 부호비트와 11비트의 지수부, 52비트의 소수부로 이루어져있다.)
cf)	float 은 소수점이하 6자리까지 표현되고
	double 은 소수점이하 15자리까지 표현된다고 하는 이유
	float 의 예만 봐도 표현할수 있는 수는 최대값이 3.4 * 10 ^ 38 입니다.
	float 의 경우 소숫점 이하 6자리 표현이라고 함은...
	float 타입이 23 비트를 이용하여 소수부를 표시하는데..  23비트로 신뢰할 수 있는 숫자를
	만들어 낼수 있는 자리수가 소수점 6자리 정도까지라는 것입니다.
	즉 소숫점 이하 6자리 이상의 값이 출력될때 그 이상은 근사값이므로 "정확한 값이라고 믿으면 안된다" 라는 뜻으로 해석해야 합니다.
	하지만 소숫점 6자리라는 것도 절대적인 것이 아니기 때문에 너무 맹신하시면 안됩니다.
	컴퓨터에서 0 과 1로 실수를 표현할려고 하니... 당연히 표현상의 오차가 발생하는것은 어쩔 수 없습니다.
	double 의 경우도 마찬가지로 설명할 수 있겠습니다.
	1)	float 형: 
		2.000000+3.600000*4.000000=16.400000 
	2)	double 형: 
		2.000000000000000+3.600000000000000*4.00000000... 

cf)	float = 4byte  ==> %f
	double = 8byte   ==> %lf	-> sprintf 함수에서는 %lf 사용해도 소수점 6자리 까지만 표현 됨, 소수점 6자리 이상 표현 하려면 ex) %.10f 와 같이 사용해야 함, ex) sprintf( jigDataInfo.dataName,  "%.10f", gs_pInterView->m_fSingleMeterCode_a);
	%f로 출력하면 무조건 소수점이하 6자리가 나옵니다.
	그래서 3.140000로 0으로  4자리를 채웠지요..
	3.14만 출력하고 싶으면 %.2f 이렇게 하면 두자리만 나옵니다.

cf)	16비트, 32비트에서의 unsigned
그냥 unsigned라고 되어있다면..
그건 unsigned int 입니다..
이건 프로세서에 따라 다른데요..
16비트 컴퓨터면.. 16비트 즉 2바이트이고..
32비트 컴퓨터면.. 4바이트..
63비트면.. 8바이트 입니다..

두번째 질문은 애매한데요..
가장작은 변수는 char로.. 8비트입니다.. 
가장작은 자료의 표현 단위.. 는.. 1비트겠죠.. ;;

######## 아주 아주 중요 #######
cf)	sizeof로 struct의 사이즈를 잴 경우 각별한 주의가 필요
	cf)	일반 변수/배열은 sizeof 함수가 제대로 사이즈를 읽지만
		struct는 데이터얼라이언먼트 때문에 제대로 못 읽는 경우 있음
	
	sizeof로 struct의 크기를 쟀더니 크기가 틀린데
	데이터얼라이언먼트 때문에 4바이트 씩 자리를 맞추기 때문임
	(나열되는 데이터의 형식이 틀릴 경우에만 4바이트 자리가 적용 됨)
	
	컴퓨터의 성능 향상을 위해 데이터는 4바이트 씩 자리를 맞춰줘서 데이터 접근이 쉽도록 함
	
	cf)	struct, sizeof의 관계에 대해서 몰라도 될 것 같은데
		보통의 경우는 맞다, 이런 세부적 사항들은 시스템에서 내부적으로 알아서 처리하기 때문임
		(cf, struct 구조체는 메모리 상에 시작 주소부터 정해진 규칙에 따라 배치 된다.
			 CPU 입장에서 보면 하나의 주소값을 변환하여 처리 한다.)	
		하지만, 운영체제가 다른 이기종간의 통신, 파일처리 등은 엉뚱한 데이터를 참조할 수 있기 때문에 주의를 해야 함
		ex)	A시스템 : struct member alignment = 4 사용
			B시스템 : struct member alignment = 1 사용
			A시스템 <-> B시스템 간에 통신 or 파일처리(fopen) 등을 할 경우 엉뚱한 데이터를 참조할 수 있음
			cf)	동일 시스템 내부에서 처리라면 struct member alignment의 값이 어떤 값을 가지던 문제 되지 않음

ex)
struct tag_Friend
{
	char Name[10];					// 10bytes -> 12bytes로 처리
	int Age;						// 4bytes
	double Height;					// 8bytes
//	sizeof(tag_Friend) = 24bytes
};

struct sizeof_test1
{
	char c1[3];
	int i1;
	float f1;
//	sizeof(sizeof_test1) = 12
};

struct sizeof_test2
{
	char c1[3];
	char c2;
	float f1;
//	sizeof(sizeof_test2) = 8
};

struct sizeof_test3
{
	char c1;
	int i1;
	char c2;
	float f1;
	char c3;
//	sizeof(sizeof_test3) = 20
};

struct PATIENT_DATA2					// sizeof(PATIENT_DATA2) = 128bytes(68(=2+17+17+1+20+10) + 4 + 8 + 20 + 4 + 20 + 4), cf) unsigned short 는 char 와 같은 형식으로 처리되는 것 같음
{
	unsigned short Index;				// 본 Index 는 환자 측정결과를 읽어들이는 경우에만 필요(측정결과 리스트 순서), 저장하는 경우에는 필요 없음(저장할 때는 모든 측정값이 무조건 Index = 0으로 저장됨)

	#if 1 // fix@20120203 : 수정요청 
	char OperaterID[17];
	char PatientID[17];
	char TestKind;						// Patient Test / Quick Test 를 구별
	#else
	char OperaterID[9];
	char PatientID[9];
	#endif

	#if 0 // fix@20120416 : sec addition
	char Date[17]; 
	#else
	char Date[20]; 
	#endif
 

	#if 1 // fix@stripbarcode : 마커이름 9자 표기 
	char Marker[10]; 
	#else
	char Marker[5]; 
	#endif

//	float Result;							// del@20110908 : 위치 변경 
//	char Result[16];
//	char IsNegative[4];					// del@20110908 : Nor/Abn 항목 제외
//	unsigned short IsNegative;

	// add@qctest
	int LotID;							// Lot ID(== Code)
	char Conc[8];						// LEVEL 1, LEVEL 2
//	char CheckRlt[5];					// Check result (pass, fail)
	// fix, CST Mode -> 측정값 표시 방법으로 변경
	char CheckRlt[20];					// Check result (SST : PASS/FAIL, CST(ex) : PASS(1234.56mIU/mL)/FAIL(1.23ng/mL))(최대 19자)
	// fix
	// add

	float Result;						// add@20110908 : 위치 변경   
	char ResultStr[20];				// add@20120416 : float -> string, 본 Data에 측정결과값 뿐만 아니라 측정단위까지 포함되어서 저장 됨
  
	PATIENT_DATA *pNext;
//	sizeof(PATIENT_DATA) = 128bytes
};

	sizeof_test1 stTemp;

	printf("sizeof(tag_Friend)=%d\n", sizeof(tag_Friend));			->	sizeof(tag_Friend)=24
	printf("sizeof(sizeof_test1)=%d\n", sizeof(sizeof_test1));		->	sizeof(sizeof_test1)=12
	printf("sizeof(stTemp)=%d\n", sizeof(stTemp));					->	sizeof(stTemp)=12
	printf("sizeof(stTemp.c1)=%d\n", sizeof(stTemp.c1));			->	sizeof(stTemp.c1)=3
	printf("sizeof(sizeof_test2)=%d\n", sizeof(sizeof_test2));		->	sizeof(sizeof_test2)=8
	printf("sizeof(sizeof_test3)=%d\n", sizeof(sizeof_test3));		->	sizeof(sizeof_test3)=20
	printf("sizeof(PATIENT_DATA2)=%d\n", sizeof(PATIENT_DATA2));	->	sizeof(PATIENT_DATA2)=128

4.	표준 입, 출력 함수
▼ 제어문자(escape sequence)
종 류  기 능  종 류  기 능  
＼n new line            ＼a bell소리 
＼r carriage return     ＼0 null문자 
＼b backspace           ＼＼ back slash(＼)문자 
＼t tab					＼' apostrophe(')문자 
＼v tab					＼" quotation mark(")문자 
＼f form feed			＼? question mark(?)문자 

\a        경고음
\b        백 스페이스
\t        수평 탭
\v        수직 탭
\n        줄 바꿈(0x0A)
\f         피드백
\r         캐리지 리턴(0x0D)
\'       '
\"       "
\\     \
\?      8진수의 000을 가지는 문자(000은 0~7까지의 숫자가 들어갑니다.)
\000    16진수로 앞에 x를 붙이고 나오는 16진수입니다.


\		역슬래시(\), 긴명령어 쓸 경우 줄바꿈, 일반 명령어 뿐만 아니라 #define 문에서도 사용 가능
ex1) 	strDataSave.Format("Number, mAbsTCRatio, AreaTCRatio, T_Peak, T_PeakPosition, T_RefArea, T_ABSArea, T_mABS, C_Peak, C_PeakPosition, C_RefArea, C_ABSArea, C_mABS, \
									mAbsTCRatio, AreaTCRatio, T_Peak, T_PeakPosition, T_RefArea, T_ABSArea, T_mABS, C_Peak, C_PeakPosition, C_RefArea, C_ABSArea, C_mABS, \
									mAbsTCRatio, AreaTCRatio, T_Peak, T_PeakPosition, T_RefArea, T_ABSArea, T_mABS, C_Peak, C_PeakPosition, C_RefArea, C_ABSArea, C_mABS\r\n");
ex2)
#define INTRO "Perfect C Language \
& Basic Data Structure"

cf)	코드 한 줄을 여러 줄로 나눠 쓰기(python)
보통의 경우는 백 슬래시 \나 괄호()를 쓰시면 됩니다.
e = 'a' + 'b' + \
    'c' + 'd'

e = ('a' + 'b' + 
    'c' + 'd')

if a == True and \
    b == False :
    ...

그냥 파라미터를 넘기는 거라면 다음과 같이 써도 괜찮습니다
myfunc(param1, param2,
param3, param4,
param5, param6)

다만, if문은 괄호를 쓰는 방법은 지원하지 않으니 if의 경우에는 \만 쓰실 수 있습니다.


▼ 서식지정문자
기 호  기 능  기 호  기 능  
％d 10진 정수  ％c 단일 문자  
％o 8진 정수  ％s 문자열  
％x 16진 정수  ％f 소수형 실수  
％l long형  ％e 지수형 실수  
％u 부호없는 양의 정수  ％g ％f, ％e의 혼합  
 
▼ 서식지정함수
·scanf() : 키보드로부터 데이터를 서식에 의해 입력받는 명령
·printf() : 데이터를 출력할 때 사용하는 명령
·getchar() : 키보드로 단일 문자 하나를 입력 받는 명령
·putchar() : 단일문자 출력 함수
·gets() : 문자열을 입력받는 함수
·puts() : 문자열을 출력하는 함수

제 2 장 연산자 및 제어문
1. 연산자
분 류           연 산 자                                            결합방향  
단항연산자      (), [], ->, .                                       → 
                 ！, ∼, ＋＋, --, －(type명), ＊, ＆, sizeof       ← 
이항연산자
    승제        ＊, ／, ％                                          → 
    가감        ＋, －                                              →
    shift       《, 》                                              →
    비교        〈, 〉, 〈＝, 〉＝                                  →
    등가        ＝＝                                                →
    bit AND     ＆                                                  →
    bit XOR     ^                                                   →
    bit OR      |                                                   →
    논리 곱     ＆＆                                                →
    논리 합     ||                                                  →
    논리 부정   !                                                   →
조건 연산자     ？, :                                               ← 
대입 연산자     ＝,＋＝,－＝,＊＝,/＝,％＝,》＝,《＝,＆＝,^＝,|＝   ← 
증감 연산자     + +, - -                                            → 
순차 연산자     ,
★ 연산자 우선 순위는 위가 높고 아래가 낮다.

구 분           연산자  의미            우선순위  
증감 연산자     ＋＋    1증가           같다
                --      1감소           같다
관계 연산자     〉      크 다           1
               〈       작 다           1
               〉＝     크거나 같다     1
               〈＝     작거나 같다     1
               ＝＝     같다            2
               !=       다르다          2
논리 연산자     |       논리NOT         1
                ＆＆    논리AND         2
                ||      논리OR          3
산술 연산자     ＋      덧셈            2
                －      뺄셈            2
                ＊      곱셈            1
                ／      나눗셈          1 				ex) nMin = nTime / 60;		// 누적된 초(nTime)를 60으로 / 하면 분이 나옴, ex2) 0 / 12 -> 0이 나옴
                ％      나머지          1 				ex) nSec = nTime % 60;		// 누적된 초(nTime)를 60으로 % 하면 초가 나옴, ex2) 61 % 60 -> 1이 나옴, 119 % 60 -> 59가 나옴, 120 % 60 -> 0이 나옴
                ~       1의 보수        1 
                ＆      bit AND         2 
                ^       bit X-OR        3 
                |       bit OR          4 
                <<      shift left      같다 			ex) 0x59 << 1;	// 01011001(0x59) -> 10110010(0xb2), cf) 채워지는 것은 0으로 채워짐, << 1 : 2를 곱한 것과 동일한 결과가 나옮(0xb2 = 0x59 X 2)
                >>      shift right     같다			ex)	0x59 >> 1;	// 01011001(0x59) -> 00101100(0x2c), cf) 채워지는 것은 0으로 채워짐, >> 1 : 2로 나눈 것과 동일한 결과가 나옮(0x2c = 0x59 / 2)


▼ 표 25?1 C 언어 연산자 우선순위 
우선순위	연산자				설명															결합 법칙(방향)
---------------------------------------------------------------------------
1					x++						증가 연산자(뒤, 후위)							→
					x--						감소 연산자(뒤, 후위)	
					( )						함수 호출	
					[ ]						배열 첨자	
					.							구조체/공용체 멤버 접근	
					->						포인터로 구조체/공용체 멤버 접근	
					(자료형){값}	복합 리터럴	

2					++x						증가 연산자(앞, 전위)							←
					--x						감소 연산자(앞, 전위)	
					+x						단항 덧셈(양의 부호)	
					-x						단항 뺄셈(음의 부호)	
					!							논리 NOT	
					~							비트 NOT	
					(자료형)			자료형 캐스팅(자료형 변환)	
					*x						포인터 x 역참조	
					&x						x의 주소	
					sizeof				자료형의 크기	
			
3					*							곱셈															→
					/							나눗셈	
					%							나머지	

4					+							덧셈															→
					-							뺄셈	

5					<<						비트를 왼쪽으로 시프트						→
					>>						비트를 오른쪽으로 시프트	

6					<							작음															→
					<=						작거나 같음	
					>							큼	
					>=						크거나 같음	

7					==						같음															→
					!=						다름	

8					&							비트 AND													→

9					^							비트 XOR													→

10				|							비트 OR														→

11				&&						논리 AND													→

12				||						논리 OR														→

13				? :						삼항 연산자												←

14				=							할당															←
					+=						덧셈 후 할당	
					-=						뺄셈 후 할당	
					*=						곱셈 후 할당	
					/=						나눗셈 후 할당	
					%=						나머지 연산 후 할당	
					<<=						비트를 왼쪽으로 시프트한 후 할당	
					>>=						비트를 오른쪽으로 시프트한 후 할당	
					&=						비트 AND 연산 후 할당	
					^=						비트 XOR 연산 후 할당	
					|=						비트 OR 연산 후 할당	
			
15				,							쉼표(콤마) 연산자									→

연산자 우선순위를 모두 외울 필요는 없으며 필요할 때 찾아보면 됩니다. 실무에서는 연산자의 계산 순서를 ( ) (괄호)로 명확하게 나타내는 것을 선호합니다.
보통 남이 만든 코드 중에서 연산자에 괄호를 잘 사용하지 않아 이해하기가 힘들 때나 찾아보면 됩니다.

▼ 기타연산자
1) 조건 연산자(물음표)
	조건식 ? 식1:식2
    조건식이 참이면 식1을 선택, 거짓이면 식2를 선택
예1] 
var temp_a = random(100); 
var temp_b = random(100); 
if(temp_a > temp_b){ 
trace("MAX"); 
}else{ 
trace("MIN"): 
} 

예2] 
var temp_a = random(100); 
var temp_b = random(100); 
temp_a > temp_b ? trace("MAX"): trace("MIN"); 

2) sizeof연산자 : sizeof(변수나 상수 또는 형명)
    할당된 메모리의 크기를 바이트 단위로 구한다
3) cast연산자 : (형명)
    데이터 또는 수식 데이터형을 다른 데이터형으로 바꾼다.
4) 순차 연산자 : 식1, 식2 ...
    식을 왼쪽부터 차례로 수행

cf)	### sizeof 명령을 포인터와 같이 사용할 때는 세심한 주의가 필요 함
    -> 잘 못 사용하면 경우에 따라서 일어나는 버그가 발생할 수 있음
1)	char g_chOPID[17];
2)	Touch_DelChar(g_chOPID);
3)	void Touch_DelChar(char *strID)
	{
        char tmpStr[17];

		#if 0
		memset(strID, 0x00, sizeof(strID));                     // g_chOPID 배열을 전부를(사이즈 17) 초기화하는 의도이지만 실제는 g_chOPID 배열을 사이즈 4 까지만 지워주는 버그가 발생함.
		strncpy(strID, tmpStr, sizeof(strID));
		#else
		// fix, strID 포인터가 가르키는 변수에 저장된 사이즈가 4이상인 경우 제대로 변수 데이터가 지워지지 않는 에러 제거
		//      sizeof(strID)의 값은 포인터의 사이즈이기 때문에 항상 4 이며 따라서 제대로 strID 포인터의 데이터를 지우고 쓸 수 없는 에러 발생 함
		//      따라서, 하기와 같이 포인터가 아닌 배열의 사이즈로 수정해서 strID 포인터가 가르키는 변수에 저장된 사이즈가 4 이상인 경우에도 제대로 지우고 쓸 수 있도록 수정
		memset(strID, 0x00, sizeof(tmpStr));
		strncpy(strID, tmpStr, sizeof(tmpStr));
		// fix
		#endif
	}

2. 제어문
제어문의 종류
·선택문 : if문, swich문
·반복문 : while문, do-while문, for문
·보조 제어문 : break문, continue문, goto문

▼ if문
조건식에 따라 문장을 달리 수행하고자 할 때 사용한다.

if(조건식)
{
    수행문장-1;
}
else
{
    수행문장-2;
}

▼ switch 문
switch문의 수식이 case문의 상수와 같은 곳으로 이동하여 문장을 수행
int iCnt = 0, iCnt2 = 10;

while (true)
{
	switch (iCnt++)				// switch문은 반복문이 아님
	{
		case 0:
			Console.WriteLine(iCnt2++);
			break;
		case 1:
			Console.WriteLine(iCnt2++);
			break;
		case 2:
			Console.WriteLine(iCnt2++);
			break;
		case 3:
			Console.WriteLine(iCnt2++);
			break;
		default:                // iCnt 변수가 상기 case 문에 모두 맞지 않은 경우 실행
			break;              // 본 break; 명령을 실행해도 switch 문을 빠져 나온 것이지 while 완전히 빠져 나온 것이 아니기 때문에 계속 해서 while문 때문에 switch문을 실행 함
	}

	if (iCnt > 10)
		break;					// iCnt = 11, iCnt2 = 14 인 상황에서 본 문단으로 들어와서 상기 while문을 완전히 빠져 나옴
}

-> 출력물
10
11
12
13

▼ while문
조건식이 만족할 때까지 반복 수행
while(조건식)
{
    수행문장;
}
while문은 조건식을 먼저 판단하여 반복 수행여부를 결정(선비교 후 수행) 
▼ do-while문
조건식이 만족할 때까지 반복 수행
do
{
    수행문장;
}while(조건식);
do-while문 문장을 수행한 후 조건식에 따라 수행여부를 결정(선 수행 후 비교) 
▼ for문
일정한 범위의 문장을 반복 수행하는 명령문
for(초기식; 조건식; 증감식)
{
    수행문장;
}

<for문의 실행 순서>  

 /* for문의 기본 형태 */
  for ( ⓐ초기화 ; ⓑ조건식 ; ⓒ증감식 )
  {
      ⓓ내용
  }
  ⓔ for문을 벗어남

 
  1. 우선 ⓐ초기화로 들어갑니다. 이곳에는 i=0, j=0등의 초기화 내용이 오게됩니다.
     조건식에 상관없이 무조건 실행하며, 단 한번만 실행됩니다.
  2. ⓐ를 거치면 바로 ⓑ조건식으로 넘어갑니다. ⓑ의 조건에 성립하면 for문이 내용으로 넘어가게
     되며(ⓓ), 조건이 성립하지 않으면 바로 탈출하여 for문을 벗어나게 됩니다.(ⓔ)
  3. ⓑ조건식이 성립하면, ⓓ내용으로 넘어가게 됩니다. { } 안에 있는 모든 내용을 위에서부터 아래로
     순차적으로 실행합니다.
  4. 내용안에 있는 식이 모두 마치게되면, ⓒ증감식으로 넘어갑니다.
  5. ⓒ증감식이 마치면, 다시 ⓑ조건식으로 넘어가고, 그 이후 진행은 2~4진행과 같습니다. 

	/*	while 문의 실행 순서	*/
	while(NumSects--)				// NumSects 변수에 대한 while 조건식을 실행하고 곧바로 1을 뺀 다음 하기 bSucess = EraseSector(StartSector + NumSects); 명령을 실행
	{
		bSucess = EraseSector(StartSector + NumSects);					// NumSects = 4 였던 것이 3으로 1 줄어들어서 EraseSector 함수 인수로 들어 감 <- dwLength = 0x00080000
		if (!bSucess)
		{
			MP4_DebugPrintF2(PLEVEL, "ERROR: NOR_EraseFlash: EraseSector failed on sector 0x%x!\r\n", NumSects);
			return(FALSE);
		}
	}

ex)
  /////////////////////////////////////////////
  // 숫자 0 ~ 6 까지 1씩 증가
  for (int i = 0; i <= 6; i++) {
    printf("%d, ", i);
  }
  // 출력 결과: 0, 1, 2, 3, 4, 5, 6,

  puts(""); // 편의상 줄바꿈
  /////////////////////////////////////////////
  // 숫자 2 ~ 10 까지 2씩 증가
  for (int i = 2; i <= 10; i += 2) {
    printf("%d, ", i);
  }
  // 출력 결과: 2, 4, 6, 8, 10,

  puts(""); // 편의상 줄바꿈
  /////////////////////////////////////////////
  // 숫자 6 ~ 0 까지 1씩 감소
  for (int i = 6; i >= 0; i--) {
    printf("%d, ", i);
  }
  // 출력 결과: 6, 5, 4, 3, 2, 1, 0,

  puts(""); // 편의상 줄바꿈
  /////////////////////////////////////////////
  // 실수 숫자 0.0 ~ 1.0 까지 0.1씩 증가
  for (double d = 0.0; d <= 1.0; d += 0.1) {
    printf("%f\n", d);
  }
  /* 출력 결과:
  0.000000
  0.100000
  0.200000
  0.300000
  0.400000
  0.500000
  0.600000
  0.700000
  0.800000
  0.900000
  1.000000
  */

▼ goto문
지정된 레이블로 분기
goto 레이블
.......
레이블:

    예문
goto A1
A1: 
...(문장 수행)...
▼ break문
반복문 또는 swich문에서 break문을 만나면 블록 범위를 벗어나게 한다.	cf) switch문에서 continue문을 만나면 switch 조건으로 다시 넘어가는 것이 아니라 switch문 밖에 while문 등이 있으면 이곳으로 넘어가게 됨
break; 
▼ continue문
continue문을 만나면 다음 단계의 수행으로 분기하여 반복 수행한다.
continue; 

break; 는 만나면 반복문을 탈출 하라는 의미
continue; 는 만나면 다음 문장은 실행하지 말고 반복문으로 계속 하라는 의미

continue 예를들면
#include <stdio.h>

int main(void)
{
        int a, b;
        int sum=0;
 
         for (a=1; a<=10; a++)
         {
              if(a%2==0)       //짝수이면
                 continue;    //sum += a를 수행하지 말고 계속 반복(즉, 짝수이면 더하지마시오)
              sum += a;     //합을 구하는 명령문
         }
    printf("1에서 10까지 홀수의 합은 : %d 입니다\n",sum);

 system("pause");             
 return 0;
}

break 예를 들면
#include <stdio.h>

int main(void)
{
        int a, b;
        int sum=0;
 
         for (a=1; a<=10; a++)	//반복은 10번
         {
              if(a==5)     		//그러나 a가 5가되면
                  break;		//아래 명령 실행하지 않고 for문을 벗어남  (즉, 1,2,3,4만 더함)
              sum += a;
         }
    printf("1에서 5까지 홀수의 합은 : %d 입니다\n",sum);
            
 return 0;
}

제 3 장 함수 및 기억클래스
1. 사용자 정의 함수
▼ 함수 정의

[함수명]함수명(가인수 리스트)
가인수형 선언;
{
    함수의 본체
}

함수형은 함수 내에서 계산된 결과 값을 돌려주는 경우에 그 돌려주는 값의 형을 함수형이라 한다.
인수 전달 방식은 일반적으로 사용되는 call by value와 주소 전달 방식인 call by reference가 있다.
실인수는 함수를 호출하는 쪽의 매개변수이고, 가인수는 호출되는 쪽의 매개 변수이다.
▼ return문
return [수식]
    return : 결과 값없이 호출 함수로 되돌아 간다.
    return 수식 : 수식의 결과 값을 호출 함수로 반환한다.
2. 매개변수 전달방식
call by value : 가인수에 실제값을 전달 
call by reference : 가인수에 주소값을 전달
3. 포인터(pointer)
주소값을 저장하는 함수 
* 연산자를 이용하여 선언 
기억장소의 성격은 항상 unsigned int형
4. 기억 클래스
데이터를 기억하는 기억장소 할당 및 변수의 유효 범위 등을 결정하는 것
종 류                   기억장소    유 효 범 위 
auto(자동변수)          Stack       블록 내(일시적) 
register(레지스터 변수) Register    블록 내(일시적) 
static(정적변수)        Memory      블록 내(영구적) 	// static(정적)변수는 초기값 지정이 없으면 0으로 초기화되고 프로그램 실행시 단 한번만 초기화된다.
														// 함수로 여러번 호출이 된다고 해도 첫번째 호출의 경우만 초기값 적용되고 이후 부터는 초기값 적용되지 않음
extren(외적변수)        Memory      전체 영역(영구적) 

제 4 장 배열과 구조체
1. 배열(Array)
동일한 자료형 기억장소의 집합체 
배열의 첨자는 0부터 시작 
초기화시킬 때는 {}안에 상수 기술 
static, extern 배열은 초기화 시키지 않으며 배열의 각 원소에 수치형은 0, 문자형은 '＼0'으로 초기화 된다.
▼ 1차원 배열
☞예 
(예제1)
int a[]={1, 2, 3, 4, 5};    ←  a[5]와 동일
    a[0]   a[1]    a[2]    a[3]   a[4] 
    1       2       3       4       5   
(예제2)
int a[5]={1, 2};            ←  a[5]={1,2,0,0,0}와 동일
    a[0]   a[1]    a[2]    a[3]    a[4]  
    1       2       0       0       0   
(예제3)
char a[6]={'k', 'o', 'r', 'e', 'a'}; 
char a[]={'k', 'o', 'r', 'e', 'a', '＼0'}; 
char a[]="korea"; 
    a[0]   a[1]    a[2]    a[3]    a[4]    a[5]
    'k'    'o'     'r'     'e'     'a'    '＼0'
▼ 2차원 배열
☞예 
(예제1)
 int a[2][3]={1, 2, 3, 4, 5, 6};
 int a[ ][3]={{1, 2, 3}, 4, 5, 6};
      ↓  ↓
     행  열

a[0][0] a[0][1] a[0][2] 
    1       2       3 
a[1][0] a[1][1] a[1][2] 
    4       5       6 
(예제2)
char a[][5]={"hong","kim"}; 
'h''o''n''g''＼0' 
'k''i''m''＼0''＼0' 
▼ 포인터와 배열명
배열에서 배열명은 그 배열의 기억장소의 시작주소를 가리키는 주소 상수이고, 포인터 변수는 주소를 기억하는 변수이다.
☞예
       char a[]="korea", *pt;
       pt=a;
       while(*pt)
       printf("%c", *pt++);

    a[0]   a[1]   a[2]   a[3]   a[4]   a[5]
    'k'    'o'    'r'    'e'    'a'    '＼0' 
     ↓     ↓     ↓     ↓     ↓     ↓  
    a＋0   a＋1   a＋2   a＋3   a＋4   a＋5  : 주소상수
2. 구조체(structure)
여러개의 요소들이 모여서 이루어진 집합체(record)
▼ 구조체 선언문
struct tag명{
    멤버 선언문들; }[변수명들];

☞예
struct book { 
    char name(20); 
    char tel(14); 
    int age;
}saram 1, saram2, jusorok(50), *pt;

▼ 구조체member 참조
구조체변수명, member명
구조체배열명[원소번호], member명
구조체포인터 변수 → member명
☞예
struct book saram; 
strcpy(saram, name, 'Hong Gil Dong); 
strcpy(saram, tel, '02-987-1234); 
saram,age=18;
struct book saram(10); 
strcpy(saram, name(5), 'Hong Gil Dong); 
strcpy(saram, tel(5), '02-987-1234); 
saram,age(5)=18;
struct book *pt; 
strcpy(pt->name, 'Hong Gil Dong); 
strcpy(pt->tel, '02-987-1234); 
pt->age=18; 
3. 공용체
동일한 기억장소를 서로 다른 변수가 공통으로 이용할 수 있는 기억장소를 말한다.
▼ 공용체 선언문
union tag명{
    멤버 선언문들;
}[변수명들];
☞예
union equl 
    char ch; 
    int su; 
    long love; 
    float ave; 
    jval; 
▼ 공용체 member참조
공용체 변수명, member명
공용체 포인터 변수->member명

☞예
union equ gu, *pt;
    gu,su=1234;
    pt->live=123456;

* 공용체라고 하며 union으로 만들어진 자료형의 멤버끼리 메모리를 공유하나 그 멤버 하나만 제대로 사용가능
#include <stdio.h>

union data{    
    int a;
    double b;
};

void main(void){
    union data dt;
    dt.a = 111;
    printf("%d, %f \n", dt.a, dt.b); 
    // b값이 다른값으로 바뀐다.

    dt.b = 233.34;
    printf("%d, %f \n", dt.a, dt.b);
    // a값이 다른값으로 바뀐다.
} 

출력  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
111, -92559592117433261000000000000000000000000000000000000000000000.000000
1202590843, 233.340000
계속하려면 아무 키나 누르십시오 . . .


	1) fgets 은 한줄 한줄 읽을 때 사용하는 명령으로 처음 한줄 읽고서 다시 fgets을 실행하면 자동으로 다음줄을 읽어들임
	2) C++ printf 출력 형식 %c %s %d %u %e %f %g %x %o %n %x 
				%c  문자 
				%C  %c
				%s  문자열 
				%p  포인터값 16진수
				%d  10진수 부호있는 정수
				%i  %d 
				%u  10진수 부호없는 정수
				%f  부동소수점 실수 소수 표현 무한수를 표현할 때 소문자 표현
				%F  %f 무한수를 표현할 때 대문자 표현  
				%e  부동소수점 실수 지수 표현 
				%E  %e e 대신 E 로 출력 
				%g  크기가 작으면 %f, 크기가 크면 %e
				%G  크기가 작으면 %f, 크기가 크면 %E 
				%x  16진수 정수 소문자 0 ~ 9,a,b,c,d,e,f
				%X  16진수 정수 대문자 0 ~ 9,A,B,C,D,E,F
				%o  8진수 정수 
				%n  Print nothing, but write number of characters successfully written so far into an integer pointer parameter. 
				%%  % 출력

				ex)
				printf("Open Failed \n");
				printf("frame count : %d\n", frame_cnt);
				printf("conv code : %x, ret = %d\n", code, ret);
				printf("\tHNMS_PORT=[%s]\n",gMconfig_t.hnms_port);
				sprintf(str, "a: %d\n", a);
				fprintf(stderr, "hohoho  \n");
				fprintf(stderr, " i = %d\n", i);
			    
			    ex) sprintf
			    a = 10;
			    char str[1024];
			    
			    sprintf(str, "a: %d\n", a);
			    printf("%s", str);
			    
			    ex) fprintf
			    FILE *fp;
			    fp = fopen("tmp.txt", "w");
			    fprintf(fp, "테스트\n");
			    fclose(fp);
			    
			    -> tmp.txt라는 파일이 새로 생성된다, "w"는 쓰기, "r"은 읽기
			    fprintf는 파일에 형식화된 쓰기를 하는 함수
    2-1) 코딩 규칙 및 헝가리안 표기법
Prefix              Type                        Example
dw                  double word                 DWORD dwTotal
w                   WORD                        WORD wNumber
l                   long                        long lTotal
i                   Integer                     int iNumber
f                   float                       float fAvarage
b                   bool                        bool bCheck
n                   short                       int nCount
by                  BYTE                        byOffset
ch                  CHAR                        char chKey
sz                  CHAR[] Null Terminatied     char szText[16]
sz                  WCHAR[] Null Terminatied    szPin
str                 CString                     String strAddress
s                   static                      static short ssChoice
C                   Class                       CButton
p                   Pointer                     int *pButton
r                   RECT                        rDraw
a                   Array                       aBags
g_                  Global Val                  g_bShow
m_                  Member Val                  m_iMans
s_                  static Val                  s_Helper
si                  size_t                      siCount
vec                 vector                      vecMan
map                 map                         mapWoman
lst                 list                        lstHome
hsh                 hash                        hshHome
h                   handle                      hWindow
hdc                 HDC(Handle to a device context) 디바이스 컨텍스트에 대한 핸들
hwnd                HWND(Handle to a window)        윈도우에 대한 핸들
st                  struct                      stNumber

Original            Type                        Example
unsigned char       BYTE                        byOffset
unsigned short      WORD                        nCount
unsigned long       DWORD                       dwTotal
long                LONG                        lNumber
int                 int                         iNumber
BYTE                BOOLEAN                     bChecked
WCHAR *             LPWSTR                      pszCaption
const WCHAR *       LPCWSTR                     pcszCaption
LPCWSTR             LPCTSTR                     pcszCaption
char *              LPSTR                       pszCaption
const char *        LPCSTR                      pcszCaption

접두어  의미  
a   배열  
b	또는 f  BOOL형 변수(b는 "bool", f는 "flag"의 약자)  
by  BYTE (unsigned char)형 변수  
c  	카운터로 사용되는 변수  
ch  char형 변수  
cx, cy  x, y 길이를 나타내기 위해 사용되는 변수  
d  	날짜형 변수  
dbl double형 변수  
h  	핸들(HANDLE)형 변수  
n 	또는 i  int형 변수  
l  	long형 변수  
p  	포인터 변수  
lp  long (far) 포인터 변수(32비트 프로그래밍에서는 일반 포인터와 같음)  
s  	문자열  
sz  널(NULL)로 끝나는 문자열  
u  	unsigned int형 변수  
w  	WORD(unsigned short)형 변수  
dw  DWORD(unsigned long)형 변수  
str CString형 변수  
m_  멤버 변수


1. 변수의 접두어는 모두 소문자
   ex) m_pCheckBox, m_CheckBox, g_nTotal, g_SessionManager
         nCount, strCaption, pListBox
2. 변수에서 접두어가 없는 경우 첫 단어는 소문자로 시작
   ex) m_checkBox, g_total, g_memberCount; m_memberList;
        로컬 변수일경우:  checkbox, item,  
3. 함수의 첫글자는 대문자
   DestroySession(), Connect(), Close(), ViewMap(), 
4. 함수의 이름은 동사+명사 
   GotoURL(), ViewMap(), PlayMovie(), ParseURL()
5. Class는 접두어를 제외한 첫번째는 대문자
   CCaption, CMembers, CResourcePaint, CFileStream
6. 여러 단어가 합쳐 졌을때는 각 단어의 시작은 모두 대문자
   ConnectToTheServer(), SendToMetaData() g_nMetaDataCount
7. Typedef, #define, enum, union등의 type은 모두 대문자
typedef enum {
    T_1,
    T_2,
    T_3
}TEST_DATA;
단 struct와 union의 맴버는 m_를 붙이지 않으며 모두 대문자를 사용하지 않고 위의 표기법으로 사용한다.
맴버는 맴버이지 하나의 type이 아니기 때문이다.
8. if문 및 switch등 제어문의 표기법
   if( i = 1 )
   {           <== 반드시 개행시켜서 표현한다.
        ....
   }

   for( i = 0; i < 100 && !myIterator.empty() ; i++ )   {
      do {
          if( a == b ) {
          }
          switch( nCount ) {
          }
       }while( nCount < 100 )
   }

   이런 식의 사용은 if문 및 switch문에서 문장의 전체 범위가 한번에 들어 오지 않는다.   
   따라서 개행해서 코딩 하도록 한다.

   for( i = 0; i < 100 && !myIterator.empty() ; i++ )   
   {
       do 
       {
           if( a == b ) 
           {

           }

           switch( nCount ) 
           {

           }
       } while( nCount < 100 )
    } 

   switch( nCount )
   {
    case CNT_FIRST:
            {

            }
            break;
   }


	예제)	switch(chRepeat++)
	char chRepeat = 0;
	char chTemp = 0;

	while(1)
	{
		switch(chRepeat++)				// 1) chRepeat = 0
		{
			case 0:
				chTemp++;				// 2) chRepeat = 1, 3) chTemp = 1
				break;
			case 1:
				chTemp++;				// 4) chRepeat = 2, 5) chTemp = 2
				break;
			case 2:
				chTemp++;				// 6) chRepeat = 3, 7) chTemp = 3
				break;
			case 3:
				chTemp++;				// 8) chRepeat = 4, 9) chTemp = 4
				chRepeat = 0;			// 10) chRepeat = 0
				break;
		}

		if(chTemp > 20)
			break;
	}
9. 문단으로 구분한다.
   하나의 함수 안에서도 처리 하는 부분들이 구분 될 수 있다. 이럴때는 아래위 공백을 하나씩 사용해서 구분 해준다.
10. 제어문에서 ( )는 본문과 한칸씩 띄워준다.
   위의 switch나 if, while문등이 명령어 다음 바로 (가 붙고 조건 맨끝에서 한칸뒤에 )가 붙어 있다.
   이것또한 조건과 명령어등이 명확히 보이도록 하고 내부에서 ()가 사용되었을 경우 정확히 끝이 어디인지 한눈에 알아보기 쉽기 위해서다
  1.  if (nTotal < 1000 && myIterator !=  m_vecStudent.end())
  2.  if( nTotal < 1000 && myIterator !=  m_vecStudent.end() )   
   두개의 문장중 어떤것이 조건의 시작과 끝을 보기 편한가?
11. Class와 함수의 윗줄에 구분줄을 표시 한다.
   이 규칙은 Borland C++이나 Delphi에 있던 규칙인데 이것을 사용하게 되면 함수의 구분과 class의 영역 구분 또한 명확해 진다.
   만약 Doxygen이나 JavaDoc 같은 주석을 사용한다면 명확히 구분이 되기 때문에 사용하지 않아도 된다.
ex)   아래 코드는 즉석해서 만들어낸 예제 코드임으로 코드적 결함이 있을 수 있다.
//--------------------------------------------------------------------------------------------------------
class CBookmark
{
private:

public:
       CBookmark();
       ~CBookmark();
}   

//--------------------------------------------------------------------------------------------------------
class CInputBox
{
private:

public:
       CInputBox();
       ~CInputBox();
}   

//--------------------------------------------------------------------------------------------------------
class CViewMap
{
private:

public:
       CViewMap();
       ~CViewMap();
}   

//--------------------------------------------------------------------------------------------------------
void CViewMap::StopRandering(CParent * pParent)
{
      if( pParent->m_bsState == BS_RUNNING )
      {
            .
            .
       }

     pParent->Cancel();
}

//--------------------------------------------------------------------------------------------------------
BOOL CViewMap::BeginRandering(CParent * pParent)
{
.
.
}

//--------------------------------------------------------------------------------------------------------
CHandle* CViewMap::InitRanderer(CParent * pParent)
{
.
.
}


    3)  포인터 개념
포인터는 어떤 변수의 주소를 가리켜주는 변수입니다. 한마디로 다른 변수의 주소값을 가지는 변수라고
생각하시면 됩니다. 밑에 예제가 있습니다.

#include <stdio.h>
void main(){
    int *num ;                                  // 정수형 포인터 선언, int* num;과 같이 선언해도 상관 없음(int *num;과 같은 의미 임)
    int a = 5;

    num = &a;                                   // num은 a의 주소를 가진다.

    printf("num 자체 값 : %d\n" , num);         // 주소값이므로 큰 수의 랜덤한 값이 나옴
    printf("num가 가리키는 값 : %d\n" , *num);  // a의 값인 5가 나옴
    *num = 3;                                   // *num 포인터 값이 3으로 변경 되고
                                                // num 포인터의 주소가 a변수를 가리키고 있으므로 a 변수 값도 5로 바뀌게 됨
    printf("num가 가리키는 값 : %d\n" , *num);  // *num 포인터의 변경된 값이 3이 출력
    printf("num가 가리키는 값 : %d\n" , a);     // 변경된 값이 3이 출력
}
    
num = &a 에서 변수 num이 a의 주소를 가리키게 합니다. 따라서 num 자체에는 a의 주소가 들어있고
이것은 랜덤하게 바뀌는 7자리의 큰 수입니다. 따라서 첫번째 printf 값은 이 7자리의 주소값이 나오게
되고 *num 을 하면 num이 가리키고 있는 변수의 값, 즉 a의 값인 5가 나오게 됩니다. 따라서 두번째
printf는 5가 나오게 됩니다.
포인터는 주소를 가리킨다는 점 때문에 변수의 주소를 지역함수등에 넘길 때 주로 사용됩니다.


	3-1-1)	포인터와 구조체 사용 이유
		가)	포인터 사용 이유
			i)	변수의 내용을 주소로 이동 시킬 수 있기 때문에 변수 내용을 다른 함수의 매개변수로 전달하는 경우
				대량의 데이터도 별도의 데이터 이동 명령을 수행할 필요 없고(주소만 넘겨 주면 되기 때문에)
				주소로 넘겨 주었기 때문에 다른 함수에서 변수 내용을 수정 시켜도 원본 변수의 내용이 곧바로 수정되는 효과를 볼 수 있음
			ii)	다른 함수의 매개변수로 포인터를 사용하면 다른 함수에 포인터 주소가 넘어가기 때문에
				그 포인터의 값을 다이렉트로 다른 함수에서 변경할 수 있는 편리성이 있다
			ex)
			void function(char *input)
			{
				*input = 7;
			}
			
			void main(void)
			{
				char temp = 1;
				
				function(&temp);		// temp값이 1에서 7로 바뀜
			}
			
		나)	구조체 사용 이유
			구조체를 사용하는 이유는 보기에 간결하고 하나로 묶을 수 있는 이점이 있고
			다른 함수의 매개변수로 준다면 구조체 안의 많은 변수 데이터를 한번의 이동 명령으로
			한꺼번에 옮길 수 있다.			


    3-1)  int *i 와 char *i 의 차이점

윗분 설명이 조금 잘못된 것 같습니다.
sizeof를 사용할 경우 sizeof(char)은 1, sizeof(int)는 4가 나오겠지만 포인터는 모두 동일하게 4로 표시될 것입니다.

질문하신 분 말씀대로 int형 주소든 char형 주소든(이 표현 자체가 좀 맞지는 않지만요, 질문에 그렇게 표현하셨으니 그렇게 쓰겠습니다)
똑같이 32비트 컴퓨터의 경우 4바이트 길이의 16진수 형태로 나타낼 수 있습니다.

즉, sizeof(char *)이나 sizeof(int *)이나 모두 4를 표시하게 됩니다.
질문하신 분이 생각하시는대로 메모리를 나타내는 주소는 사실 int든 char이든 메모리의 어느 한 곳을 가리키는 것이기 때문에
다 똑같은 형태여야 말이 되겠죠.

그럼, int형 주소니 char형이니 하는 말은 무엇이냐.
이는 C에서 편의상 그 주소에 들어있는 값이 무엇인지를 표시하기 위해 쓰는 것입니다.
주소의 형태가 다른 것이 아니라 주소에 들어 있는 실제 값의 형태를 의미하는 것입니다.

이는 프로그래밍 할 때에 주의해야 될 경우가 생기는데요.

char *a;
int *b;

printf("%x %x\n", a, a+1);
printf("%x %x\n", b, b+1);

위의 코드를 테스트해보면 a는 a+1과 1이 차이나지만 b는 b+1과 4가 차이나게 됩니다.
a는 char형 주소이므로 char의 크기인 1바이트만큼만 주소값을 증가시키며 
b는 int형 주소이므로 int형 하나의 크기인 4바이트를 증가시키기 때문입니다.

나중에 프로그래밍 실력이 느셔서 포인터와 관련된 프로그래밍을 많이 하게 되고 포인터 캐스팅을 해서 쓰는 경우가 생기신다면 위의 내용이 도움이 되실 것입니다.
열심히 하세요~


    3-2)  구조체 변수를 포인터를 이용해서 다른 함수의 입력 변수에 전달
// mystruct.h
#pragma once

typedef struct
{
  int a;
  int b;
} MYSTRUCT, *LPMYSTRUCT;                // LPMYSTRUCT는 굳이 안해 주고 써도 무관합니다. 많이들 이렇게 쓴다는 것을 설명하기 위해 적어 준것입니다
-------------------------------------------------------------------
// func.h
#pragma once

void func(MYSTRUCT *lpMyData);
-------------------------------------------------------------------
// func.cpp
#include "mystruct.h"
#include "func.h"
void func(MYSTRUCT *lpMyData)
{
  int c;
  c = lpMyData->a;                    // c = (*lpMyData).a
//c = Data.a                          // 이렇게 사용할 수 없음, Data 구조체변수는 main()함수 안에서만 사용할 수 있는 지역변수이기 때문

  lpMyData->a = 1;                    // (*lpMyData).a = 1
  lpMyData->b = 2;
  return;
}
-------------------------------------------------------------------
// main.cpp
#include mystruct.h"
#include "func.h"

int main()
{
...
MYSTRUCT Data;                        // Data.a, Data.b를 사용할 수 있음

func(&Data);                          // Data 구조체 주소를 func함수의 입력 변수로 줬고
                                      // MYSTRUCT *lpMyData = &Data이기 때문에 Data 구조체변수의 주소가 func함수의 입력 변수에 전달 됐기 때문에
                                      // 주소를 받은 lpMyData 포인터에 값을 넣으면 이에 해당하는 Data 구조체변수의 값이 변경 됨
                                      //    lpMyData->a = 1; -> Data.a의 값이 1이 됨
                                      // cf)만약 포인터를 사용하지 않고 구조체 변수값을 다른함수(func함수)에 전달할려면
                                      //    아래와 같이 노가다를 더해야 함
                                      //    func(Data.a, Data.b)
                                      //    void func(int c, int d) {
                                      //      int e,f;
                                      //      e = c;
                                    
                                      //      }
...
}


typedef struct{
     int x; 
     int y;
}POINT;

typedef	struct
{
  int UpLoadData;
  int DownLoadData;
} DATA_STRUCT;

void main(void)
{
  DATA_STRUCT structdata = {1, 2};            // 구조체 초기화

  structdata.UpLoadData = 4;
  UpLoad(structdata);                         // DATA_STRUCT transdata = structdata(cf int b = a;와 똑같은 관계, cf) structdata.UpLoadData & structdata.DownLoadData 모두 transdata로 복사 됨) 로 UpLoad의 입력변수를 줬으므로
                                              // UpLoad에서는 structdata 구조체 변수 값을 입력으로 받고 있지만 수정할 수는 없음

  DownLoad(&structdata);                      // DATA_STRUCT *receivedata = &structdata(cf int *b = &a;와 똑같은 관계) 로 DownLoad의 입력변수를 줬으므로
                                              // DownLoad에서는 structdata 구조체 변수 값을 입력으로 받고 있고 수정할 수도 있음
}

void UpLoad(DATA_STRUCT transdata)
{
  int tx;

  tx = transdata.UpLoadData;                  // tx에 4가 들어감
}

void DownLoad(DATA_STRUCT *receivedata)
{
  int rx = 3;
  int tx;

  tx = receivedata->DownLoadData;             // receivedata->DownLoadData의 값은 2였는데
  receivedata->DownLoadData = rx;             // receivedata->DownLoadData의 값이 rx의 값인 3으로 변경됨
                                              // 또한 structdata 구조체 변수의 주소와 연결되어 있으므로 structdata->DownLoadData의 값도 3으로 변경됨
                                              // (*receivedata).DownLoadData = rx;와 같은 의미
}


	3-3)  버퍼와 포인터와의 관계
				예제1)
				#include <stdio.h>
				#define SIZE 10
				 
				void get_max_min(int list[], int size, int *pmax, int *pmin);
				 
				int main(void)
				{
				       int max, min;
				       int grade[SIZE] = { 3, 2, 9, 7, 1, 4, 8, 0, 6, 5 };
				 
				       get_max_min(grade, SIZE, &max, &min);
				       printf("최대값은 %d, 최소값은 %d입니다.\n", max, min);
				 
				       return 0;
				}
				 
				void get_max_min(int list[], int size, int *pmax, int *pmin)
				{
				       int i, max, min;
				 
				       max = min = *list; // 첫번째 원소를 최대, 최소값으로가정
				       for(i = 1;i < size; i++) // 두번째 원소부터 최대, 최소값과 비교
				       {
				               if( *list > max) // list[i]가 최대값보다 크면
				                        max = *list; // list[i]를 최대값으로 설정
				               if( *list < min) // list[i]가 최소값보다 작으면
				                        min = *list; // list[i]를 최소값으로 설정
				      list++; /* 포인터를 다음 주소로 이동 (다음 멤버를 가리키도록) */
				       }
				      *pmax = max;
				      *pmin = min;
				}

				예제2)
				#include <stdio.h>
				#define size 1000
				
				int test(char *buf,int n){
					static char *a[size]; //정적로컬선언함
					a[n] = buf; //말씀하신 배열에 넣습니다
				
					if(n >= size-1){ //버퍼가 다찼습니다
						return -1;
					}
				 
					return n; //버퍼가 다차지 않았음(0~size)
				}
				
				int main(int argc, char* 림argv[])
				{
					for(int n=0; n < size; n++){
						char* buff = new char[200];
						sprintf(buff, "%d 번째 여기 들어갑니다", n);
				
						if(test(buff, n) < 0){
							printf("다 채웠습니다\n");
							break;
						}
					}
					return 0;
				}


    3-4) 배열과 포인터
         배열의 이름이 포인터이기 때문입니다. 상수 포인터라고도 합니다.
#include <stdio.h>
int main(void)
{
 int a[2]={0, 1};
 int *p=a;

 p=a;

 printf("%d %d \n", a[0], *(a+1));
 printf("%d %d \n", p[0], *(p+1));
 
 return 0;
}
출력 결과 : 0 1
            0 1


	3-5) 이중 포인터
출처 : Win32 API 연구사이트 

10-4-가.이중 포인터
이중 포인터란 포인터 변수를 가리키는 포인터라는 뜻이며 다른 말로 하면 포인터의 포인터라고 할 수 있다. 
포인터 변수도 메모리를 차지하고 있으므로 이 변수도 당연히 번지가 있다. 따라서 이 번지를 가리키는 
또 다른 포인터 변수를 선언할 수 있는 것이다. 이중 포인터 변수를 선언할 때는 * 구두점을 두 번 연속해서 쓴다.

int **ppi;
이 선언에서 ppi는 정수형 대상체를 가리키는 포인터 변수의 번지를 가리키는 포인터 변수로 선언되었다. 
말이 조금 꼬이는 것 같고 복잡해 보이는데 어째서 저런 변수를 선언할 수 있는지 차근 차근히 풀어 보도록 하자. 
다음 두 명제는 앞에서 이미 공부했던 것들인데 이중 포인터를 이해하기 위해 다시 정리해 보자.

T *형은 하나의 타입으로 인정된다.
T형 변수를 선언할 수 있으면 T *형도 항상 선언할 수 있다.

정수형 포인터 변수는 다음과 같이 선언한다.
int *pi;

이 선언문에서 int *라는 표현이 "정수형 포인터"라는 뜻으로 그 자체가 하나의 타입이다. 
따라서 다음과 같이 괄호로 묶으면 좀 더 읽기 쉬워지고 뜻이 분명해질 것이다.
(int *) pi;

두 번째 명제에 의해 T형에 대해 항상 T *형이 가능하므로 int *형에 대한 포인터형을 만들 수 있다. 
int *형 변수를 가리키는 변수 ppi를 선언하면 다음과 같아진다.
(int *) *ppi;

이 선언문에서 괄호를 제거하면 최초의 이중 포인터 선언문인 int **ppi;가 된다. 
물론 여기서 사용한 괄호는 어디까지나 설명을 위해 쓴 것이지 실제로 타입에 괄호를 쓰면 컴파일 에러로 처리된다. 
하지만 typedef문으로 int *형을 별도의 타입으로 정의한 후 이 타입의 변수를 선언할 수는 있다.
typedef int *PINT;
PINT pi;

보다시피 int *형을 PINT라는 사용자 정의 타입으로 정의하였고 이 타입의 변수 pi를 선언할 수 있다. 
포인터 변수 pi를 가리킬 수 있는 포인터 변수를 선언하면 다음과 같다.
PINT *ppi;

이 선언문에서 PINT를 사용자 정의형으로 풀어 쓰면 int **ppi;가 되는 것이다. 
같은 원리로 3중 포인터는 int ***pppi;와 같이 선언하면 되고 5중 포인터나 8중 포인터도 그 수만큼 *를 계속 붙이면 된다. 
3중 포인터 이상은 현실적으로 거의 사용되지 않지만 이중 포인터와 원리는 동일하므로 이중 포인터만 이해하면 된다. 
이중 포인터는 포인터 변수를 가리키는 변수이므로 이 변수에는 포인터의 포인터값을 대입해야 한다. 
즉, 포인터 변수에 &연산자를 붙인 값이면 이중 포인터에 대입할 수 있다. 
다음 예제는 이중 포인터의 동작 원리를 보여주는 가장 간단한 예제이다.

예 제 : dblPointer
#include <Turboc.h>
void main()
{
     int i;
     int *pi;
     int **ppi;

     i=1234;
     pi=&i;
     ppi=&pi;

     printf("%d\n",**ppi);
}
정수형 변수 i에 1234값을 대입해 놓고 이중 포인터로 이 값을 읽는 시범을 보인다. 
정수형 포인터 pi가 i의 번지를 가지고 정수형 이중 포인터 변수 ppi에는 pi의 번지를 대입해 놓고 
**ppi값을 읽으면 결국 i의 값이 읽혀진다. 이 프로그램에서 각 변수들이 서로를 가리키는 모양은 다음과 같을 것이다.

i는 일반 변수이므로 메모리상에 4바이트를 차지하고 1234가 대입되었다. 
정수형 포인터 pi도 일종의 변수이므로 메모리상에 할당되며 그 초기값으로 &i, 즉 i의 번지를 대입받았다. 
이 상태에서 pi가 i를 가리키고 있으므로 *pi 연산문으로 i값을 읽을 수 있다. 여기까지는 앞에서 이미 살펴 본 것들이다.

포인터 변수 pi도 일종의 변수이므로 분명히 메모리에 할당될 것이고 따라서 번지를 가지고 있다. 
pi가 할당되어 있는 번지값인 &pi를 이중 포인터 변수 ppi에 대입했다. 
그래서 ppi는 pi를 가리키고 pi는 다시 i를 가리키고 있는 것이다. 이
상태에서 **ppi 연산문으로 값을 읽으면 *(*ppi)=*(pi)=i가 되므로 결국 출력되는 값은 i인 것이다.

ppi가 가리키는 곳에 pi가 있으며 pi가 가리키는 곳에는 i가 있으므로 ppi에 대해 *연산자를 두 번 적용하면 
결국 i값이 읽혀진다. 이 예제의 상황에서 다음 수식들은 모두 동등한 대상을 나타낸다.

i=*pi=**ppi
&i=pi=*ppi 
*&i=*&*pi=*&**ppi

* 연산자와 & 연산자는 서로 반대되는 동작을 하는데 이 두 연산자에 의해 가리키고 끄집어 내오다 보면 
동등한 수식이 여러 개 생길 수 있다. 그렇다고 해서 &&i=&pi=ppi라는 등식은 성립하지 않는데 &연산자를 
두 번 쓰는 것은 적법하지 않다. 왜냐하면 &연산자의 피연산자는 메모리상의 실제 번지를 점유하고 있는 
좌변값(lvalue)이어야 하는데 &i는 i가 저장된 번지를 나타내는 포인터 상수일 뿐 좌변값이 아니기 때문이다.

다음 예제는 이중 포인터의 전형적인 활용예인데 포인터를 참조 호출로 전달하여 함수가 포인터를 변경할 수 있도록 한다. 
main에서 이름을 입력받는 함수를 호출하는데 이 이름의 길이가 DB나 사용자로부터 입력되어 실제 입력받아 보기 
전에는 얼마일지를 알 수 없다고 하자. 이럴 경우 함수가 필요한만큼 메모리를 할당해서 할당한 번지를 리턴하도록 해야 한다.

예 제 : FuncAlloc
#include <Turboc.h>

void InputName(char **pName)
{
     *pName=(char *)malloc(12);
     strcpy(*pName,"Cabin");
}

void main()
{
     char *Name;

     InputName(&Name);
     printf("이름은 %s입니다\n",Name);
     free(Name);
}

main에서 char *형의 변수 Name을 선언하고 이 포인터 변수의 번지, 즉 char **형의 이중 포인터를 InputName 함수로 전달했으며 
이 함수는 이중 포인터를 형식 인수 pName으로 대입받는다. Name은 함수 내부에서 값이 결정되는 출력용 인수이기 때문에 
호출원에서 초기화하지 않아도 상관없다. InputName 함수는 필요한만큼(예제에서는 12로 가정) 동적으로 메모리를 할당하여 할당된 번지를 
pName이 가리키는 번지인 *pName에 대입했다. 여기서 *pName이라는 표현식은 곧 main에서 InputName으로 전달한 실인수 Name을 의미한다.
그리고 할당된 번지에 어떤 문자열을 복사했다.

결국 InputName 함수는 main의 Name 포인터 변수를 참조 호출로 전달받아 Name에 직접 메모리를 할당하고 
이 번지에 scanf로 입력받은 이름까지 복사한 것이다. InputName이 리턴되었을 때 Name은 12바이트 길이로 할당된 번지를 
가리키며 이 안에는 입력된 이름까지 들어 있으므로 printf로 출력할 수 있고 다 사용한 후 free로 해제하면 된다. 
이 문제를 잘못 생각하면 다음과 같이 InputName 함수가 char *형을 받도록 작성할 수도 있다.

예 제 : FuncAlloc2
#include <Turboc.h>

void InputName(char *pName)
{
     pName=(char *)malloc(12);
     strcpy(pName,"Cabin");
}

void main()
{
     char *Name;

     InputName(Name);
     printf("이름은 %s입니다\n",Name);
     free(Name);
}

언뜻 보기에는 이 코드가 맞는 것 같지만 실제로 컴파일해 보면 경고가 하나 발생하며 실행하면 제대로 동작하지도 않을 뿐더러 
죽어 버리기까지 한다. 왜 그런지 다음 그림을 보자.

main에서 Name을 선언하고 초기화되지도 않은 Name의 값(비록 그 값이 번지라 하더라도 어쨌든 값이다.)을 InputName의 pName으로 전달했다. 
이 함수는 pName에 메모리를 할당하고 이름 문자열을 복사해 넣지만 pName은 함수의 지역변수일 뿐이지 호출원의 실인수 Name과는 아무런 상관이 없다. 
함수가 char *의 값을 전달받으면 이 번지가 가리키는 내용을 변경할 수는 있지만 포인터 자체를 변경해서 호출원으로 돌려줄 수는 없다. 

이 코드대로라면 pName에 메모리가 할당되고 이름도 복사되지만 그 결과가 main함수의 Name까지는 전달되지 않는다. 
main의 Name은 여전히 쓰레기값을 가지고 있으며 이 번지를 잘못 읽거나 할당되지도 않은 영역을 해제하려고 시도하면 죽어 버릴 수도 있다. 
뿐만 아니라 지역변수 pName은 함수가 리턴되기 전에 사라지므로 할당된 메모리의 진입점을 잃어 버려 더 이상 이 메모리를 읽을 수 없고 
해제할 수도 없는 상태가 되어 버린다.

6장에서 배운 바에 의하면 인수 X의 값을 함수 내부에서 변경하려면 X의 포인터를 넘기는 참조 호출을 해야 한다. 
그러므로 InputName에서 char *형의 인수 Name을 변경할 수 있도록 하려면 char *의 포인터인 char **형을 넘겨야 하고 
InputName 함수에서는 *pName으로 실인수를 참조해야 하는 것이다. 만약 이 두 예제가 잘 이해가 되지 않는다면 
6장의 값 호출, 참조 호출 예제로 돌아가 좀 더 단순한 타입인 정수형의 경우부터 복습한 후 다시 읽어 보아라. 
그리고 메모리 안에서 어떤 일들이 일어나는지 잘 상상해 보아라.


/***** malloc 기본개념 및 사용 시 주의점(핵심, 반드시 읽어볼 것) *****/

 [포인터/메모리/동적할당/C언어] 메모리 동적할당과 정적할당 (malloc,calloc,realloc)  ♬ 컴퓨터 / ＃ 리뷰 ＆ 끄적¿  2011/03/08 02:13
 http://the2384.blog.me/10104632061 
 
포인터를 사용해서 메모리 동적 할당을 해봅시다.
메모리 동적 할당은 프로그램을 실행하는 도중 메모리를 동적으로 할당하는 것을 말합니다.
즉, 컴파일이전에 메모리를 얼마나 쓸 것인지 지정하는 것이 아니라 컴파일을 하며 소스 코드를 해석하면서 동적으로 (임의의 크기로)메모리를 할당하는 것입니다.

 1번) Static Memory Allocation
  int arr[n] = {0,};

 2번) Dynamic Memory Allocation
  int *ptr =NULL;
  ptr=(int *)malloc(sizeof(int)*n);
 
 n개 만큼의 메모리 공간을 할당한다고 가정을 해봅시다.

1번)의 경우 처음에 메모리 공간을 n으로 지정합니다.
2번)의 경우 처음에 지정하는 것이 아니라 컴파일을 하면서 주소 공간을 malloc을 통해 받아옵니다.

1번)과 같은 정적인 메모리 할당의 경우에는 배열의 크기를 고정시켜 주어야 합니다. 즉, 상수(Constant value)여야 합니다.
배열의 크기를 위와같이 n으로 지정해 줄 경우에는 컴파일시에 에러가 발생합니다.
n과 같은 변수가 아니라 구체적으로 100과 같은 상수여야 하는 것이죠.
(단지 위의 코드에서는 예를 든 것 뿐입니다.)

반면에 2번)과 같은 동적인 메모리 할당의 경우에는 동적으로 받아서 할당을 할 수 있기 때문에 n과 같은 변수를 줄 수 있습니다.
정적 메모리 할당의 경우에는 코드가 보기 쉽고 이해하기 편한 반면, 메모리의 낭비가 있을 수 있습니다.
반면 동적인 메모리 할당의 경우에는 필요한 만큼 그때그때, 코드를 해석하면서 메모리를 할당하면 되므로 메모리를 효율적으로 사용할 수 있습니다.
(코딩이 정적 할당에 비해 어렵습니다.)

또한 정적인 메모리 할당과는 달리 동적인 메모리 할당을 하였을 경우에는 할당한 메모리를 반드시 해제해주어야 합니다.

위에서 사용한 malloc의 경우 stdlib에서 제공하는 것으로 입력 size만큼의 메모리를 할당합니다.
그리고 size만큼의 메모리를 할당하면서 메모리 블록의 시작 주소를 반환합니다. 즉 포인터 형입니다.
(초기 기본형은 void로 제공 되므로 그때 그때 cast를 앞에서 해주면 됩니다.)
또한 지금 지정된 메모리의 주소값이 NULL이 아닌지 꼭! 조건문이나 다른 판단 척도를 통해 확인하여야합니다.

보통 프로그램의 안정성 측면에서 어떤 변수를 선언하고, 쓰레기값이 들어가있는 것을 피하기 위해 초기화를 시켜줍니다.

아래의 코드를 보세요.
아래의 예제를 통해 동적할당 및 초기화, 해제까지 공부할 수 있는데요.

예제1)
void main()
{
	int *ptr = NULL;
	int size = 10;
	int i;
	
	ptr = (int *)malloc(sizeof(int)*size);
	if(ptr != NULL)
	{
		memset(ptr, 0, sizeof(int)*size);
		for(i=0; i<size; i++)
			printf("%d : %d \n", i+1, *(ptr++));
		free(ptr);
	}
} 

컴파일시는 에러가 없습니다.
하지만 실행하면 경고창이 pop up 될 것입니다.

이유가 무엇일까요?
찾으셨나요?

네 바로 ptr때문입니다.
※ memset : 위를 기준으로, ptr을 시작으로 하여 0으로, sizeof(int)*size만큼을 0으로 세팅한다.
※ free : 사용한 메모리를 해제하는 것이�������. (C++ 에서는 delete)

이제 찾으셨나요?

free를 해줄때는 사용한 메모리의 시작을 가르켜야합니다.
즉 *(ptr++)으로 ptr의 주소가  4(int자료형의 사이즈) * 10만큼 이동했기 때문에
그 부분으로 부터의 메모리 해제를 요구하는 것이므로 에러가 발생하는 것이죠.

debug를 해보시면 free에서 경고창이 pop up되는 걸 확인하실 수 있을 것입니다.

[출처] [포인터/메모리/동적할당/C언어] 메모리 동적할당과 정적할당 (malloc,calloc,realloc)|작성자 히단

상기, 예제1) free 에러를 제거하려면 아래 예제2)와 같이 수정해줘야 함
 
예제2)
void main()
{
	int *ptr = NULL;
	int *ptrInitial = NULL;
	int size = 10;
	int i;
	
	ptrInitial = ptr = (int *)malloc(sizeof(int)*size);
	if(ptr != NULL)
	{
		memset(ptr, 0, sizeof(int)*size);
		for(i=0; i<size; i++)
			printf("%d : %d \n", i+1, *(ptr++));
		free(ptrInitial);
	}
} 


	3-6) 인터럽트 내부에서는 가급적 포인터를 사용하지 말자
		정확한 것은 아니지만 아래와 같은 오류 현상이 발생했기 때문에
		인터럽트 내부에서는 가급적 포인터를 사��하지 말자
// EX.1초 Timer 인터럽트
//    void Timer1sFunc(void)함수 내부에서 unsigned char* pGetTemp2 & EXT_GetCurrentTemp(pGetTemp2); 함수를 사용하지 않으니 I2C 통신 에러가 발생하지 않음
//    원인으로는 unsigned char* pGetTemp2 포인터 선언하고 EXT_GetCurrentTemp(pGetTemp2); 내부에서 포인터로 DATA가 전달되는데
//    본, 포인터에서 의해서 예기치 않은	I2C 통신 에러가 발생한 것으로 파악됨
//    ### 따라서, 인터럽트 내부에서는 가급적 포인터를 사용하지 말자 ###


	3-7) 인터럽트 처리시 주의 사항
1. 메인 루틴과 인터럽트 루틴에서 동일한 명령 실행을 가급적 피하고
   만약 어쩔 수 없이 동일하게 사용해야 한다면 Flag를 사용해서 메인 루틴과 인터럽트 루틴에서 동일 명령이 실행되는 것을 방지 하도록 코딩 해야 함
   Ex) 아래 void main(void) 메인 루틴과 void interrupt_timer(void) 인터럽트 처리 루틴에서
       동일하게 test() 명령을 사용하고 있으며
1)	이 경우 메인 루틴에서 test()명령 실행을 완전히 끝내기도 전에 인터럽트가 걸려서 인터럽트 루틴에서 test()명령을 실행하게 된다면
test() 명령이 끝나지도 않은 상황에서 다시 test()명령이 중복으로 실행되는 치명적인 결과가 발생하며
이에, 경우에 따라서는 프로그램이 멈춰버리는 심각한 오류가 발생됨
2)	따라서, 이와 같은 경우에는 Flag 변수를 사용해서 메인 루틴에서 test()명령 실행 중에는
인터럽트가 발생해도 인터럽트 내부에서 test()명령 실행을 skip하도록 처리해서 test()명령이 중첩되는 오류를 방지해야 함

void test(void)
{

}

void interrupt_timer(void)
{
   test();           // -> 인터럽트로 test() 명령 실행
}

void main(void)
{
   test();           // -> 메인 루틴에서 test() 명령 폴링 처리
   .
   .
}

2. 인터럽트 처리 루틴 프로그램은 최대한 간단하고 최소 타이머 시간 보다 빠르게 끝내도록 코딩
   Ex) 타이머 처리의 최소 단위가 2msec인 경우에는 10msec 타이머 처리 루틴 내부 프로그램도 2msec보다 빠르게 처리하고서 빠져 나와야 함
       이유) 최소 타이머 시간이 2msec이기 때문에 만약 10msec 타이머 내부 프로그램이 2msec보다도 더 오래 처리하고서 빠져 나온다면
             최소 타이머인 2msec 처리 루틴은 처리가 되지 않는 에러 발생함
             이에 2msec 처리 루틴은 실행되기도 실행되지 않기도 하는 애매 모호한 오류가 발생하며 이런 오류는
             찾아내기도 어렵고 고치도 어려운 오류를 발생함.


	4) 소수점 반올림 프로그램
				//기본입출력헤더파일포함
				#include < stdio.h >
				
				// 메인함수
				void main()
				{
					// 실수형변수를선언하고계산
					float j = (float)(146*138)/(138+4);			// cf) float j = (float)9/2;		-> j = 4.5 나옮
																// cf) float j = (float)(9/2);	-> j = 4 나옮
					// 인트형변수를선언
					int i;
				
					//인트형변수에명시적형변환을하여실수형에0.5를더해 넣는다
					//이때소수점은내림하게되는데0.5가넘으면1이되면서1이증가하고
					//소수점은사라진다.
					i = (int)(j + 0.5);
				
					//출력
					printf("%d \n",i);
				}


	5) 비트 연산
//val에서 c번째 bit를 뽑아냄...
int bits(int val, int c)
{
 return (val >> c) & (1);
}

int cir_rshift(int data)
{
 //가장 오른쪽 비트의 값이 무엇인즈를 뽑아낸다.
 int lsb = bits(data, 0);

 //1bit만큼 right_shift한다.
 data = data >> 1;

 //lsb의 값이 
 if (lsb)      //1일때 msb(가장 왼쪽 비트)값이 1이 되어야 한다.
  data = data | 0x80000000; //가장오른쪽bit가 1일, 다른 bit들은 0인 값과 OR연산 시킨다.

 else       //0일때 msb(가장 오른쪽 비트)갑이 0이 되어야 한다.
  data = data & 0x7fffffff; //가장 오른쪽 bit는 0, 다른 bit들은 1인 값들과AND연산시킨다.

 //data 리턴.
 return data;
}

 for (int i=0; i<sizeof(int)*8 - 1; i++)
 {
  x = cir_rshift(x);
  display_binary(x);
 }

unsigned char cir_rshift(unsigned char data)
{
	unsigned char tmp = data;
	unsigned char tmp2 = 0xff;
	int i, lsb;

	for(i=0; i<8; i++)
	{
		//가장 오른쪽 비트의 값이 무엇인즈를 뽑아낸다.
		lsb = bits((int)tmp, 0);

		//lsb의 값이 
		if (lsb)								// 1일때 msb(가장 왼쪽 비트)값이 1이 되어야 한다.
//			tmp2 = tmp2 | 0x80;					// 가장오른쪽bit가 1일, 다른 bit들은 0인 값과 OR연산 시킨다.
			tmp2 = tmp2 | (0x80 >> i);
		else									// 0일때 msb(가장 오른쪽 비트)갑이 0이 되어야 한다.
//			tmp2 = tmp2 & 0x7f;					// 가장 오른쪽 bit는 0, 다른 bit들은 1인 값들과AND연산시킨다.
			tmp2 = tmp2 ^ (0x80 >> i);

		// 1bit만큼 right_shift한다.
		tmp = tmp >> 1;
	}

 //data 리턴.
 return tmp2;
}

#define SWAP(A) ((A>>4) | ((A&0x0f) <<4))


    6) 조건부 컴파일 지시어
    #if 조건                // #if 다음에 조건이 맞으면 #if와 #endif사이의 문장을 컴파일 한다.
    #elif 조건              // #if, #ifdef, #ifndef의 조건에 맞지 않을 경우 또 다른 조건을 검색하기 위한 지시어로 사용된다.
    #else                   // #if, #ifdef, #ifndef의 조건에 맞지 않을 경우 #else와 #endif 사이의 문장을 컴파일 한다.
    #ifdef 문자열           // 문자열이 define 되었다면
    #ifndef 문자열          // 문자열이 define 되지 않았다면
    #endif                  // #조건부 컴파일 지시어를 마치게 해주는 지시어이다. 반드시 조건부 컴파일 지시어 마지막 부분에 있어야 한다.
    6-1)  
   #ifdef
      #ifdef A 에서 중요한건 A가 선언되어 있느냐 없느냐 입니다. 
      #define A 0... 여기서 님은 A가 ㅇ의 값 즉 false값을 가지니까 그런식으로 생각을 하신것 같은데요.. 
      정작 #ifdef에서는 true로 인식을 하죠

      보통은 저런식으로 쓰지를 않죠
      #define A
      #ifdef A
      ~~
      이런식으로 사용하는게 보통입니다.
    6-2) 보통 헤더파일이 재정의 되지 않기 위해서 하기와 같이 사용한다.
         func_lib.h 헤더파일을 여러곳에서 정의 했다고 해도 한번만 정의되게 됨
        ex) func_lib.h 파일내에서 하기와 같이 정의
        #ifndef _FUNC_LIB_H
        #define _FUNC_LIB_H
        .....................................................................
        #endif

	6-3)[C]전처리기 지시어 - #include, #define, #undef, #if, #else, #endif, #ifdef, #elif, #ifndef, defined(), #error, #line  C,C++ 언어  
2008/10/15 02:17
 http://blog.naver.com/pointer98/150036254254 

전처리 지시어는 컴파일 직전에 처리된다. 

#include
ex> #include <stdio.h>
이 지시어는 헤더 파일을 지시어가 들어가 있는 위치에 헤더파일을 포함시키는 것이다. < >괄호를 사용하면 표준 헤더 파일 디렉토리에서 지정한 파일을 찾는다. 같은 폴더일 경우에는 " "괄호를 사용한다. 물론 <>, ""의경우 어떤 것을 사용해도 상관은 없다 해당 폴더를 검색해서 해당 파일이 없다면 다른 폴더도 검색하기 때문이다.

#define
ex> #define NUM 1
(치환전) int Arr[NUM]; -> (치환후) int Arr[1]; 
이 지시어는 거의 치환의 의미로 사용됩니다. 위의 NUM을 컴파일하기전에 전처리기는 1로 대체한다. NUM이 어디에 있든 찾아내서 1로 바꾼다.

ex> #define TEXT "전처리 지시어"
(치환전) printf("%s", TEXT); -> (치환후) printf("%s", "전처리 지시어");
또한 정수형과 같이 문자열로도 치환이 가능하다.

ex> #define MAX
#ifdef MAX
  //MAX가 define되어 있다면 해당 코드가 컴파일 된다.
#else
  //MAX가 define되어 있지 않다면 해당 코드가 컴파일 된다.
#endif
또한 MAX로 정의는 하지만 대치시키지는 않도록 할수도 있다. 이것은 #ifdef ~ #elif ~ #else ~ #endif 문과 같이 사용되면 상당히 유용하게 사용된다. 
이런것을 조건부 컴파일이라 한다.

#undef
ex> 
#undef MAX
//이 아래 부터서는 MAX는 정의 되어 있지 않게 된다.

#ifdef MAX
  //MAX가 undef 되어 코드를 컴파일하지 않는다.

#else
  //MAX가 undef 되어 코드를 컴파일 한다.

#endif
이 지시어는 define으로 정의된 것을 해제하는 것으로 해당 코드 아래 부터서는 MAX의 정의가 되어 있지 않은 것으로 간주 한다.
ex>
#define SIZE 100
i = SIZE;

#undef SIZE
#define SIZE 200
j = SIZE; 

또한 Define으로 정의한 것을 다시 정의하면 컴파일 에러를 일의킨다. 이때 사용하는 것이 undef이다. 
위와 같이 사용하면 컴파일 에러는 나지 않는다.
 
#if, #else, #endif
ex>
#if 0
  //if 가 0 이기 때문에 이 코드는 컴파일 되지 않는다.

#else
  //if 가 0 이기 때문에 이 코드는 컴파일 된다.

#endif
이 지시어는 일반 적인 if문과 동일 방식으로 동작한다. 

#if 0
  //대용량 코드
#endif
또한 대용량코드를 주석 처리를 하지 않고 한번에 컴파일에서 삭제가 가능하다는 것이다.

#ifdef, #elif
ex>
#ifdef MAX1
  //MAX1 이 정의 되어 있다면 이곳의 코드를 컴파일 한다.

#elif MAX2
  //MAX1 이 정의 되어 있지않고 MAX2가 정의 되어 있다면 이곳의 코드를 컴파일 한다.

#else
  //MAX1 과 MAX2 가 정의 되어 있지 않다면 이곳의 코드를 컴파일 한다.

#endif
이 지시어는 MAX1 과 MAX2가 정의(Define)되었는지 체크하고 그에 해당하는 코드를 컴파일하게 된다.

#ifndef
ex>
#ifndef FILENAME_H
#define FILENAME_H
  //코드
#endif
이 지시어는 ifdef와 반대로 해당 수식어(FILENAME_H)가 정의 되어 있지 않다면 참으로  #endif 까지의 코드를 컴파일 하게 된다.
또한 이것은 헤더 파일이 중복되어 선언 되지 않도록 할때 자주 사용 되는 방식이다.

defined()
ex>
#if defined(DEBUG1) || defined(DEBUG2) || defined(DEBUG3)
  #define GEN_DEBUG(x) {printf x;}
#else
  #define GEN_DEBUG(x)
#endif 
이 지시어는 해당디파인이 되어있다면 1을 아니면 0을 반환한다. 일반 if문과 같이 사용하여 DEBUG1, DEBUG2, DEBUG3중 하나만 Define되어 있다면 
참으로 인식하여 컴파일을 하게 된다. 이것은 디버그를 사용할때 자주 쓰이는 방식이다.

#error
ex>
#if !defined(__cplusplus)
#error C++ compiler required.
#endif 
이 지시어는  전처리기가 해당 코드를 실행하게 되면 에러 메시지를 출력시키고 컴파일 작업을 하지 않도록 만든다. 

#line 
ex> 
x = 1;                       //3번 라인
#line 100 "main.c"     //4번 라인
y = 1;                      //100번 라인
이 지시어는 사용자를 위한 문장이기 보다는 컴파일러 자체를 위한 프리프로세서문이다. 
실제 컴파일 에러가나면 line을 거치면서 5번 라인이 아니라 100라인에서 에러가 난것으로 나타난다. 

기타 전처리기 사용방법
매크로 함수(Macro function)
매크로 함수도 전처리기로 사용할 수 있다. 다만 디버깅이 힘들어 많이 사용되지 않는다.

ex>  
#define CUBE(x) ((x)*(x)*(x))
(치환전) y = CUBE(x);  -> (치환후) y = (x) * (x) * (x);
매크로 함수를 사용한다면 ()를 남발하는 습관을 키워야 한다.

ex>
#define CUBE(x) (x*x*x)
(치환전) y = CUBE(3+4);  ->  (치환후) y = (3+4 * 3+4 * 3+4);
위와 같은 경우 우리가 생각한 값은 나오지 않는다.
 C++ 사용자는 매크로 함수보다는 template이나 inline 함수를 사용해야 한다. 

문자열 조작
ex> 
#define SAY(x) printf(#x)
(치환전) SAY(Hello, world!);  ->  (치환후) printf(“Hello, world!”);
위와 같이 식별자 앞에 # 를 붙이게 되면 자동으로 “x” 와 같이 “”로 둘러 싸 준다.

문자열 결합 
ex>
#define Print(x) Print ## x
(치환전) Print(One)  ->  (치환후) PrintOne
(치환전) Print(Two)  ->  (치환후) PrintTwo
## 는 두 개의 문자열을 결합해 준다. 위와 같이 사용하면 PrintOne 이라는 문자열로 대치되고 Print(Two) 는 PrintTwo 라는 문자열로 대치된다.

assert()
 ex>
#ifndef DEBUG
  #define ASSERT(x)
#else
  #define ASSERT(x) \
       if ( ! (x) ) \
       { \
             printf(#x); \
             printf(“ is NULL on line %d in file %s”, __LINE__, __FILE__); \
       }
#endif
대부분의 컴파일러는 ASSERT() 매크로를 가지고 있다. 
DEBUG 정의에 따라 디버그때만 코드가 생성되고 릴리즈시에는 코드가 생성되지 않게 할 수 있는 것이다.
또한 여러 줄이 필요할 때는 \ 가 사용되었다는 것에 유의하자.

ex> /* VC++6.0의 asert() */
#define _ASSERT(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, NULL))) \  //Debug 정보를 출력
             _CrtDbgBreak(); } while (0)  //자동으로 Debug Break를 잡아 준다. 이것 만으로도 유용하게 사용이 가능하다.

내장 매크로
ex>
printf(“ is NULL on line %d in file %s”, __LINE__, __FILE__); 
컴파일 시에 컴파일러가 미리 정의하고 있는 매크로들 이다.  

매크로명
 타입
 설명
 
__DATE__
 문자열
 컴파일하는 날짜
 
__TIME__
 문자열
 컴파일하는 시간
 
__LINE__
 정수
 컴파일하고 있는 줄 번호
 
__FILE__
 문자열
 현재 컴파일 하고 있는 파일의 이름
 
__TIMESTAMP__
 문자열
 소스 파일의 최종 변경 날짜와 시간

 ex>
printf("%d\n", __LINE__);  //컴파일시의 해당라인 번호로 치환된다. - 1234
printf("%s\n", __FILE__);  //컴파일시의 해당파일Path로 치환된다. - c:\main.c
printf("%s\n", __DATE__);  //컴파일시의 날짜로 치환된다. - Jan 1 2009 / 월.일.년
printf("%s\n", __TIME__);  //컴파일시의 시간으로 치환된다. - 15:31:17 / 24시간:분:초
printf("%s\n", __TIMESTAMP__);  //컴파일시의 날짜와 시간으로 치환된다. - Mon Jan 1 15:31:17 2009 / 요일.월.일.24시간:분:초.년

cf)	c/c++ header 파일 중복 include 에러(error) 방지 - #ifndef 사용  C  2012/10/08 17:55
	http://blog.naver.com/yjhyjh5369/80170843604 

1. test.h
int num = 0;

2. calc.h
#include "test.h"
... (생략)

3. calc.c
#include test.h
#include calc.h
...(생략)
--------------------

위와 같은 형태로 되어있을 경우 int num = 0; 이 두번 선언이 되기 때문에 재정의 에러가 발생한다.
이것을 방지 하고자 할 경우에는

1. test.h
#ifndef __test_h__
#define __test_h__

int num = 0;

#endif

2. calc.h
#ifndef __calc_h__
#define __calc_h__

#include "test.h"
...(생략)
#endif

와 같이 header 파일을 수정한다.

1번 기준으로 설명하면, #ifndef는 컴파일 단계에서 __test_h__ 가 선언되어있는지 확인한다. 
처음에는 선언되어있지 않기 때문에 "true"로 판단하여 진행하고 바로 다음줄에서 #define __test_h__ 으로 인해 __test_h__가 선언되기 때문에 
이후에는 test.h가 여러번 include 되더라도 컴파일 하지 않게 된다.

* ) 
ifndef 는 선언되어있다면 false,
선언되어있지 않다면 true 이다.


    7) extern
extern은 현재 파일이 아닌 다른 파일에 있는 것을 가져 올때 사용합니다...
주로 c에서 많이 사용하죠...
물론 예제에서 처럼 사용도 할 수 있습니다...
extern의 장점은 다른 파일에서 선언이 되어있는 것을 가져와서 사용하기 때문에
또 다시 메모리를 생성 하지 않아도 된다는 겁니다... 
그렇기 때문에 변수의 접근성이 용이해지기 때문에 사용합니다
단점이 있다면 
extern을 선언한 변수를 가진 헤더파일을 선언한 어디서나 가져다 사용 할 수있어서
잘못관리를 하게되면 변수의 값이 바뀔 수도 있는 단점이 있습니다

    cf) 새롭게 파일을 만들어서 함수를 추가 시킨다음 다른 파일에서 본 함수를 사용하는 방법
    1)  우선 새롭게 Test.cpp 라는 파일을 만들고
        void Test_func(void) 등의 함수를 추가 시켜고 원하는 명령을 입력
    2)  추가로 Test.h 라는 파일을 만들고
        extern void Test_func(void); 명령을 입력 시킴
    3)  Main.cpp 의 상단에
        #include "Test.h" 명령을 추가 시켜서 Main.cpp에서도 상기 Test.h에서
        extern 한 void Test_func(void) 함수를 사용할 수 있도록 함
    4)  Main.cpp 에서 그냥
        Test_func(); 명령을 주면 Test.cpp에서 만든 void Test_func(void) 함수를 사용할 수 있음
        
    cf) #include 로 인한 컴파일시 binary file 용량 증가?
        Metrowerks CodeWarrior for ARM Developer Suite 로 컴파일하는 경우(DebugRel 옵션)
        #include로 용량이 많은 BMP Header file을 추가했지만 프로그램 내에서 사용하지 않으면 컴파일 시
        binary file 용량은 증가하지 않음
         
    cf) extern "C"
extern "C" 는 name mangling을 방지하는 역할을 합니다.
name mangling이란 컴파일 시 함수이름 앞 또는 뒤에 언더바(_) 등을 덧붙이는 것을 말합니다. 
C++에서, 주로 오버로딩 함수들을 상호 구분하기 위해 함수이름 앞뒤에 특정 문자/숫자들을 컴파일러가 덧붙이게 됩니다. 
굳이 오버로딩 함수가 아니더라도 함수이름 앞에 기본으로 언더바를 붙이기도 합니다. 
extern "C"는 이런 것들을 해당 함수에는 하지 말라고 일러주는 것입니다. 
함수에서 extern의 의미는 해당 함수의 실체가 다른 소스파일에 있다는 의미입니다만 extern은 옵션으로서 있을 때와 없을 때의 차이가 없습니다. 

C++ 컴파일러는 C 컴파일러와 다르게,
프로그래머가 지정한 함수 이름을 그대로 사용하지 않습니다.
프로그래머가 Func()라는 이름으로 함수를 만들었다고 해도,
이 이름과 동일한 함수들을 C++에서는 만들 수 있죠.
어떤 Func()라는 함수는 정수를 인자로 받고, 또 어떤 Func()라는 함수는 실수를 인자로 받도록 만들 수 있는 것이죠.
이렇게 함수 이름이 동일한 여러개의 함수가 나타날 수 있기 때문에,
C++ 컴파일러는 내부적으로 Func라는 이름에다가 인자들의 타입 및 리턴타입으로 어떤 문자들을 덧붙여서, 
각 함수들을 구분할 수 있도록 새로운 이름들을 만듭니다.
그런데 C언어는 함수이름을 그대로 사용하죠.
그렇다면 내 프로그램에서 만든 어떤 함수(인터페이스)를 다른 C언어 계열 프로그램에서 쓸 수 있게 하거나,
반대로 다른 C언어 계열로 만들어진 프로그램의 인터페이스를 가져다가 쓰기 위해서는 함수 이름을 그대로 사용해야 합니다.
extern "C"는 이렇게 C언어의 스펙에 따라 함수 이름을 사용하도록 컴파일러에게 지시하는 역할을 합니다.


	7-1) extern을 사용한 외부변수 선언
변수일 때 extern
같은 변수를 여러 다른 파일에서 사용하고 싶다. 그러나 이런식으로 다른 파일에서 여러번 include를 하게 되면 컴파일러에서는
에러를 뿜어낸다. 이럴때 사용하는 것이 extern 외부 변수 선언이다.

파일이름 : a.h
extern int sum;

파일이름 : a.cpp
#include "a.h"

int sum;
~~~
sum = sum + 1;
~~~


파일이름 : b.h
#include "a.h"
파일이름 : b.cpp
#include "b.h"
~~~
sum = sum + 1;
~~~

이런식으로 처음에 a.h에 sum을 선언할 때 extern을 사용하여 컴파일러에게 외부 변수니까 메모리를 할당하지 말라고 표시해주는
것이다. 그럼 컴파일러는 a.h에서는 메모리 할당을 하지 않고 a.cpp에서 int sum;에서 실제로 메모리 할당이 일어나는 것이다.
그렇게 되면 b.h에서 a.h를 include할 때 실제로 메모리 할당이 이루어 지지 않은 외부변수 sum을 사용 할 수 있는 것이다.


    8)  구조체(typedef 문을 사용해서 정의)
      결론 typedef를 사용해서 구조체를 정의 하면 하기 "(2)에서는"에서 설명하는 것 처럼
      간단하게 구조체 변수를 선언할 수 있다

typedef문을 먼저 이해하셔야 합니다.
typedef unsigned int UINT;
이 구문은 unsigned int 형의 자료형을 UINT이란 이름으로써 자료형으로 쓰겠다는 말입니다.

UINT i;

라는 식으로 자료형자체로 사용해서 인스턴스를 생성할 수 있는거죠
이건 아실겁니다.

//(1)
struct _tagPoint{
     int x; 
     int y;
}POINT;
 
//(1-1)
struct _tagPoint{
     int x; 
     int y;
};

//(2)
typedef struct _tagPoint{
     int x; 
     int y;
}POINT;

//(2-1)
typedef struct{
     int x; 
     int y;
}POINT;

하나씩 설명하겠습니다.
(1)에서는
POINT라는 인스턴스를 생성한것입니다.
POINT.x로서 사용할 수 있다는 말입니다.

(1-1)에서는 
선언된 인스턴스가 없습니다.
struct _tagPoint POINTS;            // _tagPoint POINTS; 로 사용해도 컴파일 에러 없음, 이유는 하기 8-1)에서 설명
POINTS s;
s.x로서 사용할 수 있습니다.

(2)에서는
구조체자체를 POINT라는 자료형으로 정의한 것입니다.
POINT s;
s.x로서 사용할 수 있습니다.

(2-1)도 마찬가지지만
tag명을 생략하고 사용가능합니다.
(2)와의 차이점은 
struct xxx s;
s.x로서 사용하실 수 없습니다.
오로지 POINT s;
s.x로서 사용하실 수 있습니다.

정리하면 
typedef 문을 사용하시게 되면
인스턴스가 생성되는게 아닙니다. 자료형이 하나 정의되게 되는 것입니다.

    8-1) struct Student data_name; 으로 선언을 Student data_name; 으로 선언해도 되는 이유

struct Student{
  int x;
  int y;
  };

이렇게 선언된 구조체를 쓸려면

struct Student data_name; 이렇게 써야 하는데
Student data_name; 이렇게 써도 동작은 하던데, struct 키워드를 굳이 써야하는지 궁금합니다

그에 대한 설명은 C/C++인지, 옛 버전인지 최신 표준인지 등에 따라 달라집니다.

먼저 C부터 설명드리자면...
현재 컴파일러들은 둘 다 컴파일 가능합니다.
그러나 정확한 명칭은 struct Student가 맞습니다.
즉 엄밀히 타입명이 그냥 Student가 아니라 struct Student가 정확하다는 것입니다.
물론 컴파일러에서는 그냥 구조체 토큰명을 타입명으로 하여 Student도 struct Student로 인식하긴 합니다.
그리고 그렇게 작동하는 것이 최신 C99 표준에도 맞을 겁니다.

이렇게 복잡한 원인은 C의 옛날 버전에 있습니다.
옛날 C는 기본타입(char, int, ...) 및 compiler-specific 타입(__int8, __int16, 가끔은 wchar_t 등까지) 
외에는 타입 규정은 struct 및 enum밖에는 되지 않았습니다.
솔직히 enum은 정수타입의 호환형이므로 문제가 없습니다만...

struct는 아예 종류가 다릅니다. 데이터 타입이 수가 아니라는 거죠.
따라서 컴파일러가 처리해줄 때 반드시 struct를 붙여야 했습니다,
더구나 표준도 존재하지 않을 시점엔 모든 면이 컴파일러 제멋대로였으므로 struct를 쓰는 것이 있었던 거죠.
즉 옛날 버전과의 호환성 및 프로그래머의 습관에 기인한 것입니다.
때문에 Windows 헤더(F/OSS쪽 헤더도 그런지는 모르겠습니다만) 파일을 보면 이런 식으로 구조체가 정의되어 있습니다.

typedef struct
{

 ....

} STRUCT_NAME;

..

STRUCT_NAME some_struct;

즉 typedef 과정을 거쳐서 이름없는 구조체의 정식 이름을 STRUCT_NAME으로 만들어 주었습니다.
이 경우 정확한 구조체의 접근 가능한 이름이 struct STRUCT_NAME이 아니라 STRUCT_NAME이 되는거죠.

이 개념이 C++에서는 약간 달라집니다.
class와 struct가 같은 개념으로 바뀌도록 규정되면서 struct를 써줄 공식적 이유가 사라진 거죠.
대신 typename 키워드가 생겨서 타입지정 지시어로 쓰이게 합니다. 그러나 이건 붙이지 않는 것이 정확하지 않다 말하는 류가 아닙니다.
물론 아직도 개발자들은 struct를 관례상 C에서의 용도(단순 데이터 연속 모임)로 사용하고, 컴파일러들도 최적화 루틴에서 비슷하게 동작하나...
언어상의 측면에서 보았을 때는 struct와 class가 같아지면서 struct 키워드의 변수선언 개념이 사라졌다고 보는 게 맞습니다.

결국은 모두 역사 때문에(?) 일어난 일입니다.


    9) 구조체 초기화
구조체를 초기화하는 방법은 배열과 거의 비슷하다. 선언시에 = 구분자와 { } 괄호를 써 주고 괄호안에 멤버의 초기값을 나열하면 된다. 
다음은 tag_Friend형의 구조체 Friend를 선언하면서 이 구조체를 초기화하는 예이다.

tag_Friend Friend={"아무개", 30, 178.2 };

Name 멤버에 "아무개" 문자열이 복사되고 Age에는 30이 대입되며 Height는 178.2가 될 것이다. 
초기값이 없는 멤버는 자동으로 0으로 초기화된다.

#include <stdio.h>

struct movie {
  char title[30];
  char director[20];
  float score;
  };

int main(void)
{
  struct movie m1 = {"Spiderman 3", "Sam raimi",9.8};
  printf("%s %s %d %f\n", m1.title, m1.director, m1.running_time);
  return 0;
}

■ 구조체 배열의 초기화
구조체 배열도 선언과 동시에 초기화가 가능하다.

struct person 
{
   char name[20];
   char phone[20];
}

int main(void)
{
   struct person pArray[3] =
   {
      {"Lee","333"},
      {"Kim","555"},
      {"Bae","666"},
   };
   ....
   return 0;
}

	9-1) 자기 참조 구조체
	자기 참조 구조체  = 자신의 구조체 자료형 포인트 변수가 
	구조체 정의 안에 포함되어 있는경우 

	연숙된 메모리 공간이 없어도 
	이게 있어서 저장 됨. 

	struct Node
	{ 
		int data;
		struct Node * next;  //내 다음을 가리킨다. 
	}
	링크드 리스트에서 쓰인다. 


    10) 파싱(parsing) -> sscanf
    10-1)
#include <stdio.h>

int main(void)
{
 int age, height;
 char original_string[] = "I'm 30 years old and 175 Cm";

 sscanf (original_string, "I'm %d years old and %d Cm", &age, &height);

 printf("age : %d\n", age);
 printf("height : %d\n", height);

 return 0;
}

age : 30
height : 175

    10-2)
sscanf에서 %n의 사용
%n은 입력 스트링에서 이전에 입력받은 문자열의 character 개수만큼을 반환한다고 합니다.
int형으로 값을 받아들여야 한다. 
예를 들면, 

char date_time[] = "2007-04-15 21:40:00";
char date[11];
char time[9];
int read_cnt;

sscanf(date_time, "%s %s%n", date, time, &read_cnt);

date = "2007-04-15"
time="21:40:00"
read_cnt = 19  <---  time이 다 읽혀질 때까지 사용된 character개수

    10-3)
int i = 0;
char buf[] = "hello!! hi!! test!!";
char *p;
char *pcBuf[SIZE];
char str[128];
char *delim = " ";

memset(str, 0x00, sizeof(str));
memcpy(str, buf, strlen(buf));
 
p = strtok(str, delim);			// strtok을 사용하면 무조건 원본 문자열(buf)이 변경되기 때문에
								// strtok 명령 실행전에 상기와 같이 원본 문자열(buf)을 copy한 것을 사용해야 함
 
while(p != NULL)
{
	pcBuf[i++] = p;
	p = strtok(NULL, delim);
}
 
이런식으로 하면 공백을 구분으로 하여 차례대로 토큰이 p[i]에 들어갑니다.
물론 공백이 아닌 따른 걸로도 토큰 구분이 가능하고요
두번째 인자로 "; " 이런식으로주면, 기호 ';'와 공백 두가지 모두로 토큰이 나눠집니다.

cf) 흔히 범하는 실수
예제1)
int aBuf1[10], aBuf2[10];
memset(aBuf1, 0, 10);					-> NG, 이렇게 하면 안된다, 아래와 같이 바꿔야 함
-> memset(aBuf1, 0, sizeof(int)*10); 	-> OK
-> memset(aBuf1, 0, sizeof(aBuf1);		-> OK
memcpy(aBuf1, aBuf2, 10);				-> NG, 이렇게 하면 안된다, 아래와 같이 바꿔야 함
-> memcpy(aBuf1, aBuf2, sizeof(int)*10);-> OK
-> memcpy(aBuf1, aBuf2, sizeof(aBuf2));	-> OK


    11) new, delete 사용 이유
프로그래머의 필요에 따라 사용하는 것입니다.
차이가 있다면
스텍을 사용하는 경우 해당 함수를 종료하면 자동 소멸 됩니다.
그러나 new 연산자로 생성한 것은 해당 함수가 종료되어도 사라지지 않습니다.
반드시 delete 연산자로 삭제 하여 주어야 합니다.
만일 다른 함수에서도 사용하려면 new 연산자를 사용하여야 합니다.
그러나 함수의 리턴값으로 사용되어진 경우는 해당값이 리턴이 완료된 후에 소멸되므로
굳이 new 연산자를 사용할 필요가 없습니다.

new, delete는 C의 malloc, free에 대응되는 C++의 메모리 할당 연산자이며 실행중에 메모리를 할당한다는 점에서 용도가 비슷하다. 
할당 연산자인 new의 기본 형식은 다음과 같다.

포인터 = new 타입[(초기값)];

new 다음에 할당 대상 타입을 밝히면 sizeof(타입)만큼의 메모리가 할당되고 할당된 포인터가 리턴된다. 
new가 리턴하는 번지는 같은 타입의 포인터 변수로 대입받는다. 할당과 동시에 메모리를 초기화하고 싶으면 
타입 다음의 괄호에 원하는 초기값을 적되 초기화를 할 필요가 없으면 생략할 수 있다. 
초기화하지 않은 메모리는 물론 쓰레기값을 가진다. 메모리 부족 등의 이유로 할당에 실패하면 NULL을 리턴하는데 
원칙적으로 이 리턴값을 점검해 보아야 하지만 32비트 환경에서는 실패할 확률이 거의 없어 점검을 생략하는 경우도 많다.

이렇게 할당된 메모리를 해제할 때는 delete 연산자를 사용하는데 해제할 포인터를 delete 다음에 지정한다. 
만약 할당만 하고 해제를 하지 않으면 메모리 일부를 사용할 수 없게 되는 메모리 누수(Memory Leak)가 발생하므로 
동적 할당한 메모리는 반드시 delete해야 한다. 한 포인터에 대해 delete를 두 번 하는 것은 안되지만 NULL 포인터를 삭제하는 것은 가능하다. 
즉 다음과 같이 할 필요가 없다.

if (pi != NULL) {
     delete pi;
}

delete는 NULL 포인터에 대해서는 아무런 동작도 하지 않도록 정의되어 있으므로 안전하다. 
위 코드에서 if문으로 점검할 필요없이 무조건 pi를 해제해도 상관없다. 다음은 new, delete로 정수형 변수 하나를 동적으로 생성해 본 것이다.

예 제 : newdelete
#include <Turboc.h>
void main()
{
     int *pi=new int;
     *pi=123;

     printf("*pi=%d\n",*pi);

     delete pi;
}

new연산자에 의해 정수형 하나를 저장할만큼의 공간(4바이트)이 할당되는데 할당된 포인터를 정수형 포인터 변수 pi로 대입받았다. 
힙에 할당된 4바이트를 pi가 가리키고 있으며 이후 *pi는 동적 할당된 정수형 변수가 되며 정수값 하나를 기억할 수 있다. 예
제에서는 *pi에 123이라는 정수값을 대입하고 확인을 위해 출력만 해 보았다. 다 사용하고 난 다음에는 delete pi로 해제한다. 
다음은 new 연산자로 실수형과 문자형 변수를 할당하는 예이다.

double *pd=new double;
char *pc=new char;
pd에는 8바이트가 할당되고 pc에는 1바이트가 할당될 것이다. 잘 사용되지는 않지만 new int; 라고 쓰는 대신 괄호를 써서 
new(int)라고 쓰는 방법도 있으며 이때도 new(int)(123) 형식으로 초기값을 지정할 수 있다. 
new/delete 연산자는 malloc/free와 기능적으로 동일하기 때문에 위 예제를 다음과 같이 고쳐 써도 똑같이 동작한다.

int *pi=(int *)malloc(sizeof(int));
*pi=123;
printf("*pi=%d\n",*pi);
free(pi);

new 대신 malloc을 사용했고 delete 대신 free를 사용했다. 메모리 할당의 면에서만 본다면 new/delete는 malloc/free와 동일하지만 
차이점도 많이 있다. new/delete는 malloc/free보다 메모리를 관리하는 방식이 훨씬 더 진보적이며 속도도 빠르고 
OOP에 적합한 특징들을 많이 가지고 있다. 어떤 점이 다른지 보자.

① malloc/free는 라이브러리가 제공하는 함수인데 비해 new/delete는 언어가 제공하는 연산자이다. 
그래서 별도의 헤더 파일을 포함할 필요없이 언제든지 사용할 수 있으며 이 연산자를 쓴다고 해서 프로그램이 커지는 것도 아니다. 연
산자이기 때문에 사용자 정의 타입에 대해 오버로딩할 수도 있다.
② malloc 함수는 필요한 메모리양을 바이트 단위로 지정하고 void *를 리턴하므로 sizeof 연산자와 캐스트 연산자의 도움을 받아야 한다. 
이에 비해 new는 할당할 타입을 지정하고 해당 타입의 포인터를 리턴하므로 sizeof 연산자와 캐스트 연산자를 쓸 필요가 없다. 
할당한 타입과 같은 타입의 포인터 변수로 대입만 받으면 된다.
③ malloc은 메모리를 할당하는 것만이 목적이므로 초기값을 줄 수 없지만 new 연산자는 동적으로 생성한 변수의 초기값을 지정할 수 있다. 
즉 할당과 동시에 초기화를 할 수 있는데 할당 타입 다음의 괄호에 초기값을 적어 주면 된다. 
int *pi=new int; *pi=123; 두 문장은 int *pi=new int(123); 하나로 합칠 수 있다.
④ new 연산자로 객체를 할당할 때 생성자가 자동으로 호출된다. 생성자란 객체를 자동으로 초기화하는 특별한 함수인데 다음 장에서 배우게 될 것이다. 
생성자는 생성과 동시에 객체를 초기화할 수 있도록 함으로써 클래스가 기존 타입과 동등한 자격을 가지도록 하는 중요한 역할을 한다. 
생성자를 호출한다는 점이 malloc과 new의 가장 큰 차이점이며 C++에서 별도의 할당 연산자가 추가된 이유이다. 마찬가지로 delete로 객
체를 삭제할 때는 파괴자라는 특별한 함수가 자동으로 호출된다.

new 연산자는 기본 타입뿐만 아니라 구조체나 배열, 사용자 정의형 타입도 할당할 수 있다. 다음은 new 연산자로 구조체를 할당하는 예제이다.
예 제 : newstruct
#include <Turboc.h>
struct tag_Friend {
   char Name[10];
   int Age;
   double Height;
};

void main()
{
     tag_Friend *pF=new tag_Friend;

     strcpy(pF->Name,"아무개");
     pF->Age=22;
     pF->Height=177.7;
     printf("이름=%s, 나이=%d, 키=%.1f\n",pF->Name,pF->Age,pF->Height);

     delete pF;
}

new 연산자에 의해 sizeof(tag_Friend)만큼의 메모리가 할당되고 tag_Friend * 타입이 리턴된다. 
구조체를 할당과 동시에 초기화하려면 다음 장에서 배울 생성자 함수라는 것을 만들어야 한다. 
배열을 할당하는 방법은 조금 특수하다. 할당 타입 다음의 [ ] 안에 배열의 크기를 지정하는데 다음은 정수형 배열을 할당하는 예이다.

예 제 : newarray
#include <Turboc.h>
void main()
{
     int *ar = new int[5];
     int i;

     for (i=0;i<5;i++) {
          ar[i]=i;
     }

     for (i=0;i<5;i++) {
          printf("%d번째 = %d\n",i,ar[i]);
     }

     delete[] ar;
}

new int[5];에 의해 정수형 변수 5개를 저장할 수 있는 메모리가 할당되며 int * 타입이 리턴된다. 
리턴값을 int *형의 ar로 대입받으면 ar은 정수형 배열과 동등하며 배열처럼 사용할 수 있다. 
배열을 할당할 때는 new연산자로도 초기값을 지정할 수 없다. 동적으로 할당하는 것이므로 할당할 배열의 크기를 지정하는 
값이 꼭 상수여야 할 필요는 없으며 변수로도 크기를 지정할 수 있다. 즉 다음과 같은 코드도 가능하다.

int n;
printf("도대체 몇 개나 필요하니? : ");
scanf("%d",&n);
int *ar=new int[n];

동적으로 할당한 배열을 삭제할 때는 delete 대신 반드시 delete [ ] 문을 사용해야 한다. 
그렇지 않았을 때 그러니까 할당은 new [ ]로 해 놓고 해제는 delete로 했을 때의 동작은 정의되어 있지 않으며(Undefined) 상황에 따라 다르다. 
일반적으로 배열의 첫 번째 요소에 대해서만 파괴자가 호출되고 나머지는 파괴자가 호출되지 않으므로 메모리 누수가 발생할 것이다. 
또는 할당 헤더의 구조가 달라 첫 번째 요소가 제대로 파괴되기 전에 다운될 수도 있는데 정의되지 않은 동작의 결과는 컴파일러에 따라 달라진다. 
흔히 많이 실수하는 부분이므로 동적 할당한 배열은 delete [ ]로 해제한다는 것을 꼭 기억해 놓도록 하자. 
중요한 내용이므로 한 번 더 반복한다. new는 delete와 짝이고 new [ ]는 delete [ ]와 짝이다.

new/delete의 가장 큰 장점은 객체가 생성, 파괴될 때 생성자와 파괴자가 호출된다는 점인데 이에 대해서는 다음에 따로 연구해 볼 것이다. 
이 점만 제외하면 malloc/free와 큰 차이점은 없다. C++에서는 가급적이면 malloc/free 대신 new/delete를 사용할 것을 권장하지만 
반드시 그래야 하는 것은 아니다. 단순히 메모리 할당만 한다면 malloc/free도 아직까지 쓸만하며 오히려 더 편리한 면도 있다.

예를 들어 malloc으로 할당한 메모리는 realloc으로 크기를 바꿔 재할당할 수 있지만 new에는 이에 대응하는 기능이 없어 
새로 할당하여 복사하고 원래 메모리를 해제하는 과정을 직접 해야 한다. 그래서 재할당할 때마다 매번 번지가 바뀌며 
심지어 축소할 때도 번지가 바뀐다. 또한 실행중에 할당 블록의 크기를 조사하는 _msize에 해당하는 기능도 없다. 
할당 대상이 객체가 아니고 재할당을 빈번하게 한다면 malloc/free를 사용할 수도 있고 객체를 할당할 때는 반드시 new/delete를 써야 한다. 
단, 할당, 해제 함수는 반드시 짝을 맞추어야 하며 섞어서 쓸 수는 없다. new로 할당한 메모리는 반드시 delete로 해제해야 하고 
malloc으로 할당한 메모리는 free로 해제한다.


	12) 데이터, 스택, 힙 영역
■ 데이터 영역(Data Area)
데이터 영역은 전역 변수와 static 변수가 할당되는 영역이다. 이 영역에 할당되는 변수들은 
일반적으로 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야만 메모리에서 소멸된다. 
즉, 데이터 영역에 할당된 변수는 프로그램이 종료될 때까지 계속 존재한다는 특징을 지닌다. 
전역 변수와 static 변수의 특징과 일치하는 부분이다.
■ 스택 영역(Stack Area)
스택 영역은 함수 호출 시 생성되는 지역 변수와 매개 변수, 포인터가 저장되는 영역이다. 
이 영역에 할당된 변수는 함수 호출이 완료되면 사라진다는 특징을 지닌다. 
이는 다른 메모리 영역과 확실히 비교되는 특징이다. 
늦게 할당된 변수의 메모리가 먼저 해제되므로 스택의 특징과 일치한다.
■ 힙 영역(Heap Area)
힙 영역은 프로그래머가 관리하는 메모리 영역이다. 즉 프로그래머의 필요에 의해서 
메모리 공간이 할당 및 소멸되는 영역이다. 동적 할당으로 생성되는 메모리 영역이다.
프로그램 코드 영역과는 별도로 유지되는 자유메모리 공간.  new, delete, malloc, calloc, free 등등으로 
메모리 할당/해제하면 이 공간을 사용할 수 있다.  이곳의 data는 전역변수처럼 프로그램이 종료될 때까지 유지된다.  
만약 heap이 가득차게 되면 불안정한 운영체제의 경우 치명적인 오류 등의 이상 현상을 일으켜 reboot를 해야하는 경우가 생긴다.  
C#이나 Java는 이 영역의 관리를 자동으로 해준다(gabage collection)
※ 정적 할당되는 변수의 메모리는 변수의 특성에 따라 데이터 또는 스택 영역에 생성된다. 
정적 할당은 컴파일 단계(Compile-time)에서 모두 이루어진다. 
하지만 컴파일 단계에서는 메모리의 크기만 생성 할 뿐 변수의 값은 저장 되지 않는다. 
이 때문에 배열의 크기는 상수로만 지정해야 하는 것이다. 
변수 값의 저장은 런타임(Run-time)에서 이루어지며, 런타임 단계에서 메모리를 생성하고자 할때 
사용하는 것이 동적 할당이다.

[C/C++]Heap 과 Stack 영역  프로그래밍  2008/06/17 03:26
 http://ragcarib.blog.me/120053039688 
 
프로그램이 메모리에 올라가게 되면 Data Segment 와 Code Segment 로 나뉘게 된다.
Heap 과 Stack 은 Data Segment 를 이용하게 된다.
   
 힙(Heap)은 런 타임시에 크기가 결정되는 요소들이 저장되는 공간이다.
C의 malloc() 함수나 C++의 new 연산자로 메모리 할당이 될 때에는 이 Heap 공간에 메모리가 잡히게 된다.

스택(Stack)은 컴파일시에 크기가 결정되어있는 요소들이 저장되는 공간이다.
함수가 받는 매개 변수나 함수내에서 사용되는 지역변수가 이 Stack 영역에 저장이 된다.

메모리를 가상으로 그림으로 그려보면 다음과 같이 나타낼 수 있다.

|---------------------------------------|
|※데이터 영역							|
|전역 변수와 static 변수 저장			|
|---------------------------------------|
|※힙 영역								|
|동적 할당되는 데이터 저장				|
|(데이터가 위부터 순차적으로 저장)		|
|---------------------------------------| 
|※스택 영역							|
|지역 변수와 매개변수가 저장			|
|(데이터가 아래부터 순차적으로 저장)	|
|---------------------------------------|

보통 전역 변수나 static 변수는 heap 의 윗 부분에 위치하고, Stack 은 Data Segment 의 처음부터 할당이 되고,
Heap 은 끝부분 부터 할당이 된다.
 

예제 코드를 작성하여 돌려보았다.
#include <stdio.h>

int A, B;

main()
{
 int a = 0;
 int b = 0;

 int *p1 = NULL;
 int *p2 = NULL;

 p1 = (int*)malloc(sizeof(A));
 p2 = (int*)malloc(sizeof(A));

 printf("전역 변수의 주소값 출력\n");
 printf("%d\n", &A);
 printf("%d\n", &B);
 printf("동적할당된 포인터의 주소값 출력\n");
 printf("%d\n", p1);
 printf("%d\n", p2);
 printf("지역 변수의 주소값 출력\n");
 printf("%d\n", &a);
 printf("%d\n", &b);

 free(p1);
 free(p2);
}

---------------------------------------------------------
전역 변수의 주소값 출력
4359392
4359396
동적할당된 포인터의 주소값 출력
3681776
3681824
지역 변수의 주소값 출력
1244884
1244872
Press any key to continue
---------------------------------------------------------

Visual Studio 2003에서 작성하였고, 알아보기 쉽게 10진수로 출력을 하였다.
메모리 할당이 된 간격은 틀리지만,
전역 변수와 동적 할당된 포인터의 메모리 할당 순서가 지역 변수의 메모리 할당 순서와 다른것을 확인할 수 있다.

Stack 영역에 올라가는 데이터는 프로그램이 실행되자마자 마로 메모리에 할당이 되고, 함수가 종료되거나, 프로그램이 종료될 때 자동으로 메모리 공간이 해제된다.
그에 반해, Heap 영역에 올라가는 데이터는 프로그램이 실행되는 중간에 메모리에 할당되고, 프로그램이 종료될 때
자동으로 메모리 공간이 해제되지 않는다. 메모리 공간을 해제하면 다시 그 영역을 사용할 수 있다.
따라서 동적으로 할당된 메모리 공간은 C의 free() 함수나 C++의 delete 연산자를 사용하여 메모리 공간을 다시 해제하여 주어야 한다.

그렇지 않을 경우 메모리 누수(leak) 가 발생하게 된다.
[출처] [C/C++]Heap 과 Stack 영역|작성자 우기우기


<<메모리영역>>
메모리 영역은 스택영역, 데이터영역, 코드 영역, 레지스터로 나뉜다.
여기서 데이터 영역에서는 정적데이터, 전역데이터, 동적할당 데이터로 나뉜게 된다.
 
1. 스택 영역
일반적으로 사용되는 지역변수나 매개변수.
지역변수와 매개변수 같이 자주 생성되고 지워지는 데이터는 스택 영역을 사용한다.
우리가 늘 사용해왔던 변수 선언 방법이 여기에 속한다.

2. 데이터 영역 / 정적데이터
데이터 타잎 앞에 static이 붙는 변수. 
선언 방법은 static int a;
컴파일이 할당되고, 프로그램 종료 시 소멸된다.

3. 데이터영역 / 전역 데이터(global)
함수밖에 선언된 변수이다.
int a;
int main(void)
{
return 0;
}
이런 식이다.

4. 데이터영역 동적할당 데이터(heap)
동적으로 메모리를 할당된 변수. malloc 계열이나 new 같은 함수들로 인해 동적할당된 변수이다.
기본적으로 1MB크기의 힙 메모리 영역을 할당.

5. 코드 영역
함수 코드가 저장되는 곳으로 읽기 전용이다.

6. 레지스터
데이터 타잎 앞에 register가 붙어있는 변수.
static과 마찬가지로 register 키워드로 생성된 데이터로서, CPU이 레지스터에 생성되므로
속도는 아주 빠르다. 다만 개수에 제한이 있다.
register int a;

<단어의 정의>
-지역변수 
1. 사용할 변수가 특정 함수 내부에서 선언되어 해당 영역에서만 사용가능 한 변수.
2. 함수가 종료되면 메모리에서 소멸되고 
3. 초기화하지 않으면 쓰레기값을 갖는다.

-전역변수 
1. 함수 외부에서 선언되어 모든 함수에서 사용가능하다.
2. 프로그램이 실행될 때 메모리가 할당되며 프로그램이 종료되어야 메모리에서 소멸된다.
3. 초기화하지 않으면 자동으로 0을 초기값으로 취한다.
 
-동적할당
1. 우리가 지금까지 사용해왔던 메모리는 정적 메모리로서 프로그램 안에서 사용자가 메모리를 변경할 수 없는 메모리다.
2. 동적 메모리는 프로그램 안에서 사용자가 메모리를 변경할 수 있다. 사용자가 자유자재로 메모리 사이즈를 잡을 수 있다. 
3. 지역변수는 함수가 끝나면 stack메모리가 사라지고 전역변수는 프로그램이 종료되면 data영역에서 메모리가 사라지지만 동적(heap) 메모리는 프로그램이 종료되되 메모리가 사라지지 않는다.
4. 메모리를 할당하는 함수로 Malloc나 new, delete, new[], delete[] 등의 연산자가 존재한다.
[출처] 메모리영역!|작성자 태자


	13) 링크드 리스트
[링크드리스트]링크드리스트와 배열의 비교  뇌를 자극하는 C++  2012/09/20 14:34

 http://blog.naver.com/winyong39/50150659327 
 
// 링크드 리스트
링크드 리스트는 구조체나 배열처럼 C++에서 제공하는 기능이아니다.
그렇기 때문에 직접 만들어서 사용해야 하는데,
일반적인 구조체와 포인터를 사용해서 만들 수 있다.
예를들어 우리가 a,b,c,d라는 4개의 아이템을 보관해야 한다고 생각했을때
정수 값이라고 생각해도 되고 Student변수라고 생각해도 상관 없다.
이 4개의 아이템이 배열에 보관된 모습과 링크드 리스트에 보관된 모습을 비교해보자.

// 배열
arr : | a | b | c | d |
사용자는 배열의 시작주소(arr = &arr[0])만 보관하고 있으면 된다.

// 링크드 리스트
a -- b -- c -- d
사용자는 첫번째 노드(a)의 위치만 보관하고 있으면 된다.

배열은 차례대로 위치한 공간에 a,b,c,d를 포함하고 있다.
반면에 링크드 리스트는 a,b,c,d를 담은 공간이 차례대로 위치하지는 않는다.
그 대신에 a는 b와 연결되고, b는 c와 연결되고, c는 d와 연결되는 방식으로 전체 아이템들을 보관한다.
이름처럼 연결된 리스트이다.

위의 배열과 링크드 리스트를 보면
먼저 배열의 경우 c에 접근을 하기 위해서는 *(arr+2)와 같이 한번에 접근이 가능하다.
하지만 링크드 리스트는 c가 있는 곳까지 가려면 a,b를 거쳐야 한다.

이렇게 구성된 상태에서 사용자가 배열과 링크드리스트를 사용하는 시나리오를 생각해보자.
먼저 배열은 각 원소들이 차례대로 줄지어서 위치하기 때문에 이렇게 단순한 덧셈을 통해 원소에 접근이 가능하다.
하지만 링크드리스트는 배열처럼 차례대로 위치한것이 아니기 때문에 첫번째 노드부터 하나씩
밟아가면서 c를 보관한 곳을 찾아가야 한다. 
구체적으로 말하면 일단 첫번째노드(a)에 접근해서 두번째 노드(b)의 위치를 알아내고, 다시 두번째 노드(b)에 접근한뒤
다음엔 세번째 노드(c)의 위치를 알아낼 수 있다. 결국 c를 보관한 노드에 접근할수 있게되는 식이다.

하지만 여기까지만 보았을때는 배열이 훨신 좋다
어떤 원소에 접근하려고 할때 배열은 덧셈 한번만 하면 끝나지만, 링크드리스트는 첫번째 노드부터 원하는 노드에 이르기까지
모든 노드를 한번씩 거쳐야 하기 때문이다.

하지만 링크드리스트의 진정한 강점은 노드의 삽입과 삭제가 훨씬 간단하다는 점이다.
우선 배열과 링크드리스트에 e를 보관할 새로운 공간을 추가하는 시나리오를 생각해보자
이는 두가지로 나누어 볼수 있는데 배열이나 링크드 리스트의 중간에 삽입하는 경우와 끝에 삽입하는 경우가 있다.

※원소와 노드
- 배열에서 a,b,c,d를 보관하는 공간을 원소(Elements)라고 부른다.
비슷하게 링크드 리스트에서 a,b,c,d를 보관하는 공간을 노드(Nodes)라고 부른다.

// 배열
arr : | a | b | c | d | e
배열이 원소 5개를 보관할 수 있을만큼 크게 정의됐다는 가정하에서 끝에 e를 추가할수있다.

// 링크드 리스트
a -- b -- c -- d
e를 보관할 노드를 만들어서 d의 노드와 연결시키면 된다.

배열의 끝에 e를 포함하는 원소를 추가하려면 처음 배열을 만들 때부터 충분한 크기의 공간을 만들어야 한다.
만약 원소 4개짜리 배열이었다면 실행중에 새로운 원소를 추가하는 것은 불가능하다.

하지만 링크드리스트이 경우에는 e를 포함하는 새로운 노드를 만들고, 마지막 노드와 새로운 노드를 연결시켜주면 끝난다.

이번에는 배열이나 링크드 리스트 중간에 새로운 정보를 삽입하는 시나리오를 보자
우선 배열의 경우 e라는 값을 a와 b사이에 삽입하려면 b~d까지의 원소를 뒤로 한칸씩 밀어내야 한다.
그다음에 기존에 b가 있던 위치를 e에 넣으면 된다. 만약 10000개쯤있는 배열이라면 9999개의 원소를 밀어내야한다.
반면 링크드리스트는 a와 b의 연결을 끊은 후에 a와 e, e와 b를 연결시키면 간단하게 끝난다.
그 뒤에 9999개의 노드가 있더라도 똑같다.

이런식으로 비교를 해봤을때 삽입삭제 면에서는 링크드리스트가 훨씬 압승이라는 점을 느꼈을 것이다.
[출처] [링크드리스트]링크드리스트와 배열의 비교|작성자 범수


예제 : linked.cc #include <iostream>
#include <string>
#include <iterator>

using namespace std;

template <typename T>
class List
{
    private:
        // 노드갯수
        int         node_num;
        // NODE데이타를 저장할 구조체 
        struct Node
        {
            T    Data;
            Node *NextNode;
        };
        Node *mNode;  // 노드 할당을 위해서 사용한다. 
        Node *SNode;  // 시작노드를 포인트한다.
        Node *NNode;  // 다음노드를 포인트한다.  
        Node *ENode;  // 마지막노드를 포인트한다.

    public:
        // 생성자
        List()
        {
            node_num = 0;
        };

        // 삽입관련 메서드 ------------------------

        // 가장뒤에 노드를 추가한다. 
        // 마지막 노드 정보를 가지고 있음으로 
        // 새로운 노드를 할당하고 기존의 마지막노드가 
        // NULL대신 새로할당된 노드를 가리키게 하면 된다. 
        void push_back(T data)
        {
            mNode = new Node;
            mNode->Data     = data;
            mNode->NextNode = NULL;

            if (node_num == 0)
            {
                SNode = mNode;
                ENode = mNode;
            }
            else
            {
                ENode->NextNode = mNode;
                ENode = mNode;
            }
            node_num++;
        };

        // 가장앞에 노드를 추가한다. 
        // 만약 처음으로 노드가 추가되는거라면 
        // 이 노드는 다음노드로 NULL을 가리키게 된다. 
        // 그렇지 않을경우 기존에 가장 처음에 있던 노드를 
        // 가리키게 된다. 
        void push_front(T data)
        {
            mNode = new Node;
            mNode->Data     = data;
            mNode->NextNode = NULL;
            if (node_num == 0)
            {
                SNode =  mNode;
            }
            else
            {
                mNode->NextNode = SNode;
                SNode =  mNode;
            }
            node_num++;
        };

        // 임의의 위치에 노드를 삽입한다.  
        int insert(T data, int position)
        {
            Node *PNode;
            int i = 0;
            if (position > node_num)
            {
                return -1;
            }

            // 처음과 마지막 위치에 
            // 삽입할때는 이미 만들어진 메서드를
            // 활용한다.
            if (position == 0)
            {
                push_front(data);
                return 1;
            }
            if (position == node_num)
            {
                push_back(data);
                return 1;
            }

            mNode = new Node;
            mNode->Data     = data;
            mNode->NextNode = NULL;

            NNode = SNode;
            while(NNode)
            {
                if (i == position)
                {
                    mNode->NextNode = NNode;
                    PNode->NextNode = mNode;
                    node_num++;
                    break;
                }
                PNode = NNode;
                NNode = NNode->NextNode;
                i++;
            }
            return 1;
        }


        // 삭제 관련 메서드 -------------------------
        // 가장앞에 있는 노드를 삭제
        void pop_front()
        {
            NNode = SNode->NextNode;
            delete SNode;
            SNode = NNode;
            node_num--;
        }

        // 가장뒤에 있는 노드를 삭제
        // 싱글 링크드 리스트라서 가장뒤에 있는 노드를 
        // 지울경우 어쩔수 없이 처음부터 노드를 검색하는 수 
        // 밖에 없다. 
        // 더블링크드 리스트라면 좀더 쉽게 삭제 가능할것이다.  
        void pop_back()
        {
            int i = 0;
            Node *PNode;
            NNode = SNode;

            while(1)
            {
                if(i == node_num - 1)
                {
                    PNode->NextNode = NULL;
                    delete(NNode);
                    break;
                }
                PNode = NNode;
                NNode = NNode->NextNode;
                i++;
            }
            node_num--; 
        }


        // 값 가져오기 메서드 -----------------------

        // 가장앞의 노드에서 데이타를 가져온다.
        T front()
        {
            return SNode->Data; 
        }

        // 가장뒤의 노드에서 데이타를 가져온다.
        T back()
        {
            return ENode->Data;
        }

        // 노드를 순환하면서 모든 데이타를 출력한다.
        void show()
        {
            NNode = SNode;

            while(NNode)
            {
                cout << NNode->Data << endl;
                NNode = NNode->NextNode;
            }
        }

        // 임의의 위치에 있는 노드의 데이타를 
        // 가져온다.  
        // 이 메서드는 비효율적이고 깔끔하지 못하다. 
        // 바꿔보자. 
        T get(int num)
        {
            int i = 0;
            if (num > node_num)
            {
                return NULL;
            }
            NNode = SNode;
            while(i < num)
            {
                NNode = NNode->NextNode;
                i++;
            }
            return NNode->Data;
        }

        // 부가 메서드 ----------------------------- 
        int size()
        {
            return node_num;
        }
};

int main()
{
    List<string> list;

    // 테스트
    list.push_back("A");
    list.push_back("B");
    list.push_back("C");
    list.push_front("D");
    list.insert("100", 1);
    list.push_front("101");

    cout << "Size " << list.size() << endl;
    cout << "First Data is " << list.front() << endl;
    cout << "Last Data is " << list.back() << endl;
    list.show();

    list.pop_front();
    list.show();

    list.pop_back();
    list.show();

    cout <<"GET DATA" << list.size() << endl;
    for (int i =0; i < list.size(); i++)
    {
        cout << list.get(i) << endl;
    }
}
[출처] 링크드 리스트|작성자 맥스


	13-1) 링크드 리스트 예제
linked_list.c #include <unistd.h>
#include <string.h>

typedef struct
{
    char name[12];
    struct list_item *next_link;
} list_item;

list_item * add_item(list_item *, char *);
list_item * remobe_item(list_item *);
void print_list(list_item *item);

int main()
{
    list_item *list;

    list = NULL;

    list = add_item(list, "yundream");
    list = add_item(list, "kknd2");
    list = add_item(list, "hohoho");
    list = add_item(list, "loveisall");
    print_list(list);

    printf("\n");
    list = remove_item(list);
    print_list(list);
}

list_item * add_item(list_item *item, char *name)
{
    list_item *lp = item;

    // 기존에 Item 이 있을경우 
    // 가장 최근의 Item의 next_link 가 추가 되는 Item 의 
    // 주소를 가리키도록 포인터를 조정한다.  
    if (item != NULL)
    {
        while(item->next_link != NULL)
            item = item->next_link;

        item->next_link = (struct list_item *)malloc(sizeof(list_item));
        item = item->next_link;
        strcpy(item->name, name);
        return lp;
    }
    // 처음 Item 추가시에는 가리킬 데이타가 없음으로 
    // next_link 는 NULL 이 된다.  
    else
    {
        item = (struct list_item *)malloc(sizeof(list_item));
        item->next_link = NULL;
        strcpy(item->name, name);
        return item;
    }
}

list_item * remove_item(list_item *item)
{
    list_item *tmp;
    printf("Element remove is %s\n", item->name);
    // 첫번째 링크가 가리키는 다음 데이타  
    // 즉 두번째 데이타의 정보를 tmp 에 대입하고 
    // 첫번째 데이타를 free 시켜줌으로 
    // 링크드 리스트에서 제거시킨다. 
    tmp = item->next_link;
    free(item);
    return tmp;
}

void print_list(list_item *item)
{
    if (item == NULL)
        printf("NONE LIST\n");

    // Item 의 처음부터 끝까지 순차적으로 
    // 검색하면서 데이타를 출력시킨다. 
    else
        while(item != NULL)
        {
            printf("%10s : %x %x\n",
                            item->name,
                            item,
                            item->next_link);
            item = item->next_link;
        }
}
			 


다음은 필자의 컴퓨터에서 실행시킨 결과다. 번호는 설명을 위해서 붙인것이다. [root@localhost test]# ./linked_list 
  yundream : 80498a0 80498b8 --- 1
     kknd2 : 80498b8 80498d0 --- 2
    hohoho : 80498d0 80498e8 --- 3
 loveisall : 80498e8 0       --- 4

Element remove is yundream
     kknd2 : 80498b8 80498d0
    hohoho : 80498d0 80498e8
 loveisall : 80498e8 0
			 
2개의 주소값이 출력되는데, 첫번째 주소값은 자신의 주소값이고 2번째 주소값은 다음 가리키는 데이타의 주소값이다. 
보면 1 -> 2 -> 3 -> 4 의 식으로 데이타를 가리키고 있음을 알수 있다.


	14) this 
this 는 자기 자신을 가리키는 포인터 입니다.
this 는 클래스 내부에서 자기자신의 멤버 변수나 멤버 함수에 접근하기 위해서 사용됩니다.
예를들어 int abc 가 멤버 변수라면 this.abc 로 접근할 수 있겠죠. 
그런데 클래스 내부에서는 그냥 abc 로 접근하나 this.abc 로 접근하나 똑같습니다.
실제로 this 를 써서 접근하지 않아도 컴파일러가 알아서 this 를 붙여주기 때문이죠.
그렇다면 this를 쓸 필요가 전혀 없을 것 같지만, 명시적으로 써줘야 할 때가 있습니다.
바로 함수내의 지역변수 때문인데요.

예를들어 멤버 변수에 int abc 가 선언되어 있다고 가정하고 다음 함수를 보면
void testFunction(int abc)
{
       abc = abc;           // 멤버변수 abc 에 지역변수 abc 값을 할당하려고 함
}
위와 같은 경우에 컴파일러는 abc 를 우선적으로 지역변수로 생각합니다.
프로그래머의 의도는 지역변수 abc의 값을 멤버변수 abc 에 할당하려고 하는건데
컴파일러가 같은 이름의 변수가 있으면, 지역변수라고 생각해버리기 때문에
의도대로 멤버변수에 할당할 수가 없게되죠.

즉, 위 코드는 지역변수abc 에 지역변수abc 를 할당하는 꼴이 되버립니다.

이럴 때 this 를 써서
this.abc = abc;
라고 표현하면 this.abc 는 멤버변수라는 것을 컴파일러가 알아차릴 수 있어서
의도대로 멤버변수abc 에 지역변수abc 값을 할당할 수 있겠죠.
위와 같이 this는 명시적으로 this 가 필요한 경우가 있을 때 사용하게 됩��다.


	14-1) this 상세설명
class test
{
    int first;
    int second;
};
두개의 int형 맴버변수를 가집니다.

test p1;
test p2;
그리고 위와같이 두개의 인스턴스를 만들었습니다.

이렇게 하��을��에�� test클레스 두개의 공간만큼 메모리에 로드가 되면서, 각각의 공간은 
p1, p2라는 "변수이름" 으로 연결된 상태라고 볼수있습니다.

이 경우에는 this포인터의 연결에 상관없이, 
p1.first 와 p2.first 는 "변수이름" 으로써 분명하게 구분됩니다.
너무나도 당연한 말입니다.

하지만 test 클레스에 함수가 추가되었다고 가정해보겠습니다.
간단하게 값을 변경하는

void test::change(int a, int b)
{
    first = a;
    second = b;
}
위와같은 형태라고 보겠습니다.

첫부분에서 말한바를 다시한번 생각하여 보시기 바랍니다. 
static 키워드로 연결되어 있는 변수처럼, 
test클레스에 대하여
아무리 많은 인스턴스들이 만들어 진다하여도
위의 test::change() 함수는 한번만 뿌려지게 됩니다.
다시한번 정리해서 말하면

test p1;
test p2;
와 같은 코드가 있을때, p1, p2라는 이름만으로도 충분히 first, second 의 맴버변수에 접근 가능합니다. 
하지만, 위의 p1, p2가 test::change() 맴버 함수에 접근하는 방법은 조금 다르죠.
그것은, change 함수가 뿌려져 ��는 하나의 공간에 대해서 여러 다른 인스턴스들이 ".change()" 라는 인터페이스를 통하여 
계속적으로 접근하는 하는꼴로써 나타납니다.

그렇다면 접근하는 기준은 변수 이름일까요??
아닙니다.

정답은 p1, p2가 같은 test 형식이기 때문에 찾아갈수가 있는것이지요 
test클레스에서 만들어지는 모든 인스턴스들은 test::change()에 대해서 접근할수있는 함수 첫머리 주소를 가지게 됩니다. 

여기까지 이해가 되시는지요??
그렇다면 다왔습니다.

지금 test::change() 함수에서는 맴버 변수의 값을 수정하고있습니다.
아래와 같이 p1 인스턴스가 test::change() 함수를 호출했고 보겠습니다.

p1.change(2,3);

분명한것은, test::change()함수는 p1인스턴스와, 메모리적으로 봤을때는 어떠한 연속적인 관련도 없습니다.
이말이 좀 어렵나요?? 위에서 한말 그대로입니다. 
만약 함수가 연속적으로 관련이 있어서 인스턴스마다 하나하나 다 붙어 있다면, 
이 함수가 과연 뭘 수정하면 되나요??

당연히 자기 인스턴스를 수정하면 되겠지요.
하지만, 간단한 말로 함수는 한개. 인스턴스는 무한입니다.
생성되어있는 수많은 인스턴스중에 하나가 test::change() 함수를 부르고~
그것이 바로위의 p1.change(2,3); 정도 되겠네요

여기서 void test::change(int, int) 의 함수body를 다시 한번 보겠습니다.
body 어디에서도 특정한 인스턴스를 지정해주는 코드는 없습니다.

단지 
first = a; 
second = b;
라는 말밖에 없죠.

그렇다면 이 함수는 무엇을 수정하나요??
제가 이 함수를 부르면서 
p1.change(2,3); 이라고 했으니 당연히 p1인스턴스의 값이 바뀌기를 바랬을것입니다 
그럼 인스턴스들중 아무거나 잡아서 수정하면되나요??
당연히 안되죠...그리고 결과적으로도 p1이 수정됩니다.
어떻게 이것이 가능할까요??

내부적으로 this 포인터가 전달이 되기때문에 그것이 가능해집니다.
this는 인스턴스 자신을 가리키는 포인터죠
그럼 숨겨진 코드를 모두 적어보겠습니다.
(단, 이것은 내부적으로 구현이 되어있는방식이기때문에 실제로 
이렇게 적어버리면 컴파일 에러가 발생하게 됩니다~)

void test::change(test* this, int a, int b)
{
 this->first = a;
 this->second = b;
}
클레스 내부의 모든 함수는 0번째 전달인자를 내부적으로 가지며
그 전달인자는 위와같이 해당 클레스형의 this 포인터입니다.

this 포인터를 이해하려면 먼저 변수와 함수가 어디에 어떤방식으로 뿌려지는가를 먼저 알면
이해하기가 한결 수월하지요~

그리고 함수가 불려지는 방식을 알게되면 함수 포인터 부분을 이해하는것에도 많은 도움이 될것이라고 생각합니다.


	15) 비트 구조체
비트 구조체는 비트들을 멤버로 가지는 구조체이며 비트 필드라고도 부른다. (bit field)
멤버가 가질 수 있는 값의 범위가 아주 작다면 32비트의 int나 8비트의 char보다 더 작은 단위로 비트를 쪼개 알뜰하게(?) 정보를 기
억시킬 수 있는데 이때 사용하는 것이 비트 구조체이다.

기본형식 :
struct example {
  타입 멤버1: 비트수;
  타입 멤버2: 비트수;
  타입 멤버3: 비트수;
}

각 멤버 이름 다음에 이 멤버의 비트 크기를 적는다. 멤버의 타입은 원칙적으로 정수만 가능하며 부호의 여부에 따라 unsigned int 
또는 signed int 둘 중 하나의 타입을 지정한다. 일반적으로 unsigned 타입을 주로 사용

c언어 스팩에는 비트 멤버의 타입은 int or unsigned 중 하나임
c++ ---> short, long, char 등 정수와 호환되는 모든 타입 허용

ex1)
#include <stdio.h>
#include <stdlib.h>

struct tag_bit {
  unsigned short a: 4;  >>> 4 bit
  unsigned short b: 3;  >>> 3 bit
  unsigned short c: 1;  >>> 1 bit
  unsigned short d: 8;  >>> 8 bit
}

int main(int argc, char** argv[])
{
  tag_bit bit;
  bit.a = 0xf;
  bit.b = 0;
  bit.c = 1;
  bit.d = 0xff;

  printf("크기 = %d, 값 = %x \n", sizeof(bit), bit);

  return 1;
}
[출처] [c]비트 구조체 (프로감각) |작성자 프로감각


ex2)
#include <stdio.h>
typedef union {
 char ch;
 struct  {
  int Low:4;
  unsigned int High:4;
 }BIT;
} uni;

void main()
{
 uni u;

 u.ch=0x98;
 printf("%d %d",u.BIT.Low, u.BIT.High);
}

위 처럼 작성하시면 작동할 겁니다.
union은 공용체라 불리며 struct 처럼 변수들이 별개의 공간을 가지는 것이 아니고
각각의 항목이 동일한 공간을 소유 한다고 보시면 되겠습니다.

ch에 0x98을 대입하게 되면
BIT struct 또한 0x98이 대입되게 되는데요

int Low:4;
unsigned int High:4;
Low와 High에 4bit씩 나눠서 대입이 되게 되는 겁니다.
Low에 0x8 High에 0x9이 대입되겠습니다.

결과는
-8 9 이렇게 출력됩니다.


	16)	절대값
		절대값은 상당히 조심해서 다뤄야 한다. 섣불리 사용하면 전혀 다른 값으로 계산될 수 있다
		하기, ex1), ex2) 참조할 것
		
abs
int 값의 절대값을 알려주는 함수이다.
int abs( int n );
// n의 값에서 절대값을 리턴한다.
ex>
#include <stdlib.h> or <math.h>
int    ix = -4, iy;
iy = abs( ix );  // -4의 절대값인 4를 리턴한다.

labs
long 값의 절대값을 알려주는 함수이다.
long labs( long n );
// n의 값에서 절대값을 리턴한다.
ex>
#include <stdlib.h> or <math.h>
long   lx = -41567L, ly;
ly = labs( lx );  // -41567의 절대값인 41567를 리턴한다.
[출처] [C]Data Conversion (abs, labs, fabs, atoi, atof, atol, _itoa, _ltoa, _ultoa, _ecvt, _fcvt, _gcvt, strtol, strtoul, strtod)|작성자 제우스

	ex1)
	unsigned long iTemp1, iTemp2;
	CString str;

	iTemp1 = 0x0fffffff;
	iTemp2 = (unsigned long)labs((unsigned long)iTemp1);

	str.Format(L"iTemp1 = %x(%ld), iTemp2 = %x(%ld)", iTemp1, iTemp1, iTemp2, iTemp2);

	AfxMessageBox(str);		// iTemp1 = fffffff(268435455), iTemp2 = fffffff(268435455)

	ex2)
	unsigned long iTemp1, iTemp2;
	CString str;

	iTemp1 = 0xf0000001;
	iTemp2 = (unsigned long)labs((unsigned long)iTemp1);

	str.Format(L"iTemp1 = %x(%ld), iTemp2 = %x(%ld)", iTemp1, iTemp1, iTemp2, iTemp2);

	AfxMessageBox(str);		// iTemp1 = f0000001(-268435455), iTemp2 = fffffff(268435455)


	17) #define 의 활용
		가) #define을 잘 활용하면 하기와 같이 구조체등을 사용하지 않고 간단하게 여러 인수를 함수에 전달할 수 있음
			#define OEM_ADC_EN		MP4_GPIO_K, 13, 1
			MP4_WriteGPIOBit(OEM_ADC_EN);		// void MP4_WriteGPIOBit ( MP4_GPIO Port, int BitNumber, int Value ); // Value (0 or 1)




[3] NIC card
	cf)	elev_homeinfo.dat file은 NIC card Flash에 저장? -> 맞다

	cf)	telnet 상으로 NIC card Flash files 수정, compile 할 수 있는지? -> 할 수 있다

 	cf)	Flash files 수정
   하기, 가),나),다)만 실행하면 NoteBook에 있는 elev_homeinfo.dat가 NIC card로 복사됨

   또한, 이런 과정으로 program source file을 update 시킬 수 있음
   하지만 여기서 program source란 main.c등의 파일이 아닌 make로 compile된 실행 파일을 뜻함(ex. convertor)
   main.c 파일만 변경시킨다고 변경된 동작을 하지 않음.

   1) NoteBook을 HUB에 연결하고 NIC card 상의 elev_homeinfo.dat file 지우고
   2) xterm 에서 cp elev_homeinfo.dat /tftproot/
   3) Putty 에서 
       #tftp 192.168.201.220				-> 220(Notebook ip)
       tftp> get elev_homeinfo.dat
       tftp> quit

    cf) NIC monitoring 과정 (Putty로)
       1) 192.168.201.110					-> 110(NIC ip), Notebook에서 Putty로 NIC card에 연결
       2) login : root, psssword : 없음
       3) #ps
       4) #kill 119							-> ./convertor 중에서 최상위 program 번호
       											최상위 ./convertor만 죽이면 나머지 thread들도 모두 죽음
       											이렇게 하는 이유는 Putty를 실행하기 전에도 NIC card에서 ./convertor 는 자동 실행되고 있었으므로
       											Putty에서 monitoring을 하기 위해 어쩔 수 없이 이미 실행되고 있던 ./convertor를죽여버리고(kill명령)
       											Putty에서 ./convertor를 실행시켜서 Putty에서 NIC monitoring이 실행되도록 함
       5) #./convertor						-> ./convertor 를 실행한는 명령 (simtemp/convert directory에 있음)
       											convertor 앞에 ./ 가 붙는 이유
												convertor 는 해당 디렉토리에 들어 있는 실행 화일입니다. 
												. (점, point)는 현재 디렉토리를 의미합니다. 
												( .. 은 상위 디렉토리를 의미합니다.)
												현재 디렉토리에 화일을 실행시킨다는 의미로 ./convertor 라고 명령을 줍니다.
												./ 없이 convertor만 하면 실행이 되지 않습니다. (경로 설정이 되어 있지 않기 때문)
       6) 본, ./convertor 명령이 실행되고 있는 상태에서 ctrl + C 누르면 ./convertor가 kill됨
       7) 상기 monitoring을 모두 끝냈으면 Putty를 닫고 NIC card를 reset 시켜줌
   
    cf) vi
       vi 명령으로 telnet상에서 file을 edit
       1) vi에서 저장 없이 빠져 나올려면 :q!
       2) :wq는 저장 명령
       3) i는 insert(편집모드)				-> :i 가 아니라 그냥 i를 치면 됨
       4) x는 지움, shift+Del 지움
       5) dd는 커서가 있는 라인 삭제
       6) esc는 편집모드에서 빠져나감
       0 : 행의 처음으로 이동
       $ : 행의 마지막으로 이동

    cf) 기타
       1) telnet에서 빠져 나가려면 #exit를 누름
       2) 주장치 하이퍼터미널에서 엘리베이터 수동 연동 프로그램 실행할려면 ctrl + t
       3) convertor file 만드는 방법, 해당 directory에 가서
          가) make clean
          나) make
       4) 해운대 하이페리온 오피스텔 B동 11호기 : 비상 Elevator
          해운대 하이페리온은 Elevator Group에 Master 개념이 있어서 A동은 1호기, B동은 5호기가 master이고정
          반드시, 본 호기에다가 call 명령을 줘야지만 Elevator call 명령이 제대로 실행됨.
       5) 특정 이름의 파일 찾기 											-> find . -name find.txt (find / -name find.txt)		cf)	sub directory 까지 찾아줌
       																		-> find . -name "file*"	(파일이름이 file로 시작되는 모든 파일 찾기)
       6) 전체 파일에서 특정 단어가 포함된 파일 찾기(하위 디렉토리 포함)	-> find . -type f | xargs grep "string"			->	"*string*"로 찾는 것과 동일한 결과 나옮
       7) 전체 파일에서 특정 단어가 포함된 파일 찾기(하위 디렉토리 포함)(대소문자구분없음)
       																		-> find . -type f | xargs grep -i "string"		->	"*string*"로 찾는 것과 동일한 결과 나옮
       8) 특정 파일에서 특정 단어가 포함된 파일 찾기						-> find -name "*.h" -type f | xargs grep "string"
       9) grep만 이용하는 방법
			리눅스에서 파일 내에 있는 특정 문자열을 검색할 때 쓰는 grep에 옵션을 더하면 현재 위치에서 하위 디렉토리에 있는 파일들까지 검색을 수행할 수 있다. Ubuntu에서는 grep가 하위 폴더 검색까지 지원하기 때문에 아래와 같이 간단하게 해결할 수 있다.
			$ grep -rn "찾고자 하는 문자열" *
				-r 옵션은 하위 디렉토리에 있는 파일까지 검색하겠다는 것이고,
				-n 옵션은 라인 번호를 보여주는 것이다.
				그리고 검색하는 문자열에 공백이 있다면 앞뒤에 따옴표가 반드시 있어야 한다.
			ex)	# dmesg | grep gpio			->	dmesg 출력 메시지 중에서 "gpio" 문구가 포함된 메시지만 출력 됨
       10)Notebook booting 방법
          가) HDD로 booting
          나) login : root , password : digitech_notebook

    cf) Linux 명령어
   	   - directory name을 쓰는 경우, 앞 몇자리 철자만 쓴후 TAB을 누르면 자동으로
   	     directory name이 완성된다.
   	   DOS				Linux
   	   cd				cd
   	   copy				cp -a						-> -a(가능한 원 파일의 구조와 속성을 그대로 복사, sub directory도 같이 복사)
   	   del				rm
   	   deltree			rm -r -f					-> -r(하위디렉토리) -f(물어보지 않고 강제삭제)
   	   dir				ls		ls -a -l | more		-> -a(숨어있는파일), cf) -l : 파일구조파악
   	   					ls | grep test				-> test가 들어가는 파일들만 표시(cf, *test*)
   	   dir file /s		find . -name "file*"		-> 파일이름이 file로 시작되는 모든 파일 찾기
   	   edit				vi
   	   help				man, info					-> ex) man ps, info ps
   	   md				mkdir
   	   move				mv
   	   rd				rmdir
   	   ren				mv
   	   					clear						-> 출력내용 clear
   	   					passwd
   	   					pwd							-> remote시스템의 현재 작업디렉토리를 표시
   	   					echo						-> Display 용도, ex) $ echo "The RedHat !"
   	   					cat							-> 텍스트로 작성된 파일을 화면에 출력
   	   					|							-> pipe, 왼쪽 명령의 실행 결과를 오른쪽 명령의 입력으로 연결
   	   					shutdown -h now				-> 시스템 종료, shutdown -h +10(10분 후 시스템 shutdown 후 시스템 종료), shutdown -r 13:00(13시에 시스템 shutdown 후 시스템 재시작)
   	   					su							-> 사용자 중 다른 ID로 재접속하는 명령어, su 사용자ID, 그냥 su만 입력하면 root로 재접속하겠다는 뜻(supervisor mode로 변경($->#))
   	   					sudo						-> user mode에서 supervisor mode 명령 실행하기 위해서 명령 앞에 선언하는 명령(ex, $sudo shutdown)
   	   					useradd [계정]				-> 사용자 계정 추가
   	   					passwd [계정]				-> 사용자 계정 비밀번호 변경, cf) sudo passwd root 로 root 비밀번호 변경
   	   					userdel [계정]				-> 사용자 계정 삭제
   	   					ln -s /source_directory dest_directory	->	심볼릭 링크, source_directory 가 연결된 dest_directory가 현재 디렉터리에 생성
   	   					readelf -h hello			-> x86 용으로 컴파일 한 것인지 ARM 용으로 컴파일 한 것인지 확인할 수 있는 명령어
   	   					dmesg | more				-> 처음 리눅스가 부팅 될 때 처리 작업을 보여줌, 스페이스를 누르면 다음페이지, 엔터를 누르면 한줄씩, 그만 보고 싶으면 Q키를 누르면 된다.
   	   					dmesg | grep usb			-> usb 관련된 내용 만 출력
   	   					make mrproper    			-> 실질적으로 안해도 상관없는 단계이다. 이전에 설정되어있는 모든옵션을 초기화 시키는 단계이다.
						make config | menuconfig | xconfig -> 커널의 옵션을 설정하는 단계이다. config과 meunuconfig는 터미널상에서 실행가능 xconfig는 x윈도우에서 실행가능
							config은 시스템과 상호대화식이지만 수정 불가 수정할려면 처음부터 다시
							menu는 메노보고 해서 수정가능
						make dep    				-> 커널옵션을 선택하고 커널의 의존성을 검사하는 단계 예비 컴파일을 해본다.
						make clean					-> 예비 컴파일 한후 목적파일들을 다시 소거한다.
						make bzImage | zImage		-> 커널빌드단계
							bzImage, 압축커널
							ZImage,  비압축커널
							hzImage    LiLo
						make modules				-> 커널자체에 부여 되지 않는 기능을 외부 모듈로서 만든형태이다.
							/lib/modules/커널버전 설치한다.
						make modules_install   :
						make dist					-> 배포소스를 만드는데 사용합니다, 마지막으로 이를 패키지로 꾸리기 위해 make dist를 사용할 수 있습니다. 패키지에 필요한 파일들을 모두 tar.gz으로 꾸려 줍니다.
						depmod						-> 커널새로 만들었으면 모듈도 새로 생성이 되었다.이런 새로 생성된커널에 대해서 의존성을 만들어준다.
						커널복사/ 초기화이미지 생성/ 맵파일 생성/로더갱신

						insmod 모듈명				->	디바이스 드라이버 모듈 추가(insert module) insmod가 실행되면 이 바이너리 파일이(ex, dummy_driver.ko)
														커널 메모리 영역에 복사되고, 모듈을 초기화하는 함수(ex, dummy_init)가 수행됩니다.
						lsmod 모듈명				->	추가된 모듈 출력
						modprobe 모듈 띠우기
						rmmod 모듈명				->	모듈삭제
						mknod 디바이스 드라이버		->	디바이스 파일 생성
														일단 응용 프로그램은 이러한 드라이버를 인식할 수 없습니다.
														응용 프로그램은 파일이라는 개념으로 접근하기 때문에 응용 프로그램이 인식할 수
														있는 장치 파일로 만들어 주어야 됩니다. 본 명령어가 장치 파일로 만들어 주는 명령어 입니다.
						grep 찾고자하는문자열		->	찾고자하는문자열이 포함된 메시지만 출력
														ex)	# dmesg | grep gpio	->	dmesg 출력 메시지 중에서 "gpio" 문구가 포함된 메시지만 출력 됨
						top							->	CPU Core 별 load(%) 현황을 보여준다고 함
														ex)	# busybox top
															# 1			->	누르면 CPU Core별 사용량 표시
																			1.	SelexOn2 카메라 Capture + 측정값 연산 동작시 최대 70%까지 CPU 사용량이 올라가지만
																				카메라 Capture동작이 가장 많은 시간을 소요하며 이때는 CPU 사용량이 15%이내이며
																				70%까지 CPU 사용량이 올라갈 때는 카메라 Capture 후 측정값 연산 도중임
																			2.	QR(2D) CODE 동작 시 CPU 총 사용량은 86.2%임(CPU0:  5.5% usr  3.7% sys + CPU1: 38.4% usr  1.1% sys + CPU2:  7.3% usr  1.1% sys + CPU3: 26.4% usr  2.7% sys)
																			3.	OpenCV -> canny 명령 동작 시 CPU 총 사용량은 141.7%임(CPU0: 39.3% usr  8.1% sys + CPU1: 15.3% usr  4.1% sys + CPU2: 34.8% usr  7.1% sys + CPU3: 25.9% usr  7.1% sys)
															# q			->	빠져나가기					
						
						*	Kernel 변경(Beagle Board)
						1.	~$vi .bashrc			->	아래와 같이 변경
							#export PATH=$PATH:~/bin:/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin
							export PATH=$PATH:~/bin:/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin:/usr/local/arm-2009q3/bin
							
							cf)	/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin	->	안드로이드용gcc
								/usr/local/arm-2009q3/bin													->	리눅스용gcc(본, 폴더 안에 arm-none-linux-gnueabi-gcc gcc가 들어가 있음)
						2-1.source ~/.bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령
						2.	cd /home/krh/rowboat-android/kernel
						3.	make ARCH=arm CROSS_COMPILE=arm-eabi- distclean
						4.	make ARCH=arm CROSS_COMPILE=arm-eabi- omap3_beagle_android_defconfig
						5.	make ARCH=arm CROSS_COMPILE=arm-eabi- menuconfig		->	kernel 설정 수정 후 저장(cf, 본 make ARCH=arm CROSS_COMPILE=arm-eabi- menuconfig 실행 후 make ARCH=arm CROSS_COMPILE=arm-eabi- uImage
																						명령 실행해도 kernel 변경 사항이 적용 됨)
						6.	make ARCH=arm CROSS_COMPILE=arm-eabi- uImage			->	이 명령을 통해서 컴파일 및 빌드가 성공적으로 완료가 되면, 커널 이미지는 kernel/arch/arm/boot 디렉토리에 생성이 됩니다.
																					->	간단한 *.c 파일 소스 수정의 경우 본, make ARCH=arm CROSS_COMPILE=arm-eabi- uImage 명령만 실행해도 변경 사항이 uImage 파일에 적용되며
																						본, 파일만 SD-Memory에 복사 시키면 변경된 kernel 사항이 적용 됨
																					->	uImage는 uBoot에서 사용하는 압축된 커널 이미지로 arch/arm/boot/에 있다.
						*	Kernel 변경(iMX6 Board)
						# Boot image for SABRE-SD board
						$ cd ~/myandroid
						$ source build/envsetup.sh
						$ lunch sabresd_6dq-user
						$ make bootimage			->	boot.img 이미지 내부에 kernel image도 포함되어 있으며
														본, 명령을 실행하면 X:\root\myandroid\out\target\product\sabresd_6dq\ 폴더 내부의 boot.img & uImage 이미지를 rebuild 시킴
														cf)	본 명령을 사용하면 kernel image가 make menuconfig 명령으로 설정을 변경해도 default 구성으로 다시 복구되어서 build되며
															이렇게 되는 이유는 build 시 하기 설정파일을 찾아서 build 하기 때문 임(cf, make menuconfig을 실행하려면 아래 export ARCH=arm등의 명령을 실행한 다음 실행해야 함)
															TARGET_KERNEL_DEFCONF = /root/myandroid/kernel_imx/arch/arm/configs/imx6_android_defconfig
															->	해결방법
																make menuconfig으로 변경한 kernel 설정을 default 설정으로 변경
																cp /root/myandroid/kernel_imx/.config /root/myandroid/kernel_imx/arch/arm/imx6_android_defconfig

						cf)	아래 명령은 uImage만 rebuild 시키는 명령 임
						따라서, TFTP에서 사용할 uImage만 rebuild 시키는 것으로 Images for SABRE-SD SD 에서 필요로 하는 boot.img를 만들어 주는 것은 아님
						1-2.~$vi .bashrc			->	아래와 같이 변경
							export PATH=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin:$PATH
						1-1.source ~/.bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령				
						1.	$ export PATH=~/myandroid/bootable/bootloader/uboot-imx/tools:$PATH
						2.	$ cd ~/myandroid/kernel_imx
						3.	$ echo $ARCH && echo $CROSS_COMPILE
						Make sure you have those two environment variables set. If the two variables are not set, set them as:
						4.	$ export ARCH=arm
						5.	$ export CROSS_COMPILE=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
						6.	$ make menuconfig										->	cf) default kernel setting -> $ make imx6_android_defconfig
						7.	$ make uImage											->	X:\root\myandroid\kernel_imx\arch\arm\boot\uImage 파일로 kernel image rebuild
					
						lsusb						->	어떤USB가 연결되어 있는지 확인
						dmesg						->	커널의 메시지 버퍼를 출력(cf, 본 명령은 현재까지의 Kernel message 만을 보여주며, cat /proc/kmsg 명령을 실행하면 계속해서 Kernel message를 보여 줌(빠져나오려면 Ctrl+C))
						./test						->	현재 디렉토리 내부의 test 라는 명령을 실행할 경우
						whereis						->	ex) whereis ifconfig -> ifconfig가 있는 path가 나타남
						ln -s original linkfile		->	파일연결(링크걸기)(linkfile은 파일 이름만 있고 내용은 아무것도 없으며 단지 original 파일을 링크할 뿐임)
   	   					ln -s /usr/bin linkbin		->	디렉터리연결(링크걸기)
   	   					fdisk -l					->	리눅스 파티션 알아보기, cf) gparted
   	   					ps							->	현,시행중인 process 정보 보기, ex) ps -ef, -e:모든 프로세스를 보여줍니다., -f:모든 정보를 출력합니다.
   	   													ex) ps -ef | grep nfs	->	nfs 문구를 포함하고 있는 프로세스 보여주기
   	   					service --status-all		->	부팅시, 어떤 서비스가 자동으로 실행되는지 확인할 수 있음
   	   					file test					->	해당 파일 속성을 알 수 있음
	   	   												root@krh-VirtualBox:~/program/arm-none-linux-gnueabi-gcc# file test
														test: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.16, not stripped													
														root@krh-VirtualBox:~/program/arm-linux-gnueabi-gcc# file test
														test: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=4a07c3da3e1901b6876f7e754b6e901ae2debd23, not stripped													
														root@krh-VirtualBox:~/program/Ubuntu-gcc# file test
														test: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=6ed7a61cb132767d1ee320d9e8a0a2aa46a9838e, not stripped
						fsck						->	DOS, CHKDSK 명령과 동일, ex) fsck /dev/sdb1
            sync            ->  리눅스에서 sync의 의미
                            1.  작업대상이 되는 데이터는 전부 시스템 메모리에서 그 작업이 이루어진다. 작업의 대상이 되는 데이터는 메모리에 존재하기 때문에 저장하지 않는한 디스크에 저장되지 않는다. 
                                작업하고 있는 도중에 갑자기 전원이 나가거나 장애로 인하여 시스템이 다운되었다면 작업중이던 메모리의 데이터들은 모두 사라져 버릴 것이다.
                                사용자가 작업중이던 데이터를 메모리에서 디스크로 저장하는 작업을 프로그램이 주기적이면서 자동으로 해주는 것이 바로 자동저장기능이다. 그리고 이런 저장작업을 우리는 데이터 동기화라고 한다.                            
                            2.  데이터 동기화란 경우에 따라서 여러가지 의미가 있는데 여기서는 저장되지 않은 메모리의 데이터를 디스크로 저장하는 작업을 의미한다.                            
                            3.  현재 작업중인 저장되지 않은 메모리의 데이터를 디스크로 저장하는 작업은 시스템관리자가 직접해주어야 한다. 이런 작업을 sync 작업이라고 한다.                            
                            4.  시스템 관리 도중에 한번씩 위와 같이 sync를 실행해주면 아직 저장되지 않은 메모리의 데이터가 디스크로 저장되는 "데이터동기화" 작업이 된다                            
                            5.  즉 디스크에 저장되어 있지 않은 메모리 버퍼의 데이터를 디스크에 저장하는 것을 sync 작업이라고 할 수 있다.                            
                            6.  sync 명령어는 시스템 버퍼에 있는 데이터를 디스크에 저장하는 명령어이다.                            
                            7.  재부팅이나 시스템 종료 등의 명령어 등으로 시스템을 종료할 때에 종료과정에서 sync 명령어가 자동으로 실행되는 이유도 여기에 있다.                            
                            8.  시스템이 이와 같이 연산작업과정에서 디스크를 이용하지 않고 메모리를 이용하는 것은 시스템의 속도 때문이다. 
                                디스크의 Access속도에 비해 현저하게 빠른 메모리를 이용함으로써 연산속도를 증가시켜 전체적인 시스템 성능을 향상시키기 위함이다.                            
                            9.  결론 : sync 작업은 메모리의 데이터를 디스크에 저장하여 동기화시키는 작업이라고 할 수 있다.                            
                            10. 명령어 사용법
                                # sync
            dd              - dd 옵션 설명
                            if=file
                                  표준 입력 대신에 지정한 file을 입력 대상으로 한다.
                            of=file
                                  표준 출력 대신에 지정한 file을 출력 대상으로 한다.  conv=notrunc
                                  옵션을 사용하지 않는 한은, seek= 바이트 크기에 따라 ( seek= 크기
                                  가 0아닌 한) 지정한 크기에 따라 출력 파일을 자른다.
                            ibs=bytes
                                  한번에 bytes 바이트씩 읽는다.
                            obs=bytes
                                  한번에 bytes 바이트씩 쓴다.
                            bs=bytes
                                  한번에 bytes 바이트씩 읽고 쓴다.  ibs, obs 값 무시.
                                  cf)Disk Backup Test with 'bs option of dd' 
                                  - dd의 bs value는 반드시 sector size의 배수가 되어야 한다.
                                    어떤 row device의 sector size가 512 라면, bs 값은 512, 1024, 2048 등의 값이어야 error가 발생하지 않는다.
                                  - sector size는 blockdev 를 이용해서 확인할 수 있다. (SSZ column 값)
                                   
                                  # blockdev --report
                                  RO  RA   SSZ   BSZ   StartSec       Size        Device
                                  rw   256   512  4096          0         16777216  /dev/hda
                                  rw   256   512  1024         63            256977  /dev/hda1
                                  rw   256   512  4096     257040    11261565  /dev/hda2
                                  rw   256   512  4096   11518605    2104515  /dev/hda3
                                  rw   256   512  1024   13623120                2  /dev/hda4
                                  rw   256   512  1024   13623183      208782  /dev/hda5
                                  rw   256   512  1024   13832028      208782  /dev/hda6
                                  
                                  < Test 환경 >
                                  IBM x3650 서버
                                  SAS 15000 prm 146GB Disk * 2EA
                                  
                                  < Test 결과 >
                                  Test 1) no bs option
                                  # dd if=/dev/sda of= /dev/sda
                                  result : 14400 sec = 240분,   10.2 MB/s
                                              정상 부팅 및 서비스 정상 작동
                                  
                                  Test 2) bs=4096
                                  # dd if=/dev/sda of= /dev/sda bs= 4096
                                  result : 50분,   46.8 MB/s
                                              정상 부팅 및 서비스 정상 작동
                                              
                                  Test 3) bs=16384
                                  # dd if= /dev/sda of= /dev/sda bs= 16384
                                  result : 22분,   109 MB/s
                                              정상 부팅 및 서비스 정상 작동
                                  
                                  cf) ~$ zcat n711*.img.gz | sudo dd of=/dev/sdX bs=1M                      ->  정상부팅작동
                                      ~$ zcat kk443-nitrogen6x-20160816.img.gz | sudo dd of=/dev/sdX bs=1k  ->  정상부팅작동
                                      ~$ zcat kk443-nitrogen6x-20160816.img.gz | sudo dd of=/dev/sdX bs=1M  ->  부팅에러발생(Kernel을 못 읽어 들임)
                            cbs=bytes
                                  한번에 bytes 바이트씩 변환한다.
                            skip=blocks
                                  입력 시작에서 blocks 단위 만큼 ibs 크기를 건너띈다.(가령 skip=5,
                                  ibs=10 이면, 처음 50바이트를건너띄어 작업을 계속한다.)
                            seek=blocks
                                  출력 시작에서 blocks 단위 만큼 ibs 크기를 건너띈다.
                            count=blocks
                                  입력의 blocks 의 ibs 크기만큼만 복사한다.





	cf)	i.MX6 평가보드에서 NFS 시스템 구현 시 "Freeing init memory: 252K" 문구가 나온 이후
		계속 멈춰져 있는 문제 해결을 위해 F/A 기술자가 평가보드 문제 확인 시 살펴 본 부분
		1.	ps -ef | grep nfs
		2.	cd /var/log/
			tail -f syslog
			vi syslog
			vi faillog
		3.	dmesg | grep nfs
		4.	date
		5.	ls -al
		6.	cd /opt/nfsroot
			file init

	cf)	크로스 컴파일
		비글보드의 Core는 ARM 계열이므로, 컴파일 시에 사용하는 gcc 외에 ARM용으로 실행 파일을 만들기 위한 크로스 컴파일 설치가 필요함
		Tool-chain 들은  arch [-vendor] [-os] -eabi   같이 이름 규칙.
		arch - target architecture(now, ARM)
		vendor - toolchain 공급처(회사)
		os - target operating system
		eabi - Embedded Application Binary Interface

		1.	리눅스 컴파일을 위한 Toolchain(크로스 컴파일러)의 설정
			가)	~$vi .bashrc			->	아래와 같이 변경
				#export PATH=$PATH:~/bin:/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin
				export PATH=$PATH:~/bin:/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin:/usr/local/arm-2009q3/bin
			나)	~$source .bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령
			ex)	#include <stdio.h>
				int main(void)
				{
					printf("Hello\n");
					return 0;
				}
				
				arm-linux-gnueabi-gcc test.c -o test -static				->	꼭 -static 옵션을 추가해 줘야지만 arm board에서 ./test 실행 시
																				/system/bin/sh: ./test: No such file or directory 에러가 발생하지 않음
																			->	#apt-get install gcc-arm-linux-gnueabi 명령을 실행 했다면 본 명령어로 compile 시켜도 됨

				arm-none-linux-gnueabi-gcc test.c -o test -static			->	꼭 -static 옵션을 추가해 줘야지만 arm board에서 ./test 실행 시
																				/system/bin/sh: ./test: No such file or directory 에러가 발생하지 않음
																			->	/usr/local/arm-2009q3/bin directory에 크로스컴파일러를 설치한 경우
				
				chmod 777 test
				./test 														-> Hello 문구 출력
	
		2.	안드로이드 컴파일을 위한 Toolchain(크로스 컴파일러)의 설정
			가)	~$vi .bashrc			->	아래와 같이 변경
				#export PATH=$PATH:~/bin:/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin
				export PATH=$PATH:~/bin:/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin:/usr/local/arm-2009q3/bin
			나)	~$source .bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령
			cf)	Bootloader의 빌드
				a)	~$cd rowboat-android/u-boot
				b)	~$make ARCH=arm CROSS_COMPILE=arm-eabi- distclean
				c)	~$make ARCH=arm CROSS_COMPILE=arm-eabi- omap3_beagle_config
				d)	~$make ARCH=arm CROSS_COMPILE=arm-eabi-
				->	빌드가 성공하면 해당 디렉토리에 "u-boot.bin" 파일 생성

    cf)	Kernel source 상에서 Debug message를 Terminal(RS232) 창에 출력시키는 방법
###       	->	최종결론(프로그램 소스 수정 없이 간단히, 아래 2개 명령만 실행시키면 Debug message 출력됨)
###    	$ echo 8 4 1 7 > /proc/sys/kernel/printk
###    	# echo -n 'file mxc_v4l2_capture.c line 1224 +p' > /sys/kernel/debug/dynamic_debug/control
###		# echo -n 'file mxc_v4l2_capture.c line 1100-1350 +p' > /sys/kernel/debug/dynamic_debug/control
		cf)	/dynamic_debug/control 가 생성되어 있지 않은 경우, 아래 커널 설정을 변경시켜서 빌드하면 생성 됨
			Kernel hacking -> printk and dmesg options -> [*] Enalble dynamic printk() support
    
     	1)	하기와 같은 명령 실행시키면 printk 명령으로 실행된 모든 message가 terminal 창으로 출력 됨
    		$ echo 8 4 1 7 > /proc/sys/kernel/printk			->	모든 message, terminal 창으로 출력 됨
    		cf)	echo 0 4 1 7 > /proc/sys/kernel/printk			->	모든 message, terminal 창으로 출력 안됨
			cf)	# cat /proc/sys/kernel/printk					->	어떤 환경으로 printk 명령이 설정되어 있는지 확인
				6       4       1       7
				차례대로
				console_loglevel: 이 값보다 높은 우선순위를(숫자가 작은) 지닌 메시지들은 콘솔에 출력.
				default_message_loglevel: 명확한 우선순위가 없는 메시지들은 이 값으로 출력. 
				minimum_console_loglevel:  console_loglevel 이 설정될 수 있는 최소값. 이 값이 1이라면 Console Log Level 에 0을 입력할 수 없다.
				default_console_loglevel: console_logevel  기본값.
    	
    	2)	하기 명령과 같이 printk(KERN_ERR ~)명령의 레벨을 높게 지정해 주면 Terminal 창으로 printk 명령이 출력 됨
			ex)	printk(KERN_ERR "KRH TEST HOHOHO!\n");

		2+1)프로그램 상에 출력 명령 추가
			cf) printk("<1>Initialize\n"); 명령을 추가하는 것이 가장 에러 발생도 피하면서 출력도 손쉽게 할 수 있을 것 같음
			cf) printf("message\n"); 명령은 compile 시 에러 발생 하는 경우 있음, 파일 내부 다른 프린팅 명령을 사용하는 것이 에러 발생을 최소화 할 수 있음

		3)	로그 레벨 지정
			printk() 는 출력 메지지의 레벨을 지정 할수 있다.
			
			printk(KERN_WARNING "test message\n");
			<0> : KERN_EMERG 
			<1> : KERN_ALERT
			<2> : KERN_CRIT
			<3> : KERN_ERR
			<4> : KERN_WARNING
			<5> : KERN_NOTICE
			<6> : KERN_INFO
			<7> : KERN_DEBUG

            레벨은 /linux/kernel.h 에 정의되어 있다.

 			printk(KERN_INFO "message\n");
			printk("<6>" "message\n");
			printk("<6>message\n");
			이 3개의 문장은 같은 의미를 가지며 동일한 레벨의 메시지를 출력한다.

			레벨을 지정하지 않으면 default로 KERN_WARNING 를 갖는다.
			보통 부팅메시지에 출력되는 메지시는 <6>:KERN_INFO 까지출력한다.
		
		4)	pr_debug 출력 방법  Android
			가)	예제
				// svcsock.c 파일의 1603번째 줄의 메시지를 켜기
				nullarbor:~ # echo -n 'file mxc_v4l2_capture.c line 1224 +p' > /sys/kernel/debug/dynamic_debug/control
				cf)			echo -n 'file mxc_v4l2_capture.c line 1100-1200 +p' > /sys/kernel/debug/dynamic_debug/control

				// svcsock.c 파일 안의 모든 메시지 켜기
				nullarbor:~ # echo -n 'file svcsock.c +p' > <debugfs>/dynamic_debug/control
							# echo -n 'file svcsock.c +p' > /sys/kernel/debug/dynamic_debug/control
						ex)	# echo -n 'file ov5640.c +p' > /sys/kernel/debug/dynamic_debug/control
							->	정말 이렇게 하면 ov5640.c에 있는 pr_debug 메시지가 출력된다.
###								cf)	하기 나)방법 처럼 "#define DEBUG" 추가시키고 다시 kernel compile 시키지 않아도 됨
								cf)	주의) kernel 단의 파일 이름은 대부분 소문자로 시작 됨
									mxc_v4l2_capture.c 파일을 하기와 같이 명령 내리면 동작하지 않음
									# echo -n 'file Mxc_v4l2_capture.c +p' > /sys/kernel/debug/dynamic_debug/control
								->	# echo -n 'file mxc_v4l2_capture.c +p' > /sys/kernel/debug/dynamic_debug/control	->	이렇게 명령 내려야 함

				// NFS 서버 모듈의 모든 메시지 켜기
				nullarbor:~ # echo -n 'module nfsd +p' > <debugfs>/dynamic_debug/control

				// svc_process() 함수 안의 모든 12 메시지를 켜기
				nullarbor:~ # echo -n 'func svc_process +p' > <debugfs>/dynamic_debug/control

				// svc_process() 함수 안의 모든 12 메시지를 끄기
				nullarbor:~ # echo -n 'func svc_process -p' > <debugfs>/dynamic_debug/control

				// NFS가 호출하는 READ, READLINK, READDIR 그리고, READDIR+를 위한 메시지 켜기
				nullarbor:~ # echo -n 'format "nfsd: READ" +p' > <debugfs>/dynamic_debug/control
										->	출력 메시지 중 "nfsd: READ" 으로 시작하는 모든 메시지 출력

				// "usb" 문자열을 포함하는 경로의 메시지 켜기
				nullarbor:~ # echo -n '*usb* +p' > <debugfs>/dynamic_debug/control

				// 모든 메시지 켜기
				nullarbor:~ # echo -n '+p' > <debugfs>/dynamic_debug/control
							# echo -n '+p' > /sys/kernel/debug/dynamic_debug/control
							->	이렇게하면 너무 많은 메시지(특히, i2c 통신 메시지)가 출력되서 특정 application을 아예 동작시킬 수 없다.

				// 모든 켜진 메시지에 모듈과 함수 추가
				nullarbor:~ # echo -n '+mf' > <debugfs>/dynamic_debug/control

				각 키워드의 뜻은:				
				func
				    주어진 문자열은 각 호출처의 함수 이름과 비교됩니다 예를 들면:				
				    func svc_tcp_accept			
				
				file
				    주어진 문자열은 전체 경로 이름이나 소스 루트의(src-root) 상대 경로 이름, 또는 각
				    호출처의 소스 파일의 경로를 제외한 이름(basename)과 비교됩니다. 예를 들면:
				    file svcsock.c
				    file kernel/freezer.c
				    file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c
								
				module
				    주어진 문자열은 각 호출처의 모듈 이름과 비교됩니다. 모듈 이름은 "lsmod" 에서 보여지는
				    문자열입니다. 즉, 디렉토리나 .ko 접미사가 없고, '-'는 '_'로 변경됩니다. 예를 들면:
				    module sunrpc
				    module nfsd

				format
				    주어진 문자열은 동적 디버그 형식 문자열 내에서 검색됩니다. 그 문자열은 전체 형식과
				    매치될 필요는 없고 오직 일부만 매치되면 된다는 것을 알아두세요. 공백 문자들과 다른
				    특수 문자들은 C의 8진수 문자 이스케이프 \ooo 표현을 사용해서 쓰여질 수 있습니다.
				    예를 들면, 스페이스 문자는 \040 입니다. 다른 방식으로, 문자열을 쌍따옴표 문자(") 나
				    따옴표(')로 둘러쌀 수 있습니다.
				    예제:
				    format svcrdma:	   // NFS/RDMA 서버 pr_debug 들에서 많음
				    format readahead	   // readahead 캐시 안의 pr_debug 들
				    format nfsd:\040SETATTR // 공백 문자로 형식을 매치하는 한가지 방법
				    format "nfsd: SETATTR"  // 공백 문자로 형식을 매치하는 더 깔끔한 방법
				    format 'nfsd: SETATTR'  // 공백 문자로 형식을 매치하는 또 다른 방법

				line
				    주어진 행 번호 또는 행 번호의 범위는 각 pr_debug() 호출처의 행 번호와 비교됩니다.
				    하나의 행 번호는 호출처 행 번호와 정확히 매치됩니다. 행 번호의 범위는 처음과 마지막의
				    행 번호 안의 호출처와 매치됩니다. 첫번째 수가 없는 것은 파일의 첫번째 줄을 의미하고,
				    행 번호가 없는 것은 파일의 마지막 줄을 의미합니다. 예를 들면: 
				    line 1603	   // 정확히 1603번 줄
				    line 1600-1605  // 1600번에서 1605번 줄까지의 여섯 줄
				    line -1605	   // 1번 줄에서 1605번 줄까지의 1605 줄
				    line 1600-	   // 1600번 줄에서 파일의 끝까지의 모든 줄

				플래그 명세는 하나 또는 그 이상의 플래그 성질이 따르는 하나의 변경 동작으로 구성됩니다.
				변경 동작은 하나의 성질입니다:
				  -    주어진 플래그 제거
				  +    주어진 플래그 추가
				  =    주어진 플래그로 플래그를 설정

				플래그들은 다음과 같습니다:
				  p    pr_debug() 호출처 켜기
				  f    출력된 메시지 안에 함수 이름을 포함
				  l    출력된 메시지 안에 행 번호를 포함
				  m    출력된 메시지 안에 모듈 이름을 포함
				  t    인터럽트 컨텍스트에서 생성되지 않은 메시지 안에 스레드 ID 포함.
				  _    플래그가 설정되지 않음. (또는 입력 상의 다른 것들로 설정)

			나)	Kernel 에서 pr_debug 등이 안나올 때
				간단히는 맨 위("#include <linux/kernel.h>"보다 위)에 "#define DEBUG" 추가 혹은
				http://www.kernel.org/doc/local/pr_debug.txt 처럼 makefile 수정
				DEBUG를 추가했을 때 왜 pr_debug 가 Enable 되는지 보고 싶다면, include/linux/kernel.h 참고
				커널 메시지 보기 : 커널이 어느정도 안정적이라면 UART 등을 이용하는 것보다 adb 쉘을 이용하는 것이 더 편하던데..
				adb shell cat /proc/kmsg				cf)	cat < /proc/kmsg
				cf)	</linux/kernel.h> 파일에 "#define DEBUG"을 추가시켜도 pr_debug 메시지가 표시 되기는 하겠지만
					이 경우 너무 많은 메시지가 표시 되기 때문에 제대로 프로그램이 실행될 수 없는 문제 발생 됨
					또한 이로 인한 kernel compile 시간도 엄청나게 오래 걸릴 것임
			다)	adb root
				adb remount
				adb shell mount -t debugfs none /sys/kernel/debug
				adb shell "echo 'file msm_otg.c +p' > /sys/kernel/debug/dynamic_debug/control"
				기본적으로 rooting이 되어 있어야 하며  pr_debug 가 포함되어 있는 파일의 파일명을 적어주면 된다.			
			라)	# pr_debug 함수 출력하기
				C 파일의 맨위에  #define DEBUG를 추가하면된다.
				/include/linux/kernel.h  참조

	cf)	리눅스 터미널에서 사용하는 단축키  ETC / 리눅스  2009.03.09. 16:23
		Ctrl + d  : EO로 더 이상 입력할 파일 및 내용이 없을 때 사용하는 단축키로 프롬프트 상에서는
		              더 이상 입력할 명령어가 없으므로 로그아웃을 하며 텍스트 내용을 입력할 때는
		              문서의 입력을 종료
		Ctrl + z  : 현재 실행중인 프로세스를 일시 중단
		Ctrl + c  : 현재 실행중인 프로세스를 취소
		Ctrl + u  : 커서 왼쪽 문자 지우기
		Ctrl + k  : 커서 오른쪽 문자 지우기
		Ctrl + e  : 커서를 입력되는 문자열 끝으로 이동
		Ctrl + a  : 커서를 입력되는 문자열의 처음으로 이동
		Ctrl + b  : 커서를 왼쪽으로 이동
		Ctrl + f  : 커서를 오른족으로 이동
		Ctrl + l  : clear 명령과 동일
		Ctrl + xx : 커서를 이전에 있던 위치로 이동
		Ctrl + y  : 버퍼에 저장되어 있는 내용 붙이기
		Ctrl + m  : enter키
		Ctrl + s  : 키보드 락 걸기
		Ctrl + q  : 락걸린 키보드 풀기
		Ctrl + p  : 이전 명령어(위쪽 화살표)
		Ctrl + n  : Ctrl + p의 반대(아래쪽 화살표)
		Alt  + l  : 문자열 끝까지 모두 소문자로 변환
		Alt  + u  : 문자열 끝까지 모두 대문자로 변환
		Alt  + 1-9 : 사용자 정의 제공
		Alt  + F1~F6 : 각각의 가상 터미널을 제공하며 X-Window에서는 가상 X-Window를 제공하며
		                    콘솔에서는 가상 터미널을 제공한다
		Alt  + F7~F12 : 각각의 가상 X-Window를 제공한다
		Ctrl + Alt + F1~F6 : X-Window상에서 콘솔 창으로의 변환할 때 사용
		Shift + PageUp(PageDown) : 실행중인 프로그램이 모니터 상에서 이미 지나간 경우 앞, 뒤의
		                                         내용을 확인할 때 사용하는 단축키이다
		방향키  : 히스토리 기능으로 한번 이상 사용한 명령어를 순차적으로 출력하는
		             단축키로 tab 키와 더불어 가장 많이 사용되는 단축키이다
		Tab : 현재 디렉토리의 파일 및 디렉토리의 영문자를 완성시키는 단축키로 사용.
		         방향키와 더불어 가장 많이 사용되고 있다
		Ctrl + Alt + Del : 시스템을 강제로 종료시키는 단축키

	cf)	[Android] logging functions
		Android 2013/05/02 22:27 안드로이드의 C/C++ 파일에서 logcat에 무언가 출력하려면 <cutils/log.h> 
		또는 <utils/Log.h>를 include하여 사용하면 된다.
		ex)  #define LOG_TAG "MY_TAG"
		#define LOG_NDEBUG 0
		#include <cutils.log.h>
				
		■TAG를 변경하고 싶으면 LOG_TAG를 define 한다.
		■출력할 로그 레벨을 변경하고 싶으면 LOG_NDEBUG를 define 한다.
		■<cutils/log.h>에서 LOG_TAG와 LOG_NDEBUG의 값을 참조하므로 include 하기 전에 define 해야 한다.
		■로그를 출력하려면 ALOGV, ALOGD, ALOGI, ALOGW, ALOGE 매크로를 printf처럼 사용하면 된다.
		■이 매크로는 <cutils/log.h>에서 정의한다.
		■매크로의 접미사 V, D, I, W, E는 각각 verbose, debug, info, warning, error를 의미한다.
		
		Android framework 소스에서 LOG 출력방법
		소스의 첫 줄에 다음을 추가
		#define LOG_NDEBUG 1 <= LOGE, LOGW, LOGI, LOGD 출력. LOGV 제외
		#define LOG_NDEBUG 0 <= LOGV를 포함한 모든 LOG 출력
		참고로 LOG_NDEBUG에 의해 제어되는 소스코드는 system/core/include/cutils/log.h 이다.
		->	보통은 소스 파일에 //#define LOG_NDEBUG 0 와 같이 선언되어 있고(ex, X:\root\myandroid\frameworks\base\core\jni\android_hardware_Camera.cpp)
			#define LOG_NDEBUG 0 와 같이 변경시키주면 LOGV를 포함한 모든 LOG 출력됨
    
    cf) 압축/해제
       [압축할 때] tar cvzf 파일명.tar.gz <디렉터리> 또는 파일
       [압축 해제] tar xvzf 파일명.tar.gz, tar xvzf 파일명.tgz
       [압축 해제] tar xvjf 파일명.tar.bz2

    cf) chmod 755 test
       -rwxrwxrwx			cf) 파일 속성이 -rw------- 으로 되있으면 파일이 실행되지 않는다
        user group other	cf) ftp로 파일을 windows->linux로 복사하면
	       						파일 속성이 -rw------- 으로 되어 실행되지 않는 오류가 발생함
		#chmod u+x,g-w test.txt
	   		user 퍼미션추가 실행, group 퍼미션삭제 쓰기
		#chmod 755 test		-> 4(read),2(write),1(execute)
		#chmod -R 777 .		-> 하위디렉토리 모두 777
	   	cf)	ls -l 명령으로 파일구조 파악
	   		   
	   	ex)	#chown -cR changeID:changeGroup test_dir(test_dir폴더와 그 안의 모든 파일의 소유자를 changeID로 소유 그룹을 changeGroup으로 변경)
	   		#chown -cR root:root test_dir
	   	
        cf)	
        모드 설명
		O_RDONLY 읽기 전용으로 연다
		O_WRONLY 쓰기 전용으로 연다
		O_RDWR 읽기와 쓰기 모두 가능하게 한다
		
		oflags 매개변수에 이 값들 외에 다음과 같은 값들을 조합(비트단위 OR 연산자를 이용)해서 지정할 수 있다.
		
		O_APPEND : 자료를 파일의 끝에서부터 기록한다.
		O_TRUNC : 파일의 길이를 0으로 만든다. 기존 내용은 폐기된다.
		O_CREAT : 필요하다면 파일을 생성한다(해당 접근 모드로).
	
		초기 권한
		open과 O_CREAT 플래그로 파일을 생성하는 경우 반드시 매개변수 세 개짜리 open 함수를 사용해야
		한다. 그 함수의 세 번째 매개변수 mode는 좀 더 구체적인 파일 접근 권한을 지정한다.
		
		이 매개변수에는 헤더 파일 sys/stat.h에 정의되어 있는 다음과 같은 값들을 비트단위 OR로 조합해서
		지정할 수 있다.
		
		S_IRUSR : 읽기 권한, 소유자
		S_IWUSR: 쓰기 권한, 소유자
		S_IXUSR : 실행 권한, 소유자
		S_IRGRP : 읽기 권한, 그룹
		S_IWGRP : 쓰기 권한, 그룹
		S_IXGRP : 실행 권한, 그룹
		S_IROTH : 읽기 권한, 다른 사용자들
		S_IWOTH : 쓰기 권한, 다른 사용자들
		S_IXOTH : 실행 권한, 다른 사용자들
		
		예를 들어
		
		open ("myfile", O_CREAT, S_IRUSR|S_IXOTH);
		
		는 소유자가 읽을 수 있고 다른 사용자들이 실행할 수 있는(그리고 그 외의 접근을 허용하지 않는)
		myfile이라는 파일을 사용한다.
		
		예를 들어 아래 ERROR 함수가 실행되지 않을 조건은 S_IWGRP 과 S_IWOTH 모두 0이어야 됨
		->	rwxrwxrwx = 111 101 101 = 755
	    if ((sb.st_mode & (S_IWGRP | S_IWOTH)) != 0) {
	        ERROR("skipping insecure file '%s'\n", fn);
	        goto oops;
	    }

###		cf)	부팅과 동시에 자동으로 device/파일 속성을 변경시켜 주는 방법
			Android -> image_folder -> rootfs.tar.bz2 -> ueventd.rc -> 파일 속성을 변경 시켜주고자 하는 파일 추가/수정 ex) /dev/i2c-2 0777 root root
			cf)	~/myandroid/out/target/product/sabresd_6dq/root/ueventd.rc

			cf)	JNI -> system("chmod 777 /dev/i2c-2");						-> 본 명령이 아예 동작하지 않음
				JNI -> system("/data/gpio_driver.sh");						-> 본 명령이 아예 동작하지 않음(shell 명령 안에 chmod 777 /data/gpio_driver.ko 명령을 넣어도 실행되지 않음)
				JAVA -> Runtime.getRuntime().exec("chmod 777 /dev/i2c-2");	-> 본 명령이 아예 동작하지 않음
				cf)	안드로이드에서는 mknod, insmod를 지원안해서 init.rc를 수정해주셔야해요
					아니면 안드로이드용 busybox를 사용하면 되던걸로...?  1년전에 작업했는데 벌써 기억이 가물가물;

 					좋은 답변 대단히 감사드립니다. 저도 여기저기 찾아 보고 init.rc 를 수정해야겠다는 생각이 들었는데요. 
 					이 init.rc 가 system\core\rootdir\ 에 있는 init.rc 가 맞는지요? 여기에 insmod를 삽입해봤는데, 잘 안되더군요. 
 					혹시 init.rc 의 어떤 부분에 어떻게 넣으셨는지요? 저도 계속해서 검색해서 찾아봐야겠습니다. 혹시 기억이 나시면 다시한번 댓글 부탁드립니다. 다시한번 감사합니다.

			cf)	*.ko(디바이스 드라이버)를 부팅시 자동 로딩
				~/myandroid/out/target/product/sabresd_6dq/root/init.rc 내부에 shell script를 추가시켜서 실행시키는 방법(추천 방법으로, shell script(*.sh) 파일 내부의 명령만 간단히 수정하면 수정 사항이 곧바로 적용 됨)
				가)	gpio_driver.sh를 하기와 같이 작성해서 Target board /data folder에 복사 시킴
					#!/system/bin/sh
					# test

					insmod /data/gpio_driver.ko
					chmod 777 /dev/gpio_driver0

				나)	~/myandroid/out/targer/product/sabresd_6dq/root 안에 있는 init.rc 파일을 수정한 다음
					중요)	init.rc 파일 맨 아래에 아래와 같이 추가하면 shell 명령이 실행되고 그 안에 있는 insmod 와 chmod 명령도 정상적으로 수행 됨
							
					# add, 아래 명령 확실히 실행됨 확인
					#		shell script로 처리하면 구성된 명령 수정 시 shell 명령만 수정하면 되기 때문에 간단히 구성 명령을 수정할 수 있음
					#		만약, init.rc 상에서 직접 명령을 추가한 경우라면 구성 명령 수정시
					#		boot.img를 다시 build하고 SD Memory에 writing 하는 작업을 거쳐야 하기 때문에 구성 명령 수정이 상당히 오려 걸림
					service gpio_driver /system/bin/sh /data/gpio_driver.sh
						class main
						console
						user root
						group root
						oneshot
					# add

				다)	"cf)	전체 소스에서 일부분만 다시 빌드(X:\root\myandroid\kernel_imx 내부의 kernel image Rebuild)"을 참고 해서 boot image를 rebuild 시킨 다음
				라)	i.MX6 SD-Memory를 reader에 연결시켜서 Ubuntu OS에 연결시킨 후
				마)	"-> [71]	i.MX6(i.MX 6 Series SABRE for Smart Devices) -> 3)	SD Memory/eMMC 로 부팅 하기 -> 가) Android 부팅" 명령을 참고해서 Writing 하면 됨

			cf)	*.ko(디바이스 드라이버)를 부팅시 자동 로딩
				~/myandroid/out/target/product/sabresd_6dq/root/init.rc 파일을 직접 수정하는 방법(비추천 방법으로, 구성 명령을 수정하려면 다시 build 하고 SD Memory에 writing하는 등 복잡한 과정을 거쳐야 함)
				가)	~/myandroid/out/targer/product/sabresd_6dq/root 안에 있는 init.rc 파일을 수정한 다음
					중요)	아래 명령을 init.rc 파일 맨 아래에 추가하는 것이 아닌 하기와 같이 class_start core 명령 아래 부분에 추가해야만
							정상적으로 insmod 와 chmod 명령이 수행 됨
							cf)	아래 명령을 맨 아래에 추가하면 insmod 명령이 수행되지 않고
								아래 명령을 class_start core 명령 윗 부분에 추가하면 chmod 명령이 수행되지 않음
							......................................................................................................
							class_start core
						    class_start main

							on property:sys.boot_completed=1
								......................................................................................................
							    chmod 0660 /sys/devices/system/cpu/cpufreq/interactive/io_is_busy
							
							# add
							#	echo "hohoho"
							#	mkdir /data/init.test
							#	chmod 777 /data/init.test
							#	ls /data
								insmod /system/etc/gpio_driver.ko
								chmod 777 /dev/gpio_driver0
							#	chmod 777 /dev/gpio_driver0
							#	chmod 777 /dev/gpio_driver0
							#	service gpio_driver /system/bin/sh /data/gpio_driver.sh oneshot
							# add

				나)	"cf)	전체 소스에서 일부분만 다시 빌드(X:\root\myandroid\kernel_imx 내부의 kernel image Rebuild)"을 참고 해서 boot image를 rebuild 시킨 다음
				다)	i.MX6 SD-Memory를 reader에 연결시켜서 Ubuntu OS에 연결시킨 후
				라)	"-> [71]	i.MX6(i.MX 6 Series SABRE for Smart Devices) -> 3)	SD Memory/eMMC 로 부팅 하기 -> 가) Android 부팅" 명령을 참고해서 Writing 하면 됨

			cf)	Interfacing functions between user space and kernel space
				Events			User Functions			Kernel Functions
				Load Module		insmod					module_init()
				Open device		fopen					file_operations: open
				Read device		fread					file_operations: read
				Write device	fwrite					file_operations: write
				Close device	fclose					file_operations: release
				Remove module	rmmod					module_exit()

			cf)	Android 설정 파일 수정
 				릴리즈한 ISO파일이 자신의 하드웨어 설정과 맞지 않을 경우 수정이 필요합니다. 이 경우 다시 빌드를 해야하는게 맞지만, 
 				빌드할 여건이 되지 않거나 간단한 수정일 경우 빌드를 하는것 보다 ISO파일 자체를 수정하는편이 빠를수 있습니다. 
				Androbox 에서 릴리즈 하거나, 기타 개발자들이 릴리즈한 ISO 파일에서 몇가지 수정이 필요할 경우, 유용하게 사용될수 있는 팁을 공유 하니 참조해 주시기 바랍니다.
  
				1)	init.rc 또는 init.xxx.rc 파일 수정 방법
					init 프로세서에 의해 실행되는 파일인 init.rc 파일 수정 방법입니다. 가령, sound 관련 수정이 필요할 경우, 매번 부팅후 alsa 유틸을 이용해서 수정하기란 정말 귀찮겠죠. 
					그렇다고, 부팅후 init.rc 파일은 수정 불가입니다.(read-only 이기 때문)
					init.rc, init.xxx.rc 파일은 ISO 파일내의 ramdisk.img 파일에 그 내용이 포함되어 있습니다. 만약, hard나 usb에 설치를 했다면, 
					android-system-xxxx 이라고 되어 있는 디렉토리에 ramdisk.img 파일에 내용이 포함되어 있습니다.
					이 ramdisk.img 파일을 수정하는 방법에 대해 알아보겠습니다. (아래의 수정을 위해서는 리눅스 시스템이 필요합니다.)
 
					?우선 ramdisk.img 는 위의 윈도우에서나 리눅스에서 마운트 해서 ISO파일이나 설치된 hard나 usb로 부터 가져옵니다.
					?ramdisk.img 를 ramdisk.img.gz 로 이름 변경합니다. ramdisk.img 는 gzip 으로 압축이 되어 있습니다.
					?# mv ramdisk.img ramdisk.img.gz
					?압축을 아래의 명령으로 풀어줍니다.
					?# gzip -d ramdisk.img.gz 
					?ramdisk.img 파일이 나올건데, 이건 cpio 파일 형식으로 되어 있는 파일입니다. 아래의 명령으로 압축을 다시 풉니다.
					?# cpio -i --no-absolute-filenames < ramdisk.img

					?압축을 풀면 init.rc 및 init.xxx.rc 가 보일겁니다. vi 나 기타 에디터로 수정을 합니다. 예를 들어 sound 관련 설정이 사용하시는 하드웨어마다 다르므로 자신에게 맞는 설정을 알아놓은후,
					 init.xxx.rc 에 아래와 같이 추가하시면 됩니다. 아래는 제가 사용하는 sound 관련 설정입니다. sound관련 설정을 Documentation 에 sound 관련 부분을 참조 바랍니다.
					
					?이제 수정이 끝났다면, 다시 압축을 해야 되겠죠. 압축을 푼 순서와 반대로 하면 됩니다. 기존의 ramdisk.img 는 지우고 cpio 로 압축을 합니다.
					?# rm ramdisk.img
					?# find . | cpio -o -H newc > ramdisk.img
					?다시 gzip 으로 압축을 하고, 이름을 변경합니다.
					?# gzip -c ramdisk.img > ramdisk.img.gz
					?# mv ramdisk.img.gz ramdisk.img
				
				cf)	init.rc
					1)	init.rc 파일 내부에 loglevel 3 -> loglevel 6 으로 변경하면 디버그 메시지를 볼 수 있음
					2)	예제

					-----------------
					# not complete -- just providing some examples of usage
					#
					on boot
					   export PATH /sbin:/system/sbin:/system/bin
					   export LD_LIBRARY_PATH /system/lib			
					
					   mkdir /dev
					   mkdir /proc
					   mkdir /sys					
					
					   mount tmpfs tmpfs /dev
					   mkdir /dev/pts
					   mkdir /dev/socket
					   mount devpts devpts /dev/pts
					   mount proc proc /proc
					   mount sysfs sysfs /sys					
					
					   write /proc/cpu/alignment 4					
					
					   ifup lo					
					
					   hostname localhost
					   domainname localhost					
					
					   mount yaffs2 mtd@system /system
					   mount yaffs2 mtd@userdata /data					
					
					   import /system/etc/init.conf					
					
					   class_start default					
					
					service adbd /sbin/adbd
					   user adb
					   group adb					
					
					service usbd /system/bin/usbd -r
					   user usbd
					   group usbd
					   socket usbd 666					
					
					service zygote /system/bin/app_process -Xzygote /system/bin --zygote
					   socket zygote 666					
					
					service runtime /system/bin/runtime
					   user system
					   group system					
					
					on device-added-/dev/compass
					   start akmd					
					
					on device-removed-/dev/compass
					   stop akmd					
					
					service akmd /sbin/akmd
					   disabled
					   user akmd
					   group akmd

				2)	/etc/ 아래의 설정 파일 수정 방법 (ts.conf, ts.env 등)
 					/etc/ 의 내용은 system.sfs (또는 system.img)에 포함되어 있습니다. 기타 부팅후 read-only 인 디렉토리의 내용들이 system.sfs 에 포함되어 있으니, 
 					system.sfs 를 수정할수 있다면, 여러모로 편리할것입니다. 이번장에서는 system.sfs 파일 수정하는 방법에 대해 알아보겠습니다.
					ISO 파일을 열거나, hard 또는 usb 에 설치를 했다면 android-system-xxxx 이라고 되어 있는 디렉토리에 system.sfs 파일이 포함되어 있습니다. 
					위에서와 동일하게 system.sfs 파일을 리눅스 시스템으로 옮겼다고 가정하고 수정하는 방법을 알아 보겠습니다.
					?우선 squashfs 툴을 설치를 해야 합니다. 빌드를 하시는 분들은 설치를 했겠지만, 설치하지 않으신 분들은 아래와 같이 설치를 합니다.
					?# wget http://squashfs-tools4.googlecode.com/files/squashfs-tools-4.0.deb
					?# dpkg -i squashfs-tools-4.0.deb
					?우선 수정작업을 할 장소가 /root 라고 가정하고 설명하겠습니다. /root/test 아래에 system.sfs 를 mount 할 디렉토리를 생성합니다.
					?# cd /root/test
					?# mkdir systemsfs
					?squashfs 파일 시스템으로 mount 를 합니다. squashfs 는 read-only 이기 때문에 mount 후에 다른 디렉토리로 system.img 파일을 copy 해야 합니다.
					?# mount -t squashfs -o loop ./system.sfs ./systemsfs 
					?# cp ./systemsfs/system.img ./
					?system.img 파일을 mount 할 디렉토리를 생성하고, mount 를 합니다.
					?# mkdir systemimg
					?# mount -t ext2 -o loop ./system.img ./systemimg 
					
					?이제 mount된 systemimg 로 이동을 해서 수정하고자 하는 파일을 수정합니다. 예를 들어 터치 스크린 관련 수정이 필요하면, 아래와 같이 ts.conf 관련 설정을 변경 할수 있습니다. 
					 touchkit 모듈을 사용하도록 변경하는 예입니다.
					?# cd ./systemimg/etc/
					?# vi ts.conf
					
					?수정이 끝났다면, 다시 파일을 umount 시키고, squashfs 로 만들어야 합니다.
					?# cd /root/test
					?# umount ./systemimg
					?# mksquashfs system.img system.sfs
 
					여기서 생성된 system.sfs 파일을 ISO파일에 대체 시키거나, hard 나 USB로 옮겨서 대체 시키면, 수정 적용된 파일을 적용할 수 있습니다. 
					휴~~ 정말 힘들죠. 그래도 빌드보다는 훨씬 편합니다. 간단히 설정 파일을 변경할 경우에 위의 방법으로 수정 하시면 될겁니다. 
					제가 릴리즈하는 버전에서 자신의 시스템에 맞게 수정하기 위해서 사용하는 방법이니 참조해 주시기 바랍니다.

	cf)	chown
		[리눅스] chown (파일이나 디렉토리의 소유자나 소유그룹 변경)

		사용법
		chown [옵션] [계정] [파일]

		옵션
		-c, --changes : 바뀐 ���일들에 대해서만 자세히 보여준다.
		-f, --quite : 바뀌어지지 않는 파일에 대해서 오류메시지를 보여주지 않는다.
		-v, --verbose : 작업진행상태를 자세하게 설명해준다.
		-R, --recursive : 경로와 그 하위 파일들을 모두 바꾼다.
		--version : 버전정보를 보여준다.
		--help : 도움말을 보여준다.
		
		예제
		# chown Rogue.Sejong test.txt
		=> 소유자와 그룹을 모두 변경(마침표(.) 대신 콜론(:) 사용 가능)
		# chown Rogue test.txt
		=> 사용자만 변경
		# chown .Sejong test.txt
		=> 그룹만 변경(마침표(.) 대신 콜론(:) 사용 가능)

    cf) RedHat 9.0 - IP,Gateway,DNS 설정
       1) RedHat WindowsX -> 시스템설정 -> 네트워크 -> eth0 -> double click -> 변경 -> 저장 -> #service network restart
       2)
       #netconfig
       #/etc/init.d/network restart
       
       호스트정보 - /etc/sysconfig/network
       IP주소정보 - /etc/sysconfig/network-scripts/ifcfg-eth0
       DNS정보    - /etc/resolv.conf

    cf) mysql backup/restore
       1) backup  : #mysqldump -u root -p homewiz > 2007-06-08_homewiz.sql
       2) restore : #mysql -u root -p homewiz < 2007-06-08_homewiz.sql

    cf) 명령어 끝에 &
       & 없이 실행 시킬시 접속했던 로그인 세션을 잃어 버리는 순간( 보통 터미널 접속 해제등..)
       실행 중인 프로그램에 hang up 이 발생하여 프로그램이 종료 됩니다. ( 특정 시그널이 발생하여 프로그램을 종료 시킨다고 보시면 됩니다. )
       그런데, & 를 붙이면 위의 상황에서도 종료 되지 않고 시스템이 계속 작동하게 됩니다.

    cf) reboot
       OS가 reboot함.

    cf) ntsysv
       자동으로 시작하는 서비스 목록 지정

    cf)	alias(별칭/별명)
		alias krh='cd ~krh/demo/qtopia'
        krh만 치면 cd ~krh/demo/qtopia 명령이 실행됨
        /root/.bashrc 파일을 수정하면 되며 booting하지 않고 곧바로 수정된 사항을 적용할려면
        source ~/.bashrc 명령을 사용하면 됨.
        cf)	alias 설정
			alias 리스트 출력	->	alias
			alias 해제			->	unalias lsd
			모든 alias 해제		->	unalias -a
        cf)	alias rm='rm -i'
       		alias cp='cp -i'
       		alias mv='mv -i'
       		alias dir='ls -al'
       		alias busybox='/data/busybox/bin/busybox'				->	Ubuntu terminal windows에서 이렇게 명령을 곧바로 실행시켜도 alias list에 본 명령이 추가 됨

	cf)	.bashrc & alias 설정하기
		cf)	안드로이드 같은 경우는 .bashrc 파일이 /system/etc/mkshrc 임

		우리가 터미널을 띄울 때 프롬프트가 나타나고 가장 많이 사용하는 명령이 아마도 ls 명령일 것입니다. 
		ls 명령을 수행할 때 여러 가지 옵션을 줄 수 있습니다. 하지만 매번 그렇게 옵션을 주어서 ls 명령을 수행하는 것은 조금 귀찮을 수 있습니다. 
		이것을 쉽게 할 수 있는 방법이 alias를 설정하는 것입니다.

		yhoh@ubuntu:~$ gedit ~/.bashrc

		# some more ls aliases
		#alias ll='ls -l'
		#alias la='ls -A'
		#alias l='ls -CF'
 		위와 같은 내용을 발견할 수 있습니다. 위 내용은 ll, la, l 등과 같은 것을 명령으로 사용할 수 있도록 설정하는 내용인 것입니다. 
 		물론 맨 앞의 #은 주석을 의미하고 위 내용이 반영되지는 않는 것입니다. 주석을 제거하게 되면 위 내용이 사용 가능하도록 변경됩니다. 
 		디폴트로는 #이 없지만 필자는 위 내용을 사용하지 않을 것이기 때문에 주석으로 처리하였습니다.

		yhoh@ubuntu:~$ source ~/.bashrc
 		위 source 명령은 현재의 .bashrc 파일이 바로 적용되도록 만드는 것입니다. 
 		물론 터미널 창을 종료했다가 다시 실행해도 똑 같은 결과를 얻을 수 있습니다.

    cf) shell
        하기와 같이 작성하면 명령들이 자동으로 실행됨.
        1) 파일명 : test.sh
        2) 내용 :
          #!/bin/bash
          # test
          
          ls -l
          cp *.* /krh
          
          exit 0
        2+1)첫 줄의 #!/bin/bash는 이 파일이 bash의 shell interpreter를 이용하여 실행하겠음을 선언한 것입니다. 이후에 나오는 #는 주석처리 부분입니다.
        3) ./test.sh 실행하면 상기 2명령이 자동으로 실행됨.(ls, cp)
        3+1)만약 ./test.sh 실행 시
        	/system/bin/sh: ./test.sh: No such file or directory 에러가 발생한 다면
        	상기 2)번 #!/bin/bash -> #!/system/bin/sh 로 변경하면 됨
        4) 참고) ./test.sh 를 실행하면 어떤 경우
          /bin/bash^M: bad interpreter: 그런 파일이나 디렉토리가 없음
          이라는 에러가 발생할 경우가 있다 이 경우는
          test.sh 가 UNIX 가 아닌 DOS 형식으로 저장되서 발생하는 오류로
          문서를 DOS -> UNIX 형식으로 변경해서 저장하면 상기 오류가 제거됨.
		5)	shell 안에 있는 export 명령은
            shell 안에서만(자식프로세스) 적용되고 shell이 끝난다음(부모프로세스)에는 적용되지 않는다
		6)	bash에서의 쉘변수와 환경변수
			(1)	쉘변수
				가)	개요 : 말 그대로 특정한 쉘 즉 bash에서만 적용되는 변수를 말한다.
				나)	특징
					a)	지정하는 방법은 '변수명=값' 형태로 지정하면 된다.
						$ COLOR=red
					b)	변수값을 출력할 때는 변수명 앞에 $을 붙여 echo명령을 사용하면 된다.
						$ echo $COLOR
						$ red
			(2)	환경변수
				모든 쉘에 영향을 미치는 변수라는 것을 제외 하고는 쉘변수와 지정 방법이나 특징이 유사하다.
			(3)	bash에서 쉘변수를 환경변수화 시키기
				export 명령을 사용하면 된다.
			(4)	export
				쉘변수를 환경변수로 만들어 주는 명령이다. 현재 리눅스 bash에서 일시적인 반영시에는 생략해서 사용할 수 있다.
				가)	사용방법
					export 환경변수=변수값
				나)	사용예
					a)	# export PATH="$PATH:/usr/local/apache/bin"
						->	현재 설정된 패스값에 /usr/local/apache/bin 이라는 경로를 추가한다.
				다)	참고
					export 명령은 쉘변수를 환경변수로 만들어 준다. 그러나, 쉘에서 export로 선언하여
					사용한 뒤에 로그아웃하게 되면 초기화 된다. 따라서, 해당 환경변수의 값을 계속적으로
					반영되도록 하려면 /etc/profile(전체시스템)이나 ~/.bash_profile(개인사용자) 파일안에 선언하면 된다.

    cf) echo
    	echo 다음에 오는 내용을 그대로 화면으로 보여준다.
    	cf)	PATH라는 변수를 확인하고 싶으면 echo 명령어를 통해서 확인할 수 있다
    		echo $PATH

    	echo는 인수로 지정된 문자열을 그대로 화면에 출력한다. 이것은 인수로 주어진 문자열이 오퍼레이팅 시스템으로 읽혀진 후에 다시 그대로 화면에 '메아리'치는 것으로 생각할 수 있다. 
		문법 
		echo [ -ne ] 문자열 
		옵션 
		-n : 새로 개행하지 않고 출력하게 한다. 
		-e : 문자열 중에서 백슬래쉬와 조합되는 특수 문자를 인식하게 한다. 그러한 특수 문자들은 다음과 같은 것들이 있다. 
		  
		\a 밸소리 \b 백스페이스 
		\f 용지바꿈(form feed) \n 행바꿈 
		\r 0 칼럼으로(carriage return) \f 탭(tab) 
		\v 수직 탭 \\ 백슬래쉬 문자 
		\nnn 8진법으로 표기되는 ASCII 문자 \c 출력 후 행바꿈 금지 
		설명 
		일반적으로 echo 명령은 프롬프트 상에서 사용되는 일은 없다. 하지만 스크립트 작성시 번번히 사용된다. 
		셸 스크립트 상에서 echo 명령은 BASIC의 PRINT 명령이나 C 언어의 printf() 함수와 같이 메시지를 출력하는 데에 자주 사용된다. 
		또한 전혀 필요없을 것 같은 echo의 -n 옵션도 스크립트 상에서는 유용하게 사용될 수 있다. 
		사용예 
		$ echo "The RedHat !" 
		The RedHat ! 
		$ echo -e 'Linux\RedHat !' 
		Linux RedHat !  		

    cf) rpm
        rpm -ivh test.rpm		-> 자동으로 test 프로그램이 설치됨.
                                (i:install, v:설치정보출력, h:#으로 진행과정 출력)

    cf) make 와 make install
        make 는 소스 코드를 실행이 가능한 실행화일로 만들어 줍니다.
        make install은 만들어진 실행 화일을 특정 디렉토리로 옮겨주는 역할을 합니다.
        cf)	중요
        	Makefile 을 작성할 때 실행 명령 제일 앞에 반드시 <TAB> 문자를 넣어 줘야 함
        	본 TAB 문자가 하기 Object(shellcommand:)와 명령(mkdir temp;)을 구분 시켜주는 역할을 함
        	Makefile에서 주석 처리는 제일 앞에 # 삽입
ex)
shellcommand:
	mkdir temp;
	
        	
    
    cf) mount/unmount
		#mount -t [파일시스템타입] [장치파일] [마운트 포인트]
		#umount [장치파일]
		
		ex)	mount -t vfat /dev/block/sda1 /mnt/usb	->	BeagleBoard-xm Terminal 창에서 실행할 경우
		ex)	umount /mnt/usb

	cf)	Read-only file -> RW로 변경 방법
		/system/lib 폴더는 보통 read-only 형식으로 되어 있으며 이를 rw로 변경시키려면 하기와 같이 실행하면 됨
		1)	임시변경
			cf)	본 임시변경은 수행 당시에는 변경되지만 rebooting 하면 예전에 저장되어 있던 파일로 다시 복구 됨
			가)	mount 명령으로 어떤 폴더 등이 어떻게 mount 되어 있는지 확인한 다음
				mount
				..................................
				/dev/block/mmcblk1p5 /system ext4 ro			->	ro는 read-only를 뜻함
			나)	변경하고자 하는 폴더를 하기 명령으로 remount시켜서 rw로 속성 변경시킴
				mount -o rw,remount /dev/block/mmcblk1p5
			다)	chmod 777 /system/lib/test.so 등 /system/lib 폴더 내부의 파일의 속성을 변경시킬 수 있음
		
			ex)	rootfs에 있는 init.rc 파일은 read-only 속성으로 인해 vi로 수정 불가 함
				이를 write 속성으로 바꿔서 수정 가능하도록 만듦
				a)	mount
					rootfs / rootfs ro,relatime 0 0
					................................
				b)	mount -o rw,remount rootfs
				c)	mount
					rootfs / rootfs rw,relatime 0 0
					................................
				d)	busybox vi init.rc			-> 명령으로 수정 및 저장 가능 함
		2)	임시변경
			cf)	아래의 경우도 rootfs 영역이 곧바로 수정이 되지만 rebooting 하면 예전에 저장되어 있던 파일로 다시 복구 됨
			띠로리!! Cannot create directory 'test' : Read-only file system.
			말인 즉슨, 제가 만들고자 하는 디렉토리가 읽기전용인 파일 시스템의 문제로 생성할 수가 없다는 충격적인 결과보고.
			일전에 허접함으로 무장한 막장 쉘에 이어서 이건 또 한번 사람을 당황스럽게 하는군요.
						
			네, 그렇습니다.
			안드로이드는 시스템을 자체적으로 보호하기 위해서 파티션 영역중 system 영역은 Read-only 로 설정해 버립니다.
			실질적으로 사용자가 사용할 수 있는 공간을 userdate 파티션으로 제한하게 되는 것인데요.
			
			그러나 아직 우리는 안드로이드를 가지고 막 열심히 작업하는 상태이고 시판하는건 아니란 말이죠.
			그렇다면 중요한건 보안이 아니라 우리의 작업환경 입니다! (절대 보안이 안중요하다는건 아닙니다! ^^)
			그럼 지금부터 한번 저를 따라서 간단하고 빠르게 읽고 쓰기 가능한 파일 시스템을 만들어 보죠.
			
			Step1.	램디스크로 부팅 후 app 디렉토리 내의 init.rc 수정 
					먼저 우리가 항상 해오던데로 램디스크로 부팅을 해보죠.
					그리고 app 디렉토리 (/dev/mtdblock2 영역) 에 들어가 있는 안드로이드 파일 중에서 init.rc 를 수정합니다.
					init.rc는 모든 프로세서의 조상(뭐, 이런 표현들을 많이 쓰더라구요)이라 칭송받는 init 프로세서용 스크립트 입니다.
					안드로이드용 init 프로세서는 이런 .rc 파일을 읽어서 시스템을 셋팅하게 됩니다.
			
			자! 이제 init.rc 파일을 수정해 보도록 하죠.
			내장된 vi 에디터를 사용하면 쉽게 수정할 수 있습니다. 
			# create mountpoints and mount tmpfs on sqlite_stmt_journals
			
			   ... 생략 ...
			
			    mount rootfs rootfs / ro remount                                            
			                                                                                
			   ... 생략 ...                  
			                                                              
			기존에 저렇게 mount 하도록 된 구문을 아래와 같이 바꿉니다.
			# create mountpoints and mount tmpfs on sqlite_stmt_journals
			
			   ... 생략 ...
			
			    mount rootfs rootfs / rw remount                                            
			                                                                                
			   ... 생략 ...                  
			
			rootfs 영역, 즉 / 영역을 rw, ReadWrite (기존엔 ReadOnly) 로 수정했습니다.

	cf)	Android용 root filesystem으로 cramfs 구성 할 때의 주의사항
		강래호 최종결론 :	rootfs에 들어 있는 init.rc 파일의 내용은 boot.img를 다시 build 해서 sd memory에 writing하지 않고는
			 				절대 변경 불가 함, 이유는 init.rc 등의 내용은 부팅 시 ramdisk로 loading 되는 것이기 때문에
			 				부팅 이후 terminal 창에서 아무리 init.rc 파일을 수정해도 부팅하면 다시 원래 내용으로 복구 되기 때문임
		
		http://nice295.egloos.com/1443113
		
		출처:  http://www.aesop.or.kr/?document_srl=46437#7
		
		이 글이 도움이 될 지는 모르겠지만
		제 mail로 질문이 들어와서 여기에도 구성할 때의 주의사항을 말씀드립니다.
		
		Linux system에서 root filesystem으로 사용할 수 있는 filesystem에는 여러가지가 있습니다.
		몇가지 예를 든다면, RAM Disk, Cramfs, Squashfs. ext2, ext3 등이 있습니다.
		이중 가장 많이 사용되는 것이 RAM Disk 이죠 Android도 Ram Disk를 기본으로 하고 있습니다.
		그 다음에 주로 사용되는 것이 Cramfs와 Squashfs 인데요..이 둘은 read only filesystem입니다.
		따라서 한번 image로 만든 다음 rootfs로 사용되면 다시 image를 NAND에 구울 때 까지는 절대 변경 할 수 없다는 것입니다.
		ext2와 ext3는 NAND에서는 rootfs로 사용하기가 힘듭니다.
		NAND의 기본 filesystem은 JFFS2와 YAFFS인 MTD용 filesystem 입니다.
		이 두가지 filesystem외에는 write operation을 사용할 수가 없지요..
		이유는 NAND의 bad block 때문입니다.
		여기까지 기본적인 설명 이었구요...
		 
		이제 본격적인...^^;;
		Android를 NAND에 넣고 싶다면 Android 구조를 파악하셔야 합니다.
		Android는 기본적으로 rootfs와 system, data, cache, sdcard를 기본으로 하고 있습니다.
		여기서 rootfs는 RAM Disk에서 system, data, cache는 MTD filesystem인 YAFFS에서, sdcard는 SDCARD에서 사용됩니다.
		 
		Android를 NAND에 올리기 전 가장 먼저 해야 할 일은 이 구조에 맞게 NAND에 파티셔닝을 해야 한다는 것입니다.
		각각의 파티션을 나누어서 각 이미지를 write 해야 하구요...
		각 파티션을 YAFFS로 rootfs에 mount 해야 합니다.
		이것은 init.rc 파일을 분석하시면 감이 오실 것입니다.
		일반적인 linux script와는 달라서 처음에 힘들더라구요..^^;;
		 
		0x00000000-0x00040000 : "Bootloader"
		0x00040000-0x00400000 : "Kernel"
		0x00400000-0x03400000 : "Root - Cramfs"
		0x03400000-0x10000000 : "File System"
		 
		만약 이렇게 4개의 파티션으로 나누어져 있는 NAND가 있다면 파티션을 6개로 나누어야 합니다.
		1. Bootloader
		2. Kernel
		3. Rootfs (Cramfs)
		4. system - 대략 60MB 정도
		5. userdata - 대략 50MB 이상
		6. Cache - 나머지
		 
		이러한 작업이 끝이 나면 
		rootfs 구성을 해야 하는데요..
		Android platform을 build하면 생성되는 root라는 디렉토리를 이용하여 
		rootfs를 구성하시면 됩니다.
		단 NFS용 rootfs는 system과 data를 모두 rootfs에 넣어야 하지만 
		NAND에 넣을 rootfs는 system과 data를 넣으면 안됩니다.
		이유는 조금 전에서 파티션을 나누고 부팅이 될 때 rootfs로 system과 data가 init에 의해 mount 될 것이기 때문입니다.
		다음으로 init.rc 파일을 수정해야 합니다.
		init.rc파일이 RAM Disk를 기본으로 하고 있기 때문에 rootfs의 내용을 변경하는 작업이 들어가 있거든요..
		그 부분을 주석처리 하여 막아야 합니다.
		왜냐하면 Cramfs는 read only filesystem이라서 변경이 불가능 하기 때문이죠..^^
		 
		주석처리 해야 할 부분은
		=================================
		symlink /system/etc /etc
		mkdir /system
		mkdir /data 0771 system system
		mkdir /cache 0770 system cache
		mkdir /sqlite_stmt_journals 01777 root root
		 
		mount rootfs rootfs / ro remount
		=================================
		이 부분 입니다.
		이 부분을 주석처리 한 만큼 앞으로 cramfs image로 rootfs를 구성할 root안에 
		이것들을 모두 해줘야 합니다.
		기본적으로 system, data 폴더는 생성되어 있으니까..
		아래 명령으로 설정 하면 됩니다.
		
		=================================
		ln -s /system/etc etc
		chown 0:0 system
		chown 1000:1000 data
		chmod 0771 data
		mkdir cache
		chown 1000:2001 cache
		chmod 0777 cache
		mkdir sqlite_stmt_journals
		chown 0:0 sqlite_stmt_journals
		chmod 01777 sqlite_stmt_journals
		=================================
		
		Android는 각각의 process 마다 UID/GID를 갖고 있습니다.
		물론 root는 0번이구요...
		system은 1000번 입니다.
		또한 cache는 2001번 입니다.
		원래 Linux에서는 UID/GID를 /etc/passwd, /etc/group 라는 파일을 통하여 커널에서 관리 하게 되어 있는데요..
		Android는 따로 파일이 없고 platform source 내부에 system/core/include/private/android_filesystem_config.h 파일이 있는데
		여기에 모든 UID/GID가 명시되어 있습니다.
		따라서 platform을 build하게 되면 해당 헤더파일을 참조하게 되고
		Android framework에서 관리를 하게 됩니다.
		이는 Android 만이 가지는 security 방법입니다.
		각각의 process 마다 UID/GID를 갖고 있기 때문에 다른 process가 생성한 파일에는 접근을 하지 못하는 것이죠..
		(갑자기...삼천포로...^^;;)
		
		아무튼 여기까지 변경 후에 mtd mount 하는 곳을 변경 하셔야 하는데요..
		mount yaffs2 mtd@system /system
		 
		제가 Android에 mtd로서는 해본적이 없어서 이 부분을 그대로 사용해도 될지는 모르겠지만
		한번 test 해보세요...
		혹시나 mount가 되지 않는다면
		아래와 같이 변경 해야 할 것입니다.
		mount yaffs2 /dev/mtdblock4 /system
		 
		init process의 소스를 보니까...수정 안해도 될 것 같네요..^^;;;
		 
		이렇게 변경을 하고 cramfs image를 생성 하시면 됩니다.
		말로는 이렇게 하지만 가장 우선시 되는것이 init.rc 스크립트 파일의 분석입니다.
		일반 linux shell script파일과 달라서 분석하는것이 쉽지는 않겠지만 
		이것의 분석이 완료 되어야 Android를 자유자재로 다룰 수 있을 것입니다.
		 
		여기까지 했으면 거의 끝난거나 다름 없습니다.^^
		이제 build된 Android platform에는 system.img, userdata.img이 생겨 있을 텐데요..
		이 이미지들은 YAFFS2 filesystem으로 구성된 image 입니다.
		이것을 그대로 각각의 partitoin에 write하시면 됩니다.
		 
		계속 말씀 드리지만 porting 작업에 있어서 
		처음부터 NAND에 image를 넣을려고 하면 문제 발생시 원인을 찾기가 힘듭니다.
		NAND 문제 인지 아니면 image의 문제 인지 kernel 문제 인지...등등등.....
		따라서 NFS booting을 통해 debuging 하시는게 좋을 것입니다.
		
		여기까지 읽어주시느라 수고하셨습니다..^^

	cf)	install/remove
		#apt-get install samba	->	install
		#apt-get remove samba	->	remove
		#apt-get update			->	package를 가져올 사이트로부터 package의 정보들을 가져와 update 수행
		#apt-get upgrade		->	설치되어 있는 package를 모두 새 버전으로 upgrade 수행
		#apt-get reinstall		->	설치되어 있는 package를 재설치
		
		cf)	설치 과정 등에 필요한 자료는 /etc/apt/sources.list 파일에 포함되어 있다
		
		cf)	해당프로그램이 깔려 있는지 확인
			#dpkg -l | grep samba

	cf)	[diff] diff patch 사용법
		많은 개발자들은 자신들이 개발하는 프로그램 소스의 버전을 유지하기 위해, 원소스 외에 패치파일을 준비한다. 일반적으로 패치파일은 diff를 사용해서 작성하고, 해당 패치파일을 적용할 때는 patch 명령어를 사용해 패치적용을 완료한다. 
		필자는 처음에 커널 공부를 할 때, 패치파일 사용으로 어려움을 겪은적이 있다. 실제 버전업된 커널 소스 파일 전체를 받는게 나은지, 아님, 하나의 커널 소스 파일을 斌? 패치 파일만 받는게 낳은지 잠시나마 고민했던 적도 있다. 
		따라서, diff 와 patch 파일은 커널에만 관련있는 내용은 아니나, 커널 패치와 유용히 사용될 수 있는 명령어이므로, 아래에서 살펴보고자 합니다. 
		기본 개념 및 사용법은 아래의 설명을 따라하기 식으로 해보면, 이해할 수 있을겁니다. 
		
		Diff 사용법 
		
		1. 두개의 빈 파일을 생성합니다. 
		[css@css ~]$ touch aaa bbb 
		[css@css ~]$ ls 
		aaa bbb 
		
		2. aaa에 아래의 라인을 추가합니다. (vi 사용법은 애플리케이션 소개란을 참고하세요. ^^) [css@css ~]$ vi aaa 
		This is first line // 라인을 추가합니다. 
		
		3. aaa 를 bbb로 복사하고, 새로운 라인을 추가합니다. [css@css ~]$ cp aaa bbb 
		[css@css ~]$ vi bbb 
		This is a first line 
		This is a second line // 라인 추가 
		
		4. aaa와 bbb의 변경 부분을 패치파일로 만듭니다. 그리고, 변경되는 부분이 패치파일에 어떻게 저장되나 확인합니다. 
		[css@css ~]$ diff -urN aaa bbb > mydiff.patch 
		[css@css ~]# cat mydiff.patch 
		--- aaa 2005-03-07 20:23:22.566188880 +0900 
		+++ bbb 2005-03-07 20:23:32.986604736 +0900 
		@@ -1 +1,2 @@ 
		this is a first line 
		+this is a second line 
		
		5. bbb를 지우고, 패치파일의 내용을 aaa에 적용시킵니다. [css@css ~]$ rm -f bbb 
		[css@css ~]$ patch -p 0 < mydiff.patch 
		patching file aaa 
		
		6. aaa에 패치파일의 내용이 적용되었나 확인합니다. 
		[css@css ~]$ cat aaa 
		this is a first line 
		this is a second line // 라인이 추가되었음 
		
		위의 예제에서는 diff와 patch 명령어의 사용과 개념을 이해하기 위해 간략히 설명했지만, 
		실제 소스의 크기가 상당한 경우, 원소스(aaa)를 가지고, 패치파일만 가지고 작업합니다

	cf)	Ubuntu 11.04에서 apt-get 실행하면 404 오류 나는 이유.
		IT/Linux 2013/07/04 15:36 

	1. apt-get update 실행 후 오류
	Ubuntu 11.04 사용자는 apt-get 명령으로 소프트웨어 설치할 때 404 또는 403 오류가 발생한다.
      $ sudo apt-get update
      ...
      오류 http://ftp.daum.net natty/main Sources                   
        404  Not Found
      오류 http://ftp.daum.net natty/restricted Sources
        404  Not Found
      오류 http://ftp.daum.net natty/universe Sources
        404  Not Found
      ---
      W: http://ftp.daum.net/ubuntu/dists/natty/main/source/Sources 파일을 받는데 
      실패했습니다  404  Not Found


      W: http://ftp.daum.net/ubuntu/dists/natty/restricted/source/Sources 파일을 
      받는데 실패했습니다  404  Not Found
      ..

	2. apt-get 오류 원인
	그 이유는 Ubuntu Server 11.04 (natty) 저장소의 지원이 2012년 10월 28일 부로 종료가 되었고 미러들도 2013년 
	6월 경에 archive.ubuntu.com에서 퇴출 되었다.

	따라서 ubuntu 11.04를 사용하는 사용자들은 소프트웨어의 설치가 불가능하게 되었다.
	이런 이유로 ubuntu 11.04를 상위 버전으로 갱신하여야 한다.
	참고로 ubuntu 10.04 LTS는 2015년 4월까지, ubuntu 12.04 LTS는 2017년 4월까지 지원된다.
	11.10 버전도 조만간 지원이 안될 수 있으니 12.04 LTS 버전을 사용하는 것이 적절한 선택으로 보인다.

	3. ubutu 11.04에서 계속 apt-get 사용할 수 있는 방법
	/etc/apt/sources.list의 서버를 old-releases.ubuntu.com로 변경한다.
	1) kr.archive.ubuntu.com 서버를 사용하는 경우.
 	  $ cd /etc/apt
      $ sudo cp sources.list sources.list.old
      $ sudo sed -i 's,http://.*ubuntu.com,http://old-releases.ubuntu.com,g' sources.list

	2) ftp.daum.net
      $ cd /etc/apt
      $ sudo cp sources.list sources.list.old
      $ sudo sed -i 's,http://.*ftp.daum.net,http://old-releases.ubuntu.com,g' sources.list

	
	cf)	폴더명 자동 완성 기능 	->	"TAB" 버튼 사용
	
	cf)	Git을 통해 버전관리를 해보자
		Git은 오픈소스의 코드관리도구입니다.
		
	cf)	apt-get install sun-java6-jdk 실행 도중 sh: getcwd() failed: No such file or directory 에러가 발생하는 경우
		본 명령 실행을 root 모드가 아닌 일반사용자모드(~$)에서 실행시키면 본 에러가 제거 됨
	
	cf)	컴파일
		#include <stdio.h>
		int main(void)
		{
			printf("Hello\n");
			return 0;
		}
		
		gcc test.c -o test
		gcc -o test -g test.c myfun.c
		-o : 실행파일의 이름을 지정합니다.
		-g : 컴파일 후 링크까지 합니다.(실행파일 만듦)
		-c : 목적파일까지만 만들어줌(목적파일을 링크하려면 -g 옵션으로 링크시키면 됨)
		
		-lpthread : pthread 함수를 사용하려면 본 옵셤을 추가해줘야 함, ex) gcc -o 1 1.c -lpthread
		
		./test -> Hello 문구 출력
	
	cf)	Ubuntu/ubuntu/우분투
	1-2)Ubuntu /etc/fstab에 엉뚱한 명령을 집어 넣어서 부팅조차 되지 않을 때 대처 방법
		가)	재부팅 -> Advanced options for Ubuntu -> Ubuntu, with Linux 3.13.0-32-generic (recovery mode)
			-> root (Drop to root shell prompt) -> root 비밀번호 입력 + Enter
		나)	cd /etc
		다)	# mount -o remount,rw /			-> 실행시켜서 /(root)를 rw로 재 mounting 시킴, 이렇게 재 마운트 시키면 본 /(root)를 읽고 쓰기 할 수 있음
		라)	vi fstab						-> 문제되는 명령어 삭제 + :wq!
		마) 재부팅
	1-1)Ubuntu 에 특정프로그램 설치 유/무 확인
		가)	우분투 소프트웨어 센터로 가서 해당 프로그램의 이름을 넣어서 찾아 본다.
		나)	만약, 해당 프로그램이 설치되어 있으면 "설치함"이란 문구와 "제거" 문구가 표시되며
			설치 하지 않았다면 "설치" 문구가 표시 됨
	1)	Terminal 창 띠우기
		가)	Ctrl+Alt+T
		나) Search your computer and online sources -> "Terminal" typing
	2)	Software install
		가)	Ubuntu Software Center
	3)	root 계정으로 로그인
		하기와 같이 로그인 하면 실행 후 "파일 탐색기" 등 모든 프로그램을
		root 계정으로 실행할 수 있다.		
		1)	sudo passwd root 로 root 비밀번호를 만든 후
		2)	sudo gedit /etc/lightdm/lightdm.conf.d/10-ubuntu.conf
			or sudo gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf
			하기 명령 추가
			greeter-show-manual-login=true
		3)	재부팅
		4)	사용자 선택 아래에 사용자 이름을 쓰는 칸에 root라고 입력하고 로그인

		cf)	Ubuntu 관리자 권한으로 탐색기 열기
				ex) Ubuntu -> 탐색기 -> 지에디트 사용하면 쓰기 권한이 주어지지 않아서 쓸 수 없는 문제 발생 -> 이에, 아래 명령 실행하면 본 문제 제거 됨
				->	Ubuntu 탐색기를 관리자 권한으로 실행
						$ gksudo nautilus				->	한줄 에러 뜨는 것은 무시

		cf)	GParted 

	4)	Ubuntu swapmemory 늘리기
		256M 추가 방법 
		1, dd if=/dev/zero of=/boot/swapfile bs=1024 count=262144 			// cf, dd : 가상파일 생성
		2, mkswap -v1 /boot/swapfile  
		3, swapon /boot/swapfile [ 현시스템에 바로 적용이 된다 ] 

		* 리부팅 후에도 적용 하려면, /etc/fatab에 아래의 값을 추가해 주면 됩니다. 
		 /boot/swapfile swap swap defaults 1 1 
	
	cf)	메모리 현황 알아보기
		$sudo free
		
	cf)	setenv bootargs			-> bootargs라는 설정이 제거됨
									(setenv name -> name 이라는 환경변수 삭제)
									(setenv name value -> name 이라는 환경변수값 변경)									
		saveenv					-> 저장
		print					-> 환경 설정 사항 보기

		ex)
		#print
		..................
		bootdelay=3
		..................
		
		#setenv bootdelay 5
		#saveenv
		#reset
		
	cf)	한글 문서가 깨지는 경우 해결 방법
		1.	Visual Studio 로 해당 문서를 열어서
			저장 고급 옵션 -> 한국어-코드 페이지 949(MS-949)를 선택해서 저장 하면
			Source Insight, AcroEdit, Eclipse에서 한글 문서가 모두 깨지지 않고 출력 됨
			cf)	Source Insight
				->	UTF-8 지원하지 않음, MS-949 지원 함, cf) Source Insight에서 한글 깨질 때 -> Korea ANSI 949(?)로 설정하면 안 깨짐
				AcroEdit/Visual Studio/Eclipse
				->	모두 지원

	cf)	리눅스에서 라즈베리파이 SD CARD 백업하고 복원하기 
		1. 리눅스에 카드를 넣는다.
		2. 어떤 카드인지 확인
		sudo dmesg | tail
		나는 sdb1으로 확인이 되었다. 하부 파티션이므로 sdb1 이더라도 sdb로 사용한다. 숫자1은 뺀다.
		3. 이미지를 복사한다.
		a> 첫번 째 방법, 압축없이, 편의상 홈폴더(~/)에 한다.
		sudo su
		dd bs=4M if=/dev/디스크(번호없이) | pv | dd of=~/파일.img
		a> 복원하기
		sudo su
		dd if=~/파일.img |pv| dd bs=4M of=/dev/디스크(번호없이)
		
		b> 두 번째 방법, 압축해서 복사, `date +%d%m%y`은 날짜를 자동으로 입력해 주는 스크립트다.
		sudo su
		dd bs=4M if=/dev/디스크(번호없이) | gzip > ~/파일이름`date +%d%m%y`.gz
		b> 복원하기
		sudo su
		gzip -dc ~/이미지.gz |pv| dd bs=4M of=/dev/디스크(번호없이)

	cf)	ext1, ext2, ext3, ext4
		ext1	초창기 파일시스템으로 오류가 많다
		ext2	ext1의 많은 버그 등이 해결된 버전
		ext3	ext2에서 개선된 버전으로 ext2 파일 시스템을 자료 손실 없이 ext3 파일 시스템으로 바꿀 수 있다
		ext4	최근 파일시스템으로 큰 파일(16TB)까지 지원 가능하고 ext2, ext3와의 호환성이 어느 정도 가능하며 Extends 방식이 가능 하고
				온라인 조각 모음 기능을 지원 함

	cf)	디렉토리 기능 및 내용
대부분의 리눅스는 FHS(Filesystem Hierarchy Standard) 표준 파일 시스템 계층을 사용하고 같은 목적의 파일들은 같은 장소에 일관되게 모아 관리하므로 시스템에 자원이나 프로그램들을 쉽게 찾을 수 있다. 
◎ /
루트 디렉토리라고 부르는 리눅스 시스템에서 가장 최상위 디렉토리며 디렉토리 구조의 시작이다. 시스템관리자의 홈인 /root와는 다르다. / 디렉토리 아래에 /bin, /etc, /boot, /mnt, /usr, /lib, /home, /dev, /proc, /var, /sbin, /tmp, /root, /lost+found 등의 디렉토리가 존재한다. 
◎ /bin
binaries의 약어로 이진 파일들이며 리눅스에서 가장 기본이 되는 명령어들이 모여 있는 디렉토리이다. 디렉토리의 파일들을 보면 대부분이 실행 파일임을 알 수 있다. 또한 이곳에는 부팅에 필요한 명령어들이 위치하여 부팅후에 시스템의 계정 사용자들이 사용할 수 있는 일반적인 명령어들도 위치 하고 있다. 
◎ /etc
이 디렉토리는 리눅스 시스템에 관한 각종 환경 설정에 연관된 파일들과 디렉토리들을 가진 디렉토리이다. 대부분의 이 디렉토리의 파일들은 시스템 관리자에 의해 관리되는 파일들이다. 웹 서버 환경 설정, 시스템 계정 사용자 정보, 패스 워드 관리, 시스템의 파일 시스템 관리 파일, 여러가지 시스템 보안에 관련된 파일들, 시스템 초기화 설정 파일, TCP/IP 설정 파일 등 시스쳄 전반에 걸친 거의 모든 환경 설정 파일들이 모두 이 디렉토리에 있다. 
◎ /etc/rc.d
시스템의 부팅과 시스템 실행 레벨 변경시에 실행되는 스크립트들이 저장되어 있는 디렉토리이다. 리눅스의 6가지 실행 레벨로 각각의 해당 디렉토리가 있다. 
◎ /etc/shadow
파일에서 패스워드 부분만을 따로 저장하는 파일이다. 이 파일에 패스워드는 암호화 되어 셰도우 패스워드 형태로 저장되어 있으며 시스템 관리자만이 접근할 수 있기 때문에 크래킹 등에 대한 우려가 상대적으로 적다. 
◎ /etc/group
시스템의 그룹에 대한 정보를 저장하고 있는 파일이다. 
◎ /etc/inittab
init를 설정하는 파일이다. 
◎ /etc/issue, /etc/issue.net
getty에 의해서 로그인을 위한 프롬프트가 뜨기 전에 출력되는 메시지를 설정하는 파일이다. 리눅스 시스템으로 접속할 경우 가장 처음으로 볼 수 있는 메시지이다. 보통 시스템에 대한 설명과 각종 환영 메시지를 전달하기 위해서 사용된다. issue 파일의 내용은 보통 시스템의 터미널에서 볼 수 있다. 그리고 /etc/issue.net 파일의 내용은 리모트상에서 시스템으로 접속할 경우 볼 수 있다. 
◎ /etc/motd
'Message of the day'의 약자로 시스템으로의 접속에 성공할 경우 쉘이 뜨기 전에 출력되는 메세지를 설정하는 파일이다. 
◎ /etc/profile, /etc/csh.login, /etc/csh.cshrc
시스템이 시작될 때 사용자가 로그인을 할 때 본쉘이나 C쉘에 의해서 실행되는 스크립트 파일이다. 일반적으로 사용자들에 대한 기본 환경 설정에 사용된다. 
◎ /etc/securetty
시스템 관리자가 시스템에 로그인할 수 있는 안전한 터미널에 대한 정보가 저장되어 있다. 일반적으로 가상콘솔이 설정되어 있다. 이것은 네트워크를 통해 시스템으로 침입해 시스템 관리자의 권한을 획득하는 크랙킹을 막기 위해서이다. 
◎ /ete/shell
시스템에서 안정적으로 사용할 수 있는 쉘에 대한 정보를 저장하고 있는 파일이다. 만약 chsh명령을 사용해 사용중인 쉘을 바꾸려면 이 파일에 저장되어 있는 쉘중에 선택해야한다. 또한 ftp데몬의 경우 사용자의 쉘을 검사하여 /etc/shell에 저장되어 있지 않은 쉘을 사용한다면 로그인을 허용하지 않는다. 
◎ /boot
리눅스 커널이 저장되어 있는 디렉토리로서 각종 리눅스 boot에 필요한 booting지원 파일들이 저장되어 있는 디렉토리이다. 
◎ /mnt
외부 장치인 플로피 디스크, 시디롬, 삼바등을 마운트하기 위해서 제공되는 디렉토리이다. 임시로 사용되는 디렉토리이므로 프로그램들은 /mnt에 어떤 파일 시스템이 마운트 되었는지 자동으로 인식하지 않는다. 또한 /mnt는 보통 여러 개의 하위 디렉토리로 나누어 사용되고, 평소에는 각 디렉토리들은 비어 있다. 
◎ /usr
시스템에 사용되는 각종 프로그램들이 설치되는 디렉토리이다. 프로그램과 관련된 명령어 미치 라이브러리들이 이 디렉토리에 위치 하게 된다. 또한 X 시스템관련 파일들과 리눅스 커널 소스, 각종 C언어 과련 해더 파일 등도 이 디렉토리 안에 저장되어 있다. 
◎ /usr/bin
리눅스 시스템에서 사용되는 각종 프로그램들이 저장되어 있으며 /bin 디텍토리에 없는 다양한 실행 파일들이 저장되어 있는 디렉토리이다.
◎ /usr/X11R6
X 윈도우 시스템에 사용되는 모든 파일들이 이 디렉토리 안에 저장된다. 이 디렉토리는 X 윈도우 시스템의 개발과 설치를 좀더 쉽게 하기 위해서 전체 시스템 디렉토리 구조에 통합되지 않고 독자적인 구조를 가진다. 
◎ /usr/etc
/etc 디렉토리에는 각종 환경 설정 파일들이 있듯이 이곳에도 여러 가지 시스템 환경 설정 파일들이 저장되어 있다./usr/etc의 파일들은 /etc디렉토리 안의 파일들과 달리 꼭 팔요한 파일들은 아니다. 
◎ /usr/sbin
시스템 관리자를 위한 명령어들이 저장되는 디렉토리이다. 보통 이 디렉토리의 명령어들은 루트 파일 시스템에는 필요가 없는 서버 프로그램들이 저장된다. 
◎ /usr/include
C언어 관련 해더 파일드이 저장되어 있는 디렉토리이다. 
◎ /usr/lib
각종 라이브러리들이 저장되어 있는 디렉토리이다. 만약 사용자가 직접 작성한 프로그램을 컴파일한다면 해당 프로그램은 /usr/lib 디렉토리의 파일에 link된다. 또한 이 라이브러리 안에 실행 코드가 필요하다면 /lib 디렉토리를 참조한다. 
◎ /usr/local
시스템의 특정적인 프로그램들이 저장되는 디렉토리이다.특정적인이란 시스템 관리자에 의해서 따로 설치되는 프로그램들을 말한다. 
◎ /usr/man
man페이지의 실제 내용들이 저장되어 있는 디렉토리이다. 디렉토리를 살펴보면 man1, man2, man3, 등과 같이 여러개의 디렉토리들로 나누어져 있는 모습을 볼수 있다.man1 디렉토리는 섹션 1의 man 페이지 소스를 위한 디렉토리를 말한다. 
◎ /usr/src
시스템에서 사용하는 각종 프로그램들의 컴파일되지 않은 소스 파일들이 저장되어 있다./usr/src/linux 디렉토리가 바로 리눅스의 커널소스를 저장하고 있는 디렉토리이기 때문이다. 
◎ /usr/X386
/usr/X11R6 디렉토리와 유사한 티렉토리로 X11 Release 5를 위한 디렉토리이다. 
◎ /usr/info 
GNU info문서들을 저장하고 있는 디렉토리이다. 
◎ /usr/doc
각종 문서들이 저장되어 있는 디렉토리이다 
◎ /lib
프로그램들의 각종 라이브러리들이 존재한다. 대부분 공유 라이브러리로 더 편하게 사용할 수 있으며,파일의 크기를 줄여서 실행할 때 불러 사용하게 된다. /lib/modules 디렉토리에는 커널로 로딩 사능한 커널 모듀들이 저장되어 있다. 
◎ /home
시스템 계정 사용자들의 홈 디렉토리와 ftp,www,등과 같은 서비스 디렉토리들이 저장된다. 이곳의 디렉토리와 파일들은 시스템에서 상용되지 않는다. 단지 리모트상에서 시스템으로 접속하는 사용자들을 위한 공간이다. 
◎ /dev
디렉토리에는 시스템의 각종 디바이스들에 접근하기 위한 디바이스 드라이버들이 자장되어 있는 디렉토리이다. 이 디렉토리는 물리적인 용량은 갖지 않는 가상 디렉토리이다. 대표적으로는 하드 드라이브,플로피, 씨디롬 그리고 루프팩장치 등이 존재한다. 리눅스 시스템은 윈도우와 달리 각종 디바이스 장치들을 하나의 파일로 취급한다. 따라서 시스템은 각각의 장치들로부터의 정보를 /dev 디렉토리에 존해하는 해당 장치 파일로 부터 가지고 온다. 
◎ /dev/console
시스템의 콘솔이다. 
◎ /dev/hda
시스템의 하드 디스크이다. 여기서 /dev/hda는 첫 번째 하드 디스크를 의미하는 것이다./dev/hda1은 첫번째 하드 디스크의 첫번째파티션,/dev/hda2 두 번째 파티션등을 의미한다.만약 시스템에 여러 개의 하드 디스크가 부착되어 있다면 /dev/hdb,/dev/hdc 등의 파일도 /dev/hdb1,/dev/hdb2등과 같은형식으로 저장되어 있다. 
◎ /dev/lp
시스템의 병렬 포트 장치들이다. 
◎ /dev/null
이 디렉토리는 블랙홀이라고도 부르는 특별한 장치이다. 이 장치로 데이터 등을 보내면 모두 폐기되므로 주의해야 할 것이다. 
◎ /dev/pty
시스템으로의 원격 접속을 위한 'pesudo-terminal'들이다. 만약 시스템 계정 사용자드이 원격지에서 시스템으로 텔넷등을 이용하여 시스쳄에 접속을 시도한다면 이들은 /dev/pty 디바이스들을 사용하게 되는 것이다. 
◎ /dev/sda
SCSI 장치들이다. 만약 시스템에 스카시 하드 디스크를 장착했다면 시스템은 /dev/sda파일에서 정보를 얻어 장치에 접근할 것이다. 
◎ /dev/ttyS,/dev/cuaS
/dev/ttyS은 직렬포트 장치들이고, /dev/cauS는 Callout. 장치이다. 
◎ /dev/tty
시스템의 가상콘솔들이다. 이 가상 콘솔의 기능은 하나의 화면에 여러 개의 콘솔들을 만든다. 만약 사용자가 시스템 앞에 앉을 수 있다면,Alt + F1, Alt + F2등을 이용하여 리눅스에 제공한 여러개의 가상 콘솔을 직접 볼수 있을 것이다. 
cf)	com1  :  /dev/ttyS0
    com2  :  /dev/ttyS1
    com3  :  /dev/ttyS2
    com4  :  /dev/ttyS3
예를들어 minicom에서 셋업에 아래 부분이 있다. 
   A - Serial Device : /dev/ttyS1 -> 여기에 /dev/ttyS1 은 com2를 가르킨다.
◎/proc
시스템의 각종 프로세서, 프로그램 정보 그리고 하드웨어적인 정보들이 저장된다. 이 티렉토리는 가상 파일 시스템으로 가상 파일 /dev와 마찬가지로 하드 디스크상에 물리적인 용량을 갖지 않는다. 즉 디렉토리에 존재하는 파일들은 실제 하드 디스크에 저장되지 않고 커널에 의해 메모리에 적재 된다. 디렉토리 안의 파일들은 현재의 시스템 설정을 보여 주는 것이다. 
◎ /proc/1
프로세스 번호가 1인 프로세스에 대한 정보를 저장하는 디렉토리이다. 다른 프로세스들도 자신의 고유한 프로세스 번호의 디렉토리를 가진다는 것을 의미한다. 
◎ /proc/cpuinfo
프로세서의정보를 저장하고 있는 파일이다. cpu의 타입, 모델, 제조회사, 각종 성능 등의 정보를 제공하여 준다. 
◎ /proc/devices
현재 시스템 커널에 설정되어 있는 장치들에 대한 정보를 저장하고 있다.파일등의 정보로 모든 시스템의 장치 목록에 대한 정보를 얻을 수 있다. 
◎ /proc/dma
현재 시스템에서 사용하고 있는 DMA 채널에 대한 정보를 저장하고 있다. 
◎ /proc/filesystem
시스템에 설정되어 있는 파일 시스템에 대한 정보를 저장하고 잇는 파일이다. 
◎ /proc/interrupts
현재 사용중인 인터럽트와 인터럽트의 사용량에 대한 정보를 저장하고 있는 파일이다. 
◎ /proc/ioports
현재 사용중인 I/O 포트에 대한 정보를 저장하고 있는 파일이다. 
◎ /proc/kcore
현재 시스템에서 사용중인 메로리의 실제 이미지이다. 이 파일은 실제 메모리의 내용을 모두 가진 것처럼 보이지만 프로그램이 필요로 하는 부분의 이미지만을 필요할 때 만들어 제공한다. 
◎ /proc/kmsg
커널에 의해서 출력되는 메시지들을 저장하고 있는 파일이다.이것은 또한 syslog파일에도 저장된다. 
◎ /proc/loadavg
현재 시스템의 평균 부하량(Load Average)에 대한 정보를 저장하고 있는 파일이다.이 파일을 통해서 시스템이 현재 수행해야 하는 일이 얼마나 많은지를 알려주는 3가지 지표에 대한 정보를 얻을 수 있다. 
◎ /proc/ksyms
시스템 커널이 사용하고 있는 심볼들에 대한 정보를 저장하고 있는 파일이다. 
◎ /proc/meminfo
현재 시스템이 사용중인 메모리의 사용량을 저장하고 있는 파일이다./proc/meminfo에서 실제 메모리는 물론 가상 메모리에 대한 정보도 얻으 수 있다. 
◎ /proc/self
이 디렉토리를 보고 있는 프로그램 자시의 프로세스 디렉토리로 링크도어 있다. 만약 서로 다른 2개의 프로세스가 /proc 디렉토리를 보고 있다면 두 프로세스는 서로 다른 링크를 보게 된다. 이를 통해서 프로그램들이 자신의 프로세스 디렉토리를 쉽게 찾을 수 있다. 
◎ /proc/stat
시스템의 현재 상태에 대한 다양한 정보를 저장하고 있는 파일이다. 
◎ /proc/uptime
시스템이 얼마나 오래 동작했는지에 대한 정보를 저장하고 있는 파일이다. 
◎ /proc/version			-> ex) cat /proc/version
시스템이 현재 사용중인 커널 버전에 대한 정보를 저장하고 있는 파일이다. 
◎ var
시스템에서 사용되는 동적인 파일들이 저장된다. 각종 시스템 로그 파일, 사용자 로그인에 대한 보안기록,메일서버를 운영한다면 사용자들에게 전송된 메일들을 임시로 저장한다. 
◎ /var/cache
포멧된 메뉴얼 페이지들이 잠시 대기(Cache)하기 위한 디렉토리이다. 
◎ /var/lib
시스테이 동작하면서 계속 수정되고 변경되는 파일들을 위한 디렉토리이다. 
◎ /var/local
/usr/local 디렉토리에 설치된 프로그램들의 각종 데이터들이 저장되는 디렉토리이다. 
◎ /var/lock
잠금 파일들이 저장되는 디렉토리이다.프로그램들이 특정한 장치나 파일들을 프로그램 자신이 독점적으로 사용하려 할 때 /var/lock 디렉토리에 잠금 파일을 만들어 사용하게 된다. 그렇기 때문에 다른 프로그램들은 장치나 파일을 사용하기 전에 우선 이 디렉토리의 내용을 조사하여 해당 장치나 파일들이 사용중인지 확인하게 된다. 
◎ /var/log
프로그램들의 로그 파일들이 저장되는 디렉토리이다. 이 디렉토리에 wtmp파일은 login 파일과 messages파일은 syslog의 로그 파일이다.wtmp는 시스쳄의 모든 사용자 로그인과 로그 아웃에 대한 정보르 저장하고 있는 파일이고,messages는 커널과 시스템의 모든 출력 메세지를 저장하고 있는 파일이다./var/log 안의 파일들은 시스템의 사용량에 따라 그 크기가 무한대로 증가할 있으므로 정기적으로 파이들을 삭제하는 등 디렉토리 관리가 필요하다 
◎ /var/run
시스템의 현재 정보들을 저장하고 있는 디렉토리이다./var/run/xinetd.pid 파일의 경우 현재 사용중인 xinetd 데몬의 프로세스 번호를 저장하고 있다. 
◎ /var/spool
메일이나 뉴스, 프린터 큐 등고 같은 시스템상에서 대기 상태에 있는 작업들을 위한 디렉토리이다. 각각의 대기 작업들은 모두 /var/spool 아래 고유의 디렉토리에 위치하게 된다. 예를 들어 시스템의 계정 사용자들의 메일은 /var/spool/mail 에 저장된다. 
◎ /var/tmp
/tmp에 저장된 임시 파일들중에 오래 보관되어야 할 임시 파일들이 저장되는 디렉토리이다. 
◎ /tmp
이름에도 알 수 있듯이 임시 파일들을 위한 디렉토리이다. 
◎ /root
시스템 관리자의 홈 디렉토리이다


아키텍트를 꿈꾸며 - 에코지오
태그방명록
--------------------------------------------------------------------------------
[안드로이드] 시스템 분석을 위한 쉘 명령어(shell)
Android 2010/03/19 19:04 
안드로이드 시스템 분석에 사용할만한 shell 명령을 알아보자. 

시스템 기본 정보: 하드웨어, 커널 등

cat /proc/version : 커널 버전, cf) vi kernel/Makefile
cat /proc/cpuinfo : 프로세서 정보. CPU 타입, 모델, 제조사 등
cat /proc/meminfo : 메모리 정보. 실제 메모리 및 가상 메모리
cat /proc/devices : 현재 커널에 설정되어 있는 장치 목록
mount : 마운트된 모든 장치 정보
df : 하드디스크 사용량
cat /proc/filesystems : 커널에 설정되어 있는 파일시스템 목록
cat /proc/swaps : 스왑 파티션의 크기와 사용량
cat /proc/interrupts : 장치가 사용중인 인터럽트(IRQ) 목록 표시
cat /proc/ioports : 현재 사용중인 Input/Output 포트
cat /proc/loadavg : 시스템의 평균부하량
cat /proc/partitions : 파티션 정보
cat /proc/uptime : 시스템이 얼마나 살아있었는지.
cat /proc/stat : 시스템 상태에 관한 다양한 정보. CPU 사용통계, 부팅이후 page fault 발생횟수 등
cat /proc/zoneinfo : ZONEINFO ?
dmesg : 시스템 부팅시 나왔던 메시지
 ps : 실행중인 프로세스 정보
ps -p -t : 프로세스와 쓰레드 목록
set 또는 printenv : 환경설정값 출력

시스템 리소스 사용 현황

vmstat : 시스템의 리소스 상황 모니터링. CPU, I/O, 메모리 등
cat /proc/diskstats : 디스크 utilization과 throuthput. 즉 디스크 IO 현황
top : 시스템의 프로세스 상황 모니터링. 프로세스별 CPU 사용량, 메모리와 스왑 사용량 등
procrank : 프로세스별 메모리(VSS,RSS,USS, PSS)
dumpsys meminfo [PID] : 해당 프로세스의 메모리 상세 정보
cat /proc/[PID]/stat : 해당 프로세스에 대한 정보. 시작시간, 상태, CPU 사용량 등
cat /proc/[PID]/maps : 해당 프로세스의 메모리 맵 정보
cat /proc/vmstat : 버추얼 메모리 통계?
librank : 라이브러리별 메모리 사용량?

네트워크 관련

cat /proc/net/netlink : 네트워크 정보
netcfg : 네트워크 인터페이스와 IP주소 목록
netstat : 네트워크 연결상태 확인
nc : 네트워크용 cat 명령어(netcat)
ifconfig : 네트워크 인터페이스 설정 정보. 장치명을 파라미터로 받음. IP 주소, 서브넷마스크 등
tcpdump : 실시간 패킷 모니터링
iftop : 네트워크를 위한 top
route : 해당 호스트까지 연결하는 중간 경로 정보인 라우팅 테이블 표시
ping : 원격 호스트와의 연결 테스트
cat /proc/net/route : Routes

안드로이드 제공

vi build/core/version_defaults.mk : 안드로이드 Platform version 확인(ex, PLATFORM_VERSION := 4.4.2)
logcat : 로그캣 보기
pm : package manager의 약자. 패키지/permission/instrumentation/feature 목록, 패키지 설치/제거 등
am : activity manager의 약자. 액티비티 시작, Intent 브로드캐스팅, Instrumentation 시작, profiling 시작/중지 등
service : 안드로이드 서비스 목록 표시, 서비스에 명령 전달
monkey : 애플리케이션에 랜덤 이벤트 발생시킴. 사용자 이벤트, 시스템 이벤트의 무작위 발행
cat /data/anr/traces.txt : VM TRACES (쓰레드 덤프)
cat /proc/binder/proc/[PID] : 바인더 프로세스 상태
cat /proc/binder/xxx : 바인더 관련 정보(xxx는 transactions, transaction_log, failed_transaction_log, stats 등)
cat /data/system/packages.xml : 설치된 패키지 세팅 정보
setprop : system property 세팅
getprop : 세팅된 system property 목록 출력


종합 리포트
dumpsys [service]: app/service 상태정보 덤프. 서비스별로 추가 파라미터 받을 수 있음
dumpstate : device 상태정보 덤프(cpu,mem,ps 등). 상태정보를 추출하는 여러 명령어들의 조합으로 구성
dumpcrash : 애플리케이션이 crash될 때의 상태정보 덤프?
bugreport : logcat+dumpsys+dumpstate

그밖에...
그밖의 안드로이드 shell 명령어는 /system/bin 및 /system/xbin을 뒤져보면 많이 나온다. 이제 남은 일은 찾아낸 명령어의 사용법, 출력결과를 어떻게 해석할지, 어떤 상황에서 이들을 활용할지 사례조사, 그리고 직접 활용해보는 것일게다.

	cf)	Linux software
	1)	QT (소스 수정없는 any platform용 GUI 개발을 위한 위젯 툴킷)| Unix To Linux 
이누기 | 조회 187 |추천 0 | 2009.09.03. 13:23 
 
http://ko.wikipedia.org/wiki/Qt_(%ED%88%B4%ED%82%B7)

컴퓨터 프로그래밍에서 Qt는 GUI 프로그램 개발을 위한 크로스 프랫폼 위젯 툴킷이다
Qt는 크로스 플랫폼 어플리케이션과 UI 개발을 위한 통합 프레임워크입니다 
Qt를 이용하여 어플리케이션과 사용자 인터페이스를 한번 개발할 시 소스 코드를 수정하지 않고 Windows, Mac, Linux/X11, 임베디드 Linux, Windows CE, 그리고 곧 지원된 S60에까지 동시에 탑재할 수 있습니다. 

리눅스나 유닉스에서 X-Window용 프로그램을 개발하려면 많은 지식이 필요합니다. 이를 보완하기 위해 
많은 것들이 나왔지만 그 중에서 대표적인 것이 KDE에서 사용하는 Qt와 GNOME의 GTK+ 툴킷입니다. 
이 외에도 많은 사람들이 들어 보았을 만한 것들을 열거하면 Python, LessTif,Motif,tk등이 있습니다. 
 
KDE는 리눅스의 데스크탑 환경에서 GNOME과 함께 두가지 흐름 중의 한 줄기로 거대한 응용프로그램들과 
라이브러리의 집합체 입니다. KDE는 단순한 윈도우 매니저 수준을 넘어서 완전한 데스크탑 환경을 제공하기 
때문에 콘솔 환경에 익숙하지 않은 많은 사용자들을 리눅스 환경으로 불러들였습니다. KDE는 Troll Tech사에서 
만든 Qt라는 라이브러리를 사용했습니다. 하지만, Qt는 라이센스 문제가 있었습니다. 이는 Qt 프로그램이 GPL을 
따르지 않고, Qt의 소스를 함부로 고칠 수 없었기 때문입니다. 따라서, GPL만을 고집하는 개발자들은 완전히 
자유로운 환경의 프로젝트를 생각하게 되었으며, 이런 이유로 만들어진 것이 GNOME(GNU Network Object Model Environment) 프로젝트입니다. 
 
GNOME은 Gimp를 사용하면서 GTK+ 라이브러리를 사용합니다. GTK+는 Qt에 비해 시작이 늦고 C로 구성되었다는 
단점이 있었지만, 최근엔 GTK--라는 C++ 버전이 등장할 정도로 빠른 속도로 개발되고 있습니다. 
한편 GPL을 요구하는 개발자들의 항의를 받은 Qt는 2.0버전부터 QPL(Qt Public License)를 도입하여 Qt 라이브러리의 수정을 가능하게 했습니다. 
하지만 여전히 Qt 상용 버전을 구입해야만 상용 프로그램을 개발 가능합니다. 
 
Qt는 Troll Tech에서 개발한 X윈도우, MS윈도우의 GUI의 프로그램을 개발하기 위한 라이브러리로 지원하는 플래폼은 다음과 같습니다. 
Microsoft Windows 95/98, NT,Solaris, SunOS, HP-UX, Digital UNIX(OSF/1), Irix, BSD/OS, SCO, AIX, Linux, FreeBSD 
 
Qt는 다음과 같은 특징이 있습니다. 
 
C++기반 
Qt는 C++로 만들어졌습니다.  따라서 기존의 C 개발 방식에 비해서 훨씬 쉽고, 기능 확장이 편리해서 생산성이 높습니다. 
객체 지향  
- Qt 라이브러리는 모듈화와, 구성물을 재활용 가능하도록 초점을 맞춰서 설계되었습니다. 
멀티 플랫폼 
- Qt는 앞서 살펴본 것과 같이 MS윈도우에서 유닉스까지 다양한 플랫폼을 지원하므로, 플랫폼을 바꾸더라도 소스를 
  수정해야 하는 번거로움이 줄어듭니다. 
Signal & Slot 
- Signal & Slot은 Qt에서 제공하는 이벤트 처리 모델입니다. 이것을 사용해서 객체 간의 통신이 가능하고, 복잡한  
   Callback 함수를 만드는 부담을 줄일 수 있습니다. 
국제화 
- Qt는 16비트인 유니코드를 완벽히 지원합니다. 또한 다양한 ISO 변환 규격과 지역화(Localization)를 지원합니다. 
   인 터페이스에 사용되는 모든 문장은 메시지 변환 테이블을 통해 해당 지역 언어로 바꿀 수 있습니다. 
풍부한 API 
- Qt는 250여개의 C++ 클래스를 지원하며 각 클래스에는 GUI를 위한 함수와 템플릿 기반의 collection, serialization,
   파일, I/O 장치, 디렉토리 관리 및 다양한 종류의 API를 지원합니다. 
안정성 
- Qt는 Troll Tech에서 모든 것을 관리하므로, 공개된 다른 X 툴킷에 비해 훨씬 안정적입니다. 또한 Qt 2.0부터는 CVS
   에  등록되어 관리되기 때문에 개발중인 Qt 소스를 그대로 받아볼 수도 있습니다. 
 
최근에는 임베디드 시스템의 UI로 많이 각광을 받고 있습니다. MFC에 익숙한 윈도우 개발자에게 QT는 새로운 도전입니다. 
MFC보다도 구조적으로 잘 설계되어있고 개발 하기 쉽게 구현된 앞으로도 계속 사랑받는 library가 될 것입니다. 
본 과정은 QT라이브러리 사용보다는 전체적인 구조와 원리에 초점이 맞춰져 있습니다. 윈도우 프로그램이 가져야 하는 이벤트 처리와 화면의 미세한 처리들을 함께 연구해 보도록 합니다. 
또한 open source 진형 에서 사용되는 GTK의 구현 원리와 동작도 함께 살펴 볼 것입니다. 
 
- Linux 매니저 -
[출처] Linux QT & GTK 프로그래밍 (내가 프로그래밍을 정복한다.)

http://qt.nokia.com/title-ko?set_language=ko&cl=ko

	cf)	임베디드 리눅스의 GUI에 대한 초보적인 질문을 드리려고 합니다.
DVR 개발에 대한 질문인데요
(실시간 영상을 화면을 출력하고, 해당 어플리케이션을 띄우는 것입니다..^^)

어떤 GUI를 사용하는 것이 가장 최적일까요?
---------GUI툴킷-----------
QTE
Qutopia
GTK+
SDL
Microwindows
miniGUI
SDL
GTKFB
PicoGUI, ParaGui, Tiny-X, wGui... 등등

	cf)	Embedded OS 개발 환경
		1)	Android + eclipse			cf)	Google이 Java의 Oracle에 패소하면서 License 정책이 바뀔 가능성 있음 -> 업체도 Oracle에 로열티를 내야할 수 있음
		2)	QT + Python
			QT License fee
			가)	QT개발환경 : 200만원
			나)	4$/1ea(제품 1개당, 단 1년 12만개 기준)
		3)	Mono + Visual C#
		4)	JAVA(Swing) or JAVA FX

	cf)	Embedded OS H/W(CPU)
		1)	Freescale -> NXP로 넘어감	cf)	10년 life warranty
		2)	TI							cf)	10년 life warranty
		3)	Samsung
		4)	Raspberrypi

	cf)	Qt 4.8 Embedded Linux 
수문장 [iskim71]  227 읽음    2014-02-23 13:55 
안녕하세요. 맨날 눈팅만 하는 수문장 입니다. 

Qt와 관련해서 경험자 분들의 도움을 부탁드릴 일이 생겼네요. 
Q&A에 질문해야 하지만, Qt와 관련된 포럼이 없는 관계로 일반 게시판에 글을 올리게 된 점, 먼저 양해를 구합니다. 

Qt... 이 넘도 참 운명이 기구하더군요. 
트롤테크에서 노키아에서 이제는 디지아라는 회사로 License 사업권이 넘어간것으로 압니다. 

2009년인가? 노키아에서 Qt 4.5 부터 embedded Linux를 포함하여 LGPL로 전환된다는 기쁜 소식이 있었습니다. 
그리하여 노키아 홈페이지에서 다운받아 이리저리 테스트 해보고, 쓸만하다 싶어 라이센스에 대해 
Qt 디지아 측과 이야기를 해보니, 이상한 소리를 합니다. 

정리해보면 다음과 같습니다. 

Qt 는 크게 상용버전과 LGPL 버전으로 나누어진다.(머.. 알고 있는 내용이고) 

<상용버전> 
Qt Creator 즉, 개발자 라이센스를 구입하면, 개발되는 모든 결과물을 데스크탑을 포함한 정형화된 OS에 배포하는 것에 
대해 완전한 권리를 가진다. 
Embedded 장비에 배포할 경우 Qt Runtime 라이센스가  필요하고, 이때에는 Volume에 따라 가격이 책정된다. 

요기까지는 문제 없죠...  문제는 다음 부터입니다. 

<Qt LGPL> 
Qt LGPL로 개발해서 Embedded 장치(Embedded Linux)에 배포할 경우에는 Qt Runtime 라이센스를 구매해야 한다. 
Qt Runtime 라이센스를 구매하지 않으려면 소스를 오픈해야 한다. 

즉, Qt 소스를 수정하던 말던, Qt를 이용하여 개발 하고, Embedded Linux에서 사용할꺼면 소스를 까던가 돈을 내라는 
소리입니다. 

Qt LGPL 정책이 디지아에 넘어가면서 바뀐걸까요? 

혹시 이에 대해 경험이 있으시거나, 관련된 내용을 알고 계신분들에게 우매한 중생이 가르침을 부탁드립니다. 

	cf)	Q1) LGPL이나 상용이나
글쓴이: peremen 작성 일시: 월, 2010/10/04 - 5:04오후
Q1) LGPL이나 상용이나 소스 코드를 공개할 의무는 없습니다. 단 LGPL 이용 시 Qt를 스태틱 링크로(.so 파일을 사용하지 않고 프로그램 실행 파일에 포함시켜서) 배포한다면 프로그램 소스를 공개해야 합니다. LGPL 이용 시 다이나믹 링크로 배포하는 경우 Qt 소스를 수정했다면 Qt 소스만 배포하면 됩니다. LGPL을 사용하는 경우, 제품 설명서 맨 끝쪽 and/or 정보 같은 곳에 LGPL 라이브러리를 사용했음을 명시해야 합니다. 상용의 경우 설명한 모든 의무가 없습니다.

Q2) LGPL은 돈 낼 필요가 없습니다. 상용 Qt 라이선스는 개발자 및 플랫폼당으로 가격을 매깁니다. Qt 데스크톱 프로그램을 짠다면 이외 추가 지불은 없으나 임베디드 프로그램을 짠다면 런타임 배포 라이선스 비용이 적용될 수도 있습니다.

Q3) 4.x 초기 버전에는 상용 Qt의 경우 윈도 환경에서 ActiveX를 Qt 개체로 래핑해서 쓸 수 있는 ActiveQt 지원이 상용 버전에만 들어갔고, 비주얼 스튜디오 통합 기능이 거의 대부분의 차이였으나, 현재는 오픈소스 에디션에서도 ActiveQt를 사용할 수 있습니다. LGPL 공개 이후 모듈 차이는 없다고 보면 되지만, 상용 Qt는 에디션이 여러 가지로 나뉘어 있으므로 주의해야 합니다.

자세한 사항은 http://qt.nokia.com/products/licensing 페이지, 라이선스 가격을 알아보려면 http://shop.qt.nokia.com/ 페이지를 참고하세요.

---- 절취선 ----
http://blog.peremen.name

	cf)	KDevelop
		KDE 프로젝트의 하나로 KDE 애플리케이션 개발을 위해 만들어진 IDE이다,
		C++, Java, Ruby 등 다양한 언어를 지원하며 현재 리눅스에서 돌아가는
		공짜 C++ IDE 중 가장 완성도가 높다.(Java는 이클립스가 있으니까)

	cf)	Virtual Box
		1)	중요) Virtual Box 설치한 상태에서 HAMAMATSU(C10066) 프로그램을 설치하면 Virtual box 가 실행되지 않는 심각한 문제 발생함(COM 호출 중지 에러)
			cf)	OS : Windows 10 64bits이고 BIOS에서 Virtualize & VT-d 모두 enable 시켰어도
			Virtual Box에서 가상OS설치할 때 64Bits 가상OS를 선택할 수 없는 문제는
			HOST Windows 10에 Hyper-V라는 프로그램이 깔려 있어서 그렇다(Hyper-V도 가상 OS를 설치해주는 프로그램 임)
			cf)	Hyper-V가 사용하도록 설정된 경우 VirtualBox 및 VMWare에서 가상머신을 생성할 때 64-bits 모드가 활성되지 않음
				해결 방법은 제어판 -> "프로그램 및 기능" -> "Windows 기능 켜기/끄기"에서 Hyper-V를 해제하는 것 뿐
				cf)	Hyper-V 가 VirtualBox 및 VMWare 보다 디스크I/O 성능을 포함해서 월등하게 성능이 좋다고 함
		2)	Virtual Box -> Ubuntu 설치 후 -> Booting 시 "vmwgfx error~" 에러 발생 제거 방법
			Virtual Box -> 설정 -> 디스플레이
				-> 	비디오 메모리 : 64MB
				->	Graphics Controller : VBoxVGA 로 변경 함
		
	
	cf)	Hyper-V 에 가상 OS 설치 방법
		1)	새로 만들기 -> 새 가상 하드 디스크 마법사 -> 고정 크기 -> *.vhdx 파일 만들기
		2)	새로 만들기 -> 가상컴퓨터 -> 상기 1)번에 만들었던 *.vhdx 파일 선택해서 가상 OS 설치
				
	
	1)	Ubuntu 공유 폴더
		가)	방법1
			sudo mount -t vboxsf D_DRIVE /media/sf_D_DRIVE
		나) 방법2
			a)	Virtual Box	->	게스트 확장 설치(cf, 저장소에 VBoxGuestAdditions.iso가 이미 들어가 있는 경우는 본 파일을 삭제 시키고서, 게스트 확장을 설치 함)
			b)	Virtual Box	->	공유폴더 설정
			c)	reboot
			d)	/media/ 폴더에
				EX)	sf_C_DRIVE,	sf_D_DRIVE 폴더 형식으로 공유 폴더 생성되어 있음
				
			->	본, 공유폴더를 활용해서 OS,Windows에서 Source insight 등을 사용해서 소스 파일을 편집하고(개행문자형식:DOS형식)
				OS,Ubuntu에서는 make 파일만 실행 시켜서 컴파일해도 아무 문제 없이 변경된 소스로 실행 파일이 만들어짐

	2)	SD 카드 인식시키고 확인하기. (Virtual Box & Ubuntu 10.04 32bit)
		Ubuntu  에서 다음의 명령을 통해 인식된 장치들을 확인할 수 있다.
		$ ls /dev
		참고로 Usb serial 은  ttyUSB0 로 잡힌다.

		위의 명령으로는 장치가 워낙 많아 SD 카드를 찾기가 어렵다.

		다음의 명령을 통해 disk로 인식한 목록을 알 수 있다.
		$ sudo fdisk -l
		그런데, 아무리 찾아봐도 SD 가 없다.
		SD 카드를 꽂으면 windows xp 에서만 계속 인식하고 있었다.
		다음과 같은 과정을 통해 드디어 Ubuntu 에서  SD 카드를 인식시킬 수 있었다.

		Virtual Box의 설정 -> USB 를 들어가면  추가(+) 버튼이 있다.
		이것을 누르면 인식 가능한 USB 목록이 있다. 
		이 중 USB Storage 를 클릭후 확인을 누른다.
		Ubuntu 의 오른쪽 아래에 보면 USB 아이콘이 있는데, 우클릭하여 USB Storage 를 선택한다. 몇 초 이내에 "딩동"하는 소리가 나며 SD 가 인식된다.

		다시 fdisk 명령을 쳐본다.
		$ sudo fdisk -l

		아까보다 많은 목록이 나오는 것을 확인할 수 있다.
		새로 생긴것이 SD 디바이스이다.
		Ubuntu 에서 SD 카드가 제대로 인식한다면, 윈도즈 OS에서는 인식이 안 된다
		
	3)	VirtualBox 동적확장저장소(*.vdi) 용량 늘리기
		a)	D:\>"c:\Program Files\Oracle\VirtualBox\VBoxManage.exe" modifyhd jwUbuntu.vdi --resize 20480		cf)MB 단위
			0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
		b)	VirtualBox로 Ubuntu 부팅 후 GParted로 리눅스 OS 상에서 하드디스크 용량 늘리기
			-	/dev/sda1		ext4			3)	-> 크기조정/이동 -> drag해서 용량 증가
				/dev/sda2		extended		2)	-> 삭제
					/dev/sda5	linux-swap		1)	-> 오른쪽마우스클릭 -> 스왑해제 -> 삭제
												4)	-> 할당되지 않은 나머지 여유 공간 -> 새로만들기(확장파티션) -> 추가
												5)	-> 할당되지 않음 -> 새로만들기(논리파티션, linux-swap) -> 추가
												6)	-> 편집 -> 모든작업수행하기 -> 적용
												7)	-> /dev/sda5 linux-swap -> 스왑사용
												8)	-> reboot
												9)	-> 만약 reboot시 "Press S to skip ~"등의 에러가 발생한다면(본 에러가 발생하지 않아도 아래 내용 확인해서 스왑활성 되어 있지 않으면 아래 내용 실행)
													-> 부팅 이후 GParted 실행 -> /dev/sda5	linux-swap -> 스왑사용 & UUID 확인 이후
													-> 본 UUID를 가지고 /etc/fstab 파일의 swap 부분 UUID 내용을 수정함

	3+1)VirtualBox 고정(*.vdi) 용량 늘리기
Virtual box hdd 용량 늘이기 

환경
Host os : ubuntu 14.04
guest os : win7

ubuntu 환경에서 virtualbox 를 이용해 windows 를 쓰고자 하는데. 직접 설치 한다면
불만이 없겠으나 누군가 쓰고 있는 vdi 이미지를 가져다가 쓴다면 hdd 의 용량이 맘에
들지 않을 수 있습니다.
이럴때 우리는 hdd 의용량을 늘이고 싶겠지요.
구글링해보면 많은 내용이 나오지만, 맘에 드는건 없었습니다.
구글링해서 보면 대부분 커맨드를 이용해 용량을 늘이는 부분부터 나오지만. 아래와 같은 결과를 보게 될 것 입니다.

Progress state: VBOX_E_NOT_SUPPORTED
VBoxManage: error: Resize hard disk operation for this format is not implemented yet!

결국 여기저거 정보를 조합해 보니 결론은 "
현재 적용하고자 하는  vdi 이미지가 고정 용량으로 설정 되었다면 직접 수정 하는 방법은 없다" 입니다.
virtualbox 에서 그 기능은 제고 않는다고 하네요

그럼 불가능 할까요?
아닙니다.
대신 virtualbox 에서는 고정 vdi 파일을 복사해서 저장할때 동적용량으로 변경할 수 있습니다.
그래서 아래와 같은 과정을 거치면 됩니다.

1. 고정 용량 vdi 파일을 불러와 동적 용량 vdi 파일로 복사/저장 한다.
- virtual box 를 실행 하고 가상 미디어 관리자 실행
- 복사할 현재 이미지를 선택후 복사 버튼 클릭
- 복사할 하드 디스크 확인한 후 다음 버튼 클릭
- vdi(virtual box 디스크 이미지)를 선택하고 다음 버튼 클릭
- 동적할당 을 선택 한후 다음 버튼 클릭
- 저장할 이름을 입력 하고 복사 버튼 클릭 ( bb.vdi 로 저장함을 가정 )

2. 동적 용량 vdi 파일을 vboxmanage 를 이용해 용량을 변경 한다.
- 터미널을 연다.
- 1 번에서 저장한 vdi 파일이 있는 위치로 이동 한다.
- 아래 명령을 입력해 원하는 용량으로 변경 한다.
]# VBoxManage modifyhd bb.vdi --resize 40960
--> bb.vdi 파일을 40gb 로 변경함.

3. 변경된 동적 용량 vdi 파일을 불러와 다시 변경된 용량의 고정 용량 vdi 파일로 복사/저장한다.
- virtuabox 를 실행 후 새로 만들기를 통해 bb.vdi 를 불러 온다.
- virtual box 를 실행 하고 가상 미디어 관리자 실행
- 복사할 현재 이미지를 선택후 복사 버튼 클릭
- 복사할 하드 디스크 확인한 후 다음 버튼 클릭
- vdi(virtual box 디스크 이미지)를 선택하고 다음 버튼 클릭
- 고정크기 를 선택 한후 다음 버튼 클릭
- 저장할 이름을 입력 하고 복사 버튼 클릭 ( cc.vdi 로 저장함을 가정 )

4. 실행 시킨후 guest os 에서 파티션 확장을 실행 한다.
- virtualbox 에서 새로 만드리를 통해 다시 cc.vdi 를 불러 온다.
- 저장소에서 용량이 변경된 것이 확인 되면 guest os 를 실행 한다.
- windows 가 부팅 되면  내컴퓨터 오른쪽마우스 클릭 - 관리- 저장소_디스크관리 더블클릭
- 디스크를 보면 할당되지 않은 용량이 보이며 ( 확장한 크기임 ) 확장할 파티션을 오른쪽 마우스 클릭
- 볼륨확장 선택
- 확장할 용량을 선택 적용

5. 리부팅 한다.

이렇게 하면 됩니다.

	3+2)VirtualBox *.vdi image 다른 폴더로 옮기기
		ex)	F: folder 에 있던 *.vdi image를 E: folder로 옮기는 경우
		방법1)	상기 3+1) -> 1. 고정 용량 vdi 파일을 불러와 동적 용량 vdi 파일로 복사/저장 한다. 방법을 참고해서 옮기기
		방법2)
			a)	E: folder로 *.vdi image 파일을 옮긴 다음
			b)	C:\Program Files\Oracle\VirtualBox>VBoxManage.exe internalcommands sethduuid "E:\Util\VB\Ubuntu Xenial(64-bit).vdi" 명령 실행하고서
			c)	Oracle VM VirtualBox 관리자 실행 -> 설정 -> 저장소 -> 컨트롤러:SATA -> 기존 "F:\~.vdi"를 변경 "E:\*.vdi"로 변경

	4)	VirtualBox 속도 향상
		VritualBox 를 사용하면서 장점이라면 여러 항목에 대한 자세한 설정이 가능하다는 점, 그리고 오픈 소스라는 점 등이 있다.
		하지만 사용하면서 제일 짜증나는(?) 점은 게스트 OS 의 속도가 굉장히 느리다는 점이다. 
		VMware Workstation에서 구동하는 게스트 OS와 비교해 보면 그 차이가 엄청남을 알 수 있다.
		그래서 한번 찾아보니 이런 내용이 있었다. 
		호스트 OS 가 windows 인 경우는 SATA 컨트롤러의 호스트 I/O 캐시 옵션을 선택하여 적용하면 성능이 빨라진다고 하며, 
		호스트 OS 가 Linux인 경우는 SATA 컨트롤러의 호스트 I/O 캐시 옵션을 해제해야 더 빨라진다고 한다.
		cf)	호스트 OS가 Windows라는 말은 Windows OS상에서 VirtualBox를 이용해서 Linux등의 guest os를 설치하는 경우 등을 말함

		추가 : 실제로 해보니 성능은 빨라진 것 같지만 가끔 병목 현상처럼 반응이 없는 경우가 많았다.
		따라서 호스트 I/O 캐시 기능은 해제하고 디스플레이 메모리를 64MB로 늘리고 게스트 확장 기능을 설치하니
		그나마 속도는 좀 빨라졌다.

	cf)	Ubuntu 에서 kdevelop 설치 및 사용법
		1.	개발도구설치
			sudo apt-get install build-essential
		2.	kdevelop 설치
			sudo apt-get install kdevelop
		3.	konsole 설치
			sudo apt-get install konsole
		4.	cmake 설치
			sudo apt-get install cmake kdesdk
		5.	libtool 설치
			sudo apt-get install libtool
		
		사용법 : http://mongmio.tistory.com/30
		이제 모든 프로그래밍의 시작 hello world를 만들어보자.
		메뉴에서 project-New form Template을 선택하면 대화창이 뜬다.
		그림과 같이 Simple CMake-based C++ application을 선택하고 Application name 을 입력한 후 Finish를 선택한다.
		Version Control System 은 원하는 대로 선택하는데 일단, 간단하게 None을 선택하고 Finish를 클릭한다.
		모두 완료하고 나면 build 관련 설정 창이 뜬다.
		cmake가 설치 되어있다면 별 문제 없이 위와 같은 창이 뜬다. 만약 binary 칸이 비어있다면, cmake를 설치하고 위와 같이 바이너리 파일이 위치를 찾아주면 된다. 나머지는 자동으로 위와 같이 설정된다.
		여기 까지 하면 

		#include <iostream>
		
		int main(int argc, char **argv) {
		    std::cout << "Hello, world!" << std::endl;
		    return 0;
		}

		요 익숙한 코드가 포함된 프로젝트가 생성된다. Project 창에서 해당 프로젝트를 선택하고 F8을 누르거나 Build Selection을 클릭하여 빌드를 수행한다.
		Execute를 하려면 한가지 설정이 더 필요하다.
		메뉴에서 Run-Configure Launches를 클릭하면 창이 생긴다. 여기서 실행할 프로젝트를 선택하고 + 버튼을 누르면 New Native Application Confiuration 생성되는데, 여기에 Project Target 만 설정해 주면 된다.
		실행할 파일명을 넣어주면 되고 기본적으로 프로젝트 명과 동일하다.
		설정이 완료 되었다면 Execute 버튼을 눌러보자
	
	cf)	ubuntu/debian의 경우 똑같은 역할의 여러 버전의 소프트웨어가 설치되어 있는 경우, 이를 update-alternatives라는 명령어로 관리할 수 있다.
update-alternatives(8)          dpkg utilities          update-alternatives(8) 
NAME
       update-alternatives  - maintain symbolic links determining default com?
       mands
SYNOPSIS
       update-alternatives [options] command
man page를 보면 저렇게 나오는데 뭐 이렇게 봐도 잘 모르겠다. 그럼 예를 한번 보자.

		예를 들어 vi 라는 alternative에 대한 list를 보고 싶다면 그림의 첫번째 명령어처럼
		sudo update-alternatives --list vi
		라고 하면 그림과 같이 실제로 연결될 수 있는 vi라는 alternative에 연결될 수 있는 link의 list 를 볼 수 있게 된다. 
		그리고 이렇게 설정된 link를 변경하고 싶을 경우에는
		sudo update-alternatives --config vi
		과 같이 하면 그림과 같이 설정을 할 수 있도록 뜬다. 이 중 원하는 소프트웨어를 선택하면 symbolic link가 수정된다.
		
		ex)	$sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.7.0/bin/java" 1
			$sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk1.7.0/bin/javac" 1
			$sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk1.7.0/bin/javaws" 1




[4]	NIC card program 내에 watch dog program 추가(convertor 재실행)
   1) monitor file 수정(watch dog 대상이 되는 파일명을 convertor로 수정)

#!/bin/bash
while [ 1 ]
do
	cnt=`ps -ef | grep convertor | grep -v grep | wc -l`
	if [ $cnt = 0 ]
	then
		cd /simtemp/convert
		./convertor &
	
		if [ $? != 0 ]
		then
			echo There is something wrong with convertor start-up.
			exit 1
		fi
	else
		sleep 60
	fi
done &

   2) rc file 수정(상기 1)에서 자동으로 convertor가 실행되므로 rc에서는 convertor가 실행되지 않도록 skip함)

...............................................................

/* watch a process */
/monitor
...............................................................
#launch elevator application
#cd /simtemp/convert
#convertor
#add




[4-2]	NIC card program 내에 watch dog program 추가(reboot 방식)
   convertor watchdog -> convertor 재실행이 아닌 reboot로 수정
   -> reboot 하면 엘리베이터서버와 연결되어 있던 소켓 연결도 자동으로 끊어지게 되어서
   기존 watchdog 프로그램을 넣어도 엘리베이터서버와 소켓 연결이 끊어지지 않고 계속 소켓 연결이 누적되어서
   발생하던 엘리베이터서버의 소켓연결 오버에러도 방지할 수 있다.

   1-1) monitor kill
				#ps
        #kill 123

   1-2) convertor kill
				#ps
				#kill 119			-> ./convertor 중에서 최상위 program 번호

   1) rc 수정
..........................................................................................

# fix
#/* watch a process */
#/monitor
# fix

# for elevator testing #
busybox insmod /simtemp/ddtest/gpio.o

#cd /simtemp/convert
#./convertor &

# add
/* watch a process */
/monitor
# add
..........................................................................................

   2) monitor 수정

#!/bin/bash
sleep 20
cd /simtemp/convert
./convertor &
sleep 2
while [ 1 ]
do
	cnt=`ps -ef | grep convertor | grep -v grep | wc -l`

	if [ $cnt = 0 ]
	then
		sleep 7
		reboot
	else
		sleep 15
	fi
done &




[5]	tftp booting 설정 사항

HDN7100> print
bootdelay=1
baudrate=115200
ethaddr=00:17:90:00:01:00
gatewayip=192.168.201.254
netmask=255.255.255.0
wr_uboot=protect off bank 1; erase bank 1; tftp 32000000 u-boot.bin; cp.b 320000
00 00000000 d0000
uboot=tftp 32000000 u-boot.bin; go 32000000
test=tftp 30000000 2440.bin; go 30000000
serverip=192.168.201.220
ipaddr=192.168.201.110
bootcmd=tftp 32000000 hdn7000s_kernel;bootm 32000000
bootargs=root=/dev/nfs rw nfsroot=192.168.201.220:/nfsroot/CM2440/romfs ip=192.1
68.201.110:192.168.201.220 console=ttyS0,115200
stdin=serial
stdout=serial
stderr=serial

Environment size: 555/65532 bytes
HDN7100>




[6]	nand booting 설정 사항

HDN7100> print
bootdelay=1
baudrate=115200
ethaddr=00:17:90:00:01:00
gatewayip=192.168.201.254
netmask=255.255.255.0
wr_uboot=protect off bank 1; erase bank 1; tftp 32000000 u-boot.bin; cp.b 320000
00 00000000 d0000
uboot=tftp 32000000 u-boot.bin; go 32000000
test=tftp 30000000 2440.bin; go 30000000
serverip=192.168.201.220
ipaddr=192.168.201.110
bootargs=root=/dev/mtdblock4 console=ttyS0,115200
bootcmd=nand read.jffs2 32000000 0 180000; bootm 32000000
stdin=serial
stdout=serial
stderr=serial

Environment size: 482/65532 bytes
HDN7100>




[7]	윈도우 탐색기에 리눅스 디렉토리를 네트워크 드라이브로 연결하기
1) 삼바 사용자 생성 

- 사용하려는 삼바 사용자명과 동일한 일반 사용자가 존재하여야 한다. 

// - # useradd root 와 # passwd root로 root라는 사용자를 생성.	-> 이미, root라는 사용자가 있으므로 본, 명령은 실행하지 않아도 됨.

   - # smbpasswd -a root    ( 삼바사용자 생성 ) 

2) 생성한 삼바 사용자를 ./etc/samba/smb.conf에 등록 

- smb.conf설정파일의 맨 마지막 부분에 root사용자 설정을 추가 

[root] 
   comment = KRH 
   path = /nfsroot/CM2440/romfs 
   valid users = root
   public = no 
   writable = yes 
   printable = no 
   create mask = 0777				-> user,group,other 모두 읽고/쓰고/실행 가능

3) 개인PC의 탐색기에서 원격삼바디스크 사용하기 
- 윈도우의 내컴퓨터를 오른쪽마우스클릭 후 ‘네트워크 드라이브 연결’ 메뉴을 선택 
- 드라이브 : 사용하고 있지 않은 드라이브를 선택 
- 폴더 : \\192.168.201.220\root 
- 마침 후 입력창에 팝업되면 아이드와 패스워드를 입력 (root, 패스워드)
- 컴퓨터 부팅 후 한번의 계정 입력으로 로컬드라이브처럼 사용할 수 있다.




[7-1] 우분투 14.04 삼바 설치
우선 우분투에 삼바를 설치하도록 한다.
1. 삼바를 위한  네트워크 설정.
우분투에 호스트와 통신하기 위한 네트워크를 추가한다.
설정 -> 네트워크 -> 어탭터1를 선택하고 다음에 연결됨에 호스트 전용 어댑터를 선택하고 확인을 누른다.
 
2. Samba 설치
$ sudo apt-get install samba
 
3. 공유할 디렉토리에 Samba 접속용 계정과 비밀번호 설정
$ sudo smbpasswd -a 계정      ex) sudo smbpasswd -a root
New SMB password: 비밀번호
Retype new SMB password: 비밀번호
 
4. Samba 설정
$ sudo vi /etc/samba/smb.conf
아래 3라인의 주석을 푼다.
;[homes]
;comment = Home Directories
;browseable = no
 
아래를 문서의 마지막에 추가한다.
[global]
workgroup = WORKGROUP
encrypt passwords = true
[계정]                        ex) [root]
comment = 설명
path = 공유할 패스            ex) /home/krh
read only = no
writable = yes
printable = no
public = yes
browsable = yes
quest ok = no
create mask = 0755
directory mask = 0755
 
5. Samba 재시작
$ sudo service smbd restart
 
6. 윈도우에서 접속
윈도우에서 "\\192.168.56.101\계정"  ex) \\192.168.56.101\root
으로 접속한다.                      ex) 계정 : root, 비밀번호 : SMB password




[7-2]	Ubuntu Samba 설정(네트워크 드라이브 잡기) on VirtualBox
1.	VirtualBox 만을 사용해서 삼바 연결하려면
	VirtualBox -> 네트워크 -> 호스트 전용 어댑터 -> VitualBox Host-Only Ethernet Adapter 로 변경해야 함
	cf)	첫째, 외부인터넷을 가능하게 하기 위해 "NAT" 로.
		둘째, 호스트와 게스트간 통신을 가능하게 하기 위해 "호스트 전용 어댑터"를 설정한다

2.	Ubuntu 터미널 창에서
	ifconfig을 실행 시켜서 Ubuntu 서버 ip 확인

3.	Ubuntu 터미널 창에서
- $ sudo apt-get install samba samba-common cifs-utils
- $ sudo apt-get install system-config-samba gksu
- $ sudo smbpasswd -a root
- $ sudo gedit /etc/samba/smb.conf				cf)	sudo gksu system-config-samba (본 명령을 사용하면 gui samba 설정을 실행시킬 수 있음)

ex1)	. 파일 열어서 아래부분을 추가해준다.(root 의 경우는 하기 사항 추가하지 않아도 삼바 실행 됨)
#== user add ==
[global]
workgroup = WORKGROUP
encrypt passwords = true
unix charset=utf-8
dos charset=utf-8

[root]  
comment=root(samba)
path=/
valid users = root
read only = no
writable = yes
printable = no
public = yes
browsable = yes
guest ok=no
create mask = 0777

ex2)	
[root]  
comment=root(samba)
path = /
writable = yes
guest ok = no
create mask = 0777
directory mask = 0777
; hosts allow = 192.168.56.1      (host를 제한하고 싶지 않을때는 항목 삭제)
unix charset = utf-8
dos charset = 949

root 부분은 자신이 사용하는 아이디를 넣어주면 됨. 
물론 samba 라는 폴더도 있어야겠죠?
다른 폴도를 사용할꺼면 다른 폴더면 넣어주면 됨.

4.	samba 재시작
	#service smbd restart

5.	윈도우 - 실행 창에서

- \\192.168.56.102\krh
- 위에서 설정한 passwd 물어볼 것이다. 넣어주면 ok




[7-3]	virtualbox ubuntu samba 설정  
1. virtual box의 네트워크 설정
   - 어댑터2 탭 선택
     . 네트워크 어댑터 사용하기 선택
     . 호스트 전용 어댑터 선택
     . 케이블 연결됨 선택

2. ubuntu 시작
   - terminal 
   - ifconfig 입력
      . 호스트 전용 어댑터와 연결된 ip 확인 (ex: eth1 - 192.168.56. xxx)

3. windows network 관리자의 VirtualBox Host-Only network의 IP 확인
   - 2번에서 확인한 ubuntu IP와 windows network 관리자를 통해 확인하 IP의 상위 3자리가 일치하는지 확인
   - 일치하지 않으면 일치하도록 수정 
     (ex : windows 192.168.56.1, ubuntu 192.168.56.101)

4. ubuntu reboot

5. sudo apt-get install samba smbfs  (samba 설치)

6. sudo smbpasswd - a [ubuntu에 등록된 사용자]   (samba password 설정)
   (ex : smbpasswd -a ubuntu)
 
7. sudo vi /etc/samba/smb.conf
   - 아래 내용 추가
["공유이름"] 
comment = "공유 설명"
path = "경로"
writable = "yes or no"
guest ok = 'yes or no'
create mask = '파일 권한'
directory mask = '디렉토리 권한'
host allow = '접근 가능 호스트 ip'
unix charset = '리눅스 내부 문자 set'
dos charset = 'windows 문자 set'
display charset = '출력할 문자 set'

ex>
[ubuntu]
comment = ubuntu share directory
path = /home/ubuntu
writable = yes
guest = no
create mask = 0644
directory mask = 0755
;         hosts allow = 192.168.56.1      (host를 제한하고 싶지 않을때는 항목 삭제)
unix charset = utf-8
dos charset = 949
display charset = utf-8

ex)
[root]  
comment=root(samba)
path = /
writable = yes
guest = no
create mask = 0777
directory mask = 0777
; hosts allow = 192.168.56.1      (host를 제한하고 싶지 않을때는 항목 삭제)
client code page = euc-kr
unix charset = utf-8
dos charset = euc-kr
#display charset = MS949

8. sudo service smbd restart   입력

9. windows 탐색기 주소창에 \\"ubuntu iP\"공유이름" 입력 
   ex) \\192.168.56.101\ubuntu




[7-3]	잘 작동하던 삼바가 윈도우에서 연결되지 않을 때 해결 방법
	->	결론적으로
		Oracle VM VirtualBox -> 파일 -> 환경설정 -> 네트워크 -> 호스트 전용 네트워크
		-> 편집 -> IPv4 주소 : 192.168.56.101 로 되어 있던 것을 192.168.56.1 로 변경하니 정상 동작 함
	->	위와 같이 해도 정상 동작하지 않으면
		상기 "[7-2]	virtualbox ubuntu samba 설정"  을 참고 해서 수정하면 됨




[7-4]	virtualbox ubuntu samba 설정 & NFS 기능도 함께 정상적으로 동작하도록 하는 설정 
1. virtual box의 네트워크 설정
   - 어댑터2 탭 선택
     . 네트워크 어댑터 사용하기 선택
     . 호스트 전용 어댑터 선택
     . 케이블 연결됨 선택

2. ubuntu 시작
   - terminal 
   - ifconfig 입력
      . 호스트 전용 어댑터와 연결된 ip 확인
    	eth0
			inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0

3. windows network 관리자의 VirtualBox Host-Only network의 IP 확인(Internet Protocol Version 4 (TCP/IPv4))
   - 2번에서 확인한 ubuntu IP와 windows network 관리자를 통해 확인하 IP의 상위 3자리가 일치하는지 확인
   - 일치하지 않으면 일치하도록 수정 
     (ex :	windows	->	IP주소 : 10.0.2.17, 서브넷 마스크 : 255.255.255.0, 나머지 빈 공간
     		ubuntu	->	IP주소 : 10.0.2.15, 서브넷 마스크 : 255.255.255.0)

4. ubuntu reboot

5. sudo apt-get install samba smbfs  (samba 설치)

6. sudo smbpasswd - a [ubuntu에 등록된 사용자]   (samba password 설정)
   (ex : smbpasswd -a ubuntu)
 
7. sudo vi /etc/samba/smb.conf
   - 아래 내용 추가
["공유이름"] 
comment = "공유 설명"
path = "경로"
writable = "yes or no"
guest ok = 'yes or no'
create mask = '파일 권한'
directory mask = '디렉토리 권한'
host allow = '접근 가능 호스트 ip'
unix charset = '리눅스 내부 문자 set'
dos charset = 'windows 문자 set'
display charset = '출력할 문자 set'

ex)
[root]
	comment = root(samba)
	path = /
	writeable = yes
;	public = yes
	browseable = yes
	guest ok = yes
	create mask = 0777
	directory mask = 0777
	unix charset = utf-8
	dos charset = 949

8. sudo service smbd restart   입력

9. windows 탐색기 주소창에 "\\10.0.2.15\root" 입력 




[8]	[TIPS] Putty 에서 한글 입력이 필요할때
--------------------------------------------------------------------------------

기본적으로 Putty 는 한글을 보는 것은 쉽지만, 입력하는 것은 잘 안되죠. 그럴땐 다음과 같이 해주세요.
(Putty 0.58 기준입니다. ^^)

1. regedit 를 실행
2. 내 컴퓨터\HKEY_CURRENT_USER\Software\Simon Tatham\PuTTy\Session 을 엽니다.
3. Session 아래의 여러 항목들은 Putty 에 등록해놓은 각 host 정보입니다. 한글을 입력하려는 host 를 선택하시면
4. 오른편에 key/value 목록이 표시될텐데요, 거기서 FontCharSet 이란 것을 더블 클릭으로 선택합니다.
5. 값 데이터를 16진수 81로 입력해주신 후 확인 버튼을 클릭합니다.

짜잔~ 다 되었습니다. Putty 를 기동하신 후 접속해 보시면 한글 입력이 자알~~ 될 겁니다. ^^

Putty 실행
1. Font : 굴림체, 스크립트 : 한글




[9]	HDN7100 프로그램 수정 방법
1)	system_run directory에서 hdn_7100 directory에 있는 내용 등을 수정한 다음
	make를 실행하면 hdn_7100 directory등이 개별적으로 make실행된다
	이때, hdn_7100 directory 가 make될 때는 make된 결과물 hdn_7100 실행파일이 자동으로
	romfs/apps/hdn_7100 directory로 복사된다
2)	tools directory 안에 있는 파일을 실행시켜 하기와 같이 압축 파일을 만든다
	romfs directory에서 apps(hdn_7100,sound,img 등)를 제외한 bin,dev,..등의 directory	-> romfs.yaffs
	romfs directory안에 있는 apps(hdn_7100,sound,img 등) directory						-> apps.yaffs
	cf)	mkyaffsimage: yaffs는 mkyaffsimage(512byte page) 툴을 이용하여 NAND에 맞는 파일 시스템을 생성해 준다.
					: ex) mkyaffsimage ./app yaffs.img -> app 디렉토리에 저장된 파일 및 하위 디렉토리를 yaffs.img 이미지 파일로 만들어 줍니다.
		genromfs	: 일단 파일시스템은 ramfs를 사용하고 있고 이미지를 만들기 위해서는 genromfs 라는 명령어를 사용합니다.(flash 용 image 생성)
					: ex) genromfs -f [image file] -d [directory]
		cramfs		: 루트 파일 시스템은 압축 읽기 전용 파일 시스템인 cramfs를 씁니다.
					: ex) mkcramfs dir newroot.fsm -> dir이하의 파일을 newroot.fsm으로 만들어 줍니다.
3)	상기 apps.yaffs등의 파일을 하기 방법중 하나로 HDN7100 Board에 전송한다
	가)	BOOT MENU(부팅시 비상키를 계속 누르고 있음) -> 3.Flash Writing 메뉴로 들어간 다음
		USB나 TFTP를 이용해서 HDN7100 Board로 전송하면 되며, USB의 경우는 전송하고자 하는 파일을 root directory에 복사해 놓으면 되고
		TFTP의 경우는 전송하고자 하는 파일을 /tftpboot 또는 /tftproot 에 복사해 놓고 serverip는 전송보내는 서버컴퓨터의 ip로 설정해 놓아야 한다.
		이때, 보통 7100 Program Upgrade는 단지 Application 메뉴만 실행시키면 완벽하게 Upgrade 됨
		이유는 Application은 apps.yaffs를 Download하며 apps.yaffs는 apps(hdn_7100,sound,img 등) directory의
		7100 실행,sound,img를 모두 포함하고 있으므로
	나)	Telnet을 이용해서 Ethernet을 통해 보통의 Program Upgrade를 할려면
		Source상 romfs -> apps(hdn_7100,sound,img 등) 안에 있는 파일들을 
		HDN7100 Board안에 있는 /apps 자리에 복사 하기만 하면 된다.

	cf)	u-boot.bin		(3.Flash Writing -> Bootloader) 파일은 hdn7100s_uboot directory에서 make 하면 만들어짐
		hdn7100s_kernel	(3.Flash Writing -> Kernel) 	파일은 linux-2.4.20.x directory에서 make 하면 만들어짐
		romfs.yaffs		(3.Flash Writing -> File System)파일은 상기 설명 참조
		apps.yaffs		(3.Flash Writing -> Application)파일은 상기 설명 참조
	
	cf) u-boot.bin을 Upgrade할려다가 error가 나서 아예, HDN7100 BOOT MENU로도 들어갈 수 없는 경우
		하기 두가지 방법중 하나로 Booting을 복구할 수 있다
		a) RomWriter로 29LV160 IC를 빼내서 u-boot.bin을 writing한 다음 다시 끼어 넣는다.
		b) parallel port에 JTAG(paralled)을 연결한 다음 ezjtag-vs-v04 -f u-boot.bin을 실행시켜서 Bootloader를 Upgrade 한다.
	다)	BOOT MENU(부팅시 비상키를 계속 누르고 있음) -> 1. 환경설정 메뉴로 들어간 다음
		NFS -> 2.jwyu 를 선택하면 서버에서 파일을 수정하는 것 만으로도 곧바로 세대기에 수정 사항이 적용된다.

		char *jwyu_nfs[] = {
				// bootargs
				"root=/dev/nfs rw nfsroot=192.168.1.102:/home/proj/workspace/hdn-7100/uClinux-dist/romfs ip=192.168.1.106:192.168.1.102 console=ttyS0,115200",
				// bootcmd
				"tftp 32000000 hdn7000s_kernel;bootm 32000000"	
			};
			// server ip		: 192.168.1.102
			// board ip			: 192.168.1.106
			// board console	: ttyS0




[10]	윈도우XP상에서 리눅스 설치하기
1)	윈도우XP상에서 하기와 같이 Partition을 잡아줌
	120GB = WindowsXP[60GB(30(C)+5(D)+25(E))] + Linux[54GB(F)]
2)	리눅스 CD Booting
3)	사용자 레이아웃 만들기
	가)	상기 54GB 드라이브를 삭제 버튼을 이용해서 삭제함 -> NTFS에서 여유공간으로 변경됨
	나)	/dev/sda7	/		ext3	25000
		/dev/sda8			swap	 1028
		/dev/sda9	/home	ext3	27980
	다)	GRUB 부트 로더는 /dev/sda에 설치될 것입니다. 선택
	라)	Fedora	/dev/sda7 선택
	마) ..............................
cf)	페도라 탐색기, 터미널 창에서 한글 파일명 제대로 보이게 하기
	한글 파일명이 ????.mp3로 표시되던 것을 한글 파일명이 제대로 보이도록 변경
	가)	etc/sysconfig/i18n 파일의 내용을 하기와 같이 변경
		LANG=ko_KR.UTF-8 → LANG=ko_KR.eucKR




[11]	HDN7100 compile & image 생성 설명서
1) 유첨으로 첨부한 cross-2.95.3.tar.bz2 파일을 Linux Server에 하기 위치로 압축을 해제 합니다.
    /usr/local/arm/2.95.3/bin/arm-linux

2) 홈네트웍->WorkSpace에 위치한 uClinux-dist.work.tgz 파일을 Linux Server에 하기 위치로 압축을 해제 합니다.
    /home/proj/workspace/hdn-7100/uClinux-dist

3) /home/proj/workspace/hdn-7100/uClinux-dist/user/system_run 에서
    make clean 실행 (기존 compile file 삭제)
    make 실행 (hdn_7100 compile)

    cf) font 관련 사항이 제대로 compile 되려면 하기와 같이 Makefile 을 수정해야 함
    clean:
       -rm -f $(EXEC) *.elf *.gdb *.o ./font/*.o $(LIB_FBAPI)

4) /home/proj/workspace/hdn-7100/uClinux-dist 에서
    ./mkfs 실행 (apps.yaffs, romfs.yaffs image 파일 Z:\tftpboot에 생성)

5)	cf) Upgrade file 위치
		hdn_7100				-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\user\system_run\hdn_7100
								-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\user\system_run\upgrade
								-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\romfs\apps\hdn_7100
		hdn_7100.conf			-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\user\system_run\upgrade
								-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\romfs\apps\hdn_7100\conf
		upgrade.pl				-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\user\system_run\upgrade
		HOME.png				-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\romfs\apps\img\bg
		cf) NFS 구현시 수정되어야할 파일
		hdn_7100.conf			-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\romfs\apps\hdn_7100\conf	
		rc						-> Z:\home\proj\workspace\hdn-7100\uClinux-dist\romfs\etc




[12]	HDN7100 kernel compile 설명서
1) 유첨으로 첨부한 gpe-sdk-20050210.tar.bz2 파일을 Linux Server에 하기 위치로 압축을 해제 합니다.
    /usr/local/arm/oe/arm-linux

2) 유첨으로 첨부한 linux-2.4.20.x_kernel_080422.tar.gz 파일을 Linux Server에 하기 위치로 압축을 해제 합니다.
    /home/proj/workspace/hdn-7000/linux-2.4.20.x

3) /home/proj/workspace/hdn-7000/linux-2.4.20.x 에서
    make hdn7000s_kernel 실행 (hdn_7000 kernel compile)




[13]	HDN7100 NFS 환경 구축
1) /etc/exports 파일에 하기 설정을 추가 합니다.
   /home/proj/workspace/hdn-7100/uClinux-dist/romfs      192.168.1.106(rw,sync,nohide,no_root_squash)

2) /home/proj/workspace/hdn-7100/uClinux-dist/romfs/etc/rc 파일을 하기와 같이 수정 합니다.
   참고로, 하기 사항은 제품 양산시 초기 상태로 복귀시켜야 제대로 동작함.
   # fix
   #mount -a
   mount -t proc proc /proc
   mount -t yaffs /dev/mtdblock/6 /data
   mount -t yaffs /dev/mtdblock/7 /db
   # fix

3) /home/proj/workspace/hdn-7100/uClinux-dist/romfs/apps/hdn_7100/conf/hdn_7100.conf 파일 설정 사항이
   하기와 같아야만 제대로 NFS가 동작합니다.
   # IP configuration type: IPCONF_AUTO - 00, IPCONF_MANUAL ? 01
   IPCONF_TYPE=01
 
4) BOOT MENU(부팅시 비상키를 계속 누르고 있음) -> 1. 환경설정 메뉴로 들어간 다음 하기와 같이 수정 합니다
   1) Server IP	   : 192.168.1.102
   2) System IP    : 192.168.1.106
   3) NFS -> 2.jwyu


[13-2]	HDN7100 UBOOT compile 설명서
1) 홈네트웍->WorkSpace에 위치한 hdn7000s.uboot.tgz 파일을 Linux Server에 하기 위치로 압축을 해제 합니다.
    /home/proj/workspace/hdn7000s_uboot

2) /home/proj/workspace/hdn7000s_uboot 에서
    make hdn7100_config 실행

3) /home/proj/workspace/hdn7000s_uboot 에서
    make clean 실행 (기존 compile file 삭제)
    make 실행 (uboot compile)

4) /home/proj/tftp 에 u-boot.bin 이 복사 되어 있음

Cf) bmp -> hex HeaderFile로 변경
    가) Photoshop 설정 : 이미지 -> 모드 -> RGB색상, 8비트
    나) Photoshop 저장 : 다른 이름으로 저장 -> splash.bmp  -> BMP옵션(고급 모드->16비트->R5 G6 B5)
    다) 압축파일만들기 -> splash.bmp -> splash.bmp.gz
    라) Console : xxd ?i splash.bmp.gz > splash.h
    마) splash.h 파일을 /home/proj/workspace/hdn7000s_uboot /include 로 복사
    바) /home/proj/workspace/hdn7000s_uboot 에서 make clean, make 실행


[13-3]	HDN7100 GPIO 수정
RS485통신의 Direction port등 GPIO관련 Device driver를 수정할려면
Kernel을 수정해야 함
Cf) /home/proj/workspace/hdn-7100/uClinux-dist/user/system_run/gpio/gpio.c를 수정
     -> 컴파일 -> ./mkfs -> apps.yaffs를 변경 적용해도 변경사항이 적용되지 않음

1. /home/proj/workspace/hdn-7000/linux-2.4.20.x/drivers/serial/serial_s3c2440.c를 수정해야 함




[14]	Data Base
1) SQL Server 는 Microsoft SQL Server를 뜻함




[15]	페도라 리눅스 APM 설치법

 http://blog.naver.com/dakman12/110035408275
 
페도라 APM 설치한다고 하도 고생해서 기록으로 남김 -_-;;;
일단 yum 명령으로 쉽게 설치할 수 있습니다.

1) 페도라 리눅스 터미널 상에서 아래의 명령을 칩니다.
yum install httpd php mysql mysql-server php-mysql system-config-httpd
위 명령을 치면 Apache, MySQL, PHP의 설치를 자동으로 진행합니다.
끝나고 나면 재부팅을 시킵시다. ^^

2) 다시 터미널로 돌아와 웹서버 데몬을 실행시킵니다.
/etc/rc.d/init.d/httpd start
리눅스 서버를 부팅함과 동시에 웹서비스를 시작할 수 있도록
활성화 합니다.

chkconfig --list | grep httpd
로 확인

chkconfig httpd on
chkconfig --list | grep httpd

3) 이후 방화벽을 설정 합니다.
iptables -L로 확인 후
iptables -I INPUT -p tcp --dport 80 -j ACCEPT

다시 확인 
iptables -L로 확인

방화벽 다시 설정
/etc/rc.d/init.d/iptables save

4) 호스트이름을 통해 접속하기 위해서는 squid를 중지 합니다.
chkconfig 를 통해 squid를 중지 시킵니다.

5) ---- mysql 설정 ----
/etc/rc.d/init.d/mysqld start로 시작하면 초기화가 됩니다.
초기화가 실행되면 이제 접근할수 있어야 하는데 이때 계정을 생성해 주어야 합니다.
mysqladmin -u root password '1234'
이제 실행
mysql -u root -p 
비번
chkconfig 명령으로 mysqld를 활성화 합니다.

6) 마지막으로 php와의 설정입니다.
php의 문서도 웹으로 서비스 할수 있게 해줍니다.
vi /etc/httpd/conf/httpd.conf
열고
DirectoryIndex index.php index.html index.htm
이것을 추가하고

AddType application/x-tar .tgz
AddType application/x-httpd-php .php .phtml .php3
AddType application/x-httpd-php-source .phps

위와 같이 하고 웹서버를 재시작 합니다.

여기서 User의 웹 계정을 만들어 주려면
UserDir Disable
주석처리하고
UserDir public_html
주석 해제 합니다.
아래의 
<Directory /home/*/public_html>
...
</Directory>
가 주석처리 되어 있는데 모두 주석해제 합니다.

그리고 재부팅 후 
자신의 계정으로 로그인하여 
/home/자긴의 계정명/ 안에 public_html 폴더를 생성하면 됩니다.
그리고 웹페이지에서 
localhost/~자신의 계정명 으로 테스트 해봅시다. 

출처 : http://hahakbs.dothost.co.kr/tag/yum
[출처] 페도라 리눅스 APM 설치법|작성자 닥만




[16]	JSP
1) *.jsp 파일을 Explorer에서 열면 한글이 깨지는 현상 제거 방법
	 *.jsp 파일을 UltraEdit -> "변환" -> "ASCII -> UTF-8(Unicode 편집)"으로 변환시켜서 저장함.

	cf)	요즘 리눅스는 UTF-8 기반입니다. JSP 파일은 UTF-8로 작성했으면서, JSP의 인코딩은 euc-kr로 지정하면 한글 다 깨집니다. 
			charset=utf-8 로 바꾸던지, 아니면 JSP 파일 자체를 euc-kr로 작성하도록 하십시오.
	cf) 배부분의 MySQL서버를 사용할 경우(다른 것일지라도) 기본적으로 UTF-8로 잡혀 있습니다.
			1.	Unicode와 UTF-8은 엄연히 다른 겁니다.
					우선 Unicode = United Codepage Charset? 정도로 할 수 있는데요.
					원래 영어는 1byte를 쓰지만, 중국어나 일본어 한국어 경우에는 2byte를 차지 하게 됩니다. 또 영어를 쓰는 codepage에서는
					다른 나라 언어를 읽을 수가 없지요. 그래서 나온게 통합코드페이지(UNICODE)입니다.
					이것은 모든 글자를 2byte로 표시하게 만들어서 어떠한 글자라도 표시할 수 있었습니다.
					
					하지만, 영어를 쓰는 사람들에게는 불편했습니다. 1byte면 되는 영어글자를 2byte나 들여야 한다는건 공간 낭비라고 생각했기 때문이지요.
					
					그래서 만들 것이 UTF-8입니다. UTF-8은 unicode의 장점을 그대로 가지고 있으면서도 영어는 1byte로 쓸 수 있게 만든 codepage입니다.
					그래서 어떠한 글자라도 UTF-8로 하면 공간 절약도 되고, 모든 글자를 수용할 수 있습니다.
			2.	EUC-KR, CP949
					EUC계열은 유닉스 계열 쪽의 코드페이지입니다. 우선, EUC-KR은 완성형 코드입니다.
					따라서 일반적인 한글 글자만 포함한다는 것입니다.
					EUC-KR 완성형 코드라서 "뚫훍뚤훍" 같은 글자를 표현할 수 없습니다.
					조합형 코드라면 모든 것을 표현할 수 있지만, 그럴 수 없습니다.
					
					후에 윈도우에서 사요하는 MS949, 다르게 CP949라고 불리는 코드페이지가 나왔습니다.
					이것은 조합형ㅋ드는 아니지만, 완성형코드인 EUC-KR에다가 "뚫훍"같은 글자를 포함시켜 더 많은 글자를 표현할 수 있게 되었습니다.
					
					그래서 UTF-8 -> EUC-KR 보다는 CP949로 하는 것이 더 많은 한글 글자를 표현할 수 있다는 이야기입니다.
					표현할 수 있는 글자수가 CP949가 더 많기 때문이지요.

2)	jsp 배포
		가) *.war 파일을 만든 다음 /var/lib/tomcat5/webapps/ 에 복사한 후
		나) Fedora -> 시스템 -> 관리 -> 서비스 -> tomcat5를 재시작하면 자동으로 *.war 파일이 해당 디렉토리로 압축이 풀림

3)	jsp 문법
		가) 멤버변수(C언어에서 말하는 전역변수) ex) <%! value1; %>
				선언문에서 선언된 모든 변수들은 멤버 변수이므로 JSP 페이지 전체에서 접근할 수 있다(컴파일시에 클래스에 변수가 위치하게 된다)
				따라서, JSP 페이지에서 멤버 변수를 쓸일이 많지 않으며, 오리혀 섣부른 멤버 변수의 사용은 다중 쓰레드 제어에서 문제가 된다.
				초기값은 기본값으로 숫자타입은 0, String은 null
		나) 지역변수 ex) <% value1=0; %>
				스크립트릿에서 선언한 변수는 지역 변수이므로 별도로 선언한 메소드 부분에서는 해당 변수를 사용할 수 없다.
				또한, 자동 초기화가 안 되므로 반드시 초기화를 해 주어야 한다.

4)	톰캣 한글 깨짐 처리 JSP  
2008/02/10 14:13 http://blog.naver.com/yakuball/60047600710
 
한글깨짐은 종종 발생하고 있읍니다.
우선 머릿속에 있는걸로 정리하면
utf-8
ksc5601
ms949등으로 encoding할수있습니다

tomcat 5.x 버전에서 웹브라우저로 부터 날라온 Get/Post 로 전달되는 한글이 ISO8859-1로 넘어오는 경우가 있어
한글이 깨지는 경우가 있습니다. 아래와 같이 Get / Post로 넘오는 한글 처리를 하시면 됩니다.

1. Get 방식으로 넘어오는 파라미터
   server.xml
------------------------------------------------------------
   <Connector 
               port="8080"               maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
               enableLookups="false" redirectPort="8443" acceptCount="100"
               debug="0" connectionTimeout="20000" 
               disableUploadTimeout="true" useBodyEncodingForURI="true" URIEncoding="KSC5601"/>

2. Post 방식으로 넘오는 파라미터

2-1. 톰캣이 설치된 디렉토리에서 
<TOMCAT_HOME>/webapps/jsp-examples/WEB-INF/classes/filters/SetCharacterEncodingFilter.class 파일을 복사해서
<TOMCAT_HOME>/common/classes/filters/ 밑으로 복사함.

2-2.
 web.xml
-------------------------------------------------------------
 <filter>
      <filter-name>Set Character Encoding</filter-name>
      <filter-class>filters.SetCharacterEncodingFilter</filter-class>
      <init-param>
          <param-name>encoding</param-name>
          <param-value>euc-kr</param-value>
      </init-param>
    </filter>

    <filter-mapping>
      <filter-name>Set Character Encoding</filter-name>
      <url-pattern>/*</url-pattern>
    </filter-mapping>

톰캣 폴더의 conf 폴더에는 server.xml 파일이 존재합니다.
에디터로 열어보면 

예)
    <Connector port="8080" maxHttpHeaderSize="8192"
               maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
               enableLookups="false" redirectPort="8443" acceptCount="100"
               connectionTimeout="20000" disableUploadTimeout="true" />
값이 약간 틀릴수 있지만 초기 셋팅 값이 보통 저러하고,
Connector 은 초기에 2개가 있는데 8080 포트 부분을 수정하면 됩니다.
수정하는 방법은 
URIEncoding="UTF-8" 을 추가하면 됩니다.
 
예)
    <Connector port="8080" maxHttpHeaderSize="8192"
               maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
               enableLookups="false" redirectPort="8443" acceptCount="100"
               connectionTimeout="20000" disableUploadTimeout="true" URIEncoding="utf-8" />

위와 같이 했다고 해결되는 것은 아닙니다. get 방식으로 데이터를 전송하면
자바 파일에서 확인 했을 경우 물음표 값만 넘어옵니다.
get 방식으로 보낼 경우 자바스크립트로 변환을 해줍니다.
예를 들어 "한글"을 자바스크립트에서 
<SCRIPT>alert( encodeURIComponent("한글") )</SCRIPT>
처럼 encodeURIComponent 함수로 변환하게 되면 %ED%95%9C%EA%B8%80 으로
변환됩니다. 이 값을 주소에 "한글" 대신에 넣게 되면 자바에서 알아서 잘~ 받습니다 ^^

5. HttpURLConnection 을 통하여 UTF-8 로 된 URL 을 읽을 경우.
다른 부분은 동일하고,  
BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));
로 변경합니다.

6. jsp -> bean 데이터 전송은 문제 없지만 jsp -> jsp 에서 한글이 깨진다면
받는 부분에서 
 String test = request.getParameter("test ");
 test = new String(test .getBytes("8859_1"), "UTF-8"); 
처럼 변환해서 저장합니다.				

5)	JSP 개발환경 구축
	가)	Java Development Kit 6 Update 10(jdk-6u10-rc-bin-b28-windows-i586-p-21_jul_2008.exe) 설치 및 환경변수(path) 추가
	나)	Tomcat 6.0.18(apache-tomcat-6.0.18.exe) 설치
	다)	Eclipse-jee(eclipse-jee-ganymede-SR1-win32.zip) 설치 및 Tomcat server와 연결
	라)	MySQL(mysql-5.1.30-win32.zip) 설치(MySQL은 개발용으로는 무료이지만 상용으로 사용시에는 구입해야 함)
	마)	MySQL과 JDK 연결(mysql-connector-java-5.1.7.zip->mysql-connector-java-5.1.7-bin.jar)

  cf) jsp-mssql 연동방법
			가) Microsoft SQL Server JDBC Driver 2.0(sqljdbc4.jar)을 받아서, 상기 마)처럼 MSSQL과 JDK 연결
			나) SQL Server Configuration Manager -> TCP/IP -> 
					프로토콜
						모두 수신합니다 : 예, 사용 : 예
					IP주소
						IP1 ->	사용(Active) : 예, 활성(Enabled) : 아니오, IP Address : 203.225.92.122, TCP Dynamic Ports : , TCP Port : 1433
						IP2 ->	사용(Active) : 예, 활성(Enabled) : 아니오, IP Address : 127.0.0.1,			TCP Dynamic Ports : , TCP Port : 1433
						IPALL->	TCP Dynamic Ports : , TCP Port : 1433
			다) 1433포트를 방화벽에서 풀어줌
			라) 그리고 코딩 하실땐 java.sql.*;를 import 하시고
					Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
					Connection conn = DriverManager.getConnection("jdbc:sqlserver://localhost:1433;databaseName=hcnmssql;user=root;password=hcn_linux;");
			마) 도스창에서 "netstat -na"명령을 실행시켜 1433포트가 열려 있는지 확인(TCP 0.0.0.0:1433)

	cf) MySQL DB 내용 -> MSSQL DB로 복사 하는 방법
			가) MySQL DB 내용을 Excel file 로 변경
			나) 가),Excel file을 MSSQL에서 해당 Database 선택 -> "작업" -> "데이터 가져오기"로 가져옮
			
	cf) MSSQL Scheduled backup
			가) SQL Server Configuration Manager -> SQL Server 2005 서비스 -> SQL Server Agent -> 상태:실행중, 시작모드:자동 으로 변경
			나) Microsoft SQL Server Management Studio -> 관리 -> 유지 관리 계획 -> 유지 관리 계획 마법사 를 실행시켜서
					해당하는 DB의 Scheduled backup을 설정함

	cf) MSSQL에는 limit SQL 명령이 없기 때문에 하기와 같이 TOP 명령을 사용해야 함.
			select top 100 * from 게시판 where id not in (select top 90 * from 게시판 order by id) order by id
			-> 이렇게 하면 91~ 100까지가 선택됨, 단 id는 primary key입니다.

			SELECT TOP [얻으려는 행의수] * FROM [TABLE]
			WHERE [PRIMARY KEY] NOT IN ( SELECT TOP [중간의 시작위치 - 1] [PRIMARY KEY] 
			FROM [TABLE] WHERE [조건] ORDER BY [PRIMARY KEY])
			AND [조건] ORDER BY [PRIMARY KEY]

			SELECT TOP 10 * FROM table1 WHERE id NOT IN (SELECT TOP 10 id FROM table1 WHERE name LIKE '%Lee%' OR address LIKE '%Seoul%') 
				AND (name LIKE '%Lee%' OR address LIKE '%Seoul%')

/*          	if(searchitem.equals("content"))
            		pstmt = conn.prepareStatement("select * from board where content regexp ? order by ref desc, re_step asc limit ?,?");
							.........................................................................................................................
            	pstmt.setString(1, search);
            	pstmt.setInt(2, start-1);
            	pstmt.setInt(3, end);	*/
            	// fix, MSSQL에는 regexp, limit 명령이 없기 때문에 like, top 명령으로 변경
            	pstmt = conn.prepareStatement("select top (?) * from board where num not in (select top (?) num from board where " + searchitem + " like '%" + search + "%' order by ref desc, re_step asc)" +
            		"and (" + searchitem + " like '%" + search + "%') order by ref desc, re_step asc");
            	pstmt.setInt(1, end);
            	pstmt.setInt(2, (start-1));
            	// fix
            }
            else {
                // pstmt = conn.prepareStatement("select * from board order by ref desc, re_step asc limit ?,? ");
                // pstmt.setInt(1, start-1);
                // pstmt.setInt(2, end);
                // fix, MSSQL에는 limit 명령이 없기 때문에 top 명령으로 변경
                pstmt = conn.prepareStatement("select top (?) * from board where num not in (select top (?) num from board order by ref desc, re_step asc) order by ref desc, re_step asc");
                pstmt.setInt(1, end);
                pstmt.setInt(2, (start-1));
                // fix


	cf) MySQL limit -> Oracle BETWEEN
			먼저 MySQL 에서는 
			# [MySQL]
			SELECT a.love_id 
			FROM love a
			LIMIT 1000, 2000;
			
			하면, 실제 입력된 데이터의 순서에 맞추어 1000번 부터 2000번까지의 데이터가 나온다.
			하지만.... 망할 ORACLE 에는 없다는 거....
			
			어떤 분들은 'rownum으로  WHERE rownum BETWEEN 1000 AND 2000 하면 되지 않느냐??'
			라고 하는데..... 잘 찾아보면, rownum 은 결과 값에 매겨지는 상대적인 값이므로,
			절대적인 신뢰감이 없고, 위의 수식도 먹지 않는다..... 
			뭐.. 안 믿으시면 한 번 해보시라.. --;;
			
			그럼.. 어떻게 해야할까?
			우리의 친구 꼼수를 한 번 발동 시켜볼까?
			
			* 해법 *
			************************************************************************************************
			# [Oracle]
			1. 아래 쿼리는, 데이터가 실제적으로 들어간 순서에 맞게 rownum을 부여 하여,
			그 값을 하나의 컬럼으로 출력될 수 있게 해준다.
			SELECT a.rownum as rnum, a.love_id
			FROM love a;
			
			2. 1에서 만들어진 쿼리를 아래와 같이 서브쿼리화 하여, between 사용이 가능해진다.
			SELECT b.love_id
			FROM (SELECT a.rownum as rnum, a.love_id FROM love a) as b
			WHERE b.rnum BETWEEN 1000 AND 2000;
			************************************************************************************************
			
			자, 그럼,, 저 위의 방식을 이용하여 마음껏(???) limit 인 척 해보자.


	cf) SELECT stor_name FROM stores 
WHERE stor_name LIKE '%Books%'


	cf) MySQL like와 regexp의 차이
			MySQL에서 like는 "%"를 이용하여 불특정 문자를 나타낼때 사용하지만
			regex는 검색에 정규 표현식을 사용하여 보다 복잡한 문자열 검색을 수행할 수 있습니다.
			정규표현식은 문자가 나타는 패턴을 약간의 문자식으로 편리하게 사용할 수 있도록 만든 것이며 
			like 구문은 쉘에서의 *,. 와 동일한 역할을 수행하게 하는 문장이죠
			mysql> select * from tt01 where name regexp '^[0-9][0-9]*.*de$'
			이렇게 쓰면 name 이 숫자로 시작하고 끝이 de로 끝나는 문자열을 검색해 주죠.like로는 못하죠. ^^;
			
			
	cf) Cookie cannot be resolved to a type 에러 제거
			가끔가다가 Multiple annotations found at this line - Cookie cannot be resolved to a type 라는 에러가
			발생하는데 이때는, 하기와 같이 Apache Tomcat v6.0를 Libraries로 추가하면 됨
			가) Java Build Path -> Libraries -> Add Library -> Server Runtime -> Apache Tomcat v6.0 추가
			

	cf) Java Bean 결과값을 배열로 저장
			EXCLASS ex = new EXCLASS();							// ex 클래스 객체 생성
			List exlist = ex.exmethod();						// exmethod에서 List 리턴
			String [] arra = new String[2];					// 리턴값을 저장할 배열 생성(arra[]이며 크기는 2인 String 배열 선언; arra[0], arra[1])
			
			for(int i=0; i<exlist.size(); i++)			// for문을 돌면서 List에 저장된
			{																				// 결과값을 저장한다
				arra[i] = (String)exlist.get(i);
				System.out.println("list===" + arra[i]);
			}


6)	JSP 웹서비스
	cf) Eclipse에서 웹서비스 테스트(JSP페이지 열기)할 때는 Windows XP에서 Back ground로 실행되고 있는 Tomcat을
			사용하는 것이 아니고 Eclipse내부에서 실행시킨 Tomcat을 사용하는 것임.
			따라서, Eclipse에서 웹서비스 테스트(JSP페이지 열기)할 때는 Windows XP에서 Back ground로 실행되고 있는 Tomcat을
			Stop시켜야만 함(Tomcat이 중복으로 실행되는 것을 막기 위해)
			또한, 이와 반대로 외부 IP에서 Server로 접속해서 JSP페이지를 열 때는 반대로 Eclipse내에서 실행되고 있는 Tomcat을
			Stop시키고 Server(Windows XP)에서 Back ground로 실행되고 있는 Tomcat을 Start 시켜서 Server(Windows XP)에서
			Back ground로 실행되고 있는 Tomcat이 외부 IP에 대한 웹서비스를 실행할 수 있도록 설정해야 함
	가)	Eclipse에서 해당 프로젝트명 -> 오른쪽마우스 -> Export -> WAR file -> Destination -> 
			C:\Program Files\Apache Software Foundation\Tomcat 6.0\webapps선택 -> Finish 눌러서 WAR file을 저장 시킴
	나) Server(Windows XP)에서 Back ground로 실행되고 있는 Tomcat을 Reload시키면 자동으로 WAR file이 컴파일 해석되서
			프로젝트명 폴더를 생성한다
	다) 외부 IP 웹브라우저에서 http://192.168.201.4:8080/프로젝트명 을 실행시키면 컴파일 해석된
			C:\Program Files\Apache Software Foundation\Tomcat 6.0\webapps\프로젝트명\index.jsp가 자동으로 실행된다
			이때, Server(Windows XP)에서 방화벽을 사용하고 있다면 반드시 방화벽 설정 -> 예외 -> 포트추가 -> 포트번호:8080 을
			추가 시켜서 8080포트는 방화벽에서 풀어주도록 설정해야 한다.
	cf.1)	외부 IP 웹브라우저에서
				http://192.168.201.4:8080/ 을 실행하면 C:\Program Files\Apache Software Foundation\Tomcat 6.0\webapps\ROOT\index.jsp가 실행됨
	cf.2) 외부 IP 웹브라우저에서
				http://192.168.201.4:8080/프로젝트명 을 실행하면 C:\Program Files\Apache Software Foundation\Tomcat 6.0\webapps\프로젝트명\index.jsp가 실행된다
				이때, C:\Program Files\Apache Software Foundation\Tomcat 6.0\webapps\ROOT\프로젝트명\index.jsp가 실행되는 것이 결코 아니다.
	cf) A/S서버IP 변경된 경우 환경 설정
			가) 제어판 -> 네트워크 연결 -> 로컬 영역 연결  -> TCP/IP변경
				과천IDC센터
					IP주소					: 203.225.255.118
					서브넷마스크		: 255.255.255.0
					기본게이트웨이	: 203.225.255.1
					기본DNS					: 203.225.253.254
			나) SQL Server Configuration Manager -> SQL Server 2005 Network Configuration -> Protocols for MSSQLSERVER -> TCP/IP
					-> "IP Address" 변경
			다) "http://xxx.xxx.xxx.xxx:8080/ASprocess"로 접속
	cf) 톰켓 접속 시간 변경(세션유지 시간 변경)
			가) 톰켓설치 루트 디렉토리 -> conf 폴더 -> web.xml -> session-config부분에 있는 session-timeout을 변경(분단위)




[17]	PORT(포트)
 TCP/IP 프로토콜에서 사용하는 Port 
1) 가장 많이 사용되는 포트 : 0 ~ 1023 
2) 예약된 포트 : 1024 ~ 49151 
3) 동적, 사설 포트 : 49152 ~ 65535

Cf)	윈도우 포트 확인하는 방법 
도스창에서

> netstat -a -o 하면
프로토콜	/ 로컬 아이피 	/ 원격아이피	/ 상태		/ PID 가 나옵니다 .
TCP			127.0.0.1:80	127.0.0.1		LISTENING   14520
PID 가 프로그램의 아이디 이며 
cf)도스창에서 "netstat -na"명령을 실행시켜 1433포트가 열려 있는지 확인(TCP 0.0.0.0:1433)

> tasklist /fi "pid eq 14520" 
하면 해당 포트를 사용중인 프로세스의 이름이 나오게 됩니다.

> tasklist /svc  하면 svchost.exe 의 실행목록이 나옵니다 ..

Cf)	tftp / nfs 데몬 활성화 확인
	netstat -au
	............................
	udp 0 0 *:nfs  *:*
	............................
	udp 0 0 *:tftp *:*
	............................	

Cf)	nfs 데몬 활성화 확인
	#netstat -a | grep nfs
	tcp        0      0 *:nfs                   *:*                     LISTEN     
	tcp        0      0 10.0.2.15:nfs           10.0.2.16:784           ESTABLISHED
	tcp6       0      0 [::]:nfs                [::]:*                  LISTEN     
	udp        0      0 *:nfs                   *:*                                
	udp6       0      0 [::]:nfs                [::]:* 

Cf)	netstat
1. netstat(Network Statistics)이란 무엇인가?
리눅스에서는 네트워크의 관련 정보를 볼 수 있는 여러가지 유용한 명령어를 가지고 있는데
가장 자주 사용되는 것중의 하나가 바로 netstat이라는 명령어입니다.
netstat이란 네트워크의 상태를 볼 수 있는 명령어로서, 윈도우즈에도 기본적으로 포함되고 있습니다.
현재 내가 인터넷을 사용하지 않더라도 모든 시스템은 보이지않는 네트워크의 활동이 있습니다.
ADSL 사용자의 경우 주기적으로 DHCP라 불리는 서버와 통신이 이루어지고 또한 
게이트웨이와도 꾸준하게 패킷 전송이 이루어집니다.
이러한 패킷을 볼 수는 없지만 현재 내 시스템에서 이루어지는 네트워크 상황을 모니터링할 수 있는
프로그램이 바로 netstat입니다. 물론 실시간으로 모니터링하는데는 약간의 번거로움이 있지만 
명령어 자체가 가지고 있는 의미로서의 기능은 충실합니다.

2. 기본적인 netstat 사용
콘솔창에서 netstat이라는 명령어를 입력하고 엔터를 쳐볼까요?
아래와 같이 무수히 많은 정보가 출력되는걸 알 수 있습니다.
이제 이것들이 무엇인지 하나하나 알아보도록 하겠습니다.
netstat을 아무 옵션없이 입력하게 되면 현재 네트워크에서 이루어지는 모든 통신에 대해서 출력됩니다.
우리는 주로 TCP 프로토콜을 사용하므로 프로토콜에 관련된 것들만 확인해 보려면 아래와 같이 합니다.

#netstat -na | grep tcp
tcp	0	0	127.0.0.1:32768			0.0.0.0:*			LISTEN
tcp	0	0	0.0.0.0:111				0.0.0.0:*			LISTEN
tcp	0	0	203.246.71.16:32781		203.246.64.12:80	ESTABLISHED
tcp	0	0	203.246.71.16:32780		203.246.64.12:80	ESTABLISHED
TCP사용중	로컬어드레스:포트		외부어드레스:포트	현재상태

설명 : netstat -na | grep tcp
먼저 netstat -na란 현재 내 시스템에서 이루어지는 모든 통신 내용을 출력하고(a옵션),
도네임이름으로 변경하지 말고(n옵션) 그냥 출력하라는 의미입니다. 즉 -n옵션을 사용하면
IP주소로 출력이 되겠지요.
그리고 바로 뒤에 파이프(|)가 오게 되는데 이것의 역할은 앞에서 사용된 명령어의 출력 결과를
뒤에 나오는 명령어의 입력값으로 사용하겠다는 의미입니다.
grep(움켜쥐다)이란 문자열에서 내가 원하는 특정 문자열을 추출할 때 유용하게 사용되는 명령어이며
이처럼 리눅스에서는 단일 명령어로서 사용되는 것이 아니라 다른 명령어와 함께 조합되어 
사용됩니다. grep은 이외에도 거의 모든 명령어에 조합되서 사용이 가능하기 때문에 여러분은
반드시 grep을 필수적으로 외우고 활용할 줄 알아야 합니다.
즉, netstat -na의 출력 결과가 grep의 입력으로 들어가게 되는데 grep tcp라고 명령어를 주었습니다.
그러므로 위의 그림과 같이 tcp가 포함된 문자열만 추출해서 화면에 출력되게 됩니다.
가장 오른쪽에 LISTEN 혹은 ESTABLISHED가 나오는데 LISTEN은 해당 포트를 청취중이라는
의미이고 ESTABLISHED는 이미 연결이 성립된 경우를 말합니다.

위의 그림에서 203.246.71.16과 203.246.64.12와 연결 성립되어 있다는 걸 알 수 있고 포트번호가
80번이므로 현재 웹브라우저를 사용해서 연결이 되었다고 생각할 수 있습니다.
우리가 일반적으로 인터넷(WWW)을 이용할 때는 웹서버에서 80번 포트를 사용하게 됩니다.
물론 서버관리자가 이를 변경할 수도 있지만 80번은 웹서비스만을 위해서 예약된 포트입니다.
0.0.0.0:*의 의미는 모든 외부의 IP주소로부터 연결을 기다리고 있다는 의미입니다.

unix	3	[ ]		STREAM	CONNECTED	5993	/tmp/.ICE-unix/1733
unix	3	[ ]		STREAM	CONNECTED	5992
unix	3	[ ]		STREAM	CONNECTED	5991	/tmp/.ICE-unix/X0
unix	3	[ ]		STREAM	CONNECTED	5990
...................................................................
그럼 위의 그림과 같은 경우는 어떻게 설명해야 할까요?
위의 그림은 프로세스간 통신을 의미합니다. 가장 왼쪽에 프로토콜이 나오는데 UNIX라고 되어 있죠.
이것은 내부 프로세스간 통신을 말합니다. 즉, 시스템상에서 돌아가는 다양한 프로세스들간에
상호 데이터 교환을 위해서 통신이 이루어지고 있는 것을 말합니다. 이것을 IPC라고도 하고
내가 만든 프로세스와 다른 프로세스 간의 통신은 여러분이 유닉스 시스템 혹은 
네트워크 프로그래밍 시간에 배우게 될 것입니다.
STREAM이란 TCP방식으로 통신이 이루어지고 DGRAM이란 UDP 프로토콜로 통신이 이루어지고
있음을 의미합니다.

위의 그림처럼 netstat -s 옵션을 사용하면 각 프로토콜 별로 패킷 전송 및 수신에 관한
데이터를 볼 수 있습니다.

3. 주기적인 netstat의 확인이 필요한 이유
시스템을 관리하면서 주기적으로 netstat을 확인해줘야 하는 이유는 네트워크의 문제점은 없는지
확인하는 일도 있고 혹시 시스템이 공격을 당하고 있는것은 아닌지, 내 시스템에서 사용중인
다른 유저들이 어떤 사이트를 이용하고 있는지 확인할 때도 사용합니다.
무엇보다도 해킹을 당하고 있거나 혹은 당한 후 비정상적으로 네트워크의 속도가 느려지거나
내가 모르는 외부 주소로 빈번하게 통신이 이루어지는 경우라면 해킹을 의심해봐야 합니다.
해커는 정보를 노리고 있기도 하지만 시스템의 자원과 대역폭을 노리고 자신이 원하는 목적지까지
가기전에 내 시스템을 경유해서 갈 수도 있기 때문에 관리자가 이를 주기적으로 확인하고
대처할 수 있는 능력을 필요로 합니다.
리눅스를 아직 설치하지 못한 분들도 윈도우에서 netstat명령을 사용할 수 있으니 
한번쯤은 꼭 실행해보고 결과값을 본 후 어떠한 연결이 이루어지고 있는지 확인해보시기 바랍니다.

4. netstat의 응용
netstat을 응용해서 사용할 수 있는 또 하나의 방법이 있습니다.
만약 내가 PC방에 갔을 경우 V3등의 백신 프로그램이 설치되지 않았다는 것을 가정으로 할 때
여러분은 과연 내가 앉은 PC가 해킹툴에 감염이 되었는지 되지 않았는지 확신할 수 없을겁니다.
이럴 경우 모든 인터넷과 메신저등의 프로그램을 모두 종료하시고 NETSTAT -NA 명령을 사용해서
PC방의 카운터를 제외하고는 연결된 곳이 하나도 없어야 합니다.
만약 인터넷도 하지 않고 메신저도 하지 않는데 의심스러운 IP주소와 연결이 성립되어 있다면
해킹툴로 가정은 할 수 있습니다. 물론 확실한 것은 아니고 분명히 가정입니다.
여러분이 정상적이 연결과 비정상적인 연결을 구분할 수 있다면 충분히 가능합니다.
이 경우 PC방을 예로 들었지만 공용PC실도 포함되고 많은 곳에서 생각해 볼 수 있습니다.
2000년도에 미국의 해킹그룹 cDc(Cult Dead Cow- 죽은 소들의 숭배)에서 발표한 백오리피스 종류의
S/C(서버/클라이언트)환경을 통해서 실행되는 해킹 프로그램의 경우 반드시 공격자와 희생자의
컴퓨터가 TCP이던 UDP이던 연결이 성립되어야만 가능하기 때문입니다.
만약 여러분이 모든 인터넷과 관��� 연결을 종료한후 의심스러운 연결을 구별해 낼 수 있다면
적어도 이러한 종류의 해킹프로그램은 백신이 없더라도 추측이 가능합니다.
말이 약간 다른 곳으로 빠졌군요. 어찌되었든 NETSTAT을 �� 한번��� 실행해 보세요.
그럼 열심히^^

Cf)	윈도우7 방화벽 특정 포트 열기
방법1)	하기와 같이 설정해야지만 정말/제대로 포트가 열림
1.	제어판 -> Windows 방화벽 설정 또는 해제 -> "Windows 방화벽 사용 안 함" 모두 선택
방법2)	하기와 같이 실행해도 포트가 열리지 않음
1.	제어판 -> Windows 방화벽 -> 고급설정
2.	좌측 인바운드 규칙 클릭 -> 오른쪽 "새규칙" 클릭
3.	포트 선택
4. 	TCP, 특정 로컬 포트 : 5554(열어주고자 하는 포트)
5.	연결허용
6.	도메인, 개인, 공용 모두 선택
7.	이름(ex, javaw debugging -> 포트 열어 주는 것을 설명할 수 있는 이름)
8.	인바운드 규칙에 javaw debugging 이 새롭게 추가된 것이 보인다.

Cf)	Ethernet 통신이 가능한지 체크 방법
도스창에서
ping 168.126.63.1 or ping www.yahoo.com 명령을 실행시켜서 응답이 오는지 확인
만약 응답이 없으면 시스템 자체가 Ethernet 통신을 할 수 없는 경우 임

Cf)	localhost나 127.0.0.1의 의미?
자신의 PC를 가리키는 주소가 127.0.0.1 입니다. loopback address 라고도 합니다 (내가 보내면 내가 받게 되니까)
��찬가지로 localhost도 일반적으로 내 컴퓨터를 가리키는 가상의 도메인입니다.
윈도우즈라면 C:\Windows\System32\drivers\etc\hosts 파일에 정의되어 있죠.
cf)	공유기 등이 없어서 서버 프로그램 & 클라이언트 프로그램 모두 동일한 PC 에서 동작시켜서
	정상 동작 유/무를 확인해야 한다면 본 localhost로 ip를 설정하면 됨
cf)	0.0.0.0 은 두 가지 의미가 있다
	하나는 자신이 가지고 있는 IP어드레스 모두를 의미하며
	또 하나는 자신에 접속하는 어드레스는 어떤 특정 어드레스가 아닌 모두로부터 접속 가능하다는 의미이다.

Cf)	Super DMZ(RG-3000A 공유기 셋팅)
	우선, http://192.168.10.1/ 로 접속해서 공유기 셋팅 화면으로 들어 감
	cf) 로그인 비밀번호 : admin
	
	√ Super DMZ 서버 또는 DMZ 서버를 적용하면 RG-3000A의 방화벽이 해제 됨으로 바이러스 또는 해킹의 위험에 노출 될 수 있습니다.
	
	Super DMZ 서버
	Super DMZ서버로 DMZ로 지정된 PC는 RG-3000A가 부여 받은 공인 IP를 그대로 사용할 수 있어
	리얼 서버를 운영할 수 있고 모든 게임과 P2P 응용 프로그램을 제한 없이 사용할 수 있습니다. 
	단, 내부 PC중 1대에서만 적용이 가능하며, Super DMZ로 지정된 PC와 다른 내부 PC와의 인터넷 게임과 P2P는 이용이 제한될 수 있습니다.
	(IPX를 이용한 랜 게임이나 프린터/파일 공유는 사용이 가능합니다.)
	
	셋팅 방법
	[Super DMZ 사용]에 체크한 후 [맥주소 검색]버튼을 누릅니다. RG-3000A와 연결된 PC의 목록 창이 나타납니다. 
	목록 창에서 본 기능을 적용할 PC를 선택 한 후 [확인]해 주십시오.

▶ 가장 많이 사용되는 포트 요약  (0~1023) 

키워드
 포트번호
 포트용도
 
icmp
 8/tcp, 8/udp, 

0/tcp, 0/udp
 Unassigned
 
ftp-data
 20/tcp, 20/udp
 File Transfer [Default Data]
 
ftp
 21/tcp, 21/udp
 File Transfer [Control]
 
ssh
 22/tcp, 22/udp
 SSH Remote Login Protocol
 
telnet
 23/tcp, 23/udp
 Telnet
 
smtp
 25/tcp, 25/udp
 Simple Mail Transfer
 
domain
 53/tcp, 53/udp
 Domain Name Server
 
whois++
 63/tcp, 63/udp
 whois++
 
tftp
 69/tcp, 69/udp
 Trivial File Transfer
 
gopher
 70/tcp, 70/udp
 Gopher
 
finger
 79/tcp, 79/udp
 Finger
 
www
 80/tcp, 80/udp
 World Wide Web HTTP
 
pop3
 110/tcp, 110/udp
 Post Office Protocol - Version 3
 
ntp
 123/tcp, 123/udp
 Network Time Protocol
 
epmap
 135/tcp, 135/udp
 DCE endpoint resolution
 
profile
 136/tcp, 136/udp
 PROFILE Naming System
 
netbios-ns
 137/tcp, 137/udp
 NETBIOS Name Service
 
netbios-dgm
 138/tcp, 138/udp
 NETBIOS Datagram Service
 
netbios-ssn
 139/tcp, 139/udp
 NETBIOS Session Service
 
imap
 143/tcp, 143/udp
 Internet Message Access Protocol
 
snmp
 161/tcp, 161/udp
 SNMP
 
namp
 167/tcp, 167/udp
 NAMP
 
imap3
 220/tcp, 220/udp
 Interactive Mail Access Protocol v3
 
ldap
 389/tcp, 389/udp
 Lightweight Directory Access Protocol
 
https
 443/tcp, 443/udp
 http protocol over TLS/SSL
 
shell
 514/tcp
 cmd
 
syslog
 514/udp
 syslog
 
printer
 515/tcp, 515/udp
 spooler
 
ftps-data
 989/tcp, 989/udp
 ftp protocol, data, over TLS/SSL
 
ftps
 990/tcp, 990/udp
 ftp protocol, control, over TLS/SSL
 
telnets
 992/tcp, 992/udp
 telnet protocol over TLS/SSL
 
imaps
 993/tcp, 993/udp
 imap4 protocol over TLS/SSL
 
pop3s
 995/tcp, 995/udp
 pop3 protocol over TLS/SSL (was spop3)

▶ 예약된 포트 요약  (1024 ~ 49151) 

키워드
 포트번호
 포트용도
 
ms-sql-s
 1433/tcp, 1433/udp
 Microsoft-SQL-Server
 
ms-sql-m
 1434/tcp, 1434/udp
 Microsoft-SQL-Monitor
 
sybase-sqlany
 1498/tcp, 1498/udp
 Sybase SQL Any
 
atm-zip-office
 1520/tcp, 1520/udp
 atm zip office
 
ncube-lm
 1521/tcp, 1521/udp
 nCube License Manager
 
ricardo-lm
 1522/tcp, 1522/udp
 Ricardo North America License Manager
 
cichild-lm 
 1523/tcp, 1523/udp
 cichild
 
ingreslock
 1524/tcp, 1524/udp
 ingres
 
orasrv
 1525/tcp, 1525/udp
 oracle
 
sybasedbsynch
 2439/tcp, 2439/udp
 SybaseDBSynch
 
sybaseanywhere
 2638/tcp, 2638/udp
 Sybase Anywhere
 
ms-wbt-server
 3389/tcp, 3389/udp
 MS WBT Server
 
http-alt
 8080/tcp, 8080/udp
 HTTP Alternate (see port 80)
 
cf)	다중접속 포트
포트라는 곳은 접속하고자 하는 문이고 이 문은 서버측은 고정되어있어야 됩니다.
즉 접속하는 문이니 하나로 고정되어있으면 모든 클라이언트가 이 문으로 접속을 시도합니다.
그러면 서버는 해당 클라이언트에게 데이터를 전송할 수 있는 스트림을 생성해서 연결됨 그 스트림의 한쪽끝은 클라이언트의 임의의 포트로 연결됨(OS가 비어있는 아무포트를 사용 - 사용자가 알 필요없음)
이렇기 때문에 각 클라이언트의 스트림 포트는 유동적으로 바뀌는 것이고 서버는 그냥 하나로 고정되어 있는 겁니다. 즉 포트가 여러개 필요한게 아닙니다.

cf)	Linux에서 열린 포트 확인/상대방 포트 확인/포트 열기
리눅스에서 서버 프로세스를 개발하고 테스트하다 보면 서버 프로세스는 정상적으로 기동되어 있는데 다른 컴퓨터에서 접속이 안되는 경우가 있다.
여러 가지 이유가 있겠지만 포트가 열려 있지 않아서 그런 경우도 있다. 
이 글은 그런 상황에서 포트가 열려 있는지를 확인하고 닫혀 있었다면 포트를 열어주는 방법에 대한 글이다.


1.	리눅스에서 현재 열려 있는 포트를 확인하는 방법
	1)	열려 있는 모든 포트를 표시하기
		netstat -nap
			n:host명으로 표시 안함
			a:모든소켓 표시
			p:프로세스ID와 프로그램명 표시
	2)	LISTEN중인 포트를 표시하기
		netstat -nap | grep LISTEN)


2.	상대방 포트가 열려 있는지를 확인하는 방법
	상대방 머신에 접속이 되지 않을 때 혹시 포트가 막혀 있는지를 확인해 보자.
	netcat(nc) 네트워크 유틸리티를 이용하면 된다. 

	1)	특정 호스트의 특정 포트가 열려 있는지를 확인하기
		nc -z 호스트주소 포트
		ex) nc -z www.google.com 80
			<결과예>
			Connection to www.google.com 80 port [tcp/http] succeeded!
				z: 포트 검색

	2)	특정 머신의 포트 범위를 지정하여 열린 포트를 확인하기
		nc 호스트주소 -z 시작포트-끝포트
		ex) nc 10.20.30.40 -z 19-21
			<결과 예>
			Connection to 10.20.30.40 21 port [tcp/ftp] succeeded!
			Connection to 10.20.30.40 22 port [tcp/ssh] succeeded!
			Connection to 10.20.30.40 23 port [tcp/telnet] succeeded!

3.	포트를 열기
	위의 방법으로 호스트의 포트가 LISTEN중임을 확인하였는데 상대방 호스트에서 포트가 열려있지 않다고 나온다면, 
	호스트의 포트가 막혀 있을 가능성이 있다.
	포트를 열려면 iptables를 사용하면 된다. iptables는 리눅스 방화벽을 설정하는 명령어이다.

	1)	특정 포트를 외부에서 접속할 수 있도록 열기
		iptables -I INPUT 1 -p tcp --dport 12345 -j ACCEPT 
			I: 새로운 규칙을 추가한다.
			p: 패킷의 프로토콜을 명시한다.
			j: 규칙에 해당되는 패킷을 어떻게 처리할지를 정한다.
		이 명령은 외부에서 들어오는(INBOUND) TCP포트 12345의 연결을 받아들인다는 규칙을 방화벽 1번 방화벽 규칙으로 추가한다는 의미이다.
		이렇게 추가한 규칙은 조회나 삭제가 가능하다.

	2)	추가한 설정 조회하기
		조회하기
		iptables -L -v
			L: 규칙을 출력
			v: 자세히

	3)	추가한 설정 삭제하기
		규칙을 삭제하려면 추가한 규칙의 번호로 삭제하는 방법과 추가했을 때의 명령어에서 "-I"를 "-D"로 바꾸어 주는 방법이 있다.
		규칙번호로 삭제하기
		iptables -D INPUT 1

		추가한 규칙으로 삭제하기
		iptables -D INPUT -p tcp --dport 12345 -j ACCEPT 
			D: 규칙을 삭제

cf)	telnet 으로 포트 통신 상태 확인

1.ping test를 한다.
[svr:usr] ping 172.0.0.1
응답없으면(ping이 되지 않으면) firewall에 등록이 되지 않은 것이다.
정상적 결과 172.0.0.1  is alive

2.1.telnet ip port 로 확인한다. 
[svr:usr] telnet 172.0.0.1 9999 
Trying 172.0.0.1... 
계속 대기 중이면 방화벽 오픈이 안된 것이다.

2.2 
[svr:usr] telnet 172.0.0.1 9999 
Trying 172.0.0.1... 
telnet: Unable to connect to remote host: Connection refused 
바로 연결거부가 발생하면 방화벽 오픈은 되었으나 프로세스가 안 떠있는 것이다. 
(포트를 열고 대기하고 있지 않은 상태) 

2.3 
[svr:usr] telnet 172.0.0.1 9999 
Trying 172.0.0.1...
Connected to 172.0.0.1
Escape character is '^]'.
방화벽 오픈이 정상적으로 되었고 프로세스가 올라가 있는 것이다.
(포트를 열고 대기하고 있는 상태)
=> 이상태가 되야 통신테스트를 할 수 있다

3. 라우팅 테이블 확인하기
[svr:usr] netstat -rn | grep 172.0.0.1
172.0.0.1         172.0.0.1            UG       1 186064
여기에 값이 있으면 올바로 설정된 것임.


[18]	HDN7100에서 CPU(S3C2440)와 Graphic chip(SM501)과의 관계
	CPU(S3C2440)에서는 SM501로 바탕화면에 대한 Address, x, y등의 데이터와 도어폰 화면을 어떤 Layer정보로 처리하라는 등의 명령만 SM501로 전송하고 
	SM501은 자신이 직접 Address, x, y등의 정보를 가지고서 RAM에서 바탕화면의 그림 데이터를 받아들이고 도어폰 화면을 해당 Layer로 처리해서 오버랩 해서
	LCD로 보내는 역할을 담당한다.(cf. YGV629와 ATmega128과 똑같은 명령 관계이고 다른 점은 
	SM501은 Digital바탕화면 & Digital도어폰화면 데이터를 가지고서 처리하며
	YGV629는 Digital바탕화면 & Analogue도어폰화면 데이터를 가지고서 처리한다.)
	(cf. 비디오 캡쳐 기능은 CPU(S3C2440)에서 담당한다)


[18-1]	HDN7100에서 기기연동 설명
	1) 가스밸브(신우전자), 조명제어는(아남르그랑, 세코(세인전기)) 회사에 관계 없이 모두 동일 Protocol로 동작하기 때문에
		 프로그램 수정 없이 상기 제품을 사용하면 되고
	2) 보일러는 한성(HAUWELL)과 린나이로 Protocol이 구분되어 있기 때문에
		 Z:\home\proj\workspace\hdn-7100\uClinux-dist\user\system_run\Makefile 에서 사용하는 제품을 설정해서 compile(make)시켜줘야 한다
		 (Room-con : RINNAI, HAUWELL		Boiler : RINNAI, KYOUNGDONG, KITURAMI)
	3) 중국전시대 : 전등 -> 2구 아남르그랑, Room-con -> HAUWELL Room-con과 마스터컨트롤러
		 현대디지텍기기제어전시대(old) : 전등 -> 2구 세코(세인전기),	Room-con -> HAUWELL Room-con과 마스터컨트롤러
		 리브릿지빌 과천빌라 : Room-con -> RINNAI




[19]	원격 데스크톱 연결에서 "시스템 종료" 하기
		윈도우에 "시스템 종료" 메뉴가 보이지 않을 때는 콘솔에서 shutdown 명령을 실행시킬 수 밖에 없음
		cf) 원격 데스크톱 연결 안에서 프로그램 설치 나 업그레이 등을 하면 원인을 알 수 없는 희안한 에러 발생 가능성 높다
				따라서, 원격 데스크톱 안에서는 왠만하면 프로그램 설치나 업그레이등을 실행하지 말아야 한다.

		C:\Documents and Settings\lgt>shutdown
		사용법: shutdown [-l | -s | -r | -a] [-f] [-m \\컴퓨터 이름] [-t xx] [-c "설명"] [-d up:xx:yy]
        No args                 이 메시지를 표시합니다.(-?와 동일)
        -i                      GUI 인터페이스 표시합니다.(처음 옵션이어야 합니다.)로그오프합니다. (-m 옵션과 함께 사용될 수 없음)
        -s                      시스템을 종료합니다.
        -r                      시스템을 종료한 후 다시 시작합니다.
        -a                      시스템 종료를 중단합니다.
        -m \\컴퓨터 이름        원격 컴퓨터를 종료/다시 시작/중단합니다.
        -t xx                   시스템 종료의 만료 시간을 xx초로 설정합니다.
        -c "설명"               시스템 종료 설명을 지정합니다. (최대 127 문자)
        -f                      실행 중인 응용 프로그램을 경고 없이 강제로 종료합니다.
        -d [u][p]:xx:yy 종료에 대한 이유코드를 지정합니다.
                                u: 사용자 코드
                                p: 계획된 종료 코드
                                xx: 주 이유 코드 (256 보다 작은 양수)
                                yy: 부 이유 코드 (65536 보다 작은 양수)




[20]	[FreeImage] FreeImage 라이브러리 간단 매뉴얼
● FreeImage 란?
○ Multimedia 애플리케이션 개발을 위해 여러 ImageFormat을 지원하는 오픈소스 라이브러리.
○ 대표적인 지원 포맷 : PNG, BMP, JPEG, TIFF

○ 특징
사용하기 쉽다.
빠르다.
멀티 쓰레딩에 안전하다.
플랫폼에 독립적이다.

● 사용법
○ FreeImage사용에는 크게 두 부분으로 나늰다. FreeImage 라이브러리를 사용하기 위해 준비하는 과정과 실제 준비하는 과정이다.
 
1. FreeImage 세팅
- Initialize : FreeImage 사용을 위한 초기화.
FreeImage_Initialise();
- Destroy : Application이 종료되기 전에 FreeImage 라이브러리 해제작업.
FreeImage_DeInitialise();

2. FreeImage 이용
- Load Texture : FreeImage의 대표적인 사용처라면 Texture 출력을 위해 이미지 파일을 로딩하는부분 일 것이다. 다음은 이미지를 로딩하여 사용하는 코드다.

// Image File을 로드한다.
bool LoadDIB(std::string strFileName)
{
    // 파일내용을메모리에넣는다.
    FREE_IMAGE_FORMAT freeImageFormat;

    // Image 의 포맷을 검사하는 부분.
    // FreeImage 의 편리한 점은 이렇게 파일명만 가지고도 Image의
		// 포맷까지 검사해 준다는 것이다.
    freeImageFormat = FreeImage_GetFIFFromFilename(strFileName.c_str());

    if( FIF_UNKNOWN == freeImageFormat )
           return false;

    // Image파일을 로드하여 Bitamp으로 저장한다.
    FIBITMAP* pFreeImageDIB = FreeImage_Load(freeImageFormat, strFileName.c_str());
    if( NULL == pFreeImageDIB )
           return false;

    FreeImage_FlipVertical(pFreeImageDIB);

    return true;
}

// 로드된 이미지를 해제한다.
// 로드된 Bitmap이미지 데이터를 실제 사용될 메모리에 복사한 이후에는
// 이런 식으로 해제해주어야 한다.
void s1_ImageCodec_FreeImag::UnloadDIB(FIBITMAP* pFreeImageDIB)
{
    if(pFreeImageDIB)
    {
           FreeImage_Unload(pFreeImageDIB);
           pFreeImageDIB = NULL;
    }
}

// 다음은 실제 위의 두 함수를 이용하여 텍스쳐를 생성하는 SeoulStroy 코드의 일부분이다.
// 가독성을 위해 부가적인 에러 검사 등의 부가적인 코드는 삭제했다.
bool s1_Texture::LoadTexture(std::string strFileName)
{
    // FreeImage를 이용해 이미지를 로드한 후, 이미지 데이터를 메모리에 적재한다.
    m_pImageCodec->LoadDIB(strFileName);

    // FreeImage를 사용하면 이미지의 정보를 간편하게 불러올 수 있다.
    // 아래 GetWidth()와 GetHeight()함수는 FreeImage의
// FreeImage_GetWidth(),FreeImage_GetHeight 함수를 래핑한 것에 불과하다.
    m_nWidth = m_pImageCodec->GetWidth();
    m_nHeight = m_pImageCodec->GetHeight();

    // Bitmap이미지의 사이즈를 가져오는 부분.
    // GetDIBSize()는 FreeImage_GetDIBSize()의 래핑일 뿐이다.
    unsigned int dibSize = m_pImageCodec->GetDIBSize();

    // 이 부분에서 D3DXCreateTextur()함수와 위에서 얻은 정보를 이용해
		// Texture객체를 생성한다.

    // 다음은 Texture가 생성된 상태에서 Texture에 이미지 데이터를 복사해 넣는 부분이다.
    D3DLOCKED_RECT destLockRect;
    ::ZeroMemory(&destLockRect, sizeof(destLockRect));
 
    if( FAILED(m_pTexture->LockRect(0, &destLockRect, NULL, 0)) )
           return false;

// 다음 세줄이 실제적인 작업을 수행하는 코드다.
    unsigned char* pBits = static_cast<unsigned char*>(destLockRect.pBits);
    unsigned char* texMem = m_pImageCodec->GetBits();
    memcpy(pBits, texMem, dibSize);
 
    if( FAILED(m_pTexture->UnlockRect(0)) )
           return false;

// 사용이 끝난 FreeImage의 Bitmap 데이터는 해제시켜준다.
    m_pImageCodec->UnloadDIB();
    return true;
}




[21]	원격제어프로그램 실행과정
	1. 리눅스서버
    	1) 리눅스 booting시 아파치 데몬 프로그램 실행
			httpd(Client에서 본,리눅스서버를 accept하면 /var/www/html/index.html 파일을 accept요청한 Client로 보냄,
			/var/www/html/index.html 위치는 /etc/httpd/conf/httpd.conf 파일에 명시되어 있음)
     
			2) /etc/rc.d/rc.local 실행

			[root@hn subsys]# vi /etc/rc.d/rc.local
			#!/bin/sh
			#
			# This script will be executed *after* all the other init scripts.
			# You can put your own initialization stuff in here if you don't
			# want to do the full Sys V style init stuff.
			
			touch /var/lock/subsys/local
			
			/work/samserver/mserver &				-> /work/samserver/main.c 실행
			~
			~
			~
			~
			~
			~
			~
			~
			~
			~
			~
			-- INSERT --                                                  11,1          All 
	     
	2. Data flow 처리 설명
		Client 웹페이지에서 서버(211.41.16.




[22]	ID, Password
	1. 원격제어 server
		http://hn.e-homewiz.com/
		1) id : admin
		   password : digitech_server
		2) id : test
		   password : test
		   homenet id = 1
	2. 원격제어 server _ PC
		username : root
		password : digitech_server
		
		Address : 211.41.16.45
		Subnet mask : 255.255.255.224
		Gateway : 211.41.16.33




[23]	리눅스 명령어
	1. 삼바 마운트(윈도우-리눅스 파일 공유)
		#smbmount //192.168.201.18/Download /mnt
		-> Download(윈도우XP, C:\Download, 읽고 쓰기로 속성을 줌)
	2. scp(리눅스-리눅스 끼리 파일 전송)
		1) test.txt 파일을 ip:211.41.16.45 인 컴퓨터에 root라는 계정으로 접속하여
		   /usr/local/src/ 밑에 복사하는 명령
		   #scp ./test.txt root@211.41.16.45:/usr/local/src/
		2) ip:211.41.16.45 인 컴퓨터에 root라는 계정으로 접속하여
		   /usr/local/src/ 밑에 있는 test.txt라는 파일을 자신의 컴퓨터로
		   현재 위치한 directory에 복사하는 명령
		   #scp root@211.41.16.45:/usr/local/src/test.txt ./
	3. ftp(윈도우-리눅스 파일 전송)
		C:\Download>ftp
		ftp>open
		To 211.41.16.45
		......
		230 Login successful
		ftp>get test.txt			-> remote에서 local로 파일을 가져온다
		ftp>put test.txt			-> local에서 remote로 파일을 전송
		ftp>mget *.txt				-> get과 동일하지만 여러 파일을 가져온다,	mget *	-> 모든 파일을 가져온다
		ftp>mput *.txt				-> put과 동일하지만 여러 파일을 전송,			mput *	-> 모든 파일을 전송
		ftp>close					-> 현재 접속을 끊는다
		ftp>bye						-> ftp에서 나간다
	4. cabarc(파일들을 cab 파일로 압축해주는 명령)
		cabarc n samax.cab samax.ocx samax.inf




[24]	원격제어서버 처리 flow

*.*.*.*						211.41.16.45:80					211.41.16.45:7575				192.168.201.*
[웹페이지]					[서버Prog1]						[서버Prog2]						[세대기]
							samax(ActiveX)					samserver(C)

Client -------------------> Server
		211.41.16.45
		www(HTTP):80port
							Client -----------------------> Server
									211.41.16.45
									특정port:7575port
															Server <----------------------- Client
																	 211.41.16.45				|
																	 특정port:7575port			|/	
															
															미리 세대기들이 서버Prog2와 모두 연결되어 있어야지만
															WEB/WAP 제어가 가능함(ex.1000세대라면 1000세대기가
															미리 모두 연결되어 있어야함)


Client -> Server로 request했으면 Server는 Client의 ip를 기억하고 있다가
Answer data를 보낼 때 기억하고 있던 Client의 ip로 보내야만 한다
이때, Linux 프로그램상에서는 Client를 구분할 때 소켓1,소켓2,소켓3....,소켓10등 번호로써만 구분하기 때문에
소켓1 Client에 Answer data를 전송할 때는 write(1,buf,strlen(buf)); 과 같이 간단히 번호만 넣어주면 되며
나머지 소켓1번의 ip를 대입시켜서 보내는 일은 Linux kernel 안에서 처리해 주는 것 같다.
또한, 확실하지는 않지만 Ethernet H/W와 Linux kernel 상에서 Client를 구분하는 것은 ip가 아닌 mac address인 것 같다




[25]	리눅스 커널 컴파일 과정
make menuconfig 명령을 입력하면 먼저 기존에 make menuconfig 시 생성한 심볼릭 링크 디렉토리인 include/asm 디렉토리를 지우고 
컴파일하고자 하는 아키텍처의 헤더 파일이 들어 있는 디렉토리를 include/asm 디렉토리에 심볼릭 링크한다.

가령 컴파일하고자 하는 아키텍처가 i386이라면 include/asm-i386 디렉토리를 include/asm 디렉토리로 심볼릭 링크한다. 
이는 커널 소스 내에서 아키텍처 종속적인 헤드 파일에 대해서 “#include <asm/timer.h>” 와 같은 형태로 참조하도록 돼 있기 때문이다.

커널 2.6에서는 조금 방식이 바뀌었는데 make zImage 또는 make bzImange 하는 순간에 include/asm-i386 디렉토리가 include/asm 디렉토리로 심볼릭 링크된다.

include/asm 심볼릭 링크를 만들었으면 scipts/lxdialog 디렉토리에 lxdialog 프로그램을 컴파일한다. 
make menuconfig 명령을 입력하면 푸른 화면의 메뉴가 나타남을 확인할 수 있을 것이다. 
이는 ncurses 라이브러리를 사용하는 lxdialog 프로그램이 띄워 주는 것이다.

lxdialog 는 make menuconfig 명령외에도 리눅스 응용애플리케이션의 화면 인터페이스를 위해 많이 사용되는 프로그램이다. 
실제로 배포판에 따라 /usr/bin./lxdialog 또는 /usr/bin/dialog 프로그램이 존재함을 확인할 수 있다.

다음으로 scripts/Menuconfig 스크립트가 arch/i386/config.in 을 파싱해서 lxdialog의 인수로 넘겨주면 menuconfig 화면이 출력된다.

커널2.6에서는 이 방식이 약간 바뀌어 lxdialog 컴파일 이전에 scripts/kconfig/mconf 를 컴파일하게 되는데 scripts/kconfig/mconf 가
arch/i386/Kconfig 를 파싱해서 lxdialog 의 인자로 넘겨 주도록 되어 있다.

2.4버전의 arch/i386/config.in 파일과 2.6버전의 arch/i386/Kconfig 파일은 커널 옵션의 종속 관계를 정리해 놓은 파일로서 
여기에는 각 옵션에 대한 정의와 해당 옵션이 종속돼 있는 dhqtusemfd에 대해서 정리해 놓고 있다.

2.4 버전의 config.in 파일과 2.6버전의 Kconfig파일은 그 기능에서 동일하지만 문법적인 면에서 약간 차이가 있다. 
2.4 버전의 config.in 파일은 문법이 다소 난잡하고 종속관계 기술이 힘들었던 반면 2.6 버전의 Kconfig 파일은 문법이 간결하며 종속관계 기술이 매우 쉽다.

makde menuconfig 명령을 내렸을 때 화면에 메뉴가 표시되는 것은 모두 config.in 또는 Kconfig 에서 메뉴를 정의하고 있기 때문이다. 
config.in 또는 Kconfi 파일을 바꾸게 되면 make menuconfig 화면을 바꿀 수 있게 된다.

사용자가 menuconfig 화면에서 커널 옵션을 설정하고 menuconfig 화면을 종료하면 include/linux/autoconf.h 파일과 “.config” 파일이 생성된다. 
include/linux/autoconf.h파일은 C 헤더 파일로서 사용자가 선택한 커널 옵션이 C 매크로로 define 되어 있다. 
나중에 autoconf.h 파일은 거의 대부분의 커널 소스에 include 되는데 #ifdef 문을 통해 커널 소스에서 선택적인 
컴파일 또는 배열의 크기를 결정하는 등의 일에 사용된다.

.config 파일은 Makefile에 include 되는데 커널 옵션이 make 매크로로 정의되어 있다. .config 에 정의된 매크로를 참조해 
make 는 컴파일해야 될 디렉토리 및 파일을 결정하고 링크 시 포함해야 될 object 에 대해서 결정하게 된다.

커널 옵션 설정이 끝났고 include/linux/autoconf.h 파일과 .config 파일이 생성됐으면 make dep 명령을 내리게 된다.

make dep 명령은 make 유틸리티와 관계된 내용으로서 각 소스 파일이 어떤 파일과 종속관계에 있는 지 파악해  .depend 라는 
파일 종속 관계 정의 파일을 생성한다.  .depend 파일 역시 makefile 에 include 돼 종속관계에 있는 파일이 변경시에 해당 소스 파일을 
재 컴파일할 수 있게 한다. make dep 명령은 커널 2.4 까지 사용하였지만 커널 2.6 에서는 더 이상 사용되지 않고 있다.

다음으로 make zImage 또는 make bzImage 명령을 내려 커널을 컨파일하게 된다. 이 때 컴파일 되는 소스 파일은 사용자가 
make menuconfig 를 통해 module dl 아니라 커널에 포함시킨 기능들에 대해서만 컴파일해서 링크하게 된다. 
물론 커널 이미지에 포함할 지 모듈로 포함시킬 지는 make menuconfig 시에 생성된 .config 파일에 다 정의 되어 있다.

make zImage 와 make bzImage 명령은 i386 아키텍처에서 커널 사이즈에 따라 로드되는 위치를 달리 할 때 사용되는 명령이다. 
나중에 설명하겠지만 i386 아키텍처는 부팅 시 부트로드에 의해 0x90000 이후 번지에 사용되는데 0x10000 ~ 0x90000 번지까지 커널이 들어 간다면 
make zImage 명령을 사용할 수 있다.

그러나 커널 사이즈가 커서 0x10000 ~ 0x90000 번지에 들어갈 수 없다면 make bzImage 명령을 사용해 컴파일해야 한다. 
make zImage 명령으로 컴파일하면 부팅시 커널을 0x10000 번지로 로드하고 make bzImage 명령으로 컴파일하게 되면 0x100000 위치에 로드하게 된다. 
i386 에서 bzImage 와 zImage 의 차이는 부팅시 zImage 가 약간 빠르다는 것외에는 별반 차이가 없다.

리눅스 커널 소스를 분석해 보자
커널 이미지를 생성했으면 make modules 명령을 통해 사용자가 menuconfig 시 module로 지정한 기능들에 대해서 컴파일하게 된다. 
커널 module 은 파샬 링크된 elf object 로서 insmod 명령을 통해 커널 심볼 테이블을 참조해 최종 링크가 될 object 이다. 
이 부분에 대해서는 나중에 자세히 다루도록 하겠다.

module 이 다 만들어졌으면 make modules_install 명령을 통해 module로 컴파일 된 object 를 /lib/[커널버전] 디렉토리에 복사면 
커널 컴파일 과정은 종료하게 된다.

지금까지 리눅스 커널의 대략적인 내용에 대해서 알아 봤다.




[26]	리눅스 커널의 부팅 과정 해부하기
 
리눅스 이해를 돕기위해 리눅스 커널이 어떤 구조로 돼 있는지 어떤 기능을 제공하는 지 살펴봤다. 
지난 호에서는 리눅스 커널의 컴파일 과정을 알아 보고 커널 분석을 위해 도움을 줄 수 있는 프로그램에는 어떤 것들이 있는 지 알아 봤으며 
이번 호에는 리눅스 커널의 부팅 과정에 대해 알아 보고자 한다. 리눅스 커널의 부팅 과정은 하드웨어 아키텍처에 따라 또 CPU 에 따라 각각 다른데, 
커널을 직접 고쳐서 사용해 볼 수 있는 임베디드 기기용 CPU를 통해 부팅과정을 알아 보기로 한다.

리눅스뿐만 아니라 거의 모든 OS의 부팅 과정에서 하는 일을 단순화시키면 두가지 일밖에 없다. 
하드웨어 초기화,  커널 자료 구조 초기화가 바로 부팅과정에서 일어나는 일이다. 이 중 하드웨어 초기화는 프로세서에 따라 달라지는 부분이라서 
아키텍처 종속저깅ㄹ 수 밖에 없다. 이제 리눅스 커널의 부팅 과정을 하나씩 짚어 보자. 
앞서 언급한 대로 어떤 하드웨어 아키텍처인가에 따라 하드웨어 초기화부분은 달라질 수 있다. 
예를 들면 x86 과 같은 아키텍처는 부팅할 때 segmentation 관련 주소 레지스터를 초기화하는데 이러한 segmentation 은 x86 아키텍처에만 있으며 
ARM 과 같은 아키텍처에서는 존재하기 않기 때문에 관련 설정도 필요 없다. 이렇듯 하드웨어 초기화 부분이 아키텍처마다 다르기 때문에 
우리는 부팅 코드 분석에 앞서 어떠한 아키텍처를 중심으로 분석을 할 것인지 결정을 내려야 한다.

x86 아키텍처를 분석하면 가장 많이 사용하는 아키텍처이기 때문에 마음에 와 닿는 바가 클 것이다. 
그렇지만 x86 아키텍처는 서버와 데스트톱 시장에서 주류를 이루고 있어 커널을 직접적으로 고쳐서 사용하는 일이 드물다.
때문에 커널을 분석하는 것에만 의의가 있고 분석한 것을 이용해 보기는 힘든 아키텍처이다. 
따라서 임베디드 시장에서 광범위하게 사용되고 있는 ARM 아키텍처의 리눅스 커널-2.6.13 버전으로 분석해 보기로 한다.

그리고 같은 ARM 아키텍처라고 해도 CPU 종류에 따라서 core 또는 하드웨어 IP(Intellectual Property, 예 : timer, interrupt controller, memory controller 등)
가 다르기 때문에 하드웨어를 초기화하는 코드도 달라진다. 때문에 하드웨어 아키텍처와 함께 CPU도 정해서 분석할 것인데 
여기서는 임베디스 시스템에서 광범위하게 사용되고 있는 삼성 S3C2440 CPU 의 커널을 분석하고자 한다.

리눅스 커널 부팅 과정의 전체 구조
그림 1은 ARM 아키텍처에서 리눅스 커널의 부팅 과정을 도식화한 것이다. 리눅스 커널의 부팅 과정을 간단하게 보면 그림 1과 같다고 말할 수 있다. 
물론 각 부분은 보다 복잡하게 돼 있다.

이 과정을 간단하게 설명하면 다음과 같다. 먼저 최초 전원이 인가되면 ARM 아키텍처에서는 bootloader 코드가 수행된다. 
이 bootloader 코드는 보통 0x0 번지에 위치한다.

bootloader는 최초 커널을 RAM에 로딩하기 위해 clock 을 초기화하고 RAM 컨트롤러를 초기화한다. 
그리고 커널을 메인 메모리에 로딩하고 제어권을 커널에게 넘긴다.

그러면 커널의 제일앞에 있는 코드를 수행하게 되는데 커널의 제일 앞부분에는 arch/arm/boot/compressed/head.S  
커널의 압축을 푸는 코드가 들어 있다. 커널은 보통 사이즈를 줄이기위해 압축돼 있는데 head.S 는 커널이 동작하는 위치에 압축을 풀게 된다.

그리고 제어권을 실제 커널의 head인 arch/arm/kernel/head.S 로 옮기게 된다. 실제 커널의 head 인 arch/arm/kernel/head.S는 
주로 하드웨어 초기화 및 BSS 초기화, XIP 적용 등을 담당하고 커널의 main 함수격인 start_kernel 로 제어를 넘기게 된다.

start_kernel 함수에서는 실로 여러가지 일들을 하게 돼 있다. 이 그림에서는 간단하게 세가지 일로 추려 놓았지만 실제로 커널이 부팅하면서 하는 
거의 대부분의 일은 startr_kernel 함수에서 해 주게 돼 있다.

startr_kernel 함수의 막바지에는 init이라는 kernel thread를 생성하는데 init kernel thread 는 각종 디바이스 드라이브의 초기화 루틴을 호출해서 
디바이스들을 초기화해주고 ‘/’ 디렉토리를 마운트 해 주게 된다. 마지막으로 execv 시스템 콜을 사용해 /sbin/init 프로세스를 생성하게 된다.

/sbin/init 프로세는 /etc/rc.d 에 있는 각종 초기화 스크립트를 수행해 기본적으로 수행해야 하는 데몬 프로세스를 수행시켜주고 
최종적으로 mingetty 라는 가상 터미널을 띄워주게 된다. mingetty 는 수행과 동시에 login 프로세스를 수행하게 되는데 
그러면 우리에게 친숙한 “loggin:” 프롬프트를 보게 된다.

매우 복잡한 절차같지만 이는 부팅 과정을 최대한 단순하게 설명한 것이다. 그러니 실제로 소스를 분석할 때는 얼마나 복잡할까? 
실제 소스를 분석하는 데는 책으로 써도 모자랄 만큼이다. 때문에 앞으로 소스를 가지고 설명할 때는 중요한 부분만을 중점적으로 설명하도록 하겠다. 
그럼 이제부터 본격적으로 소스 분석을 해 보도록 하겠다.




[27]	DM9000 Linux Kernel porting
About DM9000 network chip support: msg#00233
Subject:  About DM9000 network chip support 
Hi all,
I got a network chip DM9000 and want to build the driver into kernel to support. My host is Fedora C4, with cross-compile environment uClinux-dist-20040408 and arm-elf-20030314.sh (2.95.3). My target board is arm7. I download the driver from Davicom. This is what I do:

1. put dm9000x.c into drivers/net
2. create dm9000x.h contains #define CONFIG_DM9000 1
3. add a new line "obj-$(CONFIG_DM9000) += dm9000x.o" in drivers/net/Makefile
4. add a menu in Config.in, which is 
     if [ "$CONFIG_NET_VENDOR_DAVICOM" = "y" ]; then
        dep_tristate '    DM9000 support' CONFIG_DM9000 $CONFIG_ISA
5. Add header "extern int dmfe_probe(struct net_device *); " in Space.c
    and 
           #ifdef CONFIG_DM9000            /*Add DM9000 by SPUD*/
               {dmfe_probe, 0},
           #endif
Now after menuconfig and rebuild the kernel, the error message appears while "make linux":

.........................................................................................................

PS. DM9000 driver http://www.davicom.com.tw/big5/download/Driver/dm9000/dm9000_Linux_v126.zip
 
_______________________________________________
uClinux-dev mailing list
uClinux-dev@xxxxxxxxxxx
http://mailman.uclinux.org/mailman/listinfo/uclinux-dev
This message was resent by uclinux-dev@xxxxxxxxxxx
 
 
 

[28]	RedHat 9/8에서 2.6 kernel 컴파일하기

Mike Chirico 의 작품을 번역한(중?) 것입니다.
Last Updated: Tue May 11 18:59:04 EDT 2004
출처는 http://www.linuxquestions.org/questions/history/180486 입니다.

각 최종 버젼에 대한 정보는 아래에서 보실 수 있습니다.
http://prdownloads.sourceforge.net/souptonuts/README_26.txt?download

설정에대한 최종적인 내용은 아래에서 확인하실 수 있습니다.
http://sourceforge.net/project/showfiles.php?group_id=79320&package_id=109944

STEP 1:
커널의 최종 버젼과 모든 패치들을 다운로드 받습니다.
이 문서는 linux-2.6.3 을 기준으로 되었습니다.
최종버젼은 아래에서 찾을 수 있습니다.
http://www.kernel.org/pub/linux/kernel/v2.6/

또한 아래에서 정보를 찾아보실 수 있습니다.
http://www.codemonkey.org.uk/post-halloween-2.5.txt 

그 안에 내용들은 각종 변화에서 필요한 것들과 유용한 힌트등을 알아 보실 수 있습니다.

STEP 2:
module-init-tools 의 최종 버젼을 다운 받습니다.
"module-init-tools-3.0.tar.gz"과 "modutils-2.4.21-23.src.rpm" 입니다.

http://www.kernel.org/pub/linux/kernel/people/rusty/modules/module-init-tools-3.0.tar.gz
http://www.kernel.org/pub/linux/kernel/people/rusty/modules/modutils-2.4.21-23.src.rpm

STEP 3:
module-init-tools을 설치합니다. depmod [/sbin/depmod] 및 각종 다른 tool들도 덮어쓰게 됩니다.

tar -zxvf module-init-tools-3.0.tar.gz
cd module-init-tools-3.0
./configure --prefix=/sbin 
make
make install 
./generate-modprobe.conf /etc/modprobe.conf

STEP 4:
modutils-2.4.21-23.src.rpm을 설치합니다. 
만일 rusty 라는 user와 group이 없으면 몇가지 경고를 발생합니다.
이럴때는 그냥 yes 처리해서 강제로 설치할 수 있습니다. 만일 이 유틸을 설치하지 않으면 
make modules_install시에 오류가 발생할 수 있습니다.

rpm -i modutils-2.4.21-23.src.rpm
rpmbuild -bb /usr/src/redhat/SPECS/modutils.spec
rpm -Fi /usr/src/redhat/RPMS/i386/modutils-2.4.21-23.i386.rpm

STEP 5:
kernel을 설정하고 설치합니다. 절대 /usr/src/linux 영역을 사용하지 마세요!!!
README를 한번 읽고 확인해 보세요. 현재 저같은 경우 /home/src/kernel/ 안에 파일을 풀어 놓고 작업했습니다.

STEP 6:
현재 과거의 설정파일등이 있는 곳( 보통 /usr/src/linux-2.4/configs
[kernel-2.4.20-i686.config, kernel-2.4.20-i686-smp.config] 을 말합니다.)
에서 .config 현재 자신이 컴파일 하고 있는 소스 디렉토리에 복사해오세요.
저같은 경우에는 /home/src/kernel/linux-2.6.3 입니다.

cp /usr/src/linux-2.4/configs/kernel-2.4.20-i686.config \
/home/src/kernel/linux-2.6.3/.config

만약 원본 설정을 가지고 있지 않다면 아래에서 적당히 가져 올 수 있습니다.

https://sourceforge.net/project/showfiles.php?group_id=79320&package_id=109944

제 시스템의 중요하게 2.6 지원이 되는 설정이 포함된 config2.6-chirico라는 파일이 있습니다.
물론 여러분들이 실제로 돌리기엔 몇가지 문제점이 있으므로 무조건 적용은 하지 마세요.

STEP 7:
원하는 kernel-2.4의 설정을 보사해 왔다면 그 내용을 2.6 kernel에 맞게 설정해 주어야 
적절히 작동합니다. 또는 config2.6-chirico를 사용하셔도 됩니다.
물론 그것은 제 시스템의 이전 설정으로 만들어 진것이지만, 보통 일반적인 시스템에서
필수적인 문제들을 해결한 내용입니다.
일단 기존 설정을 적용하시려면 아래와 같이 해주시면 됩니다.

make oldconfig

STEP 8:
이 부분이 가장 중요합니다. .config 파일을 만든 후에 그 내용을 여신 후 CONFIG_EXT3_FS=y 부분이
되어 있는지 확인하시기 바랍니다. 만일 그 부분이 =m 가 되었다면 =y로 변경해주세요. 그렇지 않으면
아래의 에러가 발생합니다.

pivotroot: pivot_root(/sysroot,/sysroot/initrd) failed

이 이유는 Redhat 9.0 과 8.0 은 ext3 filesystem을 사용하면서 /boot를 맨먼저 참조하고 있기 때문입니다.

STEP 9:
Makefile 과 몇가지 변화된 내용을 설정하셨다면 이젠 Extraversion 부분도 변경해 주시기 바랍니다.
Patches들은 이런 값들의 수정이 꼭 필요합니다.

VERSION = 2 
PATCHLEVEL = 6 
SUBLEVEL = 3 
EXTRAVERSION = -skim-ch6

STEP 10:
make bzImage

STEP 11:
make modules

STEP 12:
make modules_install

STEP 13:
make install

만약 여기서 문제가 발생했다면 "depmod" 의 버젼 문제나 혹은 설정된 path의 문제일 것입니다.

당연히 해당하는 모듈을 찾지 못하면 아래와 같은 에러를 발생합니다.
No module aic7xxx found for kernel 2.6.x
그때에는 /lib/modules/2.6.x/kernel/drivers/scsi/aic7xxx/에다 
cp aic7xxx.ko aic7xxx.o
하고 난뒤
만약 aic7xxx.o를 계속 찾는다면 insmod 로 aic7xxx.ko 처리하면 됩니다. 

만약 계속 문제가 발생한다면 .config안의 몇가지를 변경해 주면 됩니다.
CONFIG_BLK_DEV_SD=y
and go back to STEP 10.

더 자세한 내용을 원하시면 http://prdownloads.sourceforge.net/souptonuts/rc.sysinit.txt?download
안에 nel-2.6.3-i686-smp-chirico-aic7xxx.config을 참조하시기 바랍니다.

STEP 14:
mkdir /sys

STEP 15:
/etc/rc.sysinit 는 추가 변경시에 필요합니다. 다음과 같은 줄을 찾아보시기 바랍니다.
action $"Mounting proc filesystem: " mount -n -t proc /proc /proc
찾았으면 해당하는 내용을 아래와 같이 변경하세요.

action $"Mounting sysfs filesystem: " mount -t sysfs none /sys

/etc/rc.sysinit은 아래의 링크에서 참조하실 수 있습니다.
http://prdownloads.sourceforge.net/souptonuts/rc.sysinit.txt?download
단! 이 처리 과정은 굉장히 중요한 부분으로 반드시 /etc/rc.sysinit 파일을 백업하시기 바랍니다.
Thomer [http://thomer.com/linux/migrate-to-2.6.html ]는 간혹/etc/fstab에 변경된 내용을
계속 추가 합니다. 이 때 저같은 경우 STEP 16 밑에서 부터  해당 내용을 수행합니다.

STEP 16:
usb 장비를 지원하려면 /etc/fstab에 다음과 같은 줄을 넣습니다.
/proc/bus/usb /proc/bus/usb usbdevfs defaults 0 0

STEP 17 (전/체/점/검):
다음과 같은 부분을 점검해 보세요:

a. 새로운 이미지 파일은 boot에 설치하곤 합니다. 이를 sym link 로 처리할 수 있습니다.
저의 최근 커널인 2.6.3-skim-ch6에 -skim-ch6과 같은 값을 Makefile에 다음과 같이 값을 넣어 처리해 
줄 수 있습니다. 

/boot
vmlinuz -> vmlinuz-2.6.3-skim-ch6
System.map -> System.map-2.6.3-skim-ch6

/boot/grub/grub.conf 가 make만으로 자동적으로 업데이트 됩니다.

/boot/grub/grub.conf안에서  change "default=0" 새로운 커널로 부트로 to boot
with the new kernel. Here's an example of my
grub.conf:


# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making 
# NOTICE: You have a /boot partition. This means that
# all kernel and initrd paths are relative to 
# root (hd0,2)
# kernel /vmlinuz-version ro root=/dev/hda6
# initrd /initrd-version.img
#boot=/dev/hda
default=0
timeout=10
splashimage=(hd0,2)/grub/splash.xpm.gz
title Red Hat Linux (2.6.3-skim-ch6)
root (hd0,2)
kernel /vmlinuz-2.6.3-skim-ch6 ro root=LABEL=/
initrd /initrd-2.6.3-skim-ch6.img


b. The directory /sys exists

c. You added the mount command for sys in /etc/rc.sysinit

d. CONFIG_EXT3_FS=y was used in the .config

e. Run /sbin/lsmod or cat /proc/modules to make
sure a 2.4 kernel module wasn't forgotten. Also
look at "$cat /proc/iomem"


STEP 18 (GETTING UPDATES: YUM):
Yum works with RPM based systems to update packages
automatically. Yum is an officially supported update
mechanism for Fedora, and Fedora mirrors are set up 
as Yum repositories.

Download:

http://linux.duke.edu/projects/yum/download.ptml

Before installing Yum, or any RPM package, you'll need
to do the following:

export LD_ASSUME_KERNEL=2.4.19

Next, install Yum

rpm -ivh yum-2.0.7-1.noarch.rpm

The "/etc/yum.conf" may need to be updated. Here is an
example file with the values for redhat 9 entered in
directly


[main] 
cachedir=/var/cache/yum 
debuglevel=2 
logfile=/var/log/yum.log 
pkgpolicy=newest 
distroverpkg=redhat-release 
tolerant=1 
exactarch=1 

[fedora-stable-9] 
name=Fedora Project Stable RPMS for RHL 9 
baseurl=http: //download.fedora.us/fedora/redhat/9/i386/yum/stable/ 
gpgcheck=1 

[fedora-updates-9] 
name=Fedora Project update RPMS for RHL 9 
baseurl=http: //download.fedora.us/fedora/redhat/9/i386/yum/updates/ 
gpgcheck=1 


NOTE: If you're using Redhat 8, replace 9 with "8.0" 

The following will download a lot of "HEADER" files, but WILL NOT update 
anything. Yes, I too thought my system was being updated with old files,
but IT IS NOT.

yum check-update 

After this runs, which takes awhile. You can then update selected packages.
Here is an example of the "libpng10" package being updated.

yum -y update libpng10

Also, subsequent calls to "yum check-update" shows what needs to be updated.


To update every currently installed package

yum -y update

STEP 19 (DEVELOP YOUR OWN 2.6 MODULES):
You're done with the 2.6 build. So learn how to develop
2.6 kernel modules. First, checkout the following article

http://lwn.net/Articles/driver-porting/

Then, take a look at the following sample code, which shows how
to create /proc entries for communicating with the kernel and writing
out to any available tty device.

http://prdownloads.sourceforge.net/...tar.gz?download


REFERENCES:

http://www.codemonkey.org.uk/post-halloween-2.5.txt
http://kerneltrap.org/node/view/799
http://thomer.com/linux/migrate-to-2.6.html 
http://www.kernel.org/

http://bugzilla.kernel.org/
http://groups.google.com/groups?hl=...up=linux.kernel
http://linuxdevices.com/articles/AT3855888078.html

http://prdownloads.sourceforge.net/...26.txt?download
http://prdownloads.sourceforge.net/...it.txt?download
http://prdownloads.sourceforge.net/...tar.gz?download
https://sourceforge.net/forum/forum.php?forum_id=353715

http://www.redhat.com/software/rhel/kernel26/
http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html
http://www-124.ibm.com/linux/projects/?topic_id=2

KERNEL DRIVER DEVELOPMENT IN 2.6:

Excellent (series of articles):
http://lwn.net/Articles/driver-porting/

Here's my sample program:
http://prdownloads.sourceforge.net/...tar.gz?download

Good but dated for 2.4 kernel:
http://www.oreilly.com/catalog/linuxdrive2/

http://linuxdevices.com/articles/AT4389927951.html
http://linuxdevices.com/articles/AT5793467888.html



[29]	HDS6900 Compile 방법
1) Main OSD, HYUNDAI 마크를 변경할려면 lcd68k.asm에서 HYUNDAI 부분을 변경
2) m.bat 실행(compile)
3) font_china, font_taiwan등의 선택은 MYSON Writing 실행시 OSD 입력부분에서 선택




[30]	CCTV 구현
1)	현재 CCTV는 카메라 입력을 동축케이블(Analogue)로 받고 있음
	TCP/IP Ethernet 방식으로 카메라 입력을 받는 제품은 아직 없음
	(Ethernet방식이 가격도 비싸고, 거리도 100m로 제한되는 등 문제가 있기 때문)
2)	CCTV 통제 LCD 모니터에 외부 영상이 4개 또는 16개로 나눠져서 보이는 것은
	동축케이블 16개(16ch)가 CCTV Controller에 모두 연결되어 있기 때문임
	CCTV Controller는 16개 Analogue 영상을 단지 나눠서 보여주고 있는 것임
3)	“convert 'Timestamp' to 'datetime'” Code Answer
	a)	timestamp to date python
		from datetime import datetime
		
		timestamp = 1586507536367
		dt_object = datetime.fromtimestamp(timestamp)
	b)	convert timestamp to datetime
		from datetime import datetime

		# current date and time
		now = datetime.now()

		timestamp = datetime.timestamp(now)
		print("timestamp =", timestamp)
4)	YOLO NVR(DVR) 이용한 실시간 감지(RTSP)
https://0xlordfo.tistory.com/21

LordLoop 2020. 5. 25. 15:32
YOLO는 실시간 물체 감지를 목적으로 서비스를 한다. YOLO의 사용 목적의 대부분은 실시간 물체 감지를 위해서 사용한다고 믿어 의심치 않는다.
대부분 CCTV를 NVR(DVR)에 연결해서 사용한다. 그래서 사용하려면 다소 초기 설정이 길어진다.
반대로 간단한 실험이나, 거리가 가까운 경우, IP 카메라 혹은 webcam 등을 사용해서 PC랑 직접적으로 연결하는 경우가 많기 때문에 접근이 쉬운 편이다.
CCTV는 동축케이블을 이용해서 100m 이상의 거리를 연결하는 경우가 많으며, 일반적인 PC에는 동축케이블을 연결할 방법이 없기 때문에 초반 설정 작업이 필요로 한다.
이 글은 NVR(DVR)의 RTSP를 이용해서 YOLO를 실시간 streaming 한다. 요즘에 나오는 NVR(DVR)은 네트워크 기능을 가지고 있을 확률이 높으며, 이중 RTSP를 가지고 있을 확률이 매우 높다. NVR(DVR)에 RTSP기능이나 네트워크 기능이 없는 경우도 많으니 반드시 확인하고 사용해야 한다.
RTSP는 Real Time Streaming Protocol의 약자로 말 그대로 실시간 스트리밍 프로토콜이다. 따라서 NVR(DVR)과 PC는 같은 네트워크에 연결되어있어야 한다. (통신이 되어야 한다)

1) 테스트 환경
사용 자원
CCTV, 동축케이블, NVR(DVR), PC, UTP 케이블 등

환경 구성도
< 실험 환경 네트워크 구성도 >
구성도 설명
위에 적어둔 것을 다시 작성해 보자면, CCTV는 대부분 동축케이블로 연결되어 있는 경우가 많다. 아니더라도 UTP 케이블로 연결이 되어 있는 경우는 많지 않다. 
따라서 PC와 연결하기 쉽지 않은데, NVR(DVR)은 동축케이블 포트가 있어 동영상 정보를 받아들일 수 있으며, 대부분의 NVR(DVR)의 경우 웹 서비스로도 streaming을 가능하도록 제공하기 때문에
LAN 포트가 있어 PC와 연결하기 용이하다.

위와 같은 방법을 쓰지 않고, IP 카메라나 webcam 등을 사용해서 PC에 연결이 가능하다면, iSPY 같은 오픈소스 감시 프로그램을 이용해서 RTSP를 사용할 수 있다.
NVR(DVR)과 PC는 다이렉트 케이블 방식을 이용하면 된다.

2) 사용 방법
NVR(DVR)의 RTSP 기능을 활성화한다.
대부분의 NVR(DVR)의 경우 RTSP기능을 활성화하면, example URL을 알려주는데 이를 이용해서 명령어를 완성시킨다.

IP 카메라나 webcam을 이용하는 경우, iSPY 같은 감시 프로그램을 이용하면 RTSP를 지원하기 때문에 설정 부분에서 RTSP 활성화한다.

3) 명령어
명령어
darknet detector demo [.data] [.cfg] [.weights] [rtsp]

사용한 명령어(명령어 예시)
1. No.1 NVR(DVR)
darknet detector demo data/obj.data data/yolo-obj.cfg backup/200525/yolo-obj_final.weights rtsp://admin:test1@11.11.11.11/ch9/stream1
darknet detector demo data/obj.data data/yolo-obj.cfg backup/200525/yolo-obj_final.weights rtsp://admin:test1@11.11.11.11/ch10/stream1

2. No.2 NVR(DVR)
darknet detector demo data/obj.data data/yolo-obj.cfg backup/200411/yolo-obj_63000.weights rtsp://admin:1q2w3e4r!@192.168.0.8:554/Streaming/Channels/101
darknet detector demo data/obj.data data/yolo-obj.cfg backup/200411/yolo-obj_63000.weights rtsp://admin:1q2w3e4r!@192.168.0.8:554/Streaming/Channels/201
2가지 NVR(DVR)을 가지고 테스트해봤는데, 각 NVR(DVR)마다 경로가 다르므로, 각 NVR(DVR)에서 제공하는 RTSP 경로를 제대로 확인하고, 명령어를 완성시켜야 한다.

4) YOLO에서 RTSP를 사용할 때 주의점
가끔 특정 NVR(DVR)에서는 자신의 RTSP의 URL(경로)에 %와 같은 특수문자로 표시되어 있는 경우가 있다.
웹 브라우저를 통한 접속 등을 할 때에는 문제가 없으나, cmd에서 특수문자가 포함된 URL을 넣으면, 오류가 발생한다.
따라서, RTSP UTL(경로)에 특수문자가 포함되어 있다면, URL 인코딩을 한 후 cmd에 명령어로 입력해야 한다.
ex) ......%streamtype=1 → ......%25streamtype=1

5)	정상적으로 접속 가능한 rtsp ip 카메라 접속 주소
가)	한화 IP Camera(RTSP URL) 형식
Camera - RTSP URL
RTSP is a network control protocol designed for controlling streaming media servers. The protocol is used for establishing and controlling media sessions between end points.
RTSP transmits video/audio data by using RTP.
RTSP URL:

IP Cameras

rtsp://<DeviceIP>/profile<no>/media.smp
rtsp://<DeviceIP>:port/profile<no>/media.smp
rtsp://user:password@<DeviceIP>:port/profile<no>/media.smp

* RTSP PORT
The default port for RTSP Protocol is 554. It can be changed as necessary.
Available ports are 1024-65535 & 554. Ports 3702, 49152 are not available.

Example: rtsp://192.168.1.100/profile2/media.smp

Multi-Sensor IP Cameras

rtsp://<DeviceIP>:<port>/<sensor#>/profile2/media.smp
rtsp://admin:<password>@<DeviceIP>:<port>/<sensor#>/profile2/media.smp
Sensor # range is from 0-3 (0 = Sensor 1, 1 = Sensor 2…)

Examples: PNM-9081VQ, PNM-9080VQ, PNM-9320VQP, PNM-9000VQ, or PNM-7000VD

Camera 1: rtsp://<IP address>/0/profile2/media.smp
Camera 2: rtsp://<IP address>/1/profile2/media.smp
Camera 3: rtsp://<IP address>/2/profile2/media.smp
Camera 4: rtsp://<IP address>/3/profile2/media.smp

NVR

rtsp://<DeviceIP>:port/LiveChannel/0/media.smp

Channel numbering starts at 0.
The RTSP port for NVRs will be the last Device Port set on the unit. i.e. if device port is set to 554-558, 558 will be the port for the RTSP URL.

DVR

rtsp://<DeviceIP>:port/<camera>camera numbering starts at 0.
The RTSP port for DVRs will be the last Device Port set on the unit. i.e. if device port is set to 4520-4524, 4524 will be the port for the RTSP URL. 

Available software such as VLC player can be used to test RTSP streaming.

나)	실제 실행되는 RTSP URL 주소
rtsp://admin:1q2w3e4r5t@123.215.209.105:3002/profile2/media.smp		-> 한화 IP Camera url 형식
rtsp://192.168.0.52			-> 내부인터넷 접속 IP Camera의 경우 이런식으로 주소를 입력시켜도 정상적으로 동작함

rtsp://admin:admin123!@123.215.209.105:4002/profile2/media.smp		-> 한화 IP Camera 정상적인 영상 나옴
rtsp://admin:admin123!@123.215.209.105:4002/profile1/media.smp		-> 한화 IP Camera 화면이 Line 별로 깨진 영상 나옴(아마도 yolo 객체 정보 meta data 까지 송신하는 채널로 보임)
rtsp://admin:admin123!@123.215.209.105:4002/MJPEG/media.smp			-> 한화 IP Camera 화면이 Line 별로 깨진 영상 나옴(아마도 yolo 객체 정보 meta data 까지 송신하는 채널로 보임)
rtsp://admin:admin123!@123.215.209.105:4001/MJPEG/media.smp
http://admin:admin123!@123.215.209.105:4001/cgi-bin/video.cgi?msubmenu=mjpg
http://admin:admin123!@123.215.209.105:4001/cgi-bin/video?submenu=mjpg

// 실제로 mjpg로 동영상 재생되는 URL 주소
http://80.254.191.189:8008/axis-cgi/mjpg/video.cgi
http://oviso.axiscam.net/axis-cgi/mjpg/video.cgi
http://webcam1.lpl.org/axis-cgi/mjpg/video.cgi
http://200.33.20.122:2007/axis-cgi/mjpg/video.cgi

rtsp://wowzaec2demo.streamlock.net/vod/mp4:BigBuckBunny_115k.mov	-> Big Buck BUNNY animation 동영상 재생

​

[31]	소스인사이트에서 구조체 참조 안될때
[펌]소스인사이트에서 구조체 참조 안될때..^^  IT 관련  
2007/01/31 11:24
 http://blog.naver.com/kimfami/100033794820 
 
C++빌더도 아니고 특정 에디터에대한 팁이네욤.. 마땅히 올릴때가 없어서리..
소스인사이트는 어떤 변수나 타입에 마우스를 언저 놓으면 Context윈도우에 그것이 선언된 것을 
빠르게 보여 줍니다.

또한 Ctrl + Mouse 레프트 버튼을 클릭 하면 해당하는 소스창을 열어주고 커서를 표시 해줍니다.
그래서 쉽게 변수나 구조체 같은게 선언된 지점을 추적할수 있음니다.

또한 소스인사이트는 프리프로세서 컴파일을 미리 해두고 Context윈도우에 표시같은것도 동적으로 해줍니다.

#define PACKED __packed
typedef PACKED struct XXX{
member ....
.....

} x;

이러한 소스가 잇을때  x 구조체로 선언된 변수나 그 변수의 멤버를 마우스로 추적 해보면 되지 않는 경우가 있습니다.

union 이나 struct 키워드 앞에 붙은 PACKED란 키워드를 프리프로세싱 결과 __packed 로 해도
그 키워드를 인식 하지 못하기 때문입니다.

이럴경우

C:\Documents and Settings\sparrow\My Documents\Source Insight
여기에 보면 c.tom이란 파일이 있는데 이곳에 매크로를 등록 해주면 해결 됩니다.

__packed 
PACKED

이런것을 추가해두면 __packed나 PACKED를 아무것도 아닌걸로 인식하기 때문에

소스인사이트에선 위에 소스가 단순히
typedef struct ~~ {
}

이런식으로 되어 일반 구조체나 union을 탐색하듯이 잘됩니다.

그럼^^
[출처] [펌]소스인사이트에서 구조체 참조 안될때..^^|작성자 내맘




[32]	가상메모리와 물리메모리와의 관계
가상 메모리는 가장 간결하게 정의하면 물리 주소 사이의 맵핑을 갖는 것이다. 
효율적인 방식으로 주소 공간에서 메모리 할당을 준비하고, 
할당되지 않는 주소 공간에 대한 물리메모리의 낭비를 피하려는 것이다. 
더 실용적인 측면에서, 실제적으로 사용되지 않는 할당된 주소에 대한 물리 메모리의 낭비를 막기 위해 
paging을 구현하여 가상 주소 공간을 사용한다.




[33]	NIC convert program 문제점

1) malloc 으로 메모리를 잡아주는 명령만 있고
   free 으로 해제하는 명령은 없다. 




[34-1]	USB통신(PC<->TSH/PSA보드)
/******************************************************************
 # Infopia LFI JIG communication Concept
 
	Master(Window JIG Program) <---> Slave(Target Board)

 #  Infopia LFI JIG communication Types.

 	1. Simple Command				// device initialize, preview, capture, power down....
 		[cmd] ---------->
 	 	         <---------- [rsp]
 	       
 	2. Command to send data			// firmware download
 		 [cmd] ---------->
 		 [data] ---------->
 		          <---------- [rsp]

 	3. Command to recevie data 		// capture image upload
 		 [cmd] ---------->
 		          <---------- [rsp]
 		    	   <---------- [data]
 		       
******************************************************************/
/*  우선, PC가 Master이고 TSH/PSA가 Slave이며 아래 설명은
    상기 "3. Command to recevie data 		// capture image upload" 수행 과정을 설명하고자 한다
    참고로, USB통신도 RS232통신과 동일한 알고리즘의 통신으로 별도의 프로토콜이 있는 것은 아니고
    주고 받는 Data에 대한 프로토콜을 Master/Slave에서 별도로 정의해서 통신하는 것임
    참고로, USB메모리스틱을 PC에 꼽으면 USB메모리 내용이 폴더로 나타나는 기능은 mass-storage 기능으로
    Master/Slave를 구현해 놓았기 때문임.
        

1.  [PC쪽 프로그램]에서 UsbSendCommand 함수로 JIGCMD_CAPTURE 명령을 송신
2.  [보드쪽 프로그램]에서 PCRequireProcessing 함수로 USB로 부터 날라오는 data를 주시하고 있다가
    JIGCMD_CAPTURE 명령이 수신되면 DoCapture -> USBSendRSP(SetRspInfo) 명령을 실행 시켜
    Filename, FileSize 등의 보낼 data의 사양을 먼저 송신하고 USBUpLoad(SetRspInfo, (unsigned char*)pBackUp) 명령을 실행시켜
    data를 송신함
3.  [PC쪽 프로그램]에서 UsbReceiveBulkDataLFI 함수 내에 있는 UsbReceiveRespond 함수로 우선
    [보드쪽 프로그램]에서 보내온 Filename, FileSize 등의 보낼(수신) data의 사양을 먼저 수신하고
    본 보낼(수신) data 사양대로 data를 수신함   */


[PC쪽 프로그램]

LFI_USB_DATA_STRUCT getData;		// UsbReceiveBulkDataLFI()에서 Bulk data를 받기위한 매개변수로 사용된다. 이때 &를 사용하여 


struct LFI_USB_DATA_STRUCT	/*data를 보내거나 받거나 모두 같이 이 구조체를 사용한다.*/
{
	char *usbDataBuf;		
	char	dataName[32];		// target으로 전달됨.
	unsigned int  usbDataSize;			// target으로 전달됨. 
	unsigned int 	destinationAddress;	// target으로 전달됨. 
};


    if(SUCCESS == UsbSendCommand(TRUE, JIGCMD_CAPTURE, jigDataInfo))		// CMD		
    {
      if(SUCCESS == UsbReceiveBulkDataLFI(&getData))						// RSP(size info) + Read Bulk
      {               
        m_Dib.CreateGrayImage(640, 480, 0);
        BYTE** ptr2 = m_Dib.GetPtr();
	
        unsigned int i, j;
        for( j = 0 ; j < 480; j++ )
          for( i = 0 ; i < 640; i++ )
            ptr2[j][i] = *(getData.usbDataBuf++);


int UsbSendCommand(BOOL bJustCmd, JIGCMD_TYPE jigCmdType, LFI_USB_DATA_STRUCT jigUsbData)
{
	TRACE("SendCMD-S\r\n");
       int result = 0;
       ULONG nBytesRead;
    
       if(bJustCmd == TRUE)
        {
        	hUsbWrite = open_fileUSB( outPipe);
        	if(hUsbWrite==INVALID_HANDLE_VALUE)
        	{
        		AfxMessageBox("Can't open USB device.\n\rDid you connect USB cable to PC ?");
        		return -1;
        	}
        }

	LFI_USB_COMMAND48_STRUCT Cmd;
	Cmd.StartCode = 0x0055;
	Cmd.Command   = jigCmdType;
	Cmd.Address   = jigUsbData.destinationAddress;
	Cmd.FileSize  = jigUsbData.usbDataSize;
	memcpy((char*)Cmd.Filename, (char*)jigUsbData.dataName, sizeof(char)*32);
	Cmd.EndCode   = 0x00FF;

	// 먼저 Command 를 write한다. 
	/*  BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
            (LPCVOID: Pointer to a constant of any type. LPDWORD: Pointer to a DWORD)
            
        - hFile: 기록하고자 하는 file의 handle. 이 file은 GENERIC_WRITE access 권한으로 열어야 한다.
        - lpBuffer: 츨력할 data를 가진 buffer
        - nNumberOfBytesToWrite: 기록할 byte 수를 지정한다. pipe로 network 전소을 할 시 65535 byte를 한으로 기록 가능하다.
        - lpNumberOfBytesWritten: 실제로 기록한 byte 수를 return받기 위한 출력용 인수. WriteFile은 호출 즉시 이 값을 0으로 만든다. 
            비동기 입출력을 하지 않을 경우 이 인수는 NULL로 줄 수 없으며 받드시 DWORD형 변수에 대한 포인터를 제공한다. 
        - lpOverlapped: 비동기 입출력을 위한 OVERLAPPED 구조체의 포인터. 파일을 FILE_FLAG_OVERLAPPED flag로 연다면 이 구조체를 
            반드시 제공해야 한다. 비동기 입출력을 사용하지 않을 경우 NULL을 주면 된다                                                                     */

        result = WriteFile(hUsbWrite, (void*)&Cmd, sizeof(LFI_USB_COMMAND48_STRUCT), &nBytesRead, NULL);
    
       if(bJustCmd == TRUE)
        {
            // close devices if needed
            if(hUsbWrite != INVALID_HANDLE_VALUE)
            CloseHandle(hUsbWrite);
        }

        if((result == 1) && (nBytesRead == sizeof(LFI_USB_COMMAND48_STRUCT)))
        {
            TRACE("SendCMD-E\r\n");
            return 0;
        }
        else
         return -1;    
        
}


int UsbReceiveBulkDataLFI(LFI_USB_DATA_STRUCT* pjigUsbData)
{
    int result = 0;
    ULONG nBytesRead;
  
   //memset(pjigUsbData, 0, sizeof(LFI_USB_DATA_STRUCT));
   UsbReceiveRespond(TRUE, pjigUsbData);

    /* 관련된 file name에 대해서 file을 open한다. */
    hUsbRead = open_fileUSB(inPipe);
    if(hUsbRead==INVALID_HANDLE_VALUE)
    {
        AfxMessageBox("Can't open USB device.\n\rDid you connect USB cable to PC ?");
        return -1;
    }
     
    pjigUsbData->usbDataBuf = (char *)malloc(pjigUsbData->usbDataSize);
    if(pjigUsbData->usbDataBuf==NULL)
        return -1; 

    /*file을 read한다. 만약 rxLenght만큼 read하지 못하면 다음 문장을 실행할 수 없다. */
    unsigned int offsetSize =0;
    unsigned int trasferSize = 0;
    while(1)
    {
            if(pjigUsbData->usbDataSize - offsetSize > USB_TX_SIZE)
            trasferSize = USB_TX_SIZE;
            else
            trasferSize = pjigUsbData->usbDataSize - offsetSize;

            result = ReadFile(hUsbRead, (void*)(pjigUsbData->usbDataBuf + offsetSize), trasferSize,	&nBytesRead,	NULL);
            if((result == 1) && (nBytesRead == trasferSize))
            {
                offsetSize += USB_TX_SIZE;
                if(offsetSize > pjigUsbData->usbDataSize)
                break;
            }
            else
            {
                if(hUsbRead != INVALID_HANDLE_VALUE)
                CloseHandle(hUsbRead);
                AfxMessageBox("FAIL: Read Bulk");
                return -1;
            }
    }

    if(hUsbRead != INVALID_HANDLE_VALUE)
  	CloseHandle(hUsbRead);

    return 0;
}


int UsbReceiveRespond(BOOL bJustRSP, LFI_USB_DATA_STRUCT* pjigUsbData)
{
    TRACE("ReceiveRSP-S\r\n"); 
    int result = 0;
    ULONG nBytesRead;
    LFI_USB_RESPOND48_STRUCT *pRSP = NULL;


   if(bJustRSP == TRUE)
    {
        /* 관련된 file name에 대해서 file을 open한다. */
        hUsbRead = open_fileUSB(inPipe);
        if(hUsbRead==INVALID_HANDLE_VALUE)
        {
            AfxMessageBox("Can't open USB device.\n\rDid you connect USB cable to PC ?");
            return -1;
        }
    }

    pRSP = (LFI_USB_RESPOND48_STRUCT *)malloc(sizeof(LFI_USB_RESPOND48_STRUCT));
    if(pRSP==NULL)
     return -1; 
    
/*file을 read한다. 만약 rxLenght만큼 read하지 못하면 다음 문장을 실행할 수 없다. */
    result = ReadFile(hUsbRead, pRSP, sizeof(LFI_USB_RESPOND48_STRUCT), &nBytesRead, NULL);
    if((result == 1) && (nBytesRead == sizeof(LFI_USB_RESPOND48_STRUCT)))
    {
    	if((pRSP->StartCode == 0x0055) && (pRSP->EndCode == 0x00ff))
    	{
    		if(pRSP->respond==JIGRSP_SUCCESS)
    		{
    		  if(pRSP->FileSize)
    		  {         
    			pjigUsbData->usbDataSize = pRSP->FileSize;
    			memcpy(	pjigUsbData->dataName, pRSP->Filename, 32);
    			pjigUsbData->destinationAddress = pRSP->Address;
    		  }
    		}
    		else
    		{
    			AfxMessageBox("JIGRSP_FAIL\r\n");
    			return -1; 
    		}
    	}
    	else
    	{
    		AfxMessageBox("cannot read Respond header \r\n");
    		return -1; 
    	}
    }
    else
    {
        AfxMessageBox("Error: can't receive data from the USBD\n");
        EB_Printf("Error: can't receive data from the USBD\n");
        return -1; 
    }
	
    if (pRSP)
	  free(pRSP);

   if(bJustRSP == TRUE)
    {
        // close devices if needed
        if(hUsbRead != INVALID_HANDLE_VALUE)
        CloseHandle(hUsbRead);
    }
    	TRACE("ReceiveRSP-E\r\n");
	return 0;
}


[보드쪽 프로그램]

void PCRequireProcessing()
{
    .........................................................................................

    /* Waiting to receive CMD from PC.*/
     while(!USBReceiveCmd(&receiveCmd))
    {
    .........................................................................................
         if(receiveCmd.Command == JIGCMD_CAPTURE)
        {
            EXT_STNLCD_DrawImage((char *)blank, 0, 0);
            EXT_STNLCD_UpdateLCD();
            EXT_STNLCD_DrawText(0, 20, 0, 1, 0, " Capture !");
            EXT_STNLCD_UpdateLCD();
            DoCapture();
        }
    .........................................................................................


bool USBReceiveCmd(LFI_USB_COMMAND48_STRUCT* pReceiveCmd)
{
       memset(pReceiveCmd, 0, sizeof(LFI_USB_COMMAND48_STRUCT));
       MP4_DebugPrint( "ReceiveCMD-S  I'm ready to receive your command \r\n" );
	MP4_USBD_ReadPacket((void*)pReceiveCmd, sizeof(LFI_USB_COMMAND48_STRUCT) );
	while( MP4_USBD_CheckRunning(MP4_USBD_DOWNLOAD) )
        EXT_Sleep(1);
        
       MP4_DebugPrint( "ReceiveCMD-E\r\n" );
      if((pReceiveCmd->StartCode== 0x0055) && (pReceiveCmd->EndCode == 0x00ff))
        {
            return 0;
        }
      else
        {
         	MP4_DebugPrint( "FAILE: Receive Header format S_0x%x, E_0x%x\r\n", pReceiveCmd->StartCode,  pReceiveCmd->EndCode );
                 return 1;
        }
}


	struct LFI_USB_RESPOND48_STRUCT
	{
		unsigned short StartCode;	// 0x0055
		unsigned short EndCode; //	0x00FF
		int respond;
		unsigned int	Address;
		unsigned int	FileSize;
		char	Filename[32];
	};


bool DoCapture()
{
    .........................................................................................
    LFI_USB_RESPOND48_STRUCT SetRspInfo;
    SetRspInfo.StartCode  = 0x0055;
    SetRspInfo.EndCode = 0x00ff;
    SetRspInfo.respond = JIGRSP_READY;
    SetRspInfo.Address = 0;
    SetRspInfo.FileSize = 640 * 480;
    strcpy(SetRspInfo.Filename, "Capture Image");
    SetRspInfo.respond = JIGRSP_SUCCESS;
    USBSendRSP(SetRspInfo);                             // Filename, FileSize 등의 앞으로 보낼 data에 대한 사양만 먼저 보내고
    USBUpLoad(SetRspInfo, (unsigned char*)pBackUp);     // 본 명령을 실행해서 data를 보냄
    .........................................................................................


bool USBSendRSP(LFI_USB_RESPOND48_STRUCT sendRsp)
{
        unsigned char count =0;
 	MP4_DebugPrint( "SendRSP-S\r\n" );
	MP4_USBD_WritePacket(&sendRsp, sizeof(LFI_USB_RESPOND48_STRUCT));
     	MP4_DebugPrint( "RSP Writing\r\n" );
        //while( MP4_USBD_CheckRunning(MP4_USBD_UPLOAD))
        while(1)
        {   
            MP4_DebugPrint( "count %d\r\n", count);
            EXT_Sleep(5);

            count++;
            if(count == 10)
            {
                MP4_DebugPrint( "break in while \r\n");
                break;
            }
        }
     MP4_DebugPrint( "SendRSP-E\r\n\n" );

    return 0;
}


bool USBUpLoad(LFI_USB_RESPOND48_STRUCT receiveCmd, unsigned char *p )
{
 	MP4_DebugPrint( "Upload...S \r\n" );
        
	unsigned int oldpercent=0;
	unsigned int curpercent=0;
	unsigned int step = 10;

  MP4_USBD_WritePacket( (void*)p, receiveCmd.FileSize);
	while( MP4_USBD_CheckRunning(MP4_USBD_UPLOAD) )
	{
		unsigned int cursize = MP4_USBD_GetTransferredSize(MP4_USBD_UPLOAD);
		curpercent = cursize * step / receiveCmd.FileSize;
		if( oldpercent != curpercent )
		{
			oldpercent = curpercent;
                     EXT_Sleep(10);
			MP4_DebugPrint( "Upload rate : %3d%c\r\n", curpercent*(100/step), '%' );
		}
	}
 	MP4_DebugPrint( "Upload...E\r\n" );
    return 0;
}




[34]	OPENiceEDS 사용 방법
1)  Metrowerks CodeWarrior for ARM Developer Suite v1.2 에서 compile
2)  진단기기를 Reset시킴과 동시에 하기 사항을 실행(진단기기에 이미 있는 Flash memory 내용이 RAM으로 옮겨지기 전에 JTAG Debugger(OPENiceEDS)를 실행시키기 위해)
    OPENiceEDS -> Load image -> *.AXF( 상기 1)번에서 compile한 파일) 선택해서 진단기기에 *.AXF 파일을 Downloading시킴
    (cf. TSH/PSA 보드에서는 본 과정을 Reset버튼을 계속 누르고 있는 상태에서 실행해야 함)
3)  아직은 프로그램이 실행되지 않은 상태이기 때문에
    (OPENiceEDS -> Project View -> main.cpp -> void MP4_Main(void)선택 -> MyMain();선택 -> )[!] Go(F7)실행
    (cf. TSH/PSA 보드에서는 본 과정을 Reset버튼을 계속 누르고 있는 상태에서 실행해야 함)
4)	설정: Option -> Configure Interface... -> SMU -> evb_ks17c4000


[34+1]	ARM RealView Development 설치방법
1.  Ver 4.0 설치 -> License 처리는 skip
2.  환경변수 설정
    1)  제어판 -> 시스템 -> 고급 -> 환경변수 -> 시스템변수 -> 새로만들기
        - 변수이름 : ARMLMD_LICENSE_FILE
        - 변수값   : 8224@electro_server
    2)  Command 창
        ARMCC [엔터] -> 버전표시등이 제대로 나오면 성공
3.  Ver 1.2 설치 -> 환경변수 overwrite : 예(Y)선택 -> License 처리는 skip
4.  [RVDS설치]디렉토리 -> RVS40-BN-00000-r4p0-03rel0 설치
5.  [RVDS설치]디렉토리 -> 4627_Suite Switcher 4.0 Installer
6.  Suite Switcher 프로그램 실행 -> ADS 1.2.1 선택(ARM9을 사용하기 위해)
cf) CodeWarrior for ARM Developer Suite v1.2는 인스톨은 관계 없지만
    실시간으로 1사람만 사용할 수 있음
    이를 회피할려면 하기와 같이 하면 됨
    [Ver 1.2_Crack version]디렉토리 -> [ADS12] -> [CRACK2]에서 설명하는 대로 실행
cf) TSH/PSA에서 사용하는 ARM계열만 컴파일 하는 경우 Ver 1.2 컴파일러만 설치해도 됨
    (Ver 4.0은 설치하지 않아도 됨, Ver 4.0에서도 TSH/PSA ARM계열을 컴파일 할 수 있지만
     사용 환경이 Ver 1.2와 틀림)




[35]	Frontier compile & writing 방법
1)  Metrowerks CodeWarrior에서
    가) *.mcp open
    나) Project -> Remove Object Code -> All Targets 선택
    다) Synchronize Modification Dates
    라) Make(반드시 DebugRel로 Make, DebugRel는 Debug와 Release의 중간 단계이며 Release는 코드를 너무 많이 optimize시키기 때문에 문제가 될 수 있음) 
2)  MES-DNW_V2.5
    가) USB Port -> Transmit -> 열기 -> Metrowerks CodeWarrior에서 compile한 *.bin을 선택 bin파일을 진단기기에 writing함(수정된 프로그램 적용)
    나) writing한 상태에서 LCD Test Font Test....등의 문구가 나올 때까지 반드시 기다려야지 제대로 수정 사항이 적용됨
3)  Application상에서 Register 곧바로 제어하기
    가) 하기 번지에 곧바로 data를 집어 넣으면 됨
		#define FLLSETRESG   *(volatile unsigned short*)(0xc0005102)        // = 0xa000; // 
		#define PWRMODE         *(volatile unsigned short*)(0xc0000952)        // = 0xa000; // 
        
        PWRMODE = (0x01 << 13);						// Set to SRSTENB bit
        PWRMODE |= (0x01 << 12);					// Run SW reset		
		
		#define NOR_WRITE_UINT16(addr, data)	*((volatile unsigned short *)(addr)) = (data)
		#define NOR_READ_UINT16(addr)           *((volatile unsigned short *)(addr))




[36]	TSH/PSA compile & writing 방법
1)  Metrowerks CodeWarrior에서
    가) *.mcp open
    나) Project -> Remove Object Code -> All Targets 선택
    다) Synchronize Modification Dates
    라) Make(반드시 DebugRel로 Make, DebugRel는 Debug와 Release의 중간 단계이며 Release는 코드를 너무 많이 optimize시키기 때문에 문제가 될 수 있음) 
    주의) Compile 되어질 파일 용량은 개당 100MBytes를 넘어서는 안됨(100MBytes를 넘으면 Metrowerks CodeWarrior에서 메모리 오류 발생)
2)  MES-DNW_V2.5
    가) USB Port -> Transmit -> 열기 -> Metrowerks CodeWarrior에서 compile한 *.bin을 선택 bin파일을 진단기기에 writing함(수정된 프로그램 적용)
    나) writing한 상태에서 LCD Test Font Test....등의 문구가 나올 때까지 반드시 기다려야지 제대로 수정 사항이 적용됨
3)	LFI Analysis 에서 FW download 방법(NOR Flash가 완전히 지워져 있는 경우도 가능)
	가) OPENiceEDS Debugger를 사용해서 booting
	나) 보드를 PC통신 모드로 바꾼다음 -> USB 연결
	다) LFI Analysis 윈도우 프로그램 실행 -> [FW download]버튼을 누른 다음 -> *.bin 선택해서 NOR Flash 프로그램 다운로드
4)	NOR Flash 4Mbytes -> 64Mbytes 로 교체
	가) NOR_MFG_CODE, NOR_DEV_CODE 값 수정
		ex) #define NOR_MFG_CODE				0x0001
			#define NOR_DEV_CODE				0x227E
	나) NOR용량을 32Mbytes로 증가시킨 vectors.o , mp4_system_lib.a 으로 교체
		(SDRAM 사이즈가 64Mbytes밖에 되지 않기 때문에 NOR Flash를 H/W적으로 64Mbytes를 연결했어도
		실제 32Mbytes 밖에 사용하지 못함)
	CF) NOR Flah 의 초기값은 0xFF 임(모든 비트가 '1') 




[37]	Source Insight 쌍자음 입력 시 글자 깨지는 현상 제거
1)  C:\Documents and Settings\~\My Documents\Source Insight\Projects\Base\utils.em 파일 수정
    하기와 같이 "macro DoNothing()" macro 추가
/*-------------------------------------------------------------------------
	I N S E R T   H E A D E R

	Inserts a comment header block at the top of the current function. 
	This actually works on any type of symbol, not just functions.

	To use this, define an environment variable "MYNAME" and set it
	to your email name.  eg. set MYNAME=raygr
-------------------------------------------------------------------------*/
// add
macro DoNothing()
{

}
// add
.................................................................................................

2)  Source Insight -> Project -> Add and Remove Project Files -> 상기 1)에서 수정한 utils.em 파일 추가
3)  Source Insight -> Options -> Key Assignments -> Macro: DoNothing -> Keystrokes -> "Shift+"추가("Shift" + "한/영")




[38]	Microsoft Office Outlook이 저장되는 위치

1.  Microsoft Office Outlook 실행하고, Local PC에서 메일을 읽고나면
    Local PC에 메일이 저장되며 서버에 있던 메일은 삭제됨.

2.  Outlook 2016에서 보낸 메일을 회사메일로 받으면
			HTML형식이 아닌 TEXT형식으로 표시되는 문제 해결 방법
			가)	내가 제일 처음 메일 보낼 때는 본 문제 100% 발생하지 않음
			나)	하지만 Outlook에서 이미 있는 메일에
					a)	"회신" or "전체회신" 하면 본 문제가 100% 발생 함
							아래와 같이 링크가 텍스트로 표시됨(cf, 정상적인 링크 -> 하이퍼링크 복사 를 실행해도 아래 경로 알 수 있음)
							http://127.0.0.1:36482/viewFile?docID=1MHwuK4XgpK&fileID_=1MHwuK4XgpM&fileDate=2018-07-09%2017%3A28%3A26.0&localFileDate=2017-12-11%2014%3A46%3A33.0&convertFileType=&history=true&overWrite=true&recently=true&clientType=I&fileName=%ED%96%A5%ED%9B%84%EC%9E%90%EA%B8%88%EC%82%AC%EC%9A%A9%EA%B3%84%ED%9A%8D_2018_POCT%EA%B0%9C%EB%B0%9C%EB%B9%84%28%EA%B8%B0%EA%B8%B0%2B%EC%84%BC%EC%84%9C%292.xlsx
					b)	"전달"하면 본 문제 100% 발생하지 않음
					
					

			가)	정확한 이유는 모르겠고
			나)	메일 보낼 때 홈 -> 새 전자 메일 을 실행해서 메일 작성하며
			다)	받는 사람에 나까지 포함시켜서
					회사메일로 내가 보낸 메일이 정확한 형식으로 보내졌는지 확인 함

3.  Outlook의 주소록에 연락처 정보가 나타나지 않음
Microsoft Office Outlook 2010
리본의 파일 탭으로 이동한 후 정보 탭을 선택합니다.
계정 설정 탭을 클릭한 후 계정 설정을 다시 클릭합니다. 
주소록 탭을 클릭합니다.
Outlook 주소록이 표시되면 닫기를 클릭한 후 "2단계: 연락처 폴더를 주소록과 함께 사용"으로 이동합니다. Outlook 주소록이 나열되지 않는 경우 새로 만들기를 클릭합니다.
추가 주소록을 선택하고 다음을 클릭합니다.
Outlook 주소록을 선택하고 다음을 클릭합니다.
추가한 주소록은 파일 메뉴에서 끝내기를 클릭할 때까지 시작되지 않는다는 메시지가 표시됩니다. 확인을 클릭합니다.
마침을 클릭합니다.
닫기를 클릭한 후 Outlook을 다시 시작합니다.

[39]	MFC 설명
cf)	[C++/MFC 핵심노트] Class (클래스) 정의,선언 - PART 1
클래스는 C++을 객체 지향 언어라고 부르게하는 가장 중요한 부분이라고 합니다. 클래스는 사용자가 내부의 데이터 멤버와 함수를 정의해서 만드는 데이터 타입입니다. 
그리고 이렇게 만들어진 클래스는 인스턴스를 생성해서 사용하게 된다고 합니다. 
클래스의 개념만으로는 저도 뭔소린가 싶은데, 예제를 보면서 차근차근 이해해 보도록 하겠습니다.

Class 정의

클래스 사용에 앞서 정의가 필요합니다. 클래스가 어떤 구조를 가지고 있으며 어떤 타입의 객체를 가지고 어떤 동작을 할 것인지 개략적인 컨셉을 설명해주는 과정입니다. 
정의를 하는 방법은 "class" 라는 키워드와 함께 사용할 이름과 중괄호로 둘러싼 본문을 차례대로 써주면 됩니다. 
그리고 마지막은 세미콜론으로 끝을 표시해 주어야 합니다. 아래 "Student"라는 클래스의 예제를 보죠. 예제는 이전 포스팅에서 만들었던 더미프로젝트를 사용했습니다.

[실습코드#1 (MyFirstProgramDlg.h)]
class Student
{
   public:
   int m_number;     // 멤버변수
   CString m_name;   // 멤버변수
   void PrintOut();  // 멤버함수
};
 
"Student"라는 클래스는, "public:" 이라는 접근 속성을 가지도록한 정수형 변수 "m_number"와 문자열 변수 "m_name" 그리고 void형의 함수 "PrintOut()"이라는 3개를 맴버로 정의되었습니다. 
(3행의 "public"이라는 키워드는 별도로 정리하도록 하겠습니다.)

Class 선언
클래스를 정의 했으면 사용하기 전에 선언이라는 과정이 필요합니다. 선언은 변수의 선언과 유사한 방법을 취하고 있습니다. 
변수 선언시 선언할 변수의 타입을 먼저 쓰고 뒤에 사용할 변수의 이름을 써주듯, 클래스 선언도 정의되어 있는 클래스 중 어떤 클래스를 사용할지 클래스 이름을 먼저 써주고 뒤에 그 객체가 어떤 이름을 가질지를 써주게 됩니다.
위의 "Class 정의"에서 정의한 "Student"클래스를 사용해서 객체를 선언해 보겠습니다.

[실습코드#2 (MyFirstProgramDlg.cpp)]

void CMyFirstProgramDlg::OnBnClickedButton1()
{
    // TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
     
    // ↓↓↓ << 실습용 코드가 시작되는 위치 입니다. >> ↓↓↓
    // ------------------------------------------------------
     
    Student A;                    // 객체 A 생성
    A.m_number = 1;               // 멤버변수에 값 대입
    A.m_name = _T("Jone");        // 멤버변수에 값 대입
 
    A.PrintOut();                 // 멤버함수 호출
 
    // ------------------------------------------------------
    // ↑↑↑ << 실습용 코드가 끝나는 위치 입니다. >> ↑↑↑    
    UpdateData(FALSE);
}
 
void Student::PrintOut()              // 멤버함수 정의
{
    myprint(m_name);        // 출력
}
 
8행에서 "A"라는 객체를 생성해서 "Student" 클래스가 가지고 있는 멤버변수 및 멤버함수를 "A"도 가지게 되었습니다. 
18행 부터는 "PrintOut()"이라는 멤버함수의 정의가 따라나오고 있는데 "MyFirstProgramDlg.cpp" 파일의 멘 마지막에 추가 되었습니다. 
이렇게 수정된 더미프로젝트를 실행해서 "Button1"을 눌러보면, 10행에서 멤버변수에 대입한 학생이름("Jone")이 12행에서 멤버함수를 호출하는 코드에 의해서 19~22행의 코드가 실행되어 화면에 출력이 됩니다. 
이 과정에서 "A.m_name"이나 "A.PrintOut"처럼 점(.) 연산자가 클래스 내부의 함수와 변수를 지정하는데 사용되었는데요. 이제 이런 선택 연산자에 대해서 정리해 보겠습니다.

선택 연산자
앞의 실습코드에서 생성한 객체 A는 멤버로 변수와 함수를 포함하고 있습니다. 이렇게 클래스 내부에 있는 멤버에 접근할 때 사용하는 것이 선택 연산자입니다.
선택연산자로써 점(.) 연산자와 화살표(->) 연산자를 사용할 수 있는데요. 아래 두가지 사용방법과 용도를 알아보겠습니다.

점(.) 선택 연산자
점 선택 연산자는 객체의 멤버에 접근할 때 사용하게 되는데 사용법은 객체이름뒤에 점(.)을 찍고 접근하고자 하는 멤버의 이름을 써주면 됩니다.
따라서 실습코드#2의 9행은 "A"라는 객체안에 있는 "m_name" 변수를 선택하여 해당 변수를 "Jone"으로 대입하는 모습입니다.

화살표(->) 선택 연산자
다음으로 화살표(->) 연산자입니다. Arrow selection operator라고 하던데 그냥 편하게 화살표 연산자라고 부르겠습니다.
화살표 연산자는 점 연산자 처럼 클래스 내부의 멤버에 접글할 때 사용하는 연산자인데 기준이 되는 클래스가 객체가 아니라 포인터일때 화살표 연산자를 사용합니다.
아래 예제를 보겠습니다. 

실습코드 #1에서 선언한 클래스는 그대로 사용을 하고 실습코드 #2만 아래 #3로 변경하겠습니다.
[실습코드 #3]
 
void CMyFirstProgramDlg::OnBnClickedButton1()
{
    // TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
     
    // ↓↓↓ << 실습용 코드가 시작되는 위치 입니다. >> ↓↓↓
    // ------------------------------------------------------
    Student A;                  // 객체 A 생성
    Student* pA = &A;           // 객체 A 생성
    pA->m_number = 1;           // 멤버변수에 값 대입
    pA->m_name = _T("Jone");    // 멤버변수에 값 대입
 
    pA->PrintOut();             // 멤버함수 호출
 
    // ------------------------------------------------------
    // ↑↑↑ << 실습용 코드가 끝나는 위치 입니다. >> ↑↑↑    
    UpdateData(FALSE);
}
 
void Student::PrintOut()            // 멤버함수 정의
{
    myprint(m_name);      // 출력
}
 
7~12행까지만 변경이 되었는데요. 
먼저 7행에서 객체 "A"를 생성하였습니다. 그리고 8행에서는 객체 "A"의 주소를 담을 수 있는 포인터"pA"를 선언하고 "A"객체의 주소를 대입했습니다. 
9, 10, 12행은 실습코드#2와 동일한 기능을 하는 내부 변수와 함수에 접근하는 코드인데 앞에서와는 달리 "pA"라는 포인터를 기준으로 했습니다. 
바로 이렇게 객체 자체가 아니라 포인터를 통해서 내부의 멤버에 접근할 경우 화살표 연산자를 사용하게 되겠습니다.

코드를 실행해 보시면 결과는 당연히 동일하게 나오겠죠.

출처: https://kwonkyo.tistory.com/73 [EveryX]

cf)	API, C++, MFC(Visual C++) 비교
	
	1)	API(Application programming interface)
	초금 c언어 교재를 가지고 c언어를 배운다고 해도
	우리가 만들수 있는 프로그램은 대개 시커먼 창에 hello world를 찍어내는것에서 크게 나아지지 않습니다.
	뭔가 창도 뜨게 하고 싶고 버튼도 만들고 싶은데 막상 C언어 책이라고 있는것에 보면 그런 이야기들은
	없고 맨날 if else while 과 같은 키원드와 몇가지 간단한 함수를 이용해서 오늘도 시커먼 창에서	뭔가 찍어보고 있지요...;;;
	그런 창이나 버튼은 어떻게 만드는 것일까요? 왜 C언어 책에는 그런 것들이 없을까요?
	그런 창이나 버튼은 원래 운영체제에게 "자 내가 창이 하나가 필요하고 그 창에 버튼을 하나만 달아
	줬으면 좋겠어"라고 부탁을 해야하는 것입니다.
	그런데 아무렇게나 부탁할순 없겠죠...
	그래서 그 부탁을 (운영체제 안에)C언어의 함수형태로 만들어 놓고 그 함수를 부르는 로직을 우리는 우리의
	프로그램안에 집어 넣습니다. 그러면 운영체제가 그 부탁을 들어주죠
	그 함수 형태의 부탁을 API(Aplication programming interface)라고 부르는 것입니다.
	ex) 버튼을 만들려면 Visual C++처럼 마우스로 버튼을 끌어다가 쓰는 것이 아닌
		수동으로 코드를 입력해서 만들어줘야 함

	2)	C++
	객체 지향 프로그래밍
        ( Object-Oriented Programing)
    
    cf)	내가 생각하는 객체지향
    	-	절차지향언어는 A를 한다음 B를 하고 그다음 C를 하고 처럼 모든 처리가 순차적으로 진행시키는 것이고
    	-	겍체지향은 a이벤트가 발생하면 A를 실행하고, b이벤트가 발생하면 B를 실행하게 하는 등 어떤 이벤트가 발생하면 어떤 행위를 하도록 하는
    		이벤트 중심으로 작동하며 Module(A, B, C) 단위로 코드가 분리되기 때문에 A모듈에 문제가 있으면 A모듈만 수정하면 되는 등 수정하기도 수월하고
    		여러 사람이 대형 Project Program을 코딩하기도 수월 함

	객체지향이란 용어는 Simula67 프로그래밍 언어에서 객체(object)라는 개념을 사용한데서 유래했습니다.
	객체는 시스템을 구성하는 실체로서 각 객체는 한 구성원의 특성과 상태변화를 구현하는 기본단위라고 할 수 있습니다. 
	객체는 소프트웨어를 구성하고 실제 소프트웨어를 작동시키는 실체들 즉, 논리와 데이타가 분리되어 있는 기존의 구조적 사고에서 과감히 탈피하여 논리와 데이타가 결합된 객체들이 시스템을 이룬다는 것입니다.  
	객체지향이란 소프트웨어를 자료구조와 행위가 결합된 객체들의 구조화 된 집합으로 보는 시각입니다. 소프트웨어를 구현하는 방법이라기 보다는 실세계의 문제를 보는 개념입니다.
	객체 지향 프로그램은 상속성(inheritance)와 다형성(polymorphism)이라는 중요한 두 가지 특성이 있습니다.
	상속성은 클래스들을 공통된 연산과 데이터를 공유에 관련된 타입들의 집합으로 그룹 짓는 것을 말합니다.
	다형성은 이런 집합들을 개별 클래스들이 아닌 하나의 단위로 프로그래밍 할 수 있게 합니다.

	 - 객체 지향이란 서로의 영향을 전혀 받지않는 것이다. 여기에는
	   블랙박스(Black box)의 개념이 크게 작용한다. 즉 모든 프로그
	   램의 요소를 각각의 독립적인 객체로서 생각하는것이다.  한마
	   디로 그 객체들이 어디에 쓰이는 것인지는 알아도  그객체들이
	   어떤 구조로 되어 있으며 어떤 데이타를 유통시키며 어떤 알고
	   리즘으로 움직이는가 하는것은 모른다는 것이다.
	   가장 좋은 예로 자동차를 들수있다. 많은 자동차운전자들이 자
	   동차를 운전하지만 모두가 자동차의 엔진 구조와 그 가속의 원
	   리 브레이크의 재질등등을 알고 운전하지는 않는다.  그러면서
	   도 자동차를 몰고 다니며 사업을 하고 놀러도 다닌다.  이것이
	   바로 자동차를 객체로 생각하는  것이다.  즉 내부에서는 어떤
	   일이 일어나는지 모르는것이다.
	
	 - 객체 지향의 특성
	
	   - 캡슐화(Capsulation)이다.
	     캡슐화는 객체의 속에 모든 함수와 그 함수에 의해 유통되는
	     데이타를 밖에서 유통시키지  않는것이다. 즉 겉에서 그객체
	     를 사용하기 위한 사용자 인터페이스는  제공하나  데이타를
	     검색, 수정 그리고 함수의 이용을 위해서는  이  인터페스를
	     꼭 거쳐야 되게 하는것이다.  즉 함수나 데이터가 그것이 속
	     해있는 객체전용으로 된다는것을 말한다.   좋은 예로 또 자
	     동차를 들수있다.  자동차라는 객체 클래스를 우리가 사용하
	     기 위해서는 알아야할 것이 운전하는 방법뿐인것이다.  표지
	     판이나 교통신호등은 관계는 있으나 자동차를 움직이기 위한
	     객체 인터페이스와는 아무런  관계가 없는것이다.  캡슐화는
	     기능의 조직성과 논리성을 일관시킨다.
	
	   - 데이타형 클래스와 객체(Class and Objectas any type data)
	     이다.
	     자동차를 움직이기 위한 유저가 2명 있다.  자동차라는 객체
	     를 둘다 사용하는데 한명은 부산에 가려고 하고 한명은 대구
	     에 오려고 한다.  자 그렇다면 객체를 사용하여 생기는 마지
	     막 목적지의 차이는 어디서생기는 것일까? 바로 유저가 머릿
	     속에 생각한 목적지의 차이   즉 주어진  데이타의 차이에서
	     오는것이다.  즉 어떠한 데이타형을 가지고 원하는만큼의 여
	     러가지 인스턴스를 만들수 있다는 얘기이다.  분명히 생각만
	     틀리면 자동차객체로 이동이라는 공통성속에서  무수히 많은
	     목적지 인스탄스를 만들어 낼수 있는것이다.
	
	   - ㎖, 상속성(Inheritance)이다.
	     객체를 이루는  클래스를 만들때  이전의 정의했던 클래스와
	     비슷하나 다른 특이한 특성을 지니는 클래스를 만드는것이다.
	     또 자동차다. 가진 자동차의 엔진이 출력이 150마력이다. 여
	     기다 똑같은 엔진을 하나더 달아 300마력이 되었다. 즉 앞의
	     150마력이라는 클래스에 두개로서 300마력을 만든다는  개념
	     이 포함 즉 상속되어있는것이다. 엔진력의 향상이 손쉽게 이
	     루어졌다. 만약 새 300마력엔진을 단 차를 산다고 하면 더힘
	     들것이라는것을 알것이다.
	
	   - 다형(Polymophism)이다.
	     상속성에서 다형의 개념이 많이 좀 왜곡되어 보여진 감이 없
	     지않으나 다형도 객체지향에서 빼놓을수 없는 특성이다.
	     150마력 짜리 엔진을  두개 단차와 300마력짜리 엔진을 하나
	     단 차나 두차의 출력은 같다. 이것이 다형이다. 즉 클래스가
	     같다는 뜻이다. 조상객체로 볼때는 분명히 같은 이름이지만(
	     출력이 300마력이다) 전혀 실행방법이 다른 클래스인것이다(
	     하나는 150마력엔진의 원리로 움직이고 하나는 300마력 엔진
	     의 원리로 움직인다는것). 다형은  기본 클래스를  바탕으로
	     동일한 메모리 개념을 써 다양성을 부여하는 것이다.
	
	   이상이 C++이 추구하는 객체지향 프로그램의 간단한 요약 특성이다.

	3)	MFC(Visual C++)(Microsoft Foundation Classes)
	객체지향 프로그램을 보다 Visual하게 해줍니다. 그냥 Visual C++이라고 생각하시면 되고 API에서 가능한 모든 것을
	수동이 아닌 자동으로(ex, 버튼 같은 경우 마우스로 끌어다 쓰면 된다) 만들어 준다.
	

1.  AfxMessageBox 는 printf 류 함수와 같은 형식으로 사용할 수 없습니다.
http://blog.naver.com/xtelite/50017069399 참조
그렇게 표현하고 싶으시면

CString temp;
temp.Format(_T("당신의 점수는 %d점입니다."), nScore);
AfxMessageBox(temp);

cf) MFC에서 printf와 같은 명령을 사용하고 싶다면 TRACE 명령을 사용하면 됨
TRACE("Dust filter complete, m_iPeakYPer = %d%%\r\n", m_iPeakYPer);    --> MFC 출력창에 본 명령이 출력됨.
본문 예제에서 화면 출력을 위해 사용하는 cout 객체는 콘솔 응용 프로그램에서는
유용하지만, 일반적인 GUI응용 프로그램에서는 동작하지 않는다.
만약 GUI 응용 프로그램에서도 cout 객체 또는 printf() 함수와 같은 기능이 필요하다면 TRACE 매크로를 사용하면 된다.
TRACE 매크로의 사용법은 printf() 함수와 유사함

사용 예>
int x = 1;
int y = 16;
float z = 32.0;
TRACE("This is a TRACE statement \n");
TRACE("The value of x is &d \n", x);
TRACE("x = &d and y = &d \n", x, y);
TRACE("x = &d and y = &d and z = &f \n", x, y, z);

위의 코드를 본문 예제와 마찬가지로 main() 함수의 else {.......} 부분에 입력하고 컴파일, 링크를 한 후 
[build]->[Start Debug]->[Go] 메뉴를 선택하거나 툴바에서 아이콘을 눌러서 실행하면 다음과 같이 티버그 창에 TRACE 매크로의 출력 결과가 표시됨
TRACE 매크로는 디버그(Debug) 버전으로 실행 파일을 생성할 때만 작동하면 릴리스(Release) 버전에서는 작동 하지 않는다.
이것은 TRACE 매크로가 디버깅을 위하여 제공된다는 측면을 나타낸다.
[Build]->[Set Active Configuration...] 메뉴를 선택하면 그림과 같이 활성 프로젝트를 변경함으로써 실행 파일 생성 방법을 바꿀 수 있다.
일반적으로 프로그램 개발 중에는 디버그를 선택하며 프로그램이 최종적으로 완성되면 릴리스를 선택함으로써 작고 빠른 실행 파일을 생성한다.
GUI 응용 프로그램에서 프로그램 수행 중 디버깅을 위한 목적으로 특정한 값을 출력하고자 한다면 TRACE 매크로를 사용하자.!
ps.
릴리즈 버전 디버깅은 완성프로그램에 사용하는 거(안드로이드에서도 그렇지만 로그캣 잡소스 필요없는것들 다빼고 진짜필요한것만 포함해서 실행파일 만드는것 개발에 필요한 부분이 다 없음)
그냥 디버깅은 프로그램을 만들면서 버그나 오류를 찾거나 실행되는지를 작업자가 확인하기 위한 모드로 TRACE 같은 함수를 이용해서 디버그 기록을 확인가능
결론적으로 TRACE 라는 매크로는 안드로이드의 Log.i 랑 같은 역할을 하는거내
로크켓에서 값을을 캐치해서 알아보는거고
MFC에서는 TRACE 를 이용해서 Debug 창에서 값을 캐치해서 알아보는 거내
정말 좋은거 하나 알았다! 
진짜 프로그램 만드는 사람이라면 이거 꼭 필요 존재를 알것이다.
책보고 만드는것이 아닌 머리로 알고리즘 짜서 만드는 사람들은!

int AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0);
MessageBox와는 달리 제목을 넣는 부분은 사라졌습니다.

Example)
AfxMessageBox(“메시지 박스 테스트”, MB_OK | MB_ICONEXCLAMATION);
int nResult = AfxMessageBox(_T("Are you sure you want to delete this file?"), MB_YESNO|MB_ICONQUESTION|MB_SETFOREGROUND | MB_TOPMOST | MB_TASKMODAL);
if(nResult == IDNO){
    return;
}
else{
...
}

nType은 다음 중에서 각각 하나씩 조합해서 사용할 수 있습니다.

버튼 스타일                                    의미
MB_ABORTRETRYIGNORE                [취소], [재시도], [무시]
MB_OK                                           [확인]
MB_OKCANCEL                               [확인], [취소]
MB_RETRYCANCEL                         [재시도], [취소]
MB_YESNO                                     [예], [아니오]
MB_YESNOCANCEL                         [예], [아니오], [취소]

아이콘 스타일                                  의미
MB_ICONEXCLAMATION                   [느낌표]
MB_ICONINFORMATION                    [느낌표]
MB_ICONQUESTION                          [물음표]
MB_ICONSTOP                                 [X]

디폴트 버튼                                     의미
MB_DEFBUTTON1                             첫 번째 버튼
MB_DEFBUTTON2                             두 번째 버튼
MB_DEFBUTTON3                             세 번째 버튼

모달리티                                         의미
MB_APPLMODAL                              메시지 박스를 종료시켜야 프로그램을 계속 진행할 수 있음
MB_SYSTEMMODAL                          메시지 박스를 종료시켜야 시스템을 사용할 수 있음

반환값                                            의미
IDABORT                                         [취소(Abort)]가 눌러 졌음
IDCANCEL                                       [취소(Cancel)]이 눌러 졌음
IDIGNORE                                        [무시]가 눌러 졌음
IDNO                                               [아니오]가 눌러 졌음
IDOK                                               [확인]이 눌러 졌음
IDRETRY                                          [재시도]가 눌러 졌음
IDYES                                             [예]가 눌러 졌음
[출처] AfxMessageBox 총 정리!!|작성자 cysatan

cf)	MFC에서 printf()를 사용하자(콘솔 / console 창 띄우기)
	stdafx.cpp or 헤더 파일에 하기 내용 추가 하면 콘솔 창 띄워지고 코드에서 printf 사용한 결과물이 출력 됨
	#pragma comment(linker, "/entry:WinMainCRTStartup /subsystem:console")


2.  다중파일선택 -> 파일이름만 뽑아내기(확장자 제거)
            int nIx;

            m_str = dlg.GetNextPathName(pos);
            // '\'이후 확장자가 포함된 파일이름을 뽑아냄
            nIx = m_str.ReverseFind('\\');          // m_str의 뒤에서부터 '\'이 있는 위치를 찾는다(return 정보는 앞자리 부터 '\'이 있는 위치까지의 개수)
            m_str.Delete(0, nIx+1);                 // path까지 포함되어 있는 파일명의 첫째자리(0) 서부터 '\'의 위치까지 지워버림(하지만 확장자 명도 포함되어 있음)
            TRACE("name1 = %s\n",m_str);            ->> name1 = 060921-04-W_532.tif  게 출력됩니다.

            // 확장자 앞의 파일이름만 뽑아냄
            CString strFile2 = m_str.Left(m_str.ReverseFind('.')); // Left함수는 현재 지점으로부터 왼쪽편 문자열을 카피한다.
            TRACE("name2 = %s\n",strFile2);         ->> name2 = 060921-04-W_532  게 출력됩니다.

            CString strFile3 =  strFile2 .Right( strFile2 .ReverseFind('_')); 
            TRACE("name3 = %s\n",strFile3);         ->> name3 = 21-04-W_532  게 출력됩니다.

            //m_532File.AddString(m_str);
            if(strFile3 == "532") m_532File.AddString(m_str);   // 만약 파일이름이 532 파일이면, 532 리스트 넣는다.

3.	SDK 의미
SDK과 API는 대략 혼용해서 많이 쓰기도 하는데요.... 정확히 구분을 하자면..
API(Application Programming Interface)는 운영체제 등 큰 틀에서 지원해 주는 함수의 집합군을 이야기 하구요..
SDK(Software Development Kit)는 주로 개발툴에서 지원이 되며 최종 개발자가 사용하기 편한 형태로 재구성한 함수집합군을 이야기 합니니다..
아마 Apple와 Google가 개발할때 사용하던 SDK 즉 라이브러리나 소스등을 오픈 하나보네요..

Visual C++을 예로 들면, Visual C++에서는 많은 SDK를 지원하는데요... 그 SDK는 API기반으로 사용하기 쉽게 재 작성된것도 많이 있죠

4.	.dsw와 .dsp & .sln와 .vcproj
 2004.02.24 02:44 
coolkkh78   
http://cafe.naver.com/studydotnet/10   
 
전에 올렸던 내용중에 실행하기에서 나왔던 부분 같은데
Work space는 .dsw로 저장되고
Project는 .dsp로 저장됩니다.

1) Visual C++ 6.0
.dsw(Work space)-->작업한 정보를 온전하게 읽어오려면 이 파일을 볼러 오는거랍니다.
.dsp(Project)

2) Visual Studio 2008
프로젝트를 열 경우 확장자가
.sln인 파일을 연다, 없는 경우 확장자
.vcproj인 파일을 연다.
중요)	윈도우7(Windows7)에서 Visual Studio (VS 6.0, VS 2005) 컴파일 에러 시 대처 방법
		->	Microsoft Visual C++ 6.0 속성 -> 바로가기 -> 고급 -> [v]관리자 권한으로 실행 체크
중요)	Visual Studio 2017 Pro 에서 Build 시 "stdio.h 파일 소스를 열 수 없습니다."등의 Build error가 발생하는 경우 해결 방법
		1)	Visual Studio Installer -> 수정 -> 개별구성요소 -> C++ 관련한 사항을 추가시킨다.
		2)	1)방법으로 해결되지 않는 경우
			Visual Studio Installer -> 수정 -> 개별구성요소 -> 오른쪽 항목 -> 요약 -> C++를 사용한 데스크톱 개발 -> C++용 Windows XP 지원 추가
			Visual Studio 2017 -> 프로젝트 -> 속성 -> 플랫폼 도구 집합 -> Visual Studio 2017 - Windows XP (v141_xp)선택
			Visual Studio 2017 -> 프로젝트 -> 속성 -> Windows SDK 버전 -> 7.0 선택
중요)	Visual Studio 외부DLL경로(path) 추가하기(opencv_world401d.dll이(가) 없어 코드 실행을 진행할 수 없습니다.)
		cf, 기존 윈도우 환경변수 path에서 추가시켜서 실행하던 명령을 Visual Studio 속성에 추가시켜 동작하도록 하는 방법
			1)	시스템변수 -> Path -> 편집 -> 새로만들기
					->	C:\opencv\build\x64\vc14\bin 추가

		1)	Visual Studio 프로젝트 우클릭 -> 속성 -> 구성속성 -> 디버깅 -> 환경
			에 하기와 같이 속성 추가시킴
			PATH=C:\UTIL\opencv\build\x64\vc15\bin;%PATH%
			PATH=C:\UTIL\opencv420\opencv\build\x64\vc15\bin;%PATH%
			cf)	PATH=C:\opencv\build\x64\vc14\bin;%PATH%


5.	CDC/CClientDC
CDC : 실행된 윈도우에 대한 모든 소유권을 갖으며 사용후 반드시 ReleaseDC를 해야 한다
CClientDC :		CDC의 subset 개념이며 ReleaseDC가 필요 없다
				윈도우의 클라이언트 영역으로 한정되는 DC입니다.
CWindowDC :		윈도우의 모든 영역(비클라이언트 영역 포함)에 대한 DC입니다.
				이 DC를 이용하면 다른 윈도우에 대해서 그리기가 가능합니다.
CPaintDC :		CClientDC 클래스와 유사하지만, 내부적으로 BeginPaint()/EndPaint()
				함수를 호출하여 WM_ERASEBKGND 메시지가 발생한다는 것이 다릅니다.
CMetaFileDC :	WMF(Window Meta File)와 EMF(Enhanced Meta File) 파일에 대한 DC입니다.

void CRedrawDemoView::OnLButtonDown(UINT nFlags, CPoint point)
{
	//DC를 얻는다.
	CDC* pDC = GetDC();
	//주어진 좌표에 네모를 그린다.
	pDC->Rectangle(10, 10, 110, 110);
	//DC를 반환한다.
	ReleaseDC(pDC);

	CView::OnLButtonDown(nFlags, point);
}

void CRedrawDemoView::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	//그리기 작업을 수행한다.
	dc.Rectangle(10, 10, 110, 110);
}

void CRedrawDemoView::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	//두께가 3픽셀인 붉은 색 펜을 생성한다.
	CPen NewPen(PS_SOLID, 3, RGB(192, 0, 0));
	//생성한 펜을 DC의 현재 펜으로 변경하고 기존 펜 객체에 대한
	//포인터를 별도로 저장해둔다.
	CPen* pOldPen = dc.SelectObject(&NewPen);

	//새로운 브러시를 생성하여 선택한다.
	CBrush NewBrush(RGB(192, 192, 192));
	CBrush* pOldBrush = dc.SelectObject(&NewBrush);

	//그리기 작업을 수행한다.
	dc.Rectangle(120, 10, 220, 110);

	//예전 펜을 현재 펜으로 바꾼다.
	dc.SelectObject(pOldPen);
	//예전 브러시로 현재 브러시를 바꾼다.
	dc.SelectObject(pOldBrush);
}

void CBmpDisplayDemoView::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CDC MemDC;
	BITMAP bmpInfo;
	//화면 DC화 호환되는 메모리 DC를 생성한다.
	MemDC.CreateCompatibleDC(&dc);
	//비트맵 리소스를 로딩한다.
	CBitmap bmp;
	CBitmap* pOldBmp = NULL;
	bmp.LoadBitmap(IDB_Test_Image);
	//로딩된 비트맵의 정보를 알아본다.
	bmp.GetBitmap(&bmpInfo);
	//메모리 DC에 선택한다.
	pOldBmp = MemDC.SelectObject(&bmp);
	//메모리 DC에 들어있는 비트맵을 화면 DC로 복사하여 출력한다.
#if 0
	dc.BitBlt(	200, 200,				//출력될 좌표 
				250, 300, 				//출력될 비트맵의 폭과 높이
				&MemDC, 				//출력할 비트맵을 저장한 메모리 DC의 주소
				350, 200, 				//메모리 DC에 들어 있는 비트맵의 시작 좌표
				SRCCOPY);				//메모리 DC의 내용에 변화를 주지 말고 그대로 화면 DC에 복사
#else
	//메모리 DC의 이미지를 두 배 확대하여 출력한다.
	dc.StretchBlt(	200, 200,			//출력될 좌표
					250 * 2, 300 * 2,	//폭과 높이를 두배 확대
					&MemDC,
					350, 200,			//원본 이미지 좌표
					250, 300,			//원본 이미지의 폭과 높이
					SRCCOPY);
#endif

	MemDC.SelectObject(pOldBmp);
}

void CRedrawDemoView::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CRect Rect;
	GetClientRect(&Rect);
	dc.FillSolidRect(&Rect, RGB(192, 0, 0));

	Rect -= CRect(7, 7, 7, 7);
	dc.SelectStockObject(NULL_PEN);
	dc.RoundRect(&Rect, CPoint(21, 21));

	dc.SetBkMode(TRANSPARENT);
	dc.TextOut(30, 30, _T("Test string!"));

}

6.	GetClientRect
작업영역의 중앙 찾기 : GetClientRect 의 right , bottom 을 2로 나눈다. ( left , top 은 항상 0 ) 

윈도우는 작업영역 ( Client Area ) 과 비작업영역 ( Non Client Area ) 두 부분으로 구성되어 있다.
작업영역은 윈도우 중앙의 흰 부분을 말하며 
비작업영역은 그 외의 영역을 말한다.

비 작업영역에 속하는 부분은 타이틀바 , 경계선 , 메뉴 등이 있다.
작업/비작업영역의 구분은 윈도우를 이해하는데 중요한 비중을 차지하는데 
왜냐하면 프로그래밍의 대상이 되는 것은 작업영역에 한정되기 때문이다.

일반적으로 비작업영역은 프로그래밍 대상이 아니며 운영체제가 알아서 관리하도록 되어있다.
타이틀바나 경계선을 프로그래머가 직접 그려야 할 필요가 없으며 
타이틀바를 드래그 해서 윈도우를 이동하거나 경계선을 드래그 해서 크기를 변경하는 것은 운영체제가 처리한다.
( 특수한 경우는 제외한다. 일반적으로는 건드릴 필요가 없다는 뜻이다 )

그래서 원하는 위치에 정확하게 출력하려면 
윈도우가 차지하고 있는 영역의 좌표를 조사해야 하는것이 아니라 
작업영역의 좌표를 조사해야 한다.
이때는 다음 함수를 사용한다.

BOOL GetClientRect ( HWND hWnd , LPRECT lpRect );

이름 그대로 Client 가 차지하고 있는 Rect 를 Get 하는 함수이다.
두 번째 인수로 리턴값을 돌려받기 위한 RECT 구조체의 포인터를 넘긴다.
이 함수 호출 후에  RECT 구조체에는 작업영역의 좌표가 들어가는데 
left , top 은 원점이므로 항상 0 이며 right , bottom 에 우하단의 좌표가 대입된다.

결국 , 이 함수는 작업영역의 크기를 구한다고 할 수 있다.
이 함수를 사용하여 문자열을 작업영역의 정중앙에 출력하는 예제를 만들어 본다.

작업영역의 중앙좌표를 알려면 작업영역의 크기를 구한 후 우하단 좌표를 2로 나누면 된다.

cf)	GetClientRect 사용 이유
	사용자가 창을 임의로 바꿀 수 있기 때문 입니다.
	창 크기를 바꿀 때, 그에 맞춰서 그림(정확히는 벡터이미지를(Ellipse, Rectangle 등))의 크기도
	바뀌어야 한다면 당연히 GetClientRect를 써서 표현해야겠지요

7.	화면 깜박임 제거
	윈도우가 클라이언트 영역과 비클라이언트 영역으로 구별되어 있고
	각각을 그리도록 하는 메시지는 WM_PAINT와 WM_NCPAINT메시지 입니다.
	그러나 클라이언트 영역에서는 WM_PAINT 메시지에 앞서 WM_ERASEBKGND 메시지가 발생합니다.
	그리고 WM_ERASEGKGND 메시지 핸들러 함수는 윈도우의 배경을 기리는 코드를 수행합니다.
	일반적으로 윈도우의 배경은 흰색이고, 흰색으로 배경을 칠하는 코드가 이때 실행됩니다.
	이것이 윈도우가 깜빡이는 주요 원인 중 하나입니다.
	따라서 흰색 배경을 그리는 작업이 불필요하다고 판단되면 WM_ERASEBKGND 메시지 핸들러 함수를 등록한 후
	다음과 같이 상위 클래스의 멤버를 호출하지 않고 반환하도록 코드를 수정합니다.
	그러면 배경이 하얗게 지워지는 코드가 생략되므로 깜빡임이 줄어들게 됩니다.
	
	BOOL CRedrawDemoView::OnEraseBkgnd(CDC* pDC)
	{
		return TRUE;

	//	return CView::OnEraseBkgnd(pDC);
	}

8.	MFC 기본 프로그래밍  비쥬얼 c++
 http://blog.naver.com/wizard1202/140000679062

1. CString
텍스트 데이터들을 저장하고 컨트롤 하는  클래스이다. 보통 텍스트 String을 저장하는 변수 중 우리가 
가장 쉽게 알 수 있는 변수 는 char* text, char text[80] 등으로 표현하고  저장을 할 수 있는 반면 
CString 함수는 더 많은 기능을 제공한다. 

CString m_strText;
char temp[80];
lstrcpy((LPSTR)temp, (LPSTR)"여기는 
       SAFARI 사이트입니다");
m_strText = " CString("여기는")" + "SAFARI" 
       => "여기는  SAFARI"
m_strText = m_strText + "사이트입니다"
   // "여기는 SAFARI 사이트입니다"
m_strText.GetLength()// 위의 텍스트 길이값  
       26을 리턴한다.
m_strText.Empty;=>  m_strText =  "" 가 된다.

int CString::GetLength() 
현재 설정된 문자열의  길이를 리턴합니다. 

ex)CString test = CString("안녕");
int len=test.GetLength(); 

BOOL CString::IsEmpty() 
//현재 문자열을 검사하여 없으면 TRUE 한개의  문자라도 있으면 FALSE를 리턴한다. 

void CString::Empty()
//현재 저장된 문자열을 모두 지운다.

MFC - CString 변환                                                                  
1) CString -> int
int형 = _ttoi(CString형);			// 권장
int형 = _atoi(CString형);

2) int -> CString
CString형.Format(_T("%d"), int형);

3) CString의 atoi, itoa
itoa(int형, char형, 진수);			// _itoa_s(Source(int), Destination(char), 진수)
int형 = atoi(char형);

4) CString -> char *                                                                   
CString str;                                                                        
str = "Hello";                                                                      
char* ss = LPSTR(LPCTSTR(str));                                                     
                                                                                    
5) char * --> CString                                                                  
char ss[] = "Hello";                                                                
CString str;                                                                        
str.Format("%s", ss);                                                               
(Format대신에 GetBuffer()를 써도 됩니다.)                                           
                                                                                 
6) CString -> char형배열                                                               
CString str = "어떤 문자열";                                                        
unsigned char tmp[5];                                                               
strncpy((char*)tmp, (LPTSTR)(LPCTSTR)str, 4);                                       
strncpy를 쓴 이유는 타겟 배열의 크기가 5이기 때문에, 4문자만 집어 넣기 위해서입니다.

cf)	[MFC] CString 문자열 비교하는 함수 - Compare, CompareNoCase 
Compare : 대소문자를 구분하여 문자열을 비교한다.
CompareNoCase : 대소문자를 구분하지 않고 문자열을 비교한다.

operator ==, !=, <, >, <=, >= 도 대소문자를 구분하여 CString의 문자열을 비교할 수 있으며
C언어 함수 중 strcmp, strncmp, stricmp, strnicmp 등과 비슷하다.
또 한 비교는 아스키코드를 기준으로 비교하므로 아스키코드표를 참고하면 된다.

※함수 원형 및 설명
int Compare( LPCTSTR lpsz ) const;
int CompareNoCase( LPCTSTR lpsz ) const;
//lpsz : NULL로 종결되는 비교할 문자열
//반환값 : 문자열이 lpsz보다 작을 경우 -1
//         문자열이 lpsz와 같을 경우 0
//         문자열이 lpsz보다 큰 경우 1

※예제
#include <atlstr.h>       //CString

#define print( str ) printf( "%d\n", str )

int main( )
{
	CString strText1;
	CString strText2;
	CString strText3;

	strText1 = "ABC";

	//Compare - 대소문자 구분
	print( strText1.Compare( "ABC" ) );		// -> 0 output
	print( strText1.Compare( "abc" ) );		// -> -1 output
	print( strText1.Compare( "123" ) );		// -> 1 output

	//CompareNoCase - 대소문자 구분 안 함
	print( strText1.CompareNoCase( "ABC" ) );	// -> 0 output
	print( strText1.CompareNoCase( "abc" ) );	// -> 0 output

	return 0;
}

cf)	[MFC] CString 문자열 검색 함수 - Find, ReverseFind 
CString 문자열 검색 관련 함수 중 Find(), ReverseFind()에 관한 내용이다.

※요약
Find : CString 개체의 문자열 기준, 좌측에서부터 문자 혹은 문자열을 검색
ReverseFind : CString 개체의 문자열 기준, 우측(역순)에서부터 문자를 검색

※특징
Find나 ReverseFind의 반환값은 0 ~ (문자열 길이 n-1)이다.
찾으려는 문자열이 없을 경우 -1을 리턴한다.

※함수 원형 및 설명
int Find( TCHAR ch ) const;
//ch : 검색할 단일 문자
//반환값 : 검색된 위치, 실패 시 -1

int Find( TCHAR ch, int nStart ) const;
//ch : 검색할 단일 문자
//nStart : 검색을 시작할 위치. 생략 시 디폴트 값 0
//반환값 : 검색된 위치, 실패 시 -1

int Find( LPCTSTR lpszSub ) const;
//lpszSub : NULL로 종결되는 검색할 문자열
//반환값 : 검색된 위치, 실패 시 -1

int Find( LPCTSTR lpszSub, int nStart ) const;
//lpszSub : NULL로 종결되는 검색할 문자열
//nStart : 검색을 시작할 위치. 생략 시 디폴트 값 0
//반환값 : 검색된 위치, 실패 시 -1

int ReverseFind( TCHAR ch ) const;
//ch : 검색할 단일 문자
//반환값 : 검색된 위치, 실패 시 -1

※예제
#include <atlstr.h>		//CString

int main( )
{
	int nIndex = 0;
	CString strDate( "2013-12-16" );

	nIndex = str.Find( '0' );
	printf( "%d\n", nIndex );		// 1 output

	nIndex = str.Find( '12' );
	printf( "%d\n", nIndex );		// 0 output

	nIndex = str.ReverseFind( '-' );
	printf( "%d\n", nIndex );		// 7 output

	return 0;
}

cf)	[C++ 문법] string to char, char to string 변환
1.	string to char

    char ch[100];
    string a = "I wanna go to bed";
    strcpy(ch,a.c_str());
    cout<<ch<<endl;

		1 ) c_str로 string변수를 char로 변환 
		2 ) strcpy로 ch변수에 변환값 저장

2.	char to string

    char ch2[100] = {"Oh my god"};
    string str(ch2);
    cout <<str<<endl;
		
		string 선언시에 괄호안에 char변수를 넣어주면 된다.

3.	string to int
 // stoi example
#include <iostream>   // std::cout
#include <string>     // std::string, std::stoi

int main ()
{
  std::string str_dec = "2001, A Space Odyssey";
  std::string str_hex = "40c3";
  std::string str_bin = "-10010110001";
  std::string str_auto = "0x7f";

  std::string::size_type sz;   // alias of size_t

  int i_dec = std::stoi (str_dec,&sz);
  int i_hex = std::stoi (str_hex,nullptr,16);
  int i_bin = std::stoi (str_bin,nullptr,2);
  int i_auto = std::stoi (str_auto,nullptr,0);

  std::cout << str_dec << ": " << i_dec << " and [" << str_dec.substr(sz) << "]\n";
  std::cout << str_hex << ": " << i_hex << '\n';
  std::cout << str_bin << ": " << i_bin << '\n';
  std::cout << str_auto << ": " << i_auto << '\n';

  return 0;
}

cf)	string str2 = "1110";
	stoi(str2, null, 2); 		// str2에 있는 숫자를 2진수라 생각하고 int로 바꿔주는 명령

cf)	[C++] char형 데이터 int형으로 변환하기
문제를 풀다가 문자를 정수로 바꾸는 걸 까먹고 안해서 계속 에러가 나는 걸 꽤나 헤맸다.
뒤늦게 숫자가 아스키 코드라는 것을 깨닫고 C++에서 char 데이터형을 int로 변환하는 법을 검색해 보았다.
스택 오버플로우에 쉬운 방법이 있어 기록해 놓는다.

'1'의 문자를 int 1로 수정하고 싶다면 아래와 같이 작성할 수 있다.
char ch1 = '1';
int num1 = ch1 - '0';
cout << num1;  //1

아스키 코드의 순서가 '0' 부터 '9'씩 차례대로 1씩 늘어나므로 위와 같이 작성하면 해당 수의 값을 구할 수 있다.
'1'의 문자의 아스키 코드 값을 보고 싶다면 (int)를 붙여 형 변환을 해준다.
char ch1 = '1';
int numAscii = (int)ch1;
cout << numAscii;  //49 ('1'의 아스키 코드 값)

cf)	atoi()
	1)	atoi() 함수의 원리
			매개변수로 들어온 문자열을 앞에서 부터 읽어서 "공백" or "숫자가아닌문자"가 올때까지 숫자로 변환을 해주는 원리
	2)	atoi("문자") vs atoi("0")의 구분에 대해서
			atoi("문자")의 반환은 0이며
			atoi("0")의 결과값인 0 과 동일함
			이 경우 구별은 isdigit()를 이용해서 판단

cf)	Sum of digits in a string
int SumDigits (string strInput)				 					//get the string from main
{
	int index = 0;																//initialize index position
	int sum = 0;																	//declare sum variable
	int strLen = (int)strInput.length();					//declare and initialize variable to hold the value of string length

	while (index < strLen)
	{ 
		int str = strInput[index];									//declare int variable to hold value of string position
		sum = sum + str;
		index++;																		//goes to the next position in the string
	}

	return sum;
}

cf)	정상적으로 동작하는 String 관련 예제
bool CTagDecoderDlg::checkCheckSumOCR(String strInput)
{
	int nCheckSum = 0;
	int nCheckSum_LSB = 0;									// 최종 Sum한 CheckSum값 중 맨 끝 1자리 10진수
	int iLength = (int)strInput.length();
	int nCheckSum_OCR = 0;									// CheckSum 확인의 기준이 되는 10진수 값(OCR[2]의 10진수값)

	// CheckSum 연산(OCR[2](CheckSum)을 제외한 OCR 모두 sum)
	for (int i = 0; i < iLength; i++)
	{ 
		//-- CheckSum of OCR(11ea)	--//
		// OCR = OCR[0] + OCR[1] + OCR[2] + OCR[3] + OCR[4] + OCR[5] + OCR[6] + OCR[7] + OCR[8] + OCR[9] + OCR[10]
		// CheckSum = OCR[0] + OCR[1] + OCR[3] + OCR[4] + OCR[5] + OCR[6] + OCR[7] + OCR[8] + OCR[9] + OCR[10]
		// CheckSum값은 OCR[2]값과 같아야 함
		if (i == 2)											// Skip
		{

		}
		else												// Sum
		{
			nCheckSum += strInput[i];
			TRACE("checkCheckSumOCR, strInput[%d] = %d\n", i, strInput[i]);
			TRACE("%d\n", strInput[i]);
		}
	}

	nCheckSum_LSB = nCheckSum % 10;							// 10진수 CheckSum 값 중 맨 끝 1자리 10진수만 뽑아냄
	nCheckSum_OCR = strInput[2] - '0';						// 해당 숫자문자값에서 '0'(=48)을 빼면 해당 숫자문자에 대한 정수형 숫자값이 나옴

	if (nCheckSum_LSB == nCheckSum_OCR)						// OCR[2] == CheckSum
		return true;
	else
		return false;
}
 
4.	String을 int로 변환 
1. Bash[편집]
printf '%d\n' "42" 2>/dev/null             # 42
printf '%d\n' "42,000" 2>/dev/null       # 42

2. C[편집]
16px-Crystal_Clear_app_xmag.svg.png C언어 atoi() 문서를 참고하십시오.
#include <stdio.h>
#include <stdlib.h>
int main() {
    char *str = "123";
    printf("%d\n", atoi(str)); // 123
    return 0;
}

3. C++[편집]
#include <iostream>
#include <stdlib.h>
using namespace std;
int main() {
	string str = "123";
	int n = atoi(str.c_str());
	cout << n << endl;
    // 123	
}

#include <iostream>
#include <sstream>
using namespace std;
int main() {
	string str = "123";
	std::stringstream ss(str);
	int n;
	ss >> n;
	cout << n << endl;
    // 123	
}

4. C#[편집]
String str = "123";
int i = int.Parse(str);

5. Java[편집]
String str = "123";
int i = Integer.parseInt(str);

6. JavaScript[편집]
parseInt('123.45')  // 123
parseInt('77')      // 77

7. Objective-C[편집]
NSString *s = @"42";
int i = [s intValue];

8. Perl[편집]
print 0 + '42';                       # 42
print int '42,000';                   # 42

9. PHP[편집]
echo intval('42');                    // 42
echo intval('+42');                   // 42
echo intval('-42');                   // -42

echo intval('42,000');                // 42

echo intval(42);                      // 42
echo intval(4.2);                     // 4
echo intval(042);                     // 34
echo intval('042');                   // 42
echo intval(1e10);                    // 1410065408
echo intval('1e10');                  // 1
echo intval(0x1A);                    // 26

echo 0 + '42';                        // 42

var_dump( intval('hello42') );        // int(0)
var_dump( intval('42hello') );        // int(42)


function string_to_int($str) { return (int)preg_replace('/[^\-\d]*(\-?\d*).*/','$1',$str); }
var_dump( string_to_int( 'The value is 0083.123' ) );
// int(83)

10. Python[편집]
s = "123"
i = int(s)
print( type(i) )
# <class 'int'>

11. Ruby[편집]
str = "123"
i = str.to_i

12. VB[편집]
Dim s As String
Dim i As Integer

s = "42"
i = Val(s)


2. CPoint 
CPoint 함수는 x,y 좌료를  저장하고 응용하는 클래스이다. 
ex) CPoint po=CPoint(30,20);

3. CRect 
사각형 좌표를 저장하고  응용하는 클래스 입니다.
즉 사각형의 왼쪽 좌표(left), 상단좌표(top), 오른쪽 좌표(right), 하단  좌표(bottom)값을 가지고 
기능을 하는 클래스이다.

CRect m_pRectText;
m_pRectText=CRect(0,0,640,480);
//left=0, top=0, right=640, bottom=480이란 뜻이다. 

int CRect::Width()
현재 사각형의 가로 길이를 리턴. 

int CRect::Height()
현재 사각형의 세로 길이를 리턴. 

CSize CRect::Size()
현재 사각형의 가로 길이와 세로 길이를 CSize  형태로 함께 리턴합니다. 

CPoint& CRect::TopLeft()
현재 사각형의 좌측 상단 좌표를 CPoint형으로 리턴. 

CPoint& CRect::BottomRight()
현재 사각형의 우측 하단 좌표를 CPoint형으로 리턴. 

CPoint& CRect::CenterPoint()
현재 사각형의 중심 좌표를 CPoint형으로 리턴.

4. CView::OnDraw(CDC* pDC) 
화면이나 프린트 DEVICE에  출력할 때 사용하는 함수이다.
즉 Device Context 클래스(CDC)를 받아서 화면 출력을 설정하면 바로  화면에 뿌려진다.

5. CDC::TextOut() 
화면에 글자를 출력 함수.  두 가지 형태가 있다. 

Virtual BOOL TextOut( int x, int y, LPCTSTR  lpszString, 
       int nCount ); //LPSTR형의 스트링을 화면에 뿌림.
BOOL TextOut( int x, int y, const CString& str );
   // CSring형의 스트링을 화면에  뿌림. 

6. CDC::Rectangle() 
화면에 상자를 그리는  함수이며 두 가지 종류의 함수로 되어 있다.

BOOL Rectangle( int x1, int y1, int x2, int y2 );
   //int형 좌표값
BOOL Rectangle( LPCRECT lprect );
   //CRect형 좌표값 

7. CDC::Ellipse() 
화면에 원을 그리는  함수다. 이것도 두 가지 종류로 되어 있다.

BOOL Ellipse( int x1, int y1, int x2, int y2 );
 //int형 좌표값
BOOL Ellipse( LPCRECT lpRect ); 
// CRect형 좌표값 

8. OnLButtonDown(UINT nFlags, CPoint point) 
좌측 마우스 버튼을 누르면  작동하는 함수이며 리턴되는 인자 중 nFlags는 좌측 마우스 버튼과  함께 
어떤 키가 눌려졌는지를 확인한다. 

MK_CONTROL  Ctrl키가  눌려졌다.
MK_LBUTTON  LButton만 눌려졌다.
MK_MBUTTON 중간마우스 버튼이  눌려졌다.
MK_RBUTTON  우측 마우스 버튼이  눌려졌다.
MK_SHIFT    Shift키가  눌려졌다.
Point 안에는 현재 마우스의 좌표값이 저장된다.

9. InvalidateRect() 
OnDraw() 함수를 호출하며, 리턴  값이 TRUE이면 배경화면까지 다시 출력하고 FALSE이면 나머지 부분만 
출력한다.

10. Invalidate() 
이 함수는 전체를  재표시해주고 인자가 FALSE이면 배경화면색을 제외한 나머지 부분을  재출력한다.
(OnDraw(), OnPaint())

Invalidate(FALSE);// 화면의 배경색은  그대로 놔두고 재출력
Invalidate() 또는 Invalidate(TRUE);// 화면을  배경색부터 재출력

cf) 
UpdateAllViews(NULL)	-> Document class에서 현재 윈도우에 나타나 잇는 출력 화면을 갱신
Invalidate(FALSE)		->View class에서 현재 윈도 화면과 실제 데이터 값을 비교하여 서로 
                    	"다른 부분"만을 다시 출력한다.
                        화면 전체를 갱신하는 Invalidate(TRUE)보다 실행속도가 빠르다

이녀석들은 보통 영상을 뿌려 주거나 할때 자주 사용하게되는데,,
이 녀석을 호출해 주면 View클래스의 OnDraw()를 다시 한번 호출해 주는거 같다.


11. GDI 클래스 
GDI를 지원하는 클래스는  CDC이다. 그래픽 장치를 조절하는 클래스이므로 이것을 잘 이용하면  멋진 
화면을 만들수 있다는 것이다. 또한 사용자가 그래픽 장치를 더  세밀하고 전문적으로 조절할 수 있도
록 CDC의 파생 클래스가 있다.

CDC *pDC = GetDC();// 생성
ReleaseDC(pDC);// 소멸 

소멸시키지 않을 경우 에러가  발생한다.
그러므로 반드시 소멸시켜야하지만 아래와 같은 예외는 있다.
단 OnDraw() 함수내에서는 자동으로 소멸된다. 그러나 WM_LBUTTONDBLCLK과  같은 메세지 함수를 사용할 
경우에는 소멸시켜주어야 한다.
그러나 CClientDC를 사용하면 소멸시키지 않아도 된다. 

ClientDC
윈도우의 캡션바, 외곽툴, 상태창 등을 제외한 실질 출력되는  화면을 클라이언트 영역이라고 한다. 이 
영역 외의 부분은 그래픽 출력을 할 수 없다. 

CPaintDC
WM_PAINT메시지가 발생되면 실행되는 OnPaint함수에서 사용된다. 

CWindowDC
클라이언트 영역과 윈도우의 캡션바, 외곽툴, 상태창 등을 모두  포함한다. 그러므로 윈도우 캡션바에도 
그림을 그릴 수 있다. EX) CWindowDC *pDC=GetWindowDC(); //DC 생성

GDI안에 내장 객체
점 , 선, 면, 원, 글자, 비트맵 등을 자유롭게 사용할수 있는 객체를  제공한다.

CPen선이나 도형의 테두리를 그릴 때  사용한다. 색과 굵기, 선의 종류도 지정할 수 있다. 

CBrush
면을 색칠하는 데 사용되다. 

CPalette
윈도우에서 색상은 RGB값 즉 Red, Green, Blue색의 256단계를 서로  혼합해서 사용한다. 이 클래스는 비디
오 메모리가 부족하거나 색상의 질에 의존하지 않는 프로그램을  위한 클래스라고 보아도 좋겠다. 즉 필요
한 256색을 정하여 빠레트를 만들어 사용할 수 있게 해주는  클래스이다. 

CBitmap
이미지를 출력에 있어 한 픽셀당 해당하는 컬러가 따로따로 있는데  픽셀 대 비트의 배열을 조절하는 클래
스가 바로 CBitmap 클래스이다. 

CFont
윈도우에는 많은 폰트들이 등록되어 있다. 폰트를 로드하고 출력할  때 사용하는 클래스이다. 

CRgn
다각형이나 원 등은 어떤 범위를 가지므로 이 범위를 설정하고 그  안에 색칠하고 클리핑하는데 이용하는 클래스. 

BOOL CPalette::CreatePalette(  LPLOGPALETTE 1pLogPalette);
팔레트를 만드는 함수. 

int CPalette::GetEntryCount();
현재 팔레트 클래스 안에 설정되어 있는 색의 수를 리턴. 

CDC::Framerect(CRect ,CBrush *);
외곽선만 있는 상자를 그리는 함수이다.

12. 매핑 모드 
매핑 모드를 하려면  OnPrepareDC 또는 OnDraw에서 매핑 모드를 설정해 주면 된다. 만일  MM_ANISOTROPIC으로 
설정한다면
pDC->SetMapMode(MM_ANISOTROPIC);
       MM_TEXT//(poxel)  y축 아래로 증가
       MM_LOMETRIC // y축 아래로 감소(-)
pDC->SetWindowExt(1000,1000);
pDC->SetViewportExt(1000,1000);

설정하고 화면에 출력할 때는  LPtoDp->DPtoLp해야 합니다.

13. 화면 스케일 
화면 스케일 변환 모드 

MM_ANISOTROPIC //비율이  변해도 됨.
MM_ISOTROPIC// 비율을 1:1로 유지해야 됨. 

- 스케일 변경 

pDC->SetMapMode(MM_ANISOTROPIC);
pDC->SetWindowsExt(1000,1000);
pDC->SetViewportExt(1000, -1000);// (증가, 감소) 

- 원점의 위치 변경 

CDC::SetWindowOrg();// 윈도우 자체이동
CDC::SetViewportOrg();// 화면의 보이는  좌표가 이동

14. 좌표 
윈도우 프로그래밍에서의  좌표는 장치좌표와 로직좌표가 있다. 장치 좌표는 윈도우의 그래픽  좌표를 
말하며 로직 좌표는 다른 장치(마우스)가 갖는 좌표이다. 

- 좌표계 전환 함수 

CDC::DPtoLP(CRect m_rect);
CDC::LPtoDP(CRect m_rect);

15. SetTimer 함수 
SetTimer(시계번호, 시간(msec),  NULL)과 Ontimer() 함수를 함께 사용할 수 있다. SetTimer의 정의된 
시간이되면 OnTimer() 함수가 실행된다.
시간 해제 함수는 Killtimer(시계번호)이다.

16. 커서를 만들기 
WorkSpace의 ResourceView 탭을 열고  Tree 구조에서 오른쪽 마우스 클릭을 하여 Insert... 메뉴를 선택
한다. 그러면 다이얼로그 대화 상자가 나타나고 여기서 Cursor를  선택하면 편집 창이 열리는데 여기서 
원하는 아이콘을 그린다. 다 그린 후 ID 값을 원하는 값으로 바꾸면  된다.

17.Document 클래스 얻기 
현재 View와 연결된 Document  클래스를 얻고자 할때는 아래와 같이 입력하면 된다. CMyDoc* pDoc = 
GetDocument(); 

9.	MFC 포인터
CView
GetDocument			// 다큐먼트 객체의 포인터를 얻는다
OnDraw				// 프린���를 하거나 화면에서 그린다

CDocument
GetNextView			// 뷰 리스트에서 다음뷰를 얻어온다
GetFirstView		// 뷰 리스트에서 첫번째 뷰를 얻어온다
UpdateAllViews		// 관련된 모든 뷰의 클라이언트 영역을 다시 그린다
					// 실질적으로는 각 뷰의 OnUpdate 함수 호출

CFrameWnd
GetActiveView		// 현재 사용중인 CView 객체의 포인터를 얻어온다
GetActiveDocument 	// 현재 사용중인 CDocument 객체의 포인터를 얻어온다

MFC 클래스간 통신

							[CFrameWnd]

						|		GetParentFrame	|\	|
	GetActiveDocument	|/						|	|/ GetActiveView

						
	[CDocument]			-->	GetDocument					[CView]
						<-- GetFirstViewPosition
							GetNextView

CTestApp	:	CWinApp 클래스 상속, 프로그램 초기화 클래스
CMainFrame	:	CFrameWnd 클래스 상속, 전체 윈도우 관련 클래스
CTestDoc	:	CDocument 클래스 상속, 문서 관련 클래스
CTestView	:	CView 클래스 상속, 사용자 화면 클래스
CAboutDlg	:	CDialog 클래스 상속, 도움말 대화 상자 클래스

SDI형태
1.	MainFrame 얻기
	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
2.	App 포인터 얻기
	CTestApp *pApp = (CTestApp *)AfxGetApp();
3.	프레임 윈도우에서 뷰/다큐먼트 참조
	1)	다큐먼트 포인터 얻기
		가)	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
			CTestDoc *pDoc = (CTestDoc *)pFrame->GetActiveDocument();
		나)	CTestDoc *pDoc = ((CMainFrame *)AfxGetMainWnd())->GetActiveDocument();
	2)	뷰 포인터 얻기
		가)	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
			CTestView *pView = (CTestView *)pFrame->GetActiveView();
		나)	CTestView *pView = ((CMainFrame *)AfxGetMainWnd())->GetActiveView();
4.	뷰 윈도우에서 프레임/다큐먼트 참조
	1)	다큐먼트 포인터 얻기
		CTestDoc *pDoc = (CTestDoc *)GetDocument();
	2)	자식프레임 포인터 얻기
		CMainFrame *pFrame = (CMainFrame *)GetParentFrame();
5.	다큐먼트 윈도우에서 뷰/프레임 참조
	1)	뷰 포인터 얻기
		가)	뷰가 하나인 경우
			CView *pView = m_viewList.GetHead();
		나)	뷰가 여러개인 경우
			POSITION pos = GetFirstViewPosition();		// 첫번째 뷰가 매달려 있는 포인터
			while(pos != NULL)
			{
				CView *pView = GetNextView(pos);		// 다음 뷰들의 포인터
				// to do
			}
6.	분할 뷰에서 참조
	위의 방법과 같이 포인터를 얻어 올 수 있거나 다음과 같은 방법으로 얻어 올 수 있습니다.
	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
	CTestView *pView1 = (CTestView *)pFrame->m_wndSplitter.GetPane(0,0);
	CXXXXView *pView2 = (CXXXXView *)pFrame->m_wndSplitter.GetPane(0,1);

	뷰 포인터의 좌표는 다음과 같습니다.
	---------------------------------
	| GetPane(0,0)	| GetPane(0,1)	|
	---------------------------------
	| GetPane(1,0)	| GetPane(1,1)	|
	---------------------------------
	| GetPane(2,0)	| GetPane(2,1)	|
	---------------------------------
7.	메시지를 이용한 통신
	포인터를 얻어 직접 서로의 함수를 호출할 수도 있지만 메시지를 보내어 간접적으로
	함수가 호출되도록 할 수도 있습니다.
	1)	SendMessage 함수
		메인 프레임 클래스 밖에서 메인 프레임 윈도우로 메시지를 보낼 시
		AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_OPEN);	
	2)	PostMessage 함수
		SendMessage 함수와 비슷하게 메시지를 보냅니다.
		차이점은 메시지 큐를 거치느냐 아니냐 하는 것이며
		SenMessage 함수는 메시지를 보내면 메시지 큐를 거치지 않고 직접 메시지 처리기를 호출합니다.
		따라서, 호출과 동시에 해당하는 메시지 처리기가 호출됩니다.
		반면, PostMessage 함수는 메시지를 메시지 큐에 넣어 주는 일만 합니다.
		따라서, 메시지를 보내주면 현재 수행되고 있는 함수가 완전히 끝나고, 메시지 큐에 쌓여 있던
		메시지들의 처리기가 다 수행되고 난 후에야 PostMessage 함수로 보낸 메시지의 처리기가 호출됩니다.

MDI형태
1.	ChildFrame 포인터 얻기
	1)	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
		CChildFrame *pChild = (CChildFrame *)pFram->GetActiveFrame();
	2)	CChildFrame *pChild = ((CMainFrame *)AfxGetMainWnd())->GetActiveFrame();

2.	Document 포인터 얻기
	1)	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
		CChildFrame *pChild = (CChildFrame *)pFrame->GetActiveFrame();
		CMdiTestDoc *pDoc = (CMdiTestDoc *)pChild->GetActiveDocument();
	2)	CMdiTestDoc *pDoc = (((CMainFrame *)AfxGetMainWnd())->GetActiveFrame())->GetActiveDocument();

3.	View 포인터 얻기
	1)	CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
		CChildFrame *pChild = (CChildFrame *)pFrame->GetActiveFrame();
		CMdiTestView *pView = (CMdiTestDoc *)pChild->GetActiveView();
	2)	CMdiTestView *pView = (((CMainFrame *)AfxGetMainWnd())->GetActiveFrame())->GetActiveView();

10.	public/ protect/ private
public 다 쓸수 있고 
protect 상속해서 쓸 수 있고
private 나만 쓰고

1. 접근 지정자(Java)
● public : 모든 접근을 허용합니다. 어떠한 클래스가 접근을 하든 모두 허용됩니다.
● protected : 상속받은 클래스 또는 같은 패키지에서만 접근이 가능합니다.
● default : 기본 제한자로써 아무것도 붙지 않고, 자신 클래스 내부와 같은 패키지 내에서만 접근이 가능. cf) public/protected/private 등을 기술하지 않으면 default 적용
● private : 외부에서 접근이 불가능합니다. 즉, 같은 클래스 내에서만 접근이 가능합니다.

한정자		클래스내부	동일패키지	하위클래스	그 외의 영역
public			●			●			●			●
protected		●			●			●			X 
default			●			● 			X 			X 
private			● 			X			X 			X 

접근 영역: public > protected > default > private

11.	UpdateData의 인수로 TRUE(1), FALSE(0) 이 있습니다.
	TRUE를 인수로 주면 컨트롤이 화면에 가지고있는 값이 그 변수로 들어오게됩니다.
	또, FALSE를 인수로 주면 그 변수에 있는 값이 컨트롤의 화면에 나타나게 됩니다. 

12. CPaintDC dc(this); // device context for painting
    // TODO: Add your message handler code here
    // Do not call CView::OnPaint() for painting messages
    CFont font;
    font.CreateFont( 12, // 폰트 높이를 논리적 단위로 지정, 0이면 기본 값)
                     0, // 폰트 폭지정, 0이면 폰트dml 장평이 일정하다.
                     0, // 폰트 각도를 0.1도 단위로 설정, 360분법으로 3시 방향이 0도이다.
                     0, // 글자 한 자와 X축과의 각도 지정
                     FW_NORMAL,// 폰트의 두께 0~1000사이 값으로 지정(기본400)
                     FALSE,// 기울임체를 할꺼냐?
                     FALSE, // 밑줄을 칠꺼냐?
                     0, // 관통선
                     ANSI_CHARSET, // 문자 셋을 설정, ANI_CHARSET(통상 윈도우), HANGEUL_CHARSET, OEM_CHARSET
                     OUT_DEFAULT_PRECIS,// 출력 정확도
                     CLIP_DEFAULT_PRECIS,// 클리핑 정확도
                     DEFAULT_QUALITY,// 논리적 폰트를 물리적 폰트에 얼마?? 근접시킬 것인가를 지정
                     DEFAULT_PITCH | FF_SWISS, // 폰트의 피치와그룹 설정
                     "Arial") ; // 글꼴의 이름을 나타내는 문자열을 설정


    CFont* def_font = dc.SelectObject(&font);
    dc.TextOut(5, 5, _T("Hello"), 5);
    dc.SelectObject(def_font);

    // Done with the font.  Delete the font object.
    font.DeleteObject();

13. MFC에서는 DeleteObject 사용할 필요 없다.
기본적으로 WinAPI 함수에서만 본다면 앞서 답변 다신 분의 말씀 대로 메모리 문제 때문에
반드시 삭제를 해 주어야 합니다만, 위의 예제에서 처럼 MFC 객체로서 생성한 경우에는
이 객체변수가 소멸될 때 ::DeleteObject를 호출하는 디스트럭터가 준비되어 있으므로 굳이
소스 코딩을 하지 않아도 윈도우즈 객체는 메모리에서 사라지게 돼 있습니다.
단, MFC 객체는 함수 내에서의 지역변수 처럼 생성되어야 하겠죠. 전역이나 정적으로 생성해
두면 프로그램이 끝날 때까지 살아 있게 되므로 자칫 메모리 누수가 있을 수 있습니다.

그리고 MFC를 사용하는 경우, 임의로도 물론 DeleteObject()를 호출할 수 있으나, 위의 예
처럼 ::DeleteObject(newPen) WinAPI 함수를 직접 호출하는 것 보다는 클래스 멤버 함수인
newPen.DeleteObject()를 사용하는 게 더 안전할 수 있습니다.

[WinAPI 방식]
HPEN hPen, hPenOld;  // 지역변수, 윈도우즈 객체 포인터

hPen = CreatePen(PS_SOLID, 3, RGB(255, 0, 0));  // 윈도우즈 객체 생성
hPenOld = (HPEN)SelectObject(hDC, hPen);
.
.
SelectObject(hPen);
DeleteObject(hPen);  // 함수를 빠져 나가기 전 반드시 삭제를 함

[MFC 방식]
CPen pen, *penOld;  // 지역변수, MFC 객체 생성

pen.CreatePen(PS_SOLID, 3, RGB(255, 0, 0));  // 윈도우즈 객체(pen.m_hObject) 생성
penOld = dc.SelectObject(&pen);
.
.
dc.SelectObject(penOld);	
// 함수를 빠져나갈 때 pen에 연결된 윈도우즈 객체(pen.m_hObject)는 자동으로 소멸됨


14. MFC에서 dc.SelectObject(pOldPen); 명령을 사용한 기존 사양으로 복구
DC를 이용한 그래픽그리기에서
CClientDC dc(this);

pOldPen = (CPen *) dc. SelectObject(&pen);
dc.SelectObject(pOldPen);

여기서 왜 기본값(이전값)으로 복구 해주어야 하는건가요?
어짜피 복구를 안해주어도, CClientDC 로 선언한 dc 역시 지역변수이므로 함수종료시 자동해제되어서
다음번 이벤트 발생시에 똑같은 함수가 불리어질때 초기화되어 다시 실행되니까 상관없는 것 아닌가요?
-> 1번과 연결되는 질문인데.. CClientDC dc(this) 란 문장은 시스템이 관리하는 DC를 가져온다는 것입니다.
   즉 시스템은 지역변수가 아니므로 프로그램이 종료될때까지 해제되지 않지요.
   그러므로 원상태로 복구하지 않으면 기본 펜을 그대로 쓰게 됩니다.
   조금 더 설명하면 A란 함수에서 pen을 파란색으로 한 후에 B 함수에서 그리려고 하면
   이게 파란색이 될지 까만색이 될지 전혀 예측을 할 수 없는 상황이 벌어지지요.
   그렇기 때문에 항상 기본 펜을 돌려주는 것입니다.
-> DC 와  font, brush, pen 등 object 의관계는 DC를 화가로 생각하면 이해가 쉽습니다
   현재 화가가 파란색 붓을 들고 있는데 빨간 붓으로 바꾸게 하려면
   빨간색 붓을 쥐어주면서 어떤 붓을 들고 있었다는 것을 알아놨다
   oldObject=SelectObject(hDC, object);
   빨간 붓의 사용이 끝나면 도로 파란 붓을 쥐어줘야 합니다
   SelectObject(hDC, oldObject);
   
   이 원칙은 brush 뿐만이 아니라 pen,font 등 모든 object에 해당됩니다
   즉,  DC를 사용후에는 사용전의 상태로 복구시켜놓는 것이 가장 안전한 방법입니다
   이 원칙을 지키지 않으면 시스템의 로스가 누적 될 수 있습니다

15. MFC※ 릴리즈모드로 컴파일을 하면, 변수들의 초기화는 자동으로 일어나지 않아 어떤 값이 들어있을지 예상할 수 없습니다. 또한, 구조체와 달리 클래스 선언에선 변수 초기화가 불가능합니다.
class Err_Init {
    int a = 10; // 에러 발생
};


16. MFC, ODBC를 이용해서 DRM 걸린 Excel file도 읽고&쓰기
	아래 명령을 아무 수정 없이 그대로 사용해도 Fasoo 등으로 DRM걸린 Excel 파일을
	간단하게 읽고 쓸 수 있음
	단, DRM걸린 Excel 파일은 하기 명령 실행전 Office -> Excel로 파일을 열어 놓은 상태에서 실행해야 함

ODBC를 이용해 엑셀파일 저장 & 읽기  오락실  2009/09/16 09:17

 http://blog.naver.com/zyanuz/10069587638 


 
CDatabase database;
CString sDriver = "MICROSOFT EXCEL DRIVER (*.XLS)";
CString sExcelFile = "d:\\demo.xls";
CString sSql;

TRY
{
sSql.Format("DRIVER={%s};DSN='';FIRSTROWHASNAMES=1;READONLY=FALSE;

CREATE_DB=\"%s\";DBQ=%s",sDriver, sExcelFile, sExcelFile);
if(database.OpenEx(sSql, CDatabase::noOdbcDialog) )
{
 sSql = "CREATE TABLE demo (Name TEXT, Age NUMBER)";
 database.ExecuteSQL(sSql);

 sSql = "INSERT INTO demo (Name,Age) VALUES ('Bruno Brutalinsky',45)";
 database.ExecuteSQL(sSql);

 sSql = "INSERT INTO demo (Name,Age) VALUES ('Fritz Pappenheimer',30)";
  database.ExecuteSQL(sSql);

 sSql = "INSERT INTO demo (Name,Age) VALUES ('Hella Wahnsinn',28)";
 database.ExecuteSQL(sSql);
}

database.Close();
}
CATCH_ALL(e)
{
TRACE1("Driver not installed: %s",sDriver);
}
END_CATCH_ALL;

 

//////////////////////////////////////////////////////////////////////////////
그리고 읽어오기
읽어오기는 조금 바꿔봤다..쿼리 조건에 "데모"쉬트의 "이름 정의"필드가 비어있지 않은것을 불러온다.
CDatabase database;
CString sDriver = "MICROSOFT EXCEL DRIVER (*.XLS)";
CString sExcelFile = "d:\\demo.xls";
CString sSql;

TRY
{
sSql.Format("DRIVER={%s};DSN='';FIRSTROWHASNAMES=1;READONLY=FALSE;CREATE_DB=\"%s\";DBQ=%s",
             sDriver, sExcelFile, sExcelFile);

if(database.OpenEx(sSql, CDatabase::noOdbcDialog) )
{
 sSql = "SELECT * FROM 데모 WHERE \"이름 정의\" <> NULL";
 CRecordset rs(&database);
 rs.Open(CRecordset::forwardOnly,sSql,CRecordset::readOnly);
 CString sItem1, sItem2;

 while( !rs.IsEOF() )
 {
  rs.GetFieldValue((short)0, sItem1);
  rs.GetFieldValue((short)1, sItem2);

  CString strMsg;
  strMsg.Format("Name : %s, Age : %s", sItem1, sItem2);
  MessageBox(strMsg);

  rs.MoveNext();

 }
}

database.Close();
}
CATCH_ALL(e)
{
TCHAR szCauses[255];
CString strErrorMsg;
e->GetErrorMessage(szCauses, 255);
strErrorMsg = "Msg: ";
strErrorMsg += szCauses;
MessageBox(strErrorMsg);
}
END_CATCH_ALL;

by Redef( http://www.redef.pe.kr )

[출처] ODBC를 이용해 엑셀파일 저장 & 읽기|작성자 스픽


16+1.DRM 걸린 Excel 문서 DRM 걸리지 않은 새로운 파일로 만드는 방법

1. DRM으로 암호화된 Excel 파일 중, 한개 Sheet 전체를 파일 복사해서 암호되지 않은 새로운 Excel 파일로 만드는 방법
   (본 방법은 원본 엑셀 문서의 원본서식(행/열, 높이 폭 등)을 그대로 복사해서 새로운 Excel 파일로 만드는
    방법으로 주의할 점은 원본 문서 내용이 없어져 버리기 때문에 없어져 버린 원본 문서를 저장하지 않도록 주의해야 함)
   Cf) 페이지 설정은 임의대로 설정 가능

1)	사용방법
VBA를(개발도구 Visual Basic) 사용해서 아래 내용을 DRM 해제 하고자 하는 Sheet에 복사 하고서 실행하면 됨. 


Sub test()

        Set NewBook = Workbooks.Add
            With NewBook
'                .Title = "title01"
'                .Subject = "Subject01"
                .SaveAs Filename:=ThisWorkbook.Path & "\" & "barcode.xl"
            End With
        
        Cells.Copy
        Windows("barcode.xl").Activate
        Sheets("Sheet1").Activate
        ActiveSheet.PasteSpecial
        
        Cells.Cut
        ActiveSheet.Paste
        
        With ActiveSheet.PageSetup
            .LeftMargin = Application.CentimetersToPoints(0.3)
            .RightMargin = Application.CentimetersToPoints(0.8)
            .TopMargin = Application.CentimetersToPoints(0.3)
            .BottomMargin = Application.CentimetersToPoints(0)
            .HeaderMargin = Application.CentimetersToPoints(0)
            .FooterMargin = Application.CentimetersToPoints(0)
            .Orientation = xlLandscape  '용지방향 가로, 세로는 xlPortrait
        End With
        
'       Windows("c:\barcode.xls").Activate
        ActiveWorkbook.Save
        ActiveWindow.Close

End Sub


16+2.	3시간 주기로 DRM 걸려 있지 않은 파일도 DRM 걸리게 하는 파일
		C:\Program Files\Fasoo DRM\Utility\Batch Encryption\PackagerBatch.exe가 본 파일로
		이 파일이 실행하면서 검정색 Terminal 창이 뜨면서 DRM 걸려 있지 않던 *.BMP 파일 등도 DRM 걸리게 해 버림

16+3.	OneDrive 를 사용해서 저장 & 파일열기
		1)	OneDrive 설치 & 개정 등록 이후(Microsoft)
		2)	부팅이후 OneDrive를 실행시키지 않은 상황에서
		3)	클라우디움서버에서 해당 Office 파일 열기 -> 다름이름으로 저장 -> OneDrive 선택 & 저장
		4)	본 상황에서 Office program -> 파일열기 -> OneDrive 선택 해서 파일 열 수 있음
		cf)	이 경우에만 아래 로그파일에 별다른 이력이 남지 않음
		cf)	윈도우탐색기에서 오피스 파일 여는 경우는 아래 로그파일에 이력이 저장됨
			C:\Cyberdigm\DestinyDrive\Log\PSERVICE\*.log
			C:\Cyberdigm\DestinyDrive\Log\Agent\*.log

16+4.	클라우디움
		1)	폴더복사 방법
			워드프로그램 실행 -> 열기 -> 찾아보기 -> 클라우디움 네트워크 드라이브 선택 -> 복사를 원하는 폴더 복사 -> 복사할 위치 선택 후 붙여넣기
		2)	클라우디움 로그 파일 저장 정보
			거의 모든 사항이 아래 파일에 저장됨(클라아우디움 서버가 아닌 윈도우창에서 어떤 파일을 어떤 프로그램으로 열어본 정보 등)
			C:\Cyberdigm\DestinyDrive\Log\PSERVICE\*.log
			C:\Cyberdigm\DestinyDrive\Log\Agent\*.log




17. :: -> win32 API 함수를 사용할 때 사용
	ex) ::Sleep(5000);


18. MFC 팁2 
수행 시간재기

CTime startTime = CTime::GetCurrentTime();
// ... perform time-consuming task ...
for(UINT a=0;a<=1000000;a++)
for(UINT b=0;b<=1000;b++);

CTime endtime = CTime::GetCurrentTime();

CTimeSpan elapsedTime = endtime - startTime;

////////////////////////

DWORD end=GetTickCount();
GetTickCount()은 시스템이 시작한 시각부터 밀리센컨 단위로
리턴
1000=1초


===============================================

팝업 메뉴 

CMenu menu, *pMenu;

menu.LoadMenu(IDR_POPUP); //리소스 뷰에서 ID IDR_POPUP 메뉴
를 로드한다
pMenu=menu.GetSubMenu(0); //ID IDR_POPUP 메뉴의 첫번째 서브
메뉴를 로드한다
ASSERT( pMenu);
pMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON,pt.x,
pt.y,this);//팝업메뉴 보이기


=================================================

[MFC] assert 설명
assert 함수를 사용하시려구요? assert 함수는 일단 assert.h 해더 파일을 포함해야지만 사용할수 
있습니다. 인자로 넘어가는 수식이 거짓(0) 인경우에 오류 상자를 띄우고 종료할 것인지를 
사용자에게 묻습니다. 따라서 아래와 같은 경우에는 아무런 문제가 생기지 않구요... 

int count = 0; 
assert(count == 0); // count가 0 이므로 수식이 참이다. 따라서 오류상자가 나오지 않는다. 

아래와 같은 경우에는 "Debug Error" 하면서 대화상자가 나오고 계속 진행할 것인지 여부를 물어봅니다. 

int count = 0; 
assert(count != 0); // 수식이 거짓이다. 

그럼, 즐거운 하루되세요~! 


printf,sprintf 표기자리수

sprintf(x,"%05.1f",float); 일경우
소수점 포함 5자리보장하고 소수점 이하는 한자리 표기 보장

34 --> 034.0
34.5 --> 034.5


===============================================



시스템 시간 알아오기

CTime time=CTime::GetCurrentTime();
CString text;
text.Format("%02d%02d%02d%d%02d%02d%02d",time.GetYear()-
2000, time.GetMonth(), time.GetDay(),time.GetDayOfWeek()-
1, time.GetHour(),time.GetMinute(), time.GetSecond());



================================================



OK버튼,CANCEL 버튼 없애기 등

CWnd *pWnd = GetDlgItem( IDOK );
pWnd->ShowWindow( FALSE );

pWnd = GetDlgItem( IDCANCEL );
pWnd->ShowWindow( FALSE );

pWnd = GetDlgItem( ID_APPLY_NOW ); //적용버튼
pWnd->ShowWindow( FALSE );



====================================================

CString 형 형변환

LPSTR pszText에 CString str을 저장(가르키고)하고 싶을경우

LPSTR=chat* 이다.

포인터, 즉 문자열 저장공간을 가르킨다

CString은 클래스 이므로 약간의 형변환이 필요하다.

일단 LPCTSTR 연산자로 const char* 형으로 변환후
LPSTR 으로 캐스팅한다.

즉 pszText=(LPSTR)(LPCTSTR)str


====================================================

리스트컨트롤(CListCtrl) 확장스타일



ListView_SetExtendedListViewStyle
(m_ListControl.m_hWnd,LVS_EX_FULLROWSELECT);
마우스로 항목선택시 그 행 전부전택


GetSelectionMark()
현재 선택된행번호 리턴


=====================================================

멀티스레드에서 만든 윈도콜시 에러



메인 스레드에서 만든 윈도의 핸들(정확히 핸들을 가지고있는
캡술화된 객체)은 당연 메인 스레드가 가지고 있다.

이 윈도우를 다른 쓰레드에서 사용시 객체로 접근하면 ASSERT
에 잡힌다.

객체보다는 핸들로 접근하라고 권고함
(FromHandle)


Note: if either of the above asserts fire and you are
writing a multithreaded application,it is likely that
you have passed a C++ object from one thread to other
and have used that object in a way that was not
intended.
(only simple inline wrapper functions should be used)

In general, CWnd objects should be passed by HWND
from
one thread to another. The receiving
thread can wrap
the HWND with a CWnd object by using
CWnd::FromHandle.

It is dangerous to pass C++ objects
from one thread to
another, unless the objects are
designed to be used in
such a manner.


ActiveX에서 파일 소켓 UI스레드 쓰실수있습니다.
모두 사용가능하다는 말이죠.
단, 각 파일,소켓,UI스레드들이 MFC Object인경우 (CFile,
CXXSocket) 라면
해당 Object을 생성한 스레드에서만 되도록 사용하도록 하세요.
Object 포인터만 스레드를 넘어가서 사용하다보면 Window의 경
우 MFC Thread 구조체내에
핸들맵에 없어 핸들을 찾지 못하거나 소켓역시 그럴수 있죠.
그럼 핸들이 없다고 뻑나죠.
만일 소켓을 엑티브X의 UI스레드에서 하고 싶으시면 아래처럼
해보세요.
UI스레드를 엑티브x에서 생성합니다.
UI스레드의 OnIniInstance부에서 AfxSockInit()해줍시다.
CSocket등의 MFC소켓을 UI스레드에서 생성하여 UI스레드에서만
억세스하도록합시다.
엑티브X(메인스레드)와 UI스레드와의 통신이 필요할시엔
PostThreadMessage 또는
윈도우있는 엑티브x에게는 PostMessage를 이용합시다.


===================================================



CConttolBar 상속받기

CConttolBar를 상속받아 자신만의 다이알로그 바를 만들려면
m_dwStyle 데이타 멤버를 셋해야한다
애는 Create를 오버라이드해서 셋한다

관련문서 MSDN 토픽 TN031


// CMyControlBar is derived from CControlBar
BOOL CMyControlBar::Create( CWnd* pParentWnd, DWORD
dwStyle, UINT nID )
{
m_dwStyle = dwStyle;

.
.
.
}


====================================================



static 멤버변수



class CMyClass : public CObject
{
public:
static char lpszClassName[];//클래스의 이름은 메모리에
한 번만 할당하면 된다.
virtual char* GetClassName() const
{//베이스 클래스의GetClassName
을오버라이드한다.
return lpszClassName;//정적 멤버 변수를 리턴한다.
}
};//class CMyClass


char CMyClass::lpszClassName[]="CMyClass";//정적 변수는 반
드시 클래스의 외부에서 초기화되어야 한다.


==================================================



WM_SETCURSOR 메시지,핸들러



WM_SETCURSOR 메시지는 마우스 인풋없이 CWnd 객체위를 돌아다
닐때 발생(WM_MOUSEMOVE와 비슷,WM_SETCURSOR는 마우스 모양바
꾸기용으로 초점이 있음)

이 메시지 핸들러는 OnSetCursor()이고
이후 의 메시지 핸들러에서 메시지 작업이 더 필요없으면
TRUE리턴 다른 메시지처리작업이 잇으면 FASLE를 리턴한다

CRectTracker rect;

rect.m_rect.SetRect(100,100,200,200);
rect.m_nStyle = CRectTracker::resizeOutside;

rect.Draw(pWnd->GetDC());

//rect영역안이면 마우스 모양바꾼다 현재위치(바꿀모양)은
nHitTest에 있다
if(rect.SetCursor(pWnd,nHitTest))
return TRUE;

return FALSE;




====================================================



툴바 붙이기



//메인 프레임 툴바
m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
EnableDocking(CBRS_ALIGN_ANY);
DockControlBar(&m_wndToolBar);


//내가 만든 툴바
m_wndToolBar1.EnableDocking(CBRS_ALIGN_ANY);

//초기에 왼쪽에 붙게 한다
DockControlBar(&m_wndToolBar1,AFX_IDW_DOCKBAR_LEFT);




==================================================



좌표계,논리적좌표,물리적좌표



●논리적 좌표를 물리적 좌표로 매핑시 비율지정시

●SetViewportExt() 물리적인 범위를 지정하는 함수
ex) pDC->SetViewportExt(rect.Width(),rect.Height())
클라이언트 영역의 폭과 높이를 물리적 좌표범위로 설정

●SetWindowExt() 논리적인 범위를 지정하는 함수
ex) pDC->SetWindowExt(160,100)
폭 160, 높이 100 인 논리적 좌표범위 설정

●Window 란 단어에 논리적좌표 의미 내포
Viewport란 단어에 물리적좌표 의미 내포

●기본 맵핑모드 MM_TEXT : 장치좌표계와 논리좌표계 매핑비율
1:1

●CDC 함수들은 대부분 논리적인 값을 파라미터로 받는다

●원점(0,0) 변경함수 SetWindowOrg(),SetViewportOrg()

●DPtoLP : 장치좌표 -> 논리좌표
●LPtoDP : 논리좌표 -> 장치좌표




=================================================



이미지 더블 버퍼링 예제



CRect ClientRect;
GetClientRect(&ClientRect);
CBitmap bmpMem,*old;
CDC mDC;

int Width = ClientRect.Width
int Height = ClientRect.Height

bmpMem.CreateCompatibleBitmap(pDC, Width,
Height); //pDC와 호환되는 비트맵 생성

mDC.CreateCompatibleDC(pDC); //pDC와 호환되는 메모
리 DC생성 (현재는 시커먼 상태)

old = mDC.SelectObject(&bmpMem); //비트맵을 펜으
로 설정
mDC.Rectangle(0,0,Width, Height); //현재 펜
으로 사각형을 그리고 안은 현재 브러쉬색으로 채움

mDC.SetBkMode(TRANSPARENT); //백 그라운드 모드 설
정

//TRANSPARENT -> 이전 배경을 지우지마라


mDC.SetMapMode(MM_ISOTROPIC);
mDC.SetWindowExt(ClientRect.Width
(),ClientRect.Height()); // 논리적 x,y 좌표계를 클라이언트
크기로
mDC.SetViewportExt(ClientRect.Width
(),ClientRect.Height());//물리적 좌표계를



///도형 그리기
POSITION pos = pDoc->m_ObList.GetHeadPosition();
CDiagram* pDiagram;


while(pos)
{

pDiagram = (CDiagram*) pDoc-
>m_ObList.GetNext(pos);
//pDiagram->Draw(pDC);
pDiagram->Draw(&mDC);

}

//선택된 도형 그리기
pos = m_Arrow.m_Selected.GetHeadPosition();
while(pos)
{
CMyRectTracker* t;
t = (CMyRectTracker*)
m_Arrow.m_Selected.GetNext(pos);
t->m_rect=CRect(t->m_pDiagram->LeftTop,t-
>m_pDiagram->RightBottom);
t-
>m_nStyle=CRectTracker::hatchedBorder|CRectTracker::resizeO
utside;

//CRectTracker t(CRect(pDiagram-
>LeftTop,pDiagram-
>RightBottom),CRectTracker::resizeOutside );
//t->Draw(pDC);
t->Draw(&mDC);

}




mDC.SetMapMode(MM_TEXT);
pDC->BitBlt(0, 0, Width, Height, &mDC, 0, 0,
SRCCOPY);

mDC.SelectObject(old);
bmpMem.DeleteObject();




================================================



좀 덜 깜박이는 RedrawWindow() 인자



그냥 RedrawWindow() 사용시 보다 좀 덜 깜박임
RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);




================================================



점선 그리기



◆ CPaintDC dc(this);
CPen Pen, *pOldPen;
Pen.CreatePen(PS_DOT, 1, RGB(0,0,0));
pOldPen = dc.SelectObject(&Pen);
dc.MoveTo(0,0);
dc.LineTo(100,100);
dc.SelectObject(pOldPen);
Pen.DeleteObject();

◆1.OnLButtonDown에서 최초 point를 얻는다..
2.OnMouseMove에서 변환되는 point를 계속적으로 얻는다.
(결국은 최종 point를 저장하면 되니까..)

SetRop2(R2_NOT);으로 그리기 모드 변경...
CPen pen(PS_DOT,......);으로 선모양을 점선으로 변경
선을 두 번 그려준다.
(R2_NOT 모드이므로, 두번 그리면 지웠다 그렸다 하는
작업을 반복하죠..)

3.OnLButtonUp에서 SetRop2(R2_NOT)해 준다..
(OnMouseMove에서 마지막에 그려진 점선을 지우기 위해)
CPen pen(PS_DOT..,...);
Rectangle함수로 최초point부터 최후 point까지 한번
다시 그려준다. (역시 마지막 점선을 지위기 위해)

최초 point와 최후 point를 가지고 CRect,
혹은 CRgn 객체를 하나 만든다..

◆ CDC:DrawDragRect 함수 사용




===================================================



 GetDC(),CClientDC()



GetDC()의 경우에는 반드시 RealseDC(pDC)를 해주어야한다
CClientDC의 경우에는 자동으로 릴리즈해준다.




===================================================



MFC 프로그램시 참고할만한 것



MFC 프로그래밍에서 거의 100% 들어맞는 원칙이 하나 있습니다.

비슷한 기능을 하는 함수가 C/C++ 런타임 라이브러리 API 버전
이 있고 앞에 Afx가 붙은 MFC 버전이 있다면 무조건 Afx가 붙
은 버전을 써야 한다는 겁니다.

예를 들어, LoadLibrary 같은 것도 MFC에선 AfxLoadLibrary를
써야 합니다.



이런 얘기를 꺼내는 건 다름이 아니라

많은 분들이 MFC에서 _beginthread나 CreateThread를 이용해서
스레드를 만든 다음

그 스레드에서 CWinApp, CView 등의 인스턴스에 액세스하면서
에러를 경험하시는 것 같아서 입니다.



(1) MFC 오브젝트는 '스레드 안전'하지 않습니다.

동일한 오브젝트를 두 스레드에서 동시에 사용하려고 하면 맛
갈 수 있습니다



(2) MFC CWinThread나 AfxBeginThread를 이용하지 않고,
_beginthread나 CreateThread로 만든 스레드에서

MFC 오브젝트에 액세스하면 맛 갈 수 있습니다.



(3) MFC 스레드(보조 스레드)에서 다른 스레드로 생성된 CWnd
계열 오브젝트를 사용하면 생각대로 결과가 안 나올 수 있습니
다.

MFC 오브젝트는 실제 HWND 같은 핸들을 감싸는 C++ 랩퍼 오브젝
트인데, 각각의 랩퍼 오브젝트에 대응되는 실제 HWND 핸들이 무
엇인지 알려주는 정보가 스레드마다 개별적으로 사용되는 스레
드 로컬 스토리지에 저장되기 때문입니다.

즉 같은 CWnd 오브젝트(같은 메모리 주소)에 액세스하더라도
그 오브젝트가 사용하는 핸들(HWND)가 다를 수 있다는 겁니다.



그러니 보조 스레드에서 뭔가 UI와 관련된 조작을 할 때 직접
하려고 하지 말고

마치 2개의 프로세스가 통신하는 것처럼 ::PostMessage 같은 방
법을 이용하는 것이 좋습니다.

또한, 예를 들어, 다른 스레드로 CWnd 오브젝트를 넘길 때 오브
젝트를 직접 넘기지 말고 HWND로 넘긴 다음 받은 스레드에서
FromHandle 메소드를 써서 다시 CWnd를 사용하는 식으로 해야
합니다.



이상의 내용은, 왠만한 Visual C++ 프로그래밍 책에는 다 나올
겁니다.

http://msdn.microsoft.com/library/default.asp?
url=/library/en-
us/vccore/html/_core_multithreading_with_c.2b2b_.and_mfc.as
p

http://msdn.microsoft.com/library/default.asp?
url=/library/en-
us/vccore/html/_core_Multithreading.3a_.Programming_Tips.as
p

이 두 개의 글을 대충 정리한 것입니다.




=====================================================



Serialize 순서



1. Serialize객체는 CObject에서 상속받아야한다.
2. Serialize할 객체의
해더에는 DECLARE_SERIAL(클래스명)
소스에는 IMPLEMENT_SERIAL(클래스명,부모클래스명,버전정
보)
를 추가한다
ex) DECLARE_SERIAL(CDiagram )
IMPLEMENT_SERIAL( CDiagram, CObject,
VERSIONABLE_SCHEMA | 2 )

3.Serialize 할객체에 virtual void Serialize(CArchive& ar);
함수를 오버라이드한다.
이함수안에서 CObject::Serialize(ar); 작업을 해주어야한다.




====================================================



MFC 매크로



ifdef _DEBUG //디버그 모드일때 만 이
루틴을 탄다

#define new DEBUG_NEW //메모리 릭 나는것을 찾
는데 필요한거죵

#undef THIS_FILE //THIS_FILE 선언
된것을 없앤다.

static char THIS_FILE[] = __FILE__;

#endif


◇_T()매크로

Generic-Text
Data Type Name SBCS (_UNICODE,
_MBCS Not
Defined)
_MBCS
Defined
_UNICODE
Defined
_TCHAR char char wchar_t
_TINT int int wint_t
_TSCHAR signed char signed char wchar_t
_TUCHAR unsigned char unsigned char wchar_t
_TXCHAR char unsigned char wchar_t
_T or _TEXT No effect (removed by preprocessor) No effect
(removed by preprocessor) L (converts following character
or string to its Unicode counterpart)



위에서 보시는 것과 같이 SBCS(Single Byte Character Set: 영
어), MBCS(Multi Byte Character Set: 한글), UNICODE,

에 따라 서로 다른 유형이 사용됩니다.

그러나 일반 유형(Generic Type)을 사용하시면, 컴파일러가 자동
으로 상황에 맞는 유형으로

바꾸어서 사용합니다.

즉, 문자 유형에 상관없는 프로그램을 만들 수 있는 것입니다.




=====================================================



캐스팅



int) 와 같은 casting은 C type casting이고
static_cast 와 같은 casting은 c++에서 새로 도입된
casting 방법입니다.

몇 가지에 대해 테스트해보시면 아시겠지만
static_cast가 훨씬 더 엄격하게 type checking을 합니다.
따라서 C type casting 보다 실수를 줄일 수 있는 가능성이 많
죠.

만약 static_cast로 해서 안되는 것은 reinterpret_cast로 하시
면 됩니다만, 제대로 된 C++ program이라면 reinterpret_cast나
C type casting이 별로 없어야 합니다.
왜냐 하면 C++은 type checking이 엄격한 언어이고, C에서 부득
이하게 void pointer 등을 사용하여 type safety를 잃어버리는
코딩 방법을 여러 OOP 방법들이 대체할 수 있기 때문입니다.
////////////////////////////////////////////////////

기존의 괄호를 사용하여 캐스팅하는 C언어 방식의 캐스트의 문제
점은... 이게 어떤 의도를 가지고 캐스트 되는지
컴파일러가 알지 못했다는 것입니다.

이러한 연유로 하여 C++ 표준에서는 static_cast 말고도
const_cast, dynamic_cast, reinterpret_cast등으로
세분화 하였습니다.

이 4가지의 캐스트 오퍼레이터들은 각각 자신만의 특징을 가지
고 있답니다.
따라서 이 캐스트를 사용하면 컴파일러에서는 사용자가 어떠한
목적으로 캐스트를 시도하였는지 알 수 있기 때문에
실패하더라도 더 자세한 에러 정보를 사용자에게 줄 수 있는거지
요..

각각의 캐스팅 연산자들의 차이점은 검색을 해보시면 할 수 있으
실 거구요...

기본적으로 static_cast는 C언어에서 가장 유용하게 사용되는
cast의미와 동일합니다.
////////////////////////////////////////////////////////
BYTE Btemp = (BYTE)temp;
보다는
BYTE Btemp = static_cast(temp);
를 추천하고 싶습니다.
C++에는 static_cast, dynamic_cast, const_cast,
reinterpret_cast가 추가되었고
C style의 cast 보다는 위 4개의 keyword를 사용한 casting을 대
부분의 C++ 책에서 추천
하고 있습니다.
///////////////////////////////////////////

기존의 C에 있던 cast 연산에는 몇가지 문제가 있었습니다.
예를 들어 다음과 같은 문장을 보면

Data* data = (Data*)pSomething;

여기서 쓰인 cast가 무엇인지 알수 있는 방법이 없습니다. 코드
를 보는 사람뿐 아니
라 컴파일러도 알수 없겠죠. 따라서 컴파일러는 무조건 casting
을 하게 됩니다. 또
한 후에 아주 긴 코드상에서 cast한 부분만을 보고자 할때도 검
색어로 괄호를 넣을수
도 없고 난감하지요.

이러한 몇가지 점을 보완하고 개발자들에게 여러가지 편리함을
주고자 C++에서는 네
가지 cast operator가 정의되었습니다. static_cast,
dynamic_cast,
const_cast, reinterpret_cast가 그것입니다.

간단히 설명을 하자면 다음과 같습니다.

static_cast - 기본적으로 기존 C에서 casting하던 것과 같은 역
할을 합니다. 따
라서 기존의 C의 casting으로 안되던 것들은 이것으로도 되지 않
습니다. 또한
const형을 non-const형으로 cast하는 것 역시 이 연산자로 할수
없습니다.

const_cast - const형 데이터를 non-const형으로 바꾸거나
volatile형을 non-
volatile형으로 cast해 줍니다. 다른 용도로는 사용할 수 없습니
다.

dynamic_cast - class들의 inheritance hierachy들 사이를 올바
르게 cast하는
데 사용됩니다. 다른 용도로는 사용할수 없습니다. 이 기능은
RTTI(Run-time
Type Information)기능을 참고하시면 도움이 되실 겁니다. 참고
로 이 연산자는 올
바로 cast되지 않는 경우에는 null을 return하기 때문에 매우 유
용하게 사용됩니
다.

reinterpret_cast - 이 cast는 보통 구현에 따라 다르게 작업을
수행한다고 되어
있습니다. 따라서 이 연산자는 다른 컴파일러에 porting이 어렵
다고 되어 있습니
다. 보통 위의 세가지 cast로 불가능한 casting을 할때 사용되
며 서로 다른 프로토
타입을 가진 함수 포인터를 casting하는데 주로 사용이 됩니다.

다시 위의 예로 돌아가면

Data* data = const_cast< Data*>(pSomething);
Data* data = dynamic_cast< Data*>(pSomething);
Data* data = static_cast< Data*>(pSomething);

와 같은 문장이 있다면 왜 casting이 필요했는지를 쉽게 이 부분
의 코드만 봐도 확인
이 되겠지요. 물론 컴파일러도 좀더 효율적이고 정확하게 컴파일
이 가능할테고요.

마지막으로 C++에 관련된 책중에 여러가지 item으로 구성되어 있
어서 재밌고 유용하
게 읽을수 있는 책으로

Effective C++, by Scott Meyers, Addison Wesley
More Effective C++, by Scott Meyers, Addison Wesley

가 있습니다. 꼭 한번 읽어 보세요. 그냥 C++책이나 object-
oriented 관련 서적
을 읽는 것과는 다른 맛(?)이 있습니다.




====================================================



SetClassLong()



The WNDCLASSEX structure contains window class information

이정보를 바꾸는것이 SetClassLong()임
즉 마우스커서,아이콘,스타일등을 바꿀수있다




=================================================



추상클래스,인터페이스



추상클래스
공통된 구현에 관한 모든것
메소드들은 구현이 된것도있고 아닌것도있다
추상클래스의 인스탄스가 만들어져서는 안된다
공통된구현을 제공하기위해 존재하며, 파생되어 사용되어야 한
다

인터페이스
사용법에 관한 모든것
모든메소드의 구현은 하지않는다


=================================================



핸들과 포인터의 차이점...



정리하면요,



핸들(handle)이란 구체적인 어떤 대상에 붙여진 번호이며 문법
적으로는 32비트의 부호없는 정수값입니다.

윈도우즈 에서는 프로세스에서 생성되어지는 모든 오브젝트에
핸들값을 생성해 할당합니다.

이렇게 핸들을 사용하는 이유는 오브젝트들 사이의 구분을 하는
데 문자열보다 정수를 사용하는 것이 훨씬 더 속도가 빠르기 때
문이랍니다.



그리고 특징(?)들을 살펴보면요,



핸들은 부호없는 정수값이며 대부분의 경우 32비트값이고, 핸들
은 운영체제가 발급해 주며,

같은 종류의 핸들끼리는 절대로 중복된 값을 가지지 않습니다.
이 말은 다른종류의 핸들들 끼리는 같은값을 가질 수 도 있다
는 얘기겠죠?

그리고 어제 얘기했던대로, 핸들은 별다른 의미를 부여하지 않
는 단순히 오브젝트들을 식별하기위한 32bit 부호없는 정수형
의 숫자 아이디라고 생각하면

쉽지 않을까 생각이 되네요. 그리고 윈도우즈에서 핸들을 저장
하는 변수에는 접두어로 핸들임을 의미하는 h를 붙인다고 합니
다.

우리가 많이 봤던 HWND, HPEN, HBRUSH, HDC 등이 모두 핸들을
담기위한 데이터형인데요,

이렇게 핸들이 종류별로 되어 있기때문에, 다른 핸들끼리는 같
은값을 가져도 될거 같습니다.



윈도우즈 내부적으로는 '핸들'들을 테이블이나 맵의 형태로 해
서 관리할 것 같구요,

운영체제가 발급을 해 주기 때문에 운영체제 전체에 대해
unique할것 같네요.




================================================



this 포인터



클래스 내부에서 this키워드는 메소드를 호출하는 클래스의 인
스탄스를 가리킨다.




==================================================



 윈도우 ODBC설정없이 소스에서 설정하기



보통 윈도우 ODBC를 설정했을시 방법
return _T("ODBC;DSN=Video_Driver");


2.윈도우 ODBC설정없이 소스에서 설정하기..
2-1. FileDSN을 사용.
(윈도우의 ODBC설정시 "FILE DSN"을 선택하여 DSN화일
을 만든후 그화일을 사용한다.
return _T
("ODBC;FileDSN=C:\\video_job\\video.dsn");
2-2. 그냥 소스에서 모든걸 설정하기.
(위의 FileDSN을 만든후 생성된 DSN화일을 참고로 한
다)
return _T("ODBC;DRIVER={Microsoft Access Driver
(*.mdb)};DBQ=C:\\video_job\\Video.mdb");

**연결할 환경이 자주 바뀐다면 2-1이 좋겠고,보완을 위한다면
2-2의 방법이 좋겠죠!!


===================================================



레지스터 값얻어 오기



GetRegValue
(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\WindowsNT\\Curren
tVersion\\NetworkCards\\","Description", sValue,x);



위에처럼 함수를 호출하면 하위디렉토리의 특정값을 가지고 올
수 있습니다



=====================================================



MFC RecordSet에서 ODBC로 sql문 사용법 



CDatabase db;
CRecordset pRecset;


db.Open( NULL, FALSE, FALSE, _T( "ODBC;DRIVER=
{Microsoft Access Driver
(*.mdb)};DBQ=D:\\PROJ\\BMServer\\DBDll\\DB.mdb;PWD=KY" ));

pRecset.m_pDatabase = &db;


pRecset.Open(CRecordset::forwardOnly, _T("SELECT
COUNT(*) FROM PROJECT_MANAGE"));


CString cccc;

while(!pRecset.IsEOF())
{
pRecset.GetFieldValue((short)0, cccc);
//pRecset.GetFieldValue((short)1), lszValue2);
//pRecset.GetFieldValue((short)2), lszValue3);

//이렇게 한 행애 대한 값들을 가져오신다음에

pRecset.MoveNext();


}


===================================================



멀티스레드 코딩시 알아야할 점



먼저 커널 오브젝트라는 걸 알아야 하는데..

윈도우즈를 이루는 구성요소들 중 window, file, socket,
thread, process, event 등등을 커널 오브젝트라고 합니다.

이 오브젝트를 조작하기위해 필요한것이 핸들입니다..

커널오브젝트들은 특성상 thread에 종속적이어서 한 스레드에
서 생성된 오브젝트는 다른 스레드에서

접근할 수 없습니다.. 그러므로 위의 코드에서 다른 스레드에
서 생성된 윈도우 핸들은 사용할수 없는 거죠..



이런점을 고려 하시면 조금 도움이 되실겁니다..

참조서적을 소개해드리자면 advanced windowNT라는 책을 추천합
니다..(지금도 나올지는...)

=================================================
window , file, socket , thread, process, event 라고 하시는
데..

그건 쓰레드 종속적이지 않습니다.

프로세스 종속적이라고 하면..맞습니다만..쓰레드는 좀 이상합
니다.

나머지 모두 쓰레드 범위를 넘어서 쓸 수 있는 것들입니다.

아 물론 window 의 경우 MFC 라면...그 쓰레드에 종속적이고

핸들만을 다루는 API 라던지 MFC 라도 그 멤버들은

쓰레드를 넘겨서 처리해도 무방합니다.




========================================================



COM 의 실용성



.NET을 COM 대신 공부하신다면 할말이 없습니다.



하지만, C++로 DLL을 아무리 잘 만든다고 하더라도 COM이 지원
해주는 서비스를 따라갈 순 없습니다.

이것은 .NET 플밍을 하면서 직접 .NET 프레임웍을 만들겠다는
무모한 도전으로밖엔 보이지 않는군요.



몇몇 사람들은 COM을 만들어 사용하는 가장 큰 목적은 언어와
무관한 이진 레벨에서의 재활용이나 컴포넌트화라는 수준에서
말하는 분들도 계십니다. 하지만, 이런 것들이 프로그래머에게
와닿기에는 너무나 부족한 부분이 많습니다. 그냥 C++로 해진
님 말씀대로 dll을 잘~~~ 만들면 되니까요...



그럼 왜 COM을 해야 하는지 말씀을 드려보겠습니다.



가장 큰 이유는 DCOM이나 COM+같은 서비스를 사용하기 위해서입
니다.

클라이언트와 서버가 통신하기 위해 특정 사용자 프로토콜을 이
용해 서버에 작업을 요청하고 응답을 받고 하는 작업이 만만하
던가요?

클라이언트에서 서버의 함수를 바로 호출할 수 있다면 얼마나
편할지 생각해 보셨나요?



간단한 예로,

클라이언트와 원격지에 있는 서버와 통신하는 것을 비교해 보
죠.

클라이언트와 서버에서 TCP/IP로 소켓을 생성하고 연결합니다.
그리고 클라이언트는 특정 작업을 위해 메세지를 서버에게 보내
고 서버는 그 메세지를 받으면 A() 라는 함수를 호출하여 작업
을 처리하고 클라이언트에게 작업완료라는 메세지를 다시 보냅
니다. 그럼 클라이언트는 그 메세지에 따라서 다음 작업을 하거
나 잘못됐다면 다시 요청하는 엄청난 노가다를 해야 합니다.

하지만, COM에서는 원격지 서버의 A()를 직접 자신이 만든 함수
를 호출하듯이 A()를 호출합니다.



클라이언트에서는



if(서버인터페이스->A())

{

작업처리 완료이니 다음작업..

}

else

{

}


정말 간단하죠? 소켓을 만들필요도 없고 자신의 프로토콜을 만
들어 메세지를 주고 받을 필요도 없습니다. 그냥 바로 서버의
메서드를 호출하시면 됩니다. 그리고 수 많은 클라이언트가 동
시에 서버에 접근하는 처리방법등...



이것뿐만이 아닙니다. 최고급 프로그래머들이 코드레벨에서 엄
청난 시간을 투자하여 만들어야 하는 트랜젝션 처리는 어떻게
할까요?

그리고 동기화와 디버깅... 큐잉서비스... 이밖에도 보안 서비
스나 이벤트 서비스, 로드 벨런싱등등은... 생각만해도 끔찍하
기 짝이없는 많은 작업들이 이미 서비스 레벨에서(.NET 프레임
웍이 지원하는 것과 비슷한) 지원해준다는데 이걸 직접 만드시
겠다면...



글쎄요. 제생각은 평생해도 힘들듯 싶습니다....





너무 극단적인지는 몰라도, 이것이 실상입니다....

이정도면 COM 또는 .NET으로 짜야 할 이유는 충분하리라 생각됩
니다. 요즘 어플리케이션으로 돈버는 시대는 아니죠... 일반 데
스크탑에서 혼자 돌아가는 프로그램은 더이상 비전이 없어 보입
니다.



다시한번 COM을 되돌아 보시기 바랍니다. 아니면 .NET 을 보시
던가...그것도 아니면 일반 어플리케이션을 고집하시던가....



딴지 환영합니다.~~~~~~~~~~~~~~~~~


==================================================



COM 의 실용성



DLL도 별로 안 만들어 보신 듯 하군요. DLL로 될거라고 상상하
시다니...

한 몇년 공부와 경험이 쌓이시면 COM이 필요악임을 절절히 느끼
게 되면서

.NET이 얼마나 구세주스러운 기술인지 느끼게 되리라 감히 말하
고 싶네요.



C DLL은 정말 쉽죠. 단순 무식 그자체..

C++ DLL은 졸라 복잡합니다.

API/MFC, MFC인 경우 표준dll/확장dll, dll에서 사용한 런타임
라이브러리의 종류/버전, 유니코드 사용 여부,

사용한 C++ 컴파일러 종류에 따라 달라지는 name mangling...

여기다가 만약 한 dll에서 메모리를 할당한 포인터를 다른 dll
에서 해제할 수 있게 한다.. 그러면 거의 죽음입니다.



그냥 C DLL을 쓰면 되지 않냐??? 라고 물으신다면.. 그러시라
고 답해 드려야죠. 그냥 편하게 ANSI C로 하면 이런 고생 안해
도 됩니다.

하지만 대표적인 초대형 오픈소스 프로젝트인 넷스케이프,
ACE, 오픈오피스 모두 COM과 유사한 형태의 자체적인 컴포넌트
오브젝트 모델을 만들어서 쓰고 있습니다.

즉, 수백만 라인 규모의 대형 프로젝트에서는 COM 같은 컴포넌
트 오브젝트 모델이 필수라는 얘깁니다.



10명이 각각 개발한 10개의 dll이 서로 연동한다고 생각해보세
요.

개발 초기 단계에 정확하게 스펙을 잡지 않는 이상 거의 죽음이
고.. 아마 코드 엄청나게 수정해야 겨우 붙을 겁니다.



COM으로 만들었다?? 그냥 붙습니다. 어떤 툴과 어떤 라이브러리
를 써서 만들었든

COM 스펙에 부합하는 dll(in-proc COM 서버)이면 10개든 100개
든,

모든 C 계열 프로그램에서 다 사용할 수 있습니다.

여기다가 오토메이션 인터페이스로 구현했다면, VB를 비롯한 거
의 모든 언어에서 사용할 수 있습니다.

여기다가 DCOM을 썼다면 로컬/원격 상관없이 붙을 수 있고 멀티
티어 아키텍쳐도 가능합니다.

COM도 멀티 플랫폼을 지원합니다.

아무도 비Windows 플랫폼에서 COM을 쓰려고 하지 않을 뿐, COM
자체가 Windows 종속적인 것은 아닙니다.

(찾아보면 유닉스용 COM 시스템이 이미 출시되어있을 듯...)

그리고 유명한 Essential COM 책 서문에 보면, CORBA든 뭐든 간
데

진짜 바이너리 호환성을 지원하는 컴포넌트 오브젝트 모델은
COM 뿐이다.. 라고 나와있더군요.



COM의 핵심은 프로그래머 사이의 묵시적인 약속이라고 볼 수 있
는 COM 스펙과 COM 기반 시스템입니다.

COM 컴포넌트가 되기 위해서는 이러저러한 규칙들을 지켜야 한
다고 정의되어 있으므로

COM 컴포넌트는 일반 dll보다 훨씬 쉽게 사용할 수 있죠.

그리고 COM 기반 시스템이 메모리 관리, 스레딩 문제, 매개변
수 마샬링, 레지스트리(컴포넌트에 설명) 관리 등을 알아서 다
해주기 때문에 무지 편하구요.



MS의 COM이라는 기술이 좋다.. 꼭 배워야 한다.. 이런 얘기가
아니라,

이런 기술은 당연히 있어야 하는.. 때가 되면 필요할 수 밖에
없는 그런 기술이라는 얘깁니다.



전에도 비슷한 취지의 글을 올린 적이 있지만

COM이 나올 수 밖에 없는 이유는 C 시절부터 이어온 구닥다리
링킹 방식 때문이고

C++이 C와 오브젝트 파일 수준에서 호환되기 때문에 그 문제가
계속되고 있는 것이고

java나 .NET은 이 링킹 방식을 바꿔버렸기 때문에 COM 같은 복
잡한 기술없이도 훨씬 더 편한 개발이 가능해진 겁니다.



어쨋거나.. COM도 MFC와 마찬가지입니다.

사양세에 있는 기술이긴 하지만 앞으로 몇년 간은 꽤 써먹어야
할 기술이고

개발언어가 C/C++이라면 거의 필수적인 기술이고

배워두면 여러모도 도움되는 내용이죠.



끝으로 DCOM 얘기를 하자면,

DCOM 뭐하러 쓰냐... 소켓 통신하면 되지.. 이건 C++뭐하러 하
냐.. C로 다 되는데.. 이거와 같은 소리죠.

(다 그럴만한 이유가 있기 때문에 쓴다는 얘기입니다)



요즘은 DCOM도 복잡하다고 아예 XML 웹 서비스로 하는 시대입니
다.

XML 웹 서비스는 HTTP만 쓰는 거 아시죠?




===================================================



dll 세팅없이 암시적 인클루드



소스에

#pragma comment(lib, "a.lib")

써주면된다




================================================

__cdecl , __stdcall



3/4기 스터디 시간에 나온 질문입니다...



이것은 전에.. 제가 다른 클럽 자료실를 뒤져.. 카피해 놓은것
이니 참조하세요~~



참고로 클럽명이 C++라도 잘하자는 클럽입니다.. ^^







함수를 호출하는데는 여러가지 사정이 있습니다.





일단 메모리에서 스택이라는걸 알아야 하는데요. 아신다고 치
고.







함수를 호출할 때는 이 스택을 사용해서 인자를 넘겨줍니다.



인자의 크기만큼 스택에 메모리를 할당하고, 인자를 복사한다
음 함수를 호출하고, 스택을 해제하지요.





int a ( int b)



{



cout << b;



return b;



}







void main()



{



a(3);



}







이렇게 있다고 하면요.







차이는 스택의 전달과 해제에 있습니다.







만약 함수 a가 __cdecl이라면 스택을 해제하는걸 main에서 해줍
니다.



함수 a가 __stdcall이라면 스택을 해제하는걸 a 함수에서 직접
하고요.



__fastcall은 __stdcall과 비슷하지만 스택대신에 레지스터를
사용할 수 있는 경우에는 레지스터를 사용해서 변수를 넘깁니
다.



좀 빠르겠죠.







그러면 __cdecl과 __stdcall은 왜 틀리게 동작을 해야 하는가
궁금해지기 마련인데요.



뭐 사정을 제가 정확히 아는 건 아니고, 대강 이해에 도움이 될
만한 것만 말씀드리자면...







__cdecl은 C만의 이상야릇한 가변 인자 함수들을 지원할 수 있
습니다. 일단 예를 들자면 printf죠.



printf 함수를 호출 할 때는



printf("포맷", 값, 값, 값, 값, ...);



이런 식으로 인자가 몇 개나 넘어갈지 알 수 없죠.



따라서 printf에서는 함수를 호출하는데 사용된 스택의 크기를
알 수 없고, 직접 해제를 할 수 없기 때문에 printf를



호출한 함수에서 해제를 해줘야 합니다.







__stdcall인 경우는 저런걸 지원을 안합니다. 따라서 각 함수에
서 사용하는 스택의 크기는 컴파일하는 시점에서 알 수있죠.



그리고 다른 언어들은 가변인자 따위를 지원을 안하고 보통
__stdcall 방식으로 인자를 처리합니다.



그래서 윈도우 API 들은 __stdcall 형식으로 구현을 하지요.







__cdecl은 __stdcall보다 실행파일의 크기가 커진다고 하네요.
printf를 호출하는 함수마다 그 함수에서 스택을



얼마나 사용했는지를 보고, 그만큼 해제하는 코드가 들어가 있
으니 그럴 만도 하겠죠.


=====================================================



 typedef



typedef string AddressLines[4];


여기서 typedef 만 빼고 보면



string AddressLines[4];



완전히 변수 선언입니다.



여기서 실제로 선언된 변수가 AddressLines 이고.. 앞에
typedef가 있을때는 변수가 아닌 typedef이 되는거죠 -.-;;



변수선언에서 보면 AddressLines의 타입은 string [4] 입니다.
이게 그대로 typedef으로 AddressLines란 이름을 갖게 된거죠.



이런식으로 이해하는게 쉬울뿐 아니라 실제로도 변수 선언과 거
의 동일하게 취급됩니다. scope 측면에서요..




====================================================



CTypedPtrList



클래스 템플릿 입니다...
이것은 CPtrList 에 저장되어질 클래스가 SubItem* 임을 뜻하는
거죠...
class SubItem : public CObject
{
......
};

CTypedPtrList m_arFile;
CTypedPtrList m_arFile;
CPtrList m_arFile;
CObList m_arFile;

위 4개의 경우는 거의 같다고 보시면 됩니다.
자세한 내용은 Class Template 를 공부하세요..

SubItem *pItem = new SubItem;
m_arFile.AddTail(pItem)


-----------------------------------------------------------
-
>>소스 분석중
>>CTypedPtrList m_arFile;
>>와 같은 코드가 있는데 무슨뜻인지 알고 싶습니다.


-----------------------------------------------------------
사용자 메시지
1. #define WM_MYMESSAGE (WM_USER + 100)

2. BEGIN_MESSAGE_MAP(CMyWnd2, CWnd)
   ON_MESSAGE(WM_MYMESSAGE, OnMyMessage)
END_MESSAGE_MAP()

3. LRESULT CMyWnd2::OnMyMessage(WPARAM wParam, LPARAM lParam)
{
   UNREFERENCED_PARAMETER(wParam);
   UNREFERENCED_PARAMETER(lParam);

   // Handle message here.

   return 0;
}
OR - ON_THREAD_MESSAGE 

BEGIN_MESSAGE_MAP(CServerThread, CWinThread)
    //{{AFX_MSG_MAP(CServerThread)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        ON_THREAD_MESSAGE(WM_QUERY_STORE, OnGetStoreData)            
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CServerThread:: OnGetStoreData(WPARAM wparam,LPARAM lparam)
    {


    }

=============================================================
//========================================================================================
// Visual C++코드
// Wrritten By  BYUNG HO CHOI
// Copyright 2008.9.22
// All rights reserved.
// Version 1.0 
//========================================================================================

/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - 콘트롤 -  ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

//---List Box / file Dir Dlg--------------------------------------------------------

 //----------------------------------------------------------------------------
         // 폴더 얻기
   char szTemp[255];
     memset(szTemp, 0, 255);
     lstrcat(szTemp, "c:\\Data");
     CDialog::DlgDirList(szTemp, IDC_LISTBOX, NULL, DDL_EXCLUSIVE | DDL_DIRECTORY); 
  //----------------------------------------------------------------------------

  //----------------------------------------------------------------------------
         //화일명 얻기
  CString Path_Log="C:\\WaterSensor성능검사기\\Data\\";
  CString ss=""; CString tt="";
   
      tt="*.mdb";
  ss =Path_Log+"*.mdb";
  
  char szTemp[255];
  memset(szTemp, 0, 255);
  lstrcat(szTemp, ss);
  CDialog::DlgDirList(szTemp, IDC_SLOG_LIST, NULL, NULL);// DDL_EXCLUSIVE | DDL_DIRECTORY);

  int nList=0; CString csTmp="";
  sLog.SetCurSel(nList);
/*
  if(sLog.GetTextLen(nList)>0)
  {
   sLog.GetText(nList ,csTmp);
   if( FileExists(Path_Log+csTmp))
   {
       ss=LoadReadFile(Path_Log+csTmp);
       LogDisplay(ss);
   }
  }
*/

//==============================================================================
//---다른 Label 콘트롤(Threed32 Panel) Control 상속 얻기 -----------------------

#include "sspnctrl.h"

 CSSPNCtrl *Static;
 Static = (CSSPNCtrl *)GetDlgItem(IDC_IO_0); 
 Static->SetBackColor(0x0000ff); //BGR


#include "LabelControl.h"
 ((CLabelControl*)GetDlgItem(nID))->SetBackColor(OK_COLOR);


//---Control 상속 보이기--------------------------------------------------------

 CButton *pBtn;
 pBtn = (CButton *)GetDlgItem(IDC_CLOSE_BTN);
 pBtn->ShowWindow(true);

 Static = (CStatic *)GetDlgItem(IDC_CAM_NAME); 
 Static->ShowWindow(true);


//---Control 이벤트--------------------------------------------------------
 .h
 //{{AFX_MSG(CImageViewView)
 afx_msg bool OnClickImageView(UINT nID);
 //}}AFX_MSG
 DECLARE_MESSAGE_MAP()
 .cpp
 BEGIN_MESSAGE_MAP(CImageViewView, CFormView)
 //{{AFX_MSG_MAP(CImageViewView)
 ON_COMMAND_RANGE(IDC_IMG_VIEW1, IDC_IMG_VIEW4, OnClickImageView)
  END_MESSAGE_MAP()
 
 bool CImageViewView::OnClickImageView(UINT nID) 
{
 CString csTmp;
 csTmp.Format("%d",nID);
 AfxMessageBox(csTmp);
 return true;
}


#define OK_COLOR  RGB(100,150,255)
#define NG_COLOR  RGB(235,60,60)
COLORREF clLime;

 

 //--Inage List
 BOOL bRetValue = FALSE;
 HICON hIcon = NULL;
// m_CurLibType = m_SelLibrary = m_SleLibType = LINE2RECT;


 SetIcon(m_hIcon, TRUE);
 SetIcon(m_hIcon, FALSE);

 // Create image list
 bRetValue = m_ImageList.Create(80, 80, ILC_COLOR32 | ILC_MASK, 5, 1);
 ASSERT(bRetValue == TRUE);

 // Add some icons
 hIcon = AfxGetApp()->LoadIcon(IDI_ICON_MARK);
 m_ImageList.Add(hIcon);

 m_lbxListBox.SetImageList(&m_ImageList);

//--CShadeButton------------------------------------------------------
 #include "ShadeButtonST.h"
 
 .h --
 CShadeButtonST m_btnXYOrg;
 
 ..cpp
 DDX_Control(pDX,IDC_BTN_XYORG,m_btnXYOrg);  //IDC_BTN_XYORG 푸시 버튼
 
 ..OnInitDialog() 
 //COLORREF crBtnColor;
 //crBtnColor = ::GetSysColor(COLOR_ACTIVEBORDER) + RGB(100, 50, 50);
 m_btnXYOrg.SetShade(CShadeButtonST::SHS_HBUMP);
 
 //-------
 m_btnXYOrg.SetShade(CShadeButtonST::SHS_HSHADE);
 m_btnXYOrg.Invalidate(); 
 m_btnXYOrg.SetShade(CShadeButtonST::SHS_HSHADE,8,10,30,RGB(100,55,0));
 
 
 
 //--CLabelControl--------------------------------------------------

 CLabelControl *pLabel;
 for(int i=0; i<MAX_ONE_BD-2; i++)//0-5 Label1 - Label6
 {
  pLabel = (CLabelControl *)GetDlgItem(IDC_LABEL1+i);
  pLabel->SetEnabled(FALSE);
 }
 //Label7 ID가 순서대로가 아님 
 pLabel = (CLabelControl *)GetDlgItem(IDC_LABEL7);
 pLabel->SetEnabled(FALSE);

 CComboBox *pcbo;
 pcbo = (CComboBox *)GetDlgItem(IDC_COMBO_SELECT_AXIS);
 m_SelectAxisNo = pcbo->SetCurSel(0);

 pcbo = (CComboBox *)GetDlgItem(IDC_COMBO_SELECT_MODE);
 m_SelectAxisMode= pcbo->SetCurSel(0);
 pcbo->EnableWindow(false);

 CStatic *Static;
 Static = (CStatic *)GetDlgItem(IDC_STATIC_AXIS_MODE); 
 Static->EnableWindow(false);//Static->ShowWindow(false);

 CButton *pchk;
 pchk = (CButton *)GetDlgItem(IDC_RADIO_MMCBOARD1);
 pchk->SetCheck(TRUE);

 // Axis One Select LED Status
 m_ledOpSelect1.SetValue(false); m_ledOpSelect2.SetValue(false);m_ledOpSelect3.SetValue(true);

/*------Combo Box---------------------------------------------------*/

 CComboBox *pcbo2;
 pcbo2 = (CComboBox *)GetDlgItem(IDC_COMBO_SELECT_MODE);
 m_SelectAxisMode = pcbo2->SetCurSel(0);

/*------이벤트 얻기---------------------------------------------------*/

BOOL CManualMotorPage::PreTranslateMessage(MSG* pMsg) 
{
 // TODO: Add your specialized code here and/or call the base class
 int ret;
 CLabelControl *plbl;
 if(pMsg->message == WM_LBUTTONDOWN){
  for(int i=0;i<MAX_AXIS;i++){
  
   plbl = (CLabelControl *)GetDlgItem(IDC_LBL_AXIS_X+i);
   if(pMsg->hwnd == plbl->m_hWnd){
    
     return TRUE;
    }
   }
  }
 } 
 return CPropertyPage::PreTranslateMessage(pMsg);
}

/*------Icon---------------------------------------------------*/

 HICON m_hIconOnOff[2];

 m_hIconOnOff[0] = AfxGetApp()->LoadIcon(IDI_OFF);
 m_hIconOnOff[1] = AfxGetApp()->LoadIcon(IDI_ON);


 CStatic *icon;

 icon = (CStatic *)GetDlgItem(IDC_PIC_LED1);
 icon->SetIcon(m_hIconOnOff[0]);

 

/*------Button Enable-----------------------------------------------------*/ 

 CButton *opBtn;
 opBtn=(CButton *)GetDlgItem(IDC_BTN_START);
 opBtn->EnableWindow(FALSE);
 CCommandButton *origBtn; 
 origBtn=(CCommandButton *)GetDlgItem(IDC_CMD_ORIG_START);
 origBtn->SetEnabled(FALSE);

/*------Microsoft Form2.0 Check Box Set------------------------------------*/

// void SetValue(VARIANT* newValue);
 void SetValue( BOOL newValue);
// VARIANT GetValue();
 BOOL GetValue();
void CMdcCheckBox::SetValue(BOOL newValue)
{
 static BYTE parms[] =
  VTS_BOOL;
 InvokeHelper(0x0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
   newValue);
}
BOOL CMdcCheckBox::GetValue()
{
 BOOL result;
 InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
 return result;
}

 CMdcCheckBox *pchk;
 pchk = (CMdcCheckBox *)GetDlgItem(IDC_CHECKBOX1);
 pchk->SetValue(true);

 CMdcCheckBox *pchk;
 pchk = (CMdcCheckBox *)GetDlgItem(IDC_CHECKBOX1);
 if(pchk->GetValue())AfxMessageBox("on");
 else AfxMessageBox("off");

/*------Radio Button Set---------------------------------------------------*/

 CButton *pchk;
 pchk = (CButton *)GetDlgItem(IDC_RADIO_NONE);
 pchk->SetCheck(FALSE);
 pchk = (CButton *)GetDlgItem(IDC_RADIO_SPLIT);
 pchk->SetCheck(TRUE);
/*------------------------------------------------------------------------*/

/*------어레이 이벤트 발생 설정 ------------------------------------------*/
  ..h
protected:
//}}AFX_MSG
 afx_msg void OnChangeTray(UINT nID);
DECLARE_MESSAGE_MAP()

  ..cpp
BEGIN_MESSAGE_MAP(CPreMountDataPage, CPropertyPage)
 //}}AFX_MSG_MAP
 ON_COMMAND_RANGE(IDC_RADIO_TRAY1, IDC_RADIO_TRAY4, OnChangeTray)
END_MESSAGE_MAP()

void CPreMountDataPage::OnChangeTray( UINT nID )
{
 CLabelControl *label;
 UpdateData(TRUE);
 m_nTrayNo = nID - IDC_RADIO_TRAY1;
}


/*------Gride Scroll-----------------------------------------------------*/
m_MSFlexGrid.SetScrollTrack(true);


/*------Icon 불러오기-----------------------------------------------------*/ 

 IDC_PIC_LED1 : Picture Properties, Type -Icon

 HICON m_hIconOnOff[2];

 m_hIconOnOff[0] = AfxGetApp()->LoadIcon(IDI_OFF);
 m_hIconOnOff[1] = AfxGetApp()->LoadIcon(IDI_ON);

 CStatic *icon;
 for(int i=0; i<9; i++) {
  icon = (CStatic *)GetDlgItem(IDC_PIC_LED1 + i);
  icon->SetIcon(m_hIconOnOff[0]);
 }

/*------다중 콘트롤 ID 지정 및 얻기----------------------------------------*/ 

DeviceCheckView.h 화일

//}}AFX_MSG
DECLARE_MESSAGE_MAP()
afx_msg void OnChangeIoNo( UINT nID );
//-----

DeviceCheckView.cpp 화일

void CDeviceCheckView::DoDataExchange(CDataExchange* pDX)
{
 CFormView::DoDataExchange(pDX);
 //{{AFX_DATA_MAP(CDeviceCheckView)
 DDX_Radio(pDX, IDC_IONO1, m_nioNo);
 //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDeviceCheckView, CFormView)
 //{{AFX_MSG_MAP(CDeviceCheckView)
 ON_WM_TIMER()
 //}}AFX_MSG_MAP
 ON_COMMAND_RANGE(IDC_IONO1, IDC_IONO6, OnChangeIoNo)
END_MESSAGE_MAP()

void CDeviceCheckView::OnChangeIoNo( UINT nID )
{
 m_nioNo = nID - IDC_IONO1;
}


/*------콘트롤 ID 지정 및 얻기---------------------------------------------*/ 
//--------------------------------------------------------------------------
 ON_EVENT(CIODisplay, IDC_OUT_T0, -600 /* Click */, OnClickOutBtn, VTS_NONE)
 ON_EVENT(CIODisplay, IDC_OUT_T1, -600 /* Click */, OnClickOutBtn, VTS_NONE)
 ON_EVENT(CIODisplay, IDC_OUT_T2, -600 /* Click */, OnClickOutBtn, VTS_NONE)

void CIODisplay::OnClickOutBtn() 
{
 int id = GetFocus()->GetDlgCtrlID() - IDC_OUT_T0; 
}
//--------------------------------------------------------------------------

/*------상속받아 콘트롤변수지정---------------------------------------------*/ 
#include "xShadeButton.h"
#include "SXButton.h"
 DDX_Control(pDX, IDC_ESTOP, m_EStop);
 m_EStop.SetIcon( IDI_ESTOP, 32, 32 );
 m_EStop.SetImagePos( CPoint ( 2, SXBUTTON_CENTER ) );
 m_EStop.SetTextPos( CPoint ( 28, SXBUTTON_CENTER ) );
 m_EStop.SetFont(&m_sFont);

/*------상속받아 콘트롤 설정  ---------------------------------------------*/ 
#include "EditEx.h"
 CEditEx m_CmdPos[2];
 m_CmdPos[0].SubclassDlgItem(IDC_CMD_POS0, this);
 m_CmdPos[0].bkColor( BLACK );
 m_CmdPos[0].textColor( YELLOW );
 m_CmdPos[0].setFont( 10, FW_ULTRABOLD, DEFAULT_PITCH | FF_DONTCARE, _T("궁서"));
 m_CmdPos[0].SetWindowText("0.000");


 SetDlgItemDouble(IDC_CMD_POS0, cmd_pos[0]);


// 지정한 컨트롤에 값을 보여준다.
void CCAMCFS20Dlg::SetDlgItemDouble(int nID, double value)
{
 CString sTemp;
 sTemp.Format("%.3f", value);
 GetDlgItem(nID)->SetWindowText(sTemp);
}

// 지정한 컨트롤에서 값을 읽어온다.
double CCAMCFS20Dlg::GetDlgItemDouble(int nID)
{
 double dRet;
 CString sTemp;
 GetDlgItem(nID)->GetWindowText(sTemp);
 dRet = atof((LPCTSTR)sTemp);

 return dRet;
}

/*------EnableWindow--------------------------------------------------------*/
 EnableWindow(GetDlgItem(m_hDlg,IDC_BTN_START),FALSE);
 EnableWindow(GetDlgItem(m_hDlg,IDC_BTN_STOP),TRUE);

 char szBuf[256];
 SetDlgItemText(m_hDlg, IDC_MSG, "Server Running");
 GetDlgItemText(m_hDlg,IDC_LISTEN_EDIT,szBuf,256);
 
 int iPort = atoi(szBuf);
 memset(szBuf,0,256);

/*------EDIT CONTROL--------------------------------------------------------*/ 
void CWinDlg::WriteText(char* szData)
{
 HWND hWndOutput;
 int iChar;
 
 hWndOutput = GetDlgItem(m_hDlg, IDC_EDIT_BOARD);
 iChar = SendMessage(hWndOutput, EM_GETLIMITTEXT, 0, 0);
 SendMessage(hWndOutput, EM_SETSEL, iChar, iChar);
 SendMessage(hWndOutput, EM_REPLACESEL, FALSE, (LPARAM)szData);
 SendMessage(hWndOutput, EM_REPLACESEL, FALSE, (LPARAM)"\r\n");
}

/*------Control Key--------------------------------------------------------*/ 
#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

 KeyCode=GetKeyState(VK_CONTROL);
 if((KeyCode==CONTROLKEY1)||(KeyCode==CONTROLKEY2)){bConKey=TRUE;}

/*------Read Only----------------------------------------------------------*/ 
 m_FileSaveAsButton[nCh].EnableWindow(FALSE);
 m_ItemSelectCombo[nCh].EnableWindow(nMode);
 m_SetRevCheckBox[nCh].EnableWindow(nMode);
 m_TestViasstatic[nCh].SetReadOnly(nMode);

/*------Slider------------------------------------------------------------*/

 m_SpotTopSlider.GetPos();//일반
// m_SpotLeftSlider.SetRange(0, 1024);//일반
 m_SpotLeftSlider.SetValue(140);    //NI 콘트롤

void CGraphResultPage3::OnPointerValueChangedSpotBottomSlider(long Pointer, VARIANT FAR* Value) 
{
 // TODO: Add your control notification handler code here
 int nData=0;
 nData = CNiVariant(Value);m_nSpotBottomLimit=nData;
}

/*------Message------------------------------------------------------------*/

// MessageBox(NULL,buf,title,MB_OK|MB_ICONEXCLAMATION);

// if (MessageBox("Module Aging Program Quit? ", " OLED Module Aging Program",
//  /*MB_ICONQUESTION*/MB_ICONSTOP | MB_OKCANCEL) == IDOK)  {
// OnClose();
// PostQuitMessage(0);
// }

 RedrawWindow();//Invalidate(FALSE);

/*------ 콘트롤 Bmp-------------------------------------------------------------------*/
 CBitmap m_ButtonBmp1;
 m_ButtonBmp1.LoadBitmap(IDB_SAVEBUTTONBMP);
 m_FileSaveAsButton[0].SetBitmap(m_ButtonBmp1);
 RedrawWindow();//Invalidate(FALSE);

/*------ 콘트롤 Enable----------------------------------------------------------------*/
 m_ccEdit1.SetReadOnly(TRUE);
 m_ccButton1.EnableWindow(TRUE);

 m_ccModeCheck1.ShowWindow(SW_SHOW); 
 m_ccModeCheck2.ShowWindow(SW_HIDE);
/*------------------------------------------------------------------------------------*/
/*------CT 콘트롤 제어----------------------------------------------------------------*/
 m_cttPosition11.SetBackColor(RGB(255,0,0));
 m_cttPosition11.SetForeColor(RGB(255,0,0));
 m_cttPosition11.SetCaption("-120.000");
 m_cttPosition11.ShowWindow(FALSE);

/*------NI 콘트롤 숨김----------------------------------------------------------------*/

 m_nctlTestButton1.ShowWindow(FALSE);//숨김

/*------NI Graph----------------------------------------------------------------*/

 m_ResultLineGraph1.GetAxes().Item(3.0).GetTicks().SetMajorTickColor(White);
 m_ResultLineGraph1.GetPlots().Item(2.0).SetLineColor(White);
 m_ResultLineGraph1.GetAxes().Item(1).GetLabels().SetColor(White);

 m_ResultLineGraph1.GetAxes().Item(1).AutoScaleNow();
 m_ResultLineGraph1.GetAxes().Item(2).AutoScaleNow();

 m_ResultLineGraph1.GetAxes().Item(1).SetMinMax(m_GraphScaleMin_x,m_GraphScaleMax_x);
 m_ResultLineGraph1.GetAxes().Item(2).SetMinMax(m_GraphScaleMin_y,m_GraphScaleMax_y);


//==================================================================================
/*------DlgList [..][]------------------------------------------------------------*/
  char szTemp[255];
     memset(szTemp, 0, 255);
     lstrcat(szTemp, "c:\\Data");
     CDialog::DlgDirList(szTemp, IDC_LISTBOX, NULL, DDL_EXCLUSIVE | DDL_DIRECTORY); 
 

/*----------------------------------List Box Text 얻기----------------------------*/
//=================================================================================
 CString strTmp="";
 int nListNo=m_ccName.GetCurSel();
 
 if(m_ccName.GetTextLen(nListNo)>0)
 {
  m_ccName.GetText(nListNo,strTmp);
 }

 m_ccModuleMeasureList.InsertString(nListNo,csFind);


 nListNo=m_ccImageList.GetCurSel();
 
 CString csFind;m_ccImageList.GetText(nListNo,csFind);
 nListNo=m_ccModuleMeasureList.GetCurSel();
 m_ccModuleMeasureList.DeleteString(nListNo);
 m_ccModuleMeasureList.InsertString(nListNo,csFind);
 
 
 int nListMax=flBox.GetCount();
 csTmp.Format("%d",nListMax); AfxMessageBox(csTmp);


 
//==================================================================================

/*----------------------------------Multi Edit 한줄씩 얻기----------------------------*/ 
 CString ReadData; CString strTmp="";
 GetDlgItemText(IDC_INSTRUCT_EDIT, ReadData);
 int index=0; int length=0;
 char chBuf[2];


 length = ReadData.GetLength();
 int nListCount=0;

 CString csLineData[CHMAX];
 CString csBuf=_T("");

 for(int i=0; i<length; i++)
 {
  csBuf=ReadData.Mid(i,1);
  if(csBuf=="\n")
  {
   csBuf=""; 
   nListCount++;
  }
  else
  {
   if(csBuf!="\r")
   {
   chBuf[0]=csBuf.GetAt(0);
   chBuf[1]='\0';
   csLineData[nListCount]+=chBuf;
   }
  }
 }

 for(int n=0; n<nListCount+1; n++)
 AfxMessageBox(csLineData[n]);


/*----------------------------------콘트롤 생성-------------------------------------*/
// CComboBox m_pComboBox[CHMAX];
// CEdit m_pEditBox[CHMAX];
// CListBox m_pListBox[CHMAX];
// CButton m_pButton[CHMAX];

 WS_THICKFRAME  콘트롤 크기 가변

 RECT ovlScrRect;
 m_Display.GetWindowRect(&ovlScrRect);
 ::CopyRect(&OverlayClientRect,&ovlScrRect);
 ScreenToClient(&OverlayClientRect);

 pVision->OutputOverlay(GetDC()->m_hDC,&ovlScrRect);
 UpdateOverlayWindow();

 

/* CStatic *m_static;
 m_static = new CStatic;
 m_static->Create(_T("스태틱"),
     WS_VISIBLE | SS_CENTER,
     CRect(10,10,210,40),
     this,
     ID_SAMPLE_STATIC1);
*/

 //리스트 박스 만들기
 RECT rect1={10,100,200,200};
 m_pListBox.Create(WS_CHILD | WS_VISIBLE | LBS_STANDARD,rect1,this,200);
 m_pListBox.ShowWindow(SW_SHOW);
 //데이터 삽입
 m_pListBox.AddString("data1");
 m_pListBox.AddString("data2");
 m_pListBox.AddString("data3");

 //에디터 박스 만들기
 RECT rect2={210,10,400,100};
 m_pEditBox.Create(
  WS_CHILD | WS_VISIBLE | 
  ES_MULTILINE //여러 라인 입력
  | ES_AUTOHSCROLL | ES_AUTOVSCROLL| //자동 수직,수평 스크롤
  WS_BORDER |WS_VSCROLL,//외곽선과 수직 수크롤바 설정
    rect2,this,300);
 m_pEditBox.ShowWindow(SW_SHOW);

 //콤보박스 만들기
 RECT rect3={210,200,400,300};//콤보박스 출력 위치
 //윈도우 만들기
 m_pComboBox.Create(WS_CHILD | WS_VISIBLE|CBS_DROPDOWN ,rect3,this,400);
 m_pComboBox.ShowWindow(SW_SHOW);
 //콤보박스에 데이터를 넣는다.
 m_pComboBox.AddString("cdata1");
 m_pComboBox.AddString("cdata2");
 m_pComboBox.AddString("cdata3");


/*------KeyBoadData------------------------------------------------------------------*/

void CTESTView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
 // TODO: Add your message handler code here and/or call default
 
 CString csText=_T("");

 csText=nChar;
 AfxMessageBox(csText);

 CFormView::OnChar(nChar, nRepCnt, nFlags);
}


/*------SendDlgItemMessage------------------------------------------------------------*/
 SendDlgItemMessage(IDC_STATIC_WLREM, WM_SETTEXT,0,(LPARAM)(LPSTR)"DATA NONE");

/*-------라디오버튼-------Radio button------------------------------------------------*/
//-------------------------------------------------------------------------------------

 tmModel.PCBType    = (rbSata.GetCheck()?0:1);
 tmModel.Rotate     = (rbRetn.GetCheck()?false:true);
 tmModel.ScrewCheck = (rbNChk.GetCheck()?false:true);
 tmModel.ScrewType  = (rbTyp1.GetCheck()?0:1);

 m_Select11.SetCheck(TRUE);
 m_Select11.SetCheck(FALSE);

 m_ccModeCheck3.SetWindowText("Photo(uA)");

 radio button 
 변수 생성시 Gruop 지정

 0  : on
        -1 : off

 CNiPlot3D::PlotStyles style=m_Graph3D.GetPlots().Item(1).GetStyle();
 m_Point.SetCheck((style == CNiPlot3D::PlotStyles::Point)? 1 : 0);
 m_Line.SetCheck((style == CNiPlot3D::PlotStyles::Line)? 1 : 0);
 m_LinePoint.SetCheck((style == CNiPlot3D::PlotStyles::LinePoint)? 1 : 0);

/*------------List Box 변수 선언 대입------------------------------------------------*/
 
 CListBox  m_ListBox[4];

 m_ListBox[0].SubclassDlgItem(IDC_LIST1, this);
 m_ListBox[1].SubclassDlgItem(IDC_LIST2, this);
 m_ListBox[2].SubclassDlgItem(IDC_LIST3, this);
 m_ListBox[3].SubclassDlgItem(IDC_LIST4, this);

 m_ListBox[i].EnableWindow(FALSE);
 m_ListBox[port-1].AddString(m_strReceived[port-1]);
 m_ListBox[port-1].SetSel(m_ListBox[port-1].GetCount()-1, TRUE);

 m_ListBox[0].ResetContent();//clear


 m_ccModuleMeasureList.InsertString(nListNo,csFind);
//---List Control 빈문자 에러방지---------------------------------------------------
 if(m_ccName.GetCount()>0)
 {
   m_ccName.SetCurSel(m_nListCurrentNo);
   
    if(m_ccName.GetTextLen(m_ccName.GetCurSel())>0)
    {
    m_ccName.GetText(m_ccName.GetCurSel(),strTmp);
    m_csName=strTmp;
    }
    else
    {
    m_csName=_T("");
    }

   strTmp.Format("%d / %d", m_nListCurrentNo, m_nListMaxCount);
   SetDlgItemText(IDC_PAGEMODEL, strTmp); 
   }
// m_ccModule_A_JobList.SetItemHeight(nListMaxCount,LISTHIGH2);//넓게 표시

/*----------------------------Check Box On/Off제어---------------------------------*/
 
 m_ccCheck.SetCheck(TRUE);//ON
 m_ccCheck.SetCheck(FALSE);//OFF

/*----------------------------------커서 활성-------------------------------------*/
 
 m_clbName.SetFocus();

/*----------------------------------콘트롤 보이기 숨기기--------------------------*/
 m_TestButton.ShowWindow(SW_HIDE);//(FALSE) 
 m_TestButton.ShowWindow(SW_SHOW);//(TRUE)

/*------------콘트롤 생성--------------------------------------------------------*/
 public:
 CListBox m_pListBox;

 RECT rect={10,100,200,200};

 m_pListBox.Create(WS_CHILD|WS_VISIBLE|LBS_STANDARD,rect,this,200);
 m_pListBox.ShowWindow(SW_SHOW);
 m_pListBox.AddString("data1");
 m_pListBox.AddString("data2");
 m_pListBox.AddString("data3");

// m_ccName.GetText(m_ccName.GetCurSel(),strTmp);

/*------------콤보BOX Text제어--------------------------------------------------*/

 CString csTmp;
 int nNo=m_ccPalletSelect.GetCurSel();
 m_ccPalletSelect.GetLBText(nNo,csTmp);
 AfxMessageBox(csTmp);

 for(i=0; i<10; i++)
 {
 m_ccCombo.DeleteString(i);
 csText.Format("%dH:",i);
 m_ccCombo.InsertString(i,csText);
 }

/*------List Control-------------------------------------------------------------*/
 CString csTmp;
 m_ccNameList.AddString("DATA 1");

 m_ccNameList.SetCurSel(0);
 m_ccNameList.GetText(m_ccNameList.GetCurSel(),csTmp);


 if(m_cliItemName.GetTextLen(m_cliItemName.GetCurSel())>0)
 {
 m_cliItemName.GetText(m_cliItemName.GetCurSel(),csTmp);
 m_csItemName=csTmp;
 }
 
 for(i=m_ccName.GetCount()-1;i>=0;i--) 
 {m_ccName.DeleteString(i);}

 if(m_cliItemName.GetCount()>0)
 {
  if(m_cliItemName.GetTextLen(m_nCurrentModelNo-1)>0)
  {
   m_cliItemName.GetText(m_nCurrentModelNo-1,strTmp);
  }

  SearchModelItemName(strTmp, false);
 }

/*--------------------Edit-> 리스트Box로 사용-----------------------------------*/ 
void CFOOLPROOFView::Status_display(CString sdisplay)
{
      //Edit -Control
 if ( m_ComDisplay.GetLineCount() > 5)
 {
  m_ComDisplay.SetSel(0, -1);
  m_ComDisplay.Clear();
 }
 
 sdisplay+="\r\n";
 m_ComDisplay.ReplaceSel(sdisplay); 
 
/*--------------------Edit-> 커서 생성-----------------------------------------*/ 
 m_clbEdit.SetFocus();

}

//-------------Edit->GetWindowText----------------------------------------------------//
//-----------------------------------------------------------------------------------//
//--unsigned char-> CString ,  unsigned char-> char----------------------------------

 int Length= m_ccEdit1.GetWindowTextLength();
 unsigned char *temp = NULL;
 temp = new unsigned char [Length];

 char temp2[2]; CString csText;
 m_ccEdit1.GetWindowText((LPSTR)temp,255);

 for(int i=0; i<Length; i++)
 {
  temp2[0]=temp[i]; temp2[1]='\0';
  csText+=(LPSTR)temp2;
 }

 AfxMessageBox(csText);

//----------------------------------------------------
 char temp[255];
 for(int i=0; i<255; i++) temp[i]='\0';

 GetDlgItemText(IDC_EDIT1,(LPSTR)temp,255);
 GetDlgItemText(IDC_EDIT1,(char*)temp,255);
 CString csText=(LPSTR)temp;
 AfxMessageBox(csText);

//-----------------------------------------------------------------------------------//
/*-------------Control에 고유번호 부여 호출-----------------------------------*/
 CString Buf;
 CString data; 
 CString BufSET;

 int No=1001; /*Resource.h -#define  IDC_EDIT  1001 */
 int No2=1004;

 data="A1입니다";
 SetDlgItemText(No,data);

 GetDlgItemText(No2,BufSET);
 AfxMessageBox(BufSET);

 UpdateData(FALSE);
/*----------------콘트롤에서 직접 text 얻기----------------------------------*/
 GetDlgItemText(IDC_SELECT_NAME_SCHOOL_YEAR1, csName);
 SetDlgItemText(IDC_PAGEMODEL, strText);


 //===========================================
 CString strRX, strRY;

 CStatic *pRX, *pRY;
 pRX = (CStatic *)GetDlgItem(IDC_LBL_RESULTX);
 pRY = (CStatic *)GetDlgItem(IDC_LBL_RESULTY);
 pRX->GetWindowText(strRX);
 pRY->GetWindowText(strRY);
/*------------------------FluxGrid 텍스트 중앙위치---------------------------*/
 m_GridData.SetCellAlignment(4);

/*-------------------상태바--------------------------------------------------*/
void CMainFrame::DisplayMessage(CPoint point)
{
 CString msg;
 msg.Format("마우스 위치 : (%d, %d)",
  point.x, point.y);
 m_wndStatusBar.SetWindowText(msg);
}

/*-------------------ProgressBar----------------------------------------------*/

 // ProgressBar표시를 위한 부분 
 CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
 pFrame->m_pProgressBar.SetRange(0, height-tHeight);
 pFrame->m_pProgressBar.SetStep(1);
 CRect rc;
        pFrame->pStatusBar->GetItemRect (0, rc); 
 pFrame->m_pProgressBar.MoveWindow(&rc);

 pFrame->m_pProgressBar.StepIt();

//---------------------------------------------------------------------------*/


void CColorView::OnMouseMove(UINT nFlags, CPoint point) 
{
 //#include "MainFrm.h"
 CMainFrame *pWnd = (CMainFrame*) AfxGetMainWnd();
 pWnd->DisplayMessage(point);
 CView::OnMouseMove(nFlags, point)
}

/*------------------------------SPIN Button 범위 지정--------------------*/

 1-12 까지 범위지정
void CDBdeleteDlg::OnDeltaposMonthStartSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
 NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
 // TODO: Add your control notification handler code here
 UpdateData(TRUE);
 pNMUpDown->iPos = 0;
 m_MonthStartEdit -= (pNMUpDown->iDelta);
 if (m_MonthStartEdit<1)
 {
  m_MonthStartEdit = 1;
 }
 else if (m_MonthStartEdit>12)
 {
  m_MonthStartEdit = 1;
 }
 
 UpdateData(FALSE);

 *pResult = 0;
}


/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// -    HDC 얻기    -  ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

 CMainFrame *pFrame= (CMainFrame*)AfxGetMainWnd();ASSERT(pFrame);
 pFrame->m_flagTemplate = TRUE;
 

 CRect rect;rect.left=0;rect.right=100;rect.top=0;rect.bottom=200;

 CDC *pDC; pDC = GetDC();
 DrawRect(pDC, rect, RGB(0,0,255), 2);


 CClientDC pDC(this);
 DrawRect(&pDC, rect, RGB(0,0,255), 2);


 HWND hParent = ::GetParent(m_hWnd);


 CMainFrame* pWnd = (CMainFrame*)AfxGetApp()->m_pMainWnd;
 HDC hDC = GetDC(pWnd->m_hWnd);

 CDC *pDC; pDC = GetDC();
 EraseBkgnd(pDC,m_CamRect,m_DisRect);


 CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
 CDC *pDC =pFrame->GetDC();

 StretchDIBits(pDC->GetSafeHdc(),20,20,width,height, 
 0, 0,width, height, m_ColorGetImg, (LPBITMAPINFO)&dibHi, DIB_RGB_COLORS, SRCCOPY);


 CPaintDC dc(this); // device context for painting
 int width=m_CamRect.right; int height=m_CamRect.bottom; 
 // TODO: Add your message handler code here
 CPaintDC dcView(GetDlgItem(IDC_IMG_HISTO_VIEW));
 
 CRect rect;
 GetDlgItem(IDC_IMG_HISTO_VIEW)->GetClientRect(&rect);
 StretchDIBits(dcView.m_hDC,rect.left,rect.top,rect.right,rect.bottom, 0, 0, 
  width, height, m_pTestBitmap, &m_pBitmapInfo, BI_RGB, SRCCOPY);

 CRect rect;
 GetDlgItem(IDC_IMG_HISTO_VIEW)->GetWindowRect(&rect);
 ScreenToClient(rect);
 InvalidateRect(&rect, FALSE);


 CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
 //CChildFrame *pFrame = (CChildFrame *)AfxGetMainWnd();

// CPaintDC *pDC;
 CDC *pDC =pFrame->GetDC();

 CVisionSysView* pView =( CVisionSysView* )((CMainFrame*)AfxGetApp()->m_pMainWnd)->GetActiveView();
 CVisionSysDoc *pDoc=pView->GetDocument();
 CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
// CDC *pDC =pFrame->GetDC();
 CDC *pDC =pView->GetDC();

/*-------------- HDC 얻기------------------------------------------------------------*/

CWnd *pWnd = GetDlgItem(IDC_CAMERA_VIEW);


void CGraphResultPage3::DrawBitmap()
{
 if (m_buf==NULL) return;

 CRect rect;
 GetDlgItem(IDC_IMG_HISTO_VIEW)->GetWindowRect(&rect);
 ScreenToClient(rect);
 InvalidateRect(&rect, FALSE);
}

void CGraphResultPage3::OnPaint() 
{
 CPaintDC dc(this); // device context for painting
 
 // TODO: Add your message handler code here
 if (m_buf==NULL) return;

 BYTE *tmp;
 // DWORD-align for display
 tmp = JpegFile::MakeDwordAlignedBuf(m_buf,m_width,m_height,&m_widthDW);
 // set up a DIB 
 BITMAPINFOHEADER bmiHeader;
 bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
 bmiHeader.biWidth = m_width;  bmiHeader.biHeight = m_height;
 bmiHeader.biPlanes = 1;    bmiHeader.biBitCount = 24;bmiHeader.biCompression = BI_RGB;
 bmiHeader.biSizeImage = 0;   bmiHeader.biXPelsPerMeter = 0;
 bmiHeader.biYPelsPerMeter = 0;bmiHeader.biClrUsed = 0;
 bmiHeader.biClrImportant = 0;// CRect rect;

 int width=bmiHeader.biWidth; int height=bmiHeader.biHeight; 
 
 CPaintDC dcView(GetDlgItem(IDC_IMG_HISTO_VIEW));
 dcView.SetStretchBltMode(STRETCH_DELETESCANS);

 CRect rect;
 GetDlgItem(IDC_IMG_HISTO_VIEW)->GetClientRect(&rect);
 StretchDIBits(dcView.m_hDC,rect.left,rect.top,rect.right,rect.bottom, 
  0, 0,width, height, tmp, (LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS, SRCCOPY);
 delete [] tmp;
 // Do not call CPropertyPage::OnPaint() for painting messages
}

/*-------------- HDC 얻기------------------------------------------------------------*/
 CDC *theDC = GetDC();

 if (theDC!=NULL) {

  CRect clientRect;
  GetClientRect(clientRect);

  // Center It
  UINT left = (clientRect.Width() - m_width) / 2;
  UINT top = (clientRect.Height() - m_height) / 2;

  // a 24-bit DIB is DWORD-aligned, vertically flipped and 
  // has Red and Blue bytes swapped. we already did the 
  // RGB->BGR and the flip when we read the images, now do
  // the DWORD-align

  BYTE *tmp;
  // DWORD-align for display
  tmp = JpegFile::MakeDwordAlignedBuf(m_buf,
           m_width,
           m_height,
           &m_widthDW);
  // set up a DIB 
  BITMAPINFOHEADER bmiHeader;
  bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
  bmiHeader.biWidth = m_width;
  bmiHeader.biHeight = m_height;  bmiHeader.biPlanes = 1;
  bmiHeader.biBitCount = 24;
  bmiHeader.biCompression = BI_RGB;
  bmiHeader.biSizeImage = 0;
  bmiHeader.biXPelsPerMeter = 0;
  bmiHeader.biYPelsPerMeter = 0;
  bmiHeader.biClrUsed = 0;
  bmiHeader.biClrImportant = 0;

  //---------------------------------------------
   theDC->SetStretchBltMode(STRETCH_DELETESCANS);
  //---------------------------------------------
  // now blast it to the CDC passed in.
  // lines returns the number of lines actually displayed

  int lines = StretchDIBits(theDC->m_hDC,
         BMP_START_EDGE_X1,BMP_START_EDGE_Y1,
         512,
         384,
         0,0,
         bmiHeader.biWidth,
         bmiHeader.biHeight,
         tmp,
         (LPBITMAPINFO)&bmiHeader,
         DIB_RGB_COLORS,
         SRCCOPY);

  delete [] tmp;

  CString info;
  info.Format("(%d x %d)", m_width, m_height);
  theDC->SetBkMode(TRANSPARENT);
  theDC->SetTextColor(RGB(0,0,0));
  theDC->TextOut(10,5, info);
 
  ReleaseDC(dc);

/*-------------- 다일로그/Propet 꽉찬 화면출력 화면-----------------------------------------*/

int CSETDlg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
 if (CDialog::OnCreate(lpCreateStruct) == -1)
  return -1;
 
 // TODO: Add your specialized creation code here
  ShowWindow(SW_SHOWMAXIMIZED);///화면  확대
  UpdateWindow();            
 return 0;
}

/*-------------- Dialog를 메인화면으로 사용-----------------------------------------*/

#include "commtestDlg.h"

BOOL CCommtestApp::InitInstance()
{
 // Standard initialization
 // If you are not using these features and wish to reduce the size
 //  of your final executable, you should remove from the following
 //  the specific initialization routines you do not need.

#ifdef _AFXDLL
 Enable3dControls();   // Call this when using MFC in a shared DLL
#else
 Enable3dControlsStatic(); // Call this when linking to MFC statically
#endif

 CCommtestDlg dlg;
 m_pMainWnd = &dlg;
 dlg.DoModal();

 // Since the dialog has been closed, return FALSE so that we exit the
 //  application, rather than start the application's message pump.
 return FALSE;
}
/*----------------------------------------------------------------------------------*/
 MainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();
 CChildFrame *pChild=(CChildFrame*)pFrame->GetActiveFrame();
 CWinColorDoc *pDoc=(CWinColorDoc*)pChild->GetActiveDocument();
 CWinColorView *pView=(CWinColorView*)pChild->GetActiveView();
/*-------------- View 에서 App 얻기------------------------------------------------*/

 CSECKLineDVM2App* pApp = (CSECKLineDVM2App*)AfxGetApp();
 pApp->SetSerialInfo();


/*-------------- Doc 에서 View 얻기------------------------------------------------*/
 CServerNetWorkView *pView=(CServerNetWorkView *)((CMainFrame *)AfxGetMainWnd())->GetActiveView ();
 pView->Status_display(lpszMessage);


/*-------------- View에서  Doc 얻기------------------------------------------------*/
 CSECKLineDVM2Doc* pDoc = GetDocument();
  
 pDoc->
/*--------------메인프레임에서 View, Doc 얻기-------------------------------------*/
 CSECKLineDVM2View* pView =
 (CSECKLineDVM2View* )((CMainFrame*)AfxGetApp()->m_pMainWnd)->GetActiveView();

 pView->
 
 CCSECKLineDVM2MultiDoc *pDoc;
 pDoc=pView->GetDocument();

 pDoc->

/*--------------다일로그에서  View, MainFrame, Doc 얻기---------------------------*/
 CSECKLineDVM2MultiView *pView=(CSECKLineDVM2MultiView *)((CMainFrame *)AfxGetMainWnd())->GetActiveView ();
 pView->

 CMainFrame* pFrame;
 pFrame = (CMainFrame*)AfxGetApp()->m_pMainWnd;
 
 pFrame->

 CSECKLineDVM2View* pView =( CSECKLineDVM2View* )((CMainFrame*)AfxGetApp()->m_pMainWnd)->GetActiveView();
 CSECKLineDVM2Doc *pDoc;
 pDoc=pView->GetDocument();

 pDoc->

/*----------------------------다일로그 호출 종료----------------------------------*/
 CProgressDlg Dlg;
 Dlg.Create();
 Dlg.DestroyWindow();

 //--------------
 EndDialog(IDOK);
 CDialog::OnCancel();
 EndDialog(IDCANCEL);
 //--------------

/*------------------------MessageBox 선택-----------------------------------------*/
 if (AfxMessageBox("모델코드를 찾지 못했습니다.!\n모델을 입력 하시겠습니까?.", MB_YESNO) == IDYES)
 {
 }
 else
 {
 return;
 }

/*-------------화면갱신----------------------------------------------------------*/

 Invalidate(TRUE); 
 RedrawWindow();

/*-------------------------------------------------------------------------------*/

/*------------타이틀 제목 없애기-------------------------------------------------*/
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
 if( !CFrameWnd::PreCreateWindow(cs) )
  return FALSE;
 // TODO: Modify the Window class or styles here by modifying
 //  the CREATESTRUCT cs
 cs.style^=FWS_ADDTOTITLE; //제목 없음 없에기
 return TRUE;

 cs.style = WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_MAXIMIZE;
 cs.lpszName = " WASS-2000 Scanning System";
 cs.x = cs.y = 0;
 cs.cx = rct.right;
 cs.cy = rct.bottom;

}

/*----------------------전체 화면 출력 위치조정------------------------------*/
 cs.x=200; cs.y=200; cs.cx=400; cs.cy=400;

/*----------------------다일로그 디스플레이 위치 변경------------------------*/
CExpansionDlg1* g_pExpansion = NULL;

  if(!g_pExpansion)
  {
  g_pExpansion = new CExpansionDlg1(this);
  g_pExpansion->MoveWindow(50,387,354,320,true);//x,y,with,high
  Invalidate(TRUE);
  }

/*------------------프로그램 종료--------------------------------------------*/
 윈도우 "x" 종료 (도큐먼트에 설정)


void CMainFrame::OnClose() 
{
 // TODO: Add your message handler code here and/or call default
 
 if (MessageBox("프로그램을 종료 하시겠습니까? ", " 재고관리프로그램",
  /*MB_ICONQUESTION*/ MB_ICONSTOP | MB_OKCANCEL) == IDOK)  {
  PostQuitMessage(0);
  CFrameWnd::OnClose();
 } 
}

BOOL CScrubDoc::SaveModified() 
{
 // TODO: Add your specialized code here and/or call the base class
 if(AfxMessageBox("프로그램을 종료하시겠습니까?",MB_ICONQUESTION|MB_YESNO)==IDYES)
 {
 OnClose();
 PostQuitMessage(0);
 //((CMainFrame*)AfxGetApp()->m_pMainWnd)->SendMessage(WM_CLOSE,0,0);

 }
 else
 {
  return 0;
 }

/* CMainFrame* m_pMainWnd;
 CMainWidowCloseDoc* pDataDoc = GetDocument();
 
 if(IDOK==AfxMessageBox("프로그램을 종료하시겠습니까?",MB_OKCANCEL))
 
 m_pMainWnd->OnClose;
 pDataDoc->OnCloseDocument();
*/ return CDocument::SaveModified();
}
{
 if(AfxMessageBox("프로그램을 종료하시겠습니까?",MB_ICONQUESTION|MB_YESNO)==IDYES)
 {
 OnClose();
 PostQuitMessage(0);
 }
 else
 {
  return;
 }
}

/*--------------------프로그램 종료-------------------------------------------*/
 ::ExitProcess(-1); 

/*--------------------프린트다일로그 않보이고 바로 출력하기-------------------*/
BOOL CManagementView::OnPreparePrinting(CPrintInfo* pInfo)
{
 // default preparation
 pInfo->m_bDirect=TRUE;
 return DoPreparePrinting(pInfo);
}
/*---------------------------다일로그 호출-----------------------------------*/
 CMyGraphDemoDlg dlg;
 int nResponse = dlg.DoModal();
 if (nResponse == IDOK)
 {
  // TODO: Place code here to handle when the dialog is
  //  dismissed with OK
 }
 else if (nResponse == IDCANCEL)
 {
  // TODO: Place code here to handle when the dialog is
  //  dismissed with Cancel
 }

/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - Windows 제 어  -  ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------*/
/*-------------- 다일로그 크기조절            ---------------------------------------*/
/*-----------------------------------------------------------------------------------*/

 SetWindowText("Image View");
 MoveWindow(50, 50,400,300); //x위치, y위치, x Size, y Size

/*-----------------------------------------------------------------------------------*/
/*-------------- 윈도우 항상 위에 활성        ---------------------------------------*/
/*-----------------------------------------------------------------------------------*/
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
 cs.dwExStyle = WS_EX_TOPMOST;
}


/*-----------------------------------------------------------------------------------*/
/*-------------- Menu Bar를 지우기            ---------------------------------------*/
/*-----------------------------------------------------------------------------------*/
 
 CMenu* pMenu = new CMenu;
 pMenu->Attach(cs.hMenu);
 pMenu->DestroyMenu();
 cs.hMenu = NULL;
 delete pMenu;
 
/*-----------------------------------------------------------------------------------*/
/*-------------- 화면 갱신                    ---------------------------------------*/
/*-----------------------------------------------------------------------------------*/

 CStatic m_PcbImageView;
 CRect  m_rectLargeCanvas;

 m_PcbImageView.GetWindowRect(&m_rectLargeCanvas);
 ScreenToClient(&m_rectLargeCanvas);
 InvalidateRect(m_rectLargeCanvas,FALSE);
 //===============================================

 Invalidate(TRUE);Invalidate(false);
 RedrawWindow();
 UpdateAllViews(FALSE);
        UpdateData(FALSE);

/*------Hot Key------------------------------------------------------------*/ 
//--------------------------------------------------------------------------
BOOL CBroadView::PreTranslateMessage(MSG* pMsg) 
{
 // TODO: Add your specialized code here and/or call the base class
 if (pMsg->message==MM_MCINOTIFY) {
  if (pMsg->wParam==MCI_NOTIFY_SUCCESSFUL) {
   StopWav();
  }
 }
 if (pMsg->message==MY_MSG_FIRE_OFF) {
  FireOff();
 }
 if (pMsg->message==WM_KEYDOWN) {
  if (GetAsyncKeyState(VK_F1)&0x8000) {
   if (GetAsyncKeyState(VK_F5)&0x8000) {
    if (GetAsyncKeyState(VK_F9)&0x8000) {
     if (m_SetupBtn.IsWindowVisible()==FALSE) {
      FuncBtnShow(SW_SHOW);
     }
    }
   }
  }

  // 2007.2.15
  if (GetAsyncKeyState(VK_F6)&0x8000){m_bPingViewChk=TRUE;Invalidate(FALSE);SetTimer(REDRAW_TIMER,2000,NULL);}//RedrawWindow();

 }

 return CFormView::PreTranslateMessage(pMsg);
}
/*-------------- 메인프레임 상속 받아 다일로그 호출-----------------------------------------*/
//--------------------------------------------------------------------------------------------
void ResultShowDlgBar(CString str)
{
 CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
 CRect rect; 
 pFrame->GetWindowRect(&rect);

 if (!pFrame->m_ResultShowBar.IsWindowVisible())
 {
  pFrame->DockControlBar(&pFrame->m_ResultShowBar);
  pFrame->m_ResultShowBar.ShowWindow(SW_SHOW);
  pFrame->FloatControlBar(&pFrame->m_ResultShowBar,CPoint(rect.right-324,rect.bottom-125));
 }


 CEdit *pEdit = (CEdit *)pFrame->m_ResultShowBar.GetDlgItem(IDC_RESULTSHOW);
 int nLength = pEdit->GetWindowTextLength();
 
 if(nLength<10000) pEdit->SetSel(nLength, nLength);
 else pEdit->SetSel(nLength-10000, nLength);
 pEdit->ReplaceSel(str);
 pFrame->RecalcLayout();

}

/*-----------------------------------------------------------------------------------*/
/*-------------- Extern File에서 다일로그제어 ---------------------------------------*/
/*-----------------------------------------------------------------------------------*/
#include "TestDlg.h"
CTestDlg *TestDlg; 
TestDlg=NULL; 

 if(TestDlg->GetSafeHwnd() == NULL) 
 {
  TestDlg= new CTestDlg;
  TestDlg->Create(IDD_TESTDIALOG1);
  //manu_Swstatus = MENU_MANUAL;//3
 }
 TestDlg->ShowWindow(FALSE);
// TestDlg->SetDlgItemText(IDC_DLGSTATIC,"TEST 2006.12");
 TestDlg->m_csData="Dlg Text 2006";

 

 if(TestDlg->GetSafeHwnd() != NULL) TestDlg->ShowWindow(true);


 if(TestDlg->GetSafeHwnd() != NULL)
 {
  CString csTmp;
  TestDlg->GetDlgItemText(IDC_DLGSTATIC,csTmp);
  AfxMessageBox(csTmp);
 }

 //============================================================
 void ResultShowDlgBar(CString str)
 {
 CMainFrame *pFrame = (CMainFrame *)AfxGetMainWnd();
 CRect rect; 
 pFrame->GetWindowRect(&rect);

 if (!pFrame->m_ResultShowBar.IsWindowVisible())
 {
  pFrame->DockControlBar(&pFrame->m_ResultShowBar);
  pFrame->m_ResultShowBar.ShowWindow(SW_SHOW);
  pFrame->FloatControlBar(&pFrame->m_ResultShowBar,CPoint(rect.right-324,rect.bottom-125));
 }


 CEdit *pEdit = (CEdit *)pFrame->m_ResultShowBar.GetDlgItem(IDC_RESULTSHOW);
 int nLength = pEdit->GetWindowTextLength();
 
 if(nLength<10000) pEdit->SetSel(nLength, nLength);
 else pEdit->SetSel(nLength-10000, nLength);
 pEdit->ReplaceSel(str);
 pFrame->RecalcLayout();
}
/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/
/*-------------- 다일로그 확장-------------------------------------------------------*/

 int m_nNormalWidth;
 int m_nExpandedWidth;
 BOOL m_bExpanded;

   void  CExpandDlgDlg::ExpandyaContract()
   {
 CRect rcDlg, rcMarker;
 GetWindowRect(rcDlg); 
 
 if (!m_bExpanded)
 {
  m_nExpandedWidth = rcDlg.Width(); 
  m_Devide.GetWindowRect(rcMarker); 
  m_nNormalWidth = (rcMarker.right - rcDlg.left);
  rcDlg.SetRect(rcDlg.left, rcDlg.top,    rcDlg.left + m_nNormalWidth+12,
   rcDlg.top + rcDlg.Height()); 
  HWND hWndChild = ::GetDlgItem(m_hWnd, IDC_STATIC_DEVIDE);
 
  while (hWndChild != NULL)
  {  
   hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT);
   ::EnableWindow(hWndChild, m_bExpanded);
  }

 }
 
 else 
 {
  rcDlg.SetRect( rcDlg.left, rcDlg.top,    rcDlg.left + + m_nExpandedWidth,
   rcDlg.top + rcDlg.Height() ); 
  HWND hWndChild = ::GetDlgItem(m_hWnd, IDC_STATIC_DEVIDE);
  
  while (hWndChild != NULL)
  {  
   hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT);
   ::EnableWindow(hWndChild, m_bExpanded);
  }
  
 } 
 
 MoveWindow(rcDlg, TRUE);
 
 m_bExpanded = !m_bExpanded; 
 

  }

/*-----------------------------------------------------------------------------------*/
/*-------------- 투명 다일로그-------------------------------------------------------*/
#define WS_EX_LAYERED 0x00080000 
#define LWA_COLORKEY 1 // Use color as the transparency color.
#define LWA_ALPHA    2 // Use bAlpha to determine the opacity of the layer

typedef BOOL (WINAPI *lpfn) (HWND hWnd, COLORREF cr, BYTE bAlpha, DWORD dwFlags);
lpfn g_pSetLayeredWindowAttributes;


 HMODULE hUser32 = GetModuleHandle(_T("USER32.DLL"));
     g_pSetLayeredWindowAttributes = (lpfn)GetProcAddress(hUser32, "SetLayeredWindowAttributes");
    HWND m_hCurrWnd;    //  Handle to the window over which the mouse was last present
 m_hCurrWnd=*this;
     if  (g_pSetLayeredWindowAttributes)
     {
          ::SetWindowLong(m_hCurrWnd, GWL_EXSTYLE, GetWindowLong(m_hCurrWnd, GWL_EXSTYLE) | WS_EX_LAYERED);
          g_pSetLayeredWindowAttributes(m_hCurrWnd, 50, 100, LWA_ALPHA);
 }
/*-----------------------------------------------------------------------------------*/
/*-------------- Windows 이벤트------------------------------------------------------*/
        #define define WSA_ASYNC    (WM_USER+1)
 //.h-----------------------------------
 protected:
   //{{AFX_MSG(CHDDINSPView)
   afx_msg LONG UDPOnReceive(UINT,LONG);

 //.cpp----------------------------------
 BEGIN_MESSAGE_MAP(CHDDINSPView, CFormView)
  //{{AFX_MSG_MAP(CHDDINSPView)
   //}}AFX_MSG_MAP
  ON_MESSAGE(WSA_ASYNC,UDPOnReceive)

 LONG CHDDINSPView::UDPOnReceive(UINT wParam, LONG lParam)
 {
 }

/*-----------------------------------------------------------------------------------*/
/*-------------- 스레드에서 변수 참조------------------------------------------------*/

UINT RepeatThread(LPVOID pFuncData)
{
 CCAMCFS20Dlg *pParent = (CCAMCFS20Dlg *)pFuncData; 
 INT16 nAxis;
 double dDistance, dVelocity, dAccel;

 nAxis  = pParent->m_nAxis;
 dDistance = pParent->GetDlgItemDouble(IDC_DISTANCE);
 dVelocity = pParent->GetDlgItemDouble(IDC_VELOCITY);
 dAccel  = pParent->GetDlgItemDouble(IDC_ACCELERATION);
 pParent->bRepeatFlag = TRUE;
}

void CWinColorView::OnDraw(CDC* pDC)
{
 CWinColorDoc* pDoc = GetDocument();
 ASSERT_VALID(pDoc);

 // TODO: add draw code for native data here
 if(pDoc->m_InImg==NULL) return;

 height = pDoc->dibHi.biHeight;
 width = pDoc->dibHi.biWidth;
 rwsize = WIDTHBYTES(pDoc->dibHi.biBitCount*pDoc->dibHi.biWidth);
 BmInfo->bmiHeader = pDoc->dibHi;

 SetDIBitsToDevice(pDC->GetSafeHdc(),0,0,width,height,
      0,0,0,height,pDoc->m_InImg,BmInfo, DIB_RGB_COLORS);
}

 

/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// -    기타 정리    -  ///////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

//------폴더안에 include화일 참조--------------------------------------------------------//
#include "../include/PortInclude.h"

//---------------------------------------------------------------------------------------//


//---시간 계산---------------------------------------------------------------------------// 
double m_lStartTimeOneChipCycle = GetCurrentTime();
double m_lEndTimeOneChipCycle = GetCurrentTime();
double m_OneCycleTime=(m_lEndTimeOneChipCycle - m_lStartTimeOneChipCycle) * 0.001;
//---------------------------------------------------------------------------------------// 

/* 선언부 */
#define  PI  3.1415926535 
#include <math.h>
#define   RADIUS  150   

// 1. 영역구함

CRect rect;
GetClientRect(rect);

// 2. 이미지 중간점 구함

int  m_nCenterX       = rect.Width() / 2;  // Center X point 
int  m_nCenterY       = rect.Height()/ 2;  // Center Y point

// 3. 반지름 

int  nHalf      = RADIUS; // 반지름 

// 4. 계산할 각도 구함 

int  m_nAngle = 0;
m_nAngle = 360 / m_nRingNum;  //  m_nRingNum <-- 점의 갯

// 5. 저장할 점 선언

CPoint  *pt;
for ( int i = 0; i < m_nRingNum ; i++)

{
    int nAxisX = 0;
    int nAxisY = 0;

    if( i == 0)
    {
        nAxisX      = (int)(    cos(360*(PI / 180)) * nHalf );          // X point
        nAxisY      = (int)(    sin(360*(PI / 180)) * nHalf );          // Y point
    }
    else

    {   
        nAxisX      = (int)(    cos((m_nAngle*i)*(PI / 180)) * nHalf    );      // X point
        nAxisY      = (int)(    sin((m_nAngle*i)*(PI / 180)) * nHalf    );      // Y point
    }
    // 6. 구한 점 저장

    pt[i].x = nAxisX;
    pt[i].y = nAxisY
}


/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - 다른프로그램 실행 -  /////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/


/*------인터넷사이트 실행------------------------------------------------------------*/
 WinExec("C:\\Program Files\\Internet Explorer\\IEXPLORE.EXE www.taeyang.com",SW_SHOW);

 WinExec("C:\\YeTools\\CpComSys\\CpPrc.exe",SW_SHOWMINIMIZED);

/*------응용프로그램 실행------------------------------------------------------------*/
 h. 헤더파일 선언 PROCESS_INFORMATION m_pi; //다른 프로그램 자동 실행및 종료를 위한
 

 STARTUPINFO StartupInfo = {0};
 StartupInfo.cb = sizeof(STARTUPINFO);
 PROCESS_INFORMATION ProcessInfo;
 
 StartupInfo.dwFlags = STARTF_USESHOWWINDOW; 
 StartupInfo.wShowWindow = SW_HIDE;//안보이기 SW_SHOWMINIMIZED-최소화
 
 if(!::CreateProcess(NULL, "C:\\YeTools\\CpComSys\\DLL\\CpPrc.exe", 
        //if(!::CreateProcess(NULL, "DataCPK.exe", 
 NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo))
 {
 AfxMessageBox("C:\\YeTools\\CpComSys\\CpPrc.exe 실행 화일을 찾을 수 없습니다.");
 }
 m_pi = ProcessInfo;


 // 종료------Close------------------------
 HANDLE Killprocess;
 CString szKillProgramName;
 szKillProgramName = "C:\\YeTools\\CpComSys\\CpPrc.exe";//종료할 프로그램 위칭르 넣으 시요..
     Killprocess = OpenProcess(PROCESS_TERMINATE,0,m_pi.dwProcessId);
     TerminateProcess(Killprocess, (unsigned)-1);

C:\\Program Files\\Amfis1130\\SigmaTV.exe
/*
 CloseHandle(m_pi.hProcess);
 CloseHandle(m_pi.hThread);
 LPSTR    gAppName = "C:\\YeTools\\CpComSys\\CpPrc.exe";
 if (FindWindow(gAppName, NULL)) {
     PostQuitMessage(0);
 }
*/

/*------NOTE PAD 실행------------------------------------------------------------*/
 char csNote[128];
 strcpy(csNote,"c:\\Windows\\NOTEPAD ");
 strcat(csNote,filename);
 WinExec(csNote,SW_SHOW);


/*------파일열기 다일로그------------------------------------------------------------*/

      void CFileDlgDlg::OnOpenFile() 
      {
 // TODO: Add your control notification handler code here
 CFileDialog dialog( TRUE,// TRUE : FileOpen, FALSE :FileClose
 _T("txt"),   // 디폴트 확장자 
 _T("C:\\Data\\*.*"),  // 디폴트 파일명 --마지막\\*.*
 OFN_ALLOWMULTISELECT | OFN_FILEMUSTEXIST| OFN_SHOWHELP,
 // OPENFILENAME
 // OFN_CREATEPROMPT
 "텍스트 파일 (*.txt) | *.txt |데이타 파일 (*.dat; *.hex) | *.dat; *.hex|모든 파일 (*.*) | *.* ||",
 // 필터 
 // 부모 윈도우
 NULL
 );

 dialog.DoModal();
     }

 //---------------------------------------------------------------
 CString InitialDir=Path_Image;// AfxMessageBox(Path_Model);
 InitialDir+="*.*";

 CString Title      = "SET IMAGE LOAD";
 //-------------------
 LPSTR File = InitialDir.GetBuffer(InitialDir.GetLength()*2);  //*char

 CFileDialog ImgDlg(TRUE,_T(Title),_T(InitialDir),OFN_ALLOWMULTISELECT | OFN_FILEMUSTEXIST| OFN_SHOWHELP,  
// CFileDialog ImgDlg(TRUE,_T(Title),File,OFN_ALLOWMULTISELECT | OFN_FILEMUSTEXIST| OFN_SHOWHELP,  
  "Image files (*.jpg)|*.jpg||",NULL);

 if (ImgDlg.DoModal()==IDOK)
 {
     //   tmModel.SetImage = ExtractFileName(ImgDlg->FileName);
     //   dpSname->CaptionFalse = tmModel.SetImage;
     }
 //---------------------------------------------------------------

      void CFileDlgDlg::OnSaveFile() 
      {
 // TODO: Add your control notification handler code here
        CFileDialog dialog( FALSE,// TRUE : FileOpen,// FALSE :FileClose
                _T("txt"),   // 디폴트 확장자
                    _T("C:\\Data\\Untitled.txt"), // 디폴트 파일명 
       OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY,
    // OPENFILENAME
    // OFN_CREATEPROMPT
      "텍스트 파일 (*.txt) | *.txt |데이타 파일 (*.dat; *.hex) | *.dat; *.hex|모든 파일 (*.*) | *.* ||",
   // 필터 
   // 부모 윈도우
                    NULL
   );
 dialog.DoModal(); 
    }
 //===읽기/저장========================================================

 CString szFileName=""; CString csFileName="";
 CString szFileDir="";

 CString csTmp="";  CString csCh=""; CString csLoad="";

// CFileDialog filedlg(TRUE,_T(""),_T(csTmp),OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,//열기 
 CFileDialog filedlg(FALSE,_T(""),_T(csTmp),OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,//저장  
  "Save AS Excel CSV Files (*.csv)|*.csv||",NULL);//"files (*.*)",NULL);

 if (filedlg.DoModal()==IDOK)
 {
 szFileDir=filedlg.GetPathName();   AfxMessageBox(szFileDir);//전체 화일+확장자까지
 szFileName=filedlg.GetFileTitle();    AfxMessageBox(szFileName);//입력 화일명만  
 szFileName=filedlg.GetFileName();      AfxMessageBox(szFileName);//입력 화일과 확장자 까지 

 //화일명 뺀 화일 Dir 
 int index1=0; int index2=0; int nMode=0;
 index1=szFileDir.GetLength(); index2=szFileName.GetLength(); 
 csTmp=szFileDir.Mid(0,(index1-index2)); 


 
 szFileName=csTmp; AfxMessageBox(szFileName);
 //_mkdir(szFileName);
 }
  
 //===읽기========================================================
 //---------------------------------------------------------------
 csFileDir=filedlg.GetPathName(); //전체 디렉토리+화일명+확장자
 csFileName=filedlg.GetFileName();//화일명+확장자
 //---------------------------------------------------------------
 CString strFilter;
 strFilter.LoadString(AFX_IDS_PICTUREFILTER);

 CString strTitle;
 strTitle.LoadString(AFX_IDS_PICTUREBROWSETITLE);

 CFileDialog fdlg(TRUE, NULL, NULL,
   OFN_FILEMUSTEXIST |
   OFN_HIDEREADONLY |
   OFN_PATHMUSTEXIST,
   strFilter);

 fdlg.m_ofn.lpstrTitle = strTitle;

 int nResult = fdlg.DoModal();
 SetFocus();

 if (nResult != IDOK)
  return;

 CString strPath = fdlg.GetPathName();
 //---------------------------------------------------
 CString csFileName="";
 CString csFileDir=""; 
 CString csOpenDir; csOpenDir=CSProgramDir+CSFileSpecDataDir+CSDriveDataFileName+"\\";

 CFileDialog filedlg(TRUE,_T("*.INI"),_T(csOpenDir),OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
  "INI files (*.ini)|*.ini||",NULL);

 if (filedlg.DoModal()==IDOK)
 {
  csFileDir=filedlg.GetPathName();
  CString csTmp;CString csBuf; CString csImage;
  if(csFileDir.GetLength()>0)
  {
  UpdateData(TRUE);
  CString csDriveName=csFileDir;
  CString filename = csDriveName;//+".ini";
  FileData_UpdateCommandData(filename);
  CommandDataUpdateDisplay();
  UpdateData(FALSE);
  }
 }

 //------------------------------------------------------------------
 CString szFileName;

 CFileDialog filedlg(TRUE,"bmp",NULL,OFN_FILEMUSTEXIST,
  "BMP files (*.bmp)|*.bmp||",NULL);
// if (freezeMode==FREEZE_BITMAP)
 {
  if (filedlg.DoModal()==IDOK)
  {
  szFileName=filedlg.GetPathName();
  szFileName=filedlg.GetFileName();
  }
 }
 
       //-----------------------------------------------------------
 int result;
 result=filedlg.DoModal();

 switch(result)
 {
 case IDOK:
  szFileName=filedlg.GetPathName();
   break;
 }
   return;

 

/*------실행화일 디렉토리 구하기--- -------------------------------------------------------*/
//--------SetCurrentDirectory----------------------------------------------------------------
 if( mDAT.tot < 1 )       return;
 int  stat;
 char *str;
 CString  fname;
 DATE_INF day;
 str = new char[MAX_PATH+10];
 ::GetCurrentDirectory(MAX_PATH+1,str);
 uiGetSysDate(&day);
 fname.Format(_T("DOC\\%s%04d%02d%02d.TXT"),
 //-----------------------------------------------------------
 (char *)(LPCTSTR)mDAT.pid,day.yy%100,day.mo,day.dd);
 //-----------------------------------------------------------
 CFileDialog  dlg(FALSE,"DOC",fname,OFN_HIDEREADONLY,"프린트화일 (*.TXT)|*.TXT");
 stat = dlg.DoModal();
 ::SetCurrentDirectory(str);
 delete str;
 if( stat != IDOK )       return;
 fname = dlg.GetPathName();     ApSaveSeekDataInfor(fname,mDAT);


 char *str;
 CString  fname;
 str = new char[_MAX_PATH+1];
 ::GetCurrentDirectory(_MAX_PATH+1,str);

 AfxMessageBox((LPCTSTR)(char *)str);

 

/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - POINT -  /////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

//======MEMCPY 생성=======================================================================


 unsigned char *OutImg = NULL;
// OutImg = new unsigned char [(nWidth*Bit)*nHeight*3];
 OutImg = (unsigned char*)calloc(nWidth*Bit*nHeight*3,sizeof(char));


 BYTE *outBuf=NULL;


 long bufsize = (long)w * 3 * (long)h;
 outBuf=(BYTE *) new BYTE [bufsize];

 outBuf=NULL;
 outBuf = new unsigned char [bufsize]; //dibHi.biSizeImage
// outBuf=(BYTE *) new BYTE [bufsize];

 

//======MEMCPY============================================================================

 int ImgSize=(width*24)*height*3;//24
// int ImgSize=(width*8)*height;//8

 memcpy(BufImg,BufImg2,ImgSize);

//======unsigned char,UINT * nWidth=======================================================

 UINT * nWidth,  UINT * nHeight
 BYTE * BufImg;
 BufImg=NULL;
 BufImg = new unsigned char [ImgSize]; //dibHi.biSizeImage

 *nHeight = NULL;
 *nWidth = NULL;

 *nHeight=height;
 *nWidth=width; 


 CVisionSysView* pView =( CVisionSysView* )((CMainFrame*)AfxGetApp()->m_pMainWnd)->GetActiveView();
 CDC *pDC =pView->GetDC();
 //----------------------------------
 int rwsize = WIDTHBYTES(24*width);
 int ADDr,ADDg,ADDb;
 //----------------------------------
 int x=0; int y=0;
  for(y=0; y<height; y++)
  {
   for(x=0; x<width; x++) 
   {
    ADDr=(y*rwsize)+(3*x)+2;
    ADDg=(y*rwsize)+(3*x)+1;
    ADDb=(y*rwsize)+(3*x)+0;

    *(BufImg+ADDr)=BufImg2[ADDr];  // r
    *(BufImg+ADDg)=BufImg2[ADDg];  // g
    *(BufImg+ADDb)=BufImg2[ADDb];     // b

    pDC->SetPixel(x+400,y,RGB(BufImg[ADDr],BufImg[ADDg],BufImg[ADDb]));
    //pDC->SetPixel(col,row,RGB(pixel[2],pixel[1],pixel[0]));
   }
  }

 


//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - 화 일 -  /////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//=======================================================================================
 FILE  *inn;
 int   i;
 CString  fstr = SysDir;
 fstr += "\\calibration.rsl";

 if( (inn= fopen(fstr,"r") ) != NULL )
 {
  for(i=0;i<7;i++)
   fscanf(inn,"%lf",&m_Calib.Val[i]);
  fclose(inn);
 }
 else
  AfxMessageBox("File could not be opened.",MB_OK,0);
  
//=======================================================================================
 FILE  *inn;
 CString  fstr = SysDir;
 fstr += "\\rotate.rsl";

 if( (inn= fopen(fstr,"w") ) != NULL )
 {
  fprintf( inn, "%lf %lf %lf %lf\n",m_Rotate.a,m_Rotate.b,m_Rotate.c,m_Rotate.d);
  fclose(inn);
 }
 else
  AfxMessageBox("File could not be opened.",MB_OK,0);

//===============화일 복사===============================================================
 sFileName=strSelectedPath + "\\" + "Pcb.dat";
 tFileName=strBackUpPath + "\\" +"Pcb.dat";
 CopyFile(sFileName, tFileName , false);

//===============확장자 검색=============================================================
  fileName=fileDlg.GetPathName();
  CString ext=fileName.Right(4);

  if (!ext.CompareNoCase(".JPG"))
  {
  // AX_LoadJPG(fileName);
  // SetDlgItemText(IDC_FILEDIR_STATIC, fileName);
  }

  if (!ext.CompareNoCase(".BMP"))
  {
   LoadBMPToSet(fileName);
  // SetDlgItemText(IDC_FILEDIR_STATIC, fileName);
  }

//=======================================================================================

 FILE *fp;

 fp=fopen(fileName,"rb");
 if (fp==NULL) {
  CString msg;                    
  msg="Can't open file for reading :\n"+fileName;
  m_errorText=msg;
  return NULL;
 } 
 else
 {
  if (fread((void  *)(pixel),1,3,fp)==3) 
  { 
   *(outBuf+ADDr)=pixel[2];  // r
   *(outBuf+ADDg)=pixel[1];  // g
   *(outBuf+ADDb)=pixel[0]; 
  }
 }
 fclose(fp);

//=====================================================================================

 HFILE fi;

 CString Contents=csData; CString csfilename="";
// csfilename=CSFileTestDataDir+csFileName;
 csfilename =FileData_TestFileDirChk(csFileName, nMode, nCh);
 fi=_lopen(csfilename,OF_READWRITE);
 int len;
 len=_lwrite(fi,(LPCSTR)m_csTestFileData[nCh],strlen(m_csTestFileData[nCh]));
 _lclose(fi);

/*------파일 -------------------------------------------------------*/
 CString   csfilename=_T(""); CString   Contents=_T("");

 if(nCh>=CHMAX) return Contents;
// filename = CSFileTestDataDir+csFileName;
 csfilename =FileData_TestFileDirChk(csFileName, FILE_CSV, nCh);

 CFile file(csfilename,CFile::modeReadWrite|CFile::shareExclusive);
// CFile file("C:\\Polaronix\\Data\\Ch01.csv",CFile::modeReadWrite |CFile::shareExclusive);
 DWORD filesize=file.GetLength();
 char *buf=new char[filesize+1];

 file.Read(buf,filesize);
 file.Close(); 

 buf[filesize]=NULL;
 Contents=LPCSTR(buf);   delete buf;
 return Contents;

/*------파일 -------------------------------------------------------*/
 CString csData="";
 char* pFileName = "C:\\Polaronix\\Data\\Ch01.csv";
 CStdioFile file;
 if( !file.Open( pFileName,
  //  | CFile::modeWrite | CFile::typeText ) ) {
   CFile::modeRead | CFile::typeText ) ) {  
 }
 file.ReadString(csData);
 AfxMessageBox(csData);
 file.Close();
 
/*------파일 Open--------------------------------------------------*/
 csBmpFile=_T("Bin\\bmp3_96.bin");

 CFile *aFile;
 try
 {
  aFile=new CFile(csBmpFile,CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone);
 }
 catch(CFileException *e)
 {
  e->Delete();
 }
 aFile->Abort(); //파일 닫기 실한 경우 예외 발생 않함 
// aFile->Close();
// delete aFile;

 


 CString csBmpFile;
 csBmpFile=_T("Bin\\bmp1_128.bin");

 CFile *aFile;
 try
 {
 // UINT readByte;
  aFile=new CFile(csBmpFile,CFile::modeNoTruncate|CFile::modeReadWrite|CFile::shareDenyNone);

  if(m_ZoomSize_X==96)
  {
  aFile->Write(temp2,12288);
  }
  else
  {
  aFile->Write(temp2,24576);
  }
 }
 catch(CFileException *e)
 {
  e->Delete();
 }

 aFile->Abort(); //파일 닫기 실패한 경우 예외 발생 않함 
// aFile->Close();
// delete aFile;

 

/*------파일 Open--------------------------------------------------*/

 HFILE fi;
 fi=_lopen("Bin\\bmp.bin",OF_READWRITE);

 int len;
 len=_lwrite(fi,(LPCSTR)temp1,strlen(temp1));

 _lclose(fi);


 FILE *fp;
 filename="Bin\\bmp.bin";

 if ((fp = fopen(filename,"w+")) == NULL) {
  AfxMessageBox("File Open Error.");  
  fclose(fp);
  return ;
 }
// Contents.Insert(Contents.GetLength(),
// Contents.Format(csBmp);
 fwrite(Contents,1,Contents.GetLength(),fp);
 fclose(fp);

/*------파일 Open--------------------------------------------------*/
#SETUP$
DF34257
CAS124T0
AS1234DF
SDFG4321
#ENDEQ$

void CSBottleView::FileDataUpdate(int nMode)
{
 CString csItemNameSelectFileName=_T("EquipSys\\ItemNameSelect.ini");

 __int16   length, exist;
 char   str[200];
 int index=0;
 int nCount=0;

 FILE   *fp ;
 CString   filename=_T("");
 CString   ReadData=_T("");
 CString   strTmp=_T("");
 BOOL   bFileCheck=false;
 BOOL   bFileCheck2=false;

 m_csModelItemName[1]=_T("");
 m_csModelItemName[2]=_T("");
 m_csModelItemName[3]=_T("");
 m_csModelItemName[4]=_T("");


 if(nMode==ITEMNAME)
 filename = csItemNameSelectFileName;
 else return;

 exist = access(filename,0); 

 if (!exist && (fp = fopen(filename,"rt")) != NULL) {
  while (!feof(fp)) {
   ReadData.Empty();
   if ( fgets(str, 200, fp) != NULL) {   // error Return NULL
    ReadData.Format("%s", str);
    length = ReadData.GetLength();

    if(bFileCheck2==false)
    {
    index = ReadData.Find("#SETUP$");
    if(index>=0){bFileCheck=true; index=0; }
    else{AfxMessageBox("설정 데이타가 없습니다 !"); break;}
    }

    index = ReadData.Find("\t");
    if(index>=0)
    {
    ReadData.Format("%s", ReadData.Mid(0 , length-2));
    }
    else
    {
    ReadData.Format("%s", ReadData.Mid(0 , length-1));
    }
  
    if(ReadData=="#ENDEQ$"){break;}

    if(bFileCheck)
    {
     if(bFileCheck2)
     {
      if(nCount>=60){AfxMessageBox("저장된 데이타가 너무많습니다");break;}
      
      if(nCount==0)
      {m_csModelItemName[1]=ReadData;}
      else if(nCount==1)
      {m_csModelItemName[2]=ReadData;}
      else if(nCount==2)
      {m_csModelItemName[3]=ReadData;}
      else if(nCount==3)
      {m_csModelItemName[4]=ReadData;}
      nCount++;
     }
    }
       bFileCheck2=true;
   }
  }
 /// fclose(fp);

 } else {
  AfxMessageBox("설정데이타가 없습니다!  ItemNameSelect.data 화일이 없습니다."); return;//return 않하면 프로그램 에러
 }
 fclose(fp);

 UpdateData(FALSE);
}

/*------파일 Open--------------------------------------------------*/

 FILE *fpRobot;
 CString str;

 fpRobot = fopen("robot.txt", "rw+");
 fprintf(fpRobot, "%s", str);
 fclose( fpRobot );


/*------파일 생성 및 NotePad로 실행--------------------------------------------------*/
 FILE *fp;
 CString Contents, datename, filename;

 filename="test.txt";

 if ((fp = fopen(filename,"w+")) == NULL) {
  AfxMessageBox("File Open Error.");  
  fclose(fp);
  return ;
 }

 Contents.Format("\r\n=== FILE INFORMATION ===\r\n");
 Contents.Insert(Contents.GetLength(),"\r\nDATE & TIME\t");
 Contents.Insert(Contents.GetLength(),datename);

 Contents.Insert(Contents.GetLength(),"\r\nOPERATOR\t");

 Contents.Insert(Contents.GetLength(),"\r\n\r\nFile Name\t");
 Contents.Insert(Contents.GetLength(),filename);
 Contents.Insert(Contents.GetLength(),"\r\n\r\n");

 Contents.Insert(Contents.GetLength(),"=== ERROR LISTS ===\r\n\r\n");

 Contents.Insert(Contents.GetLength(),
  " ERR TIME\tCODE\tERROR MESSAGE                  \tOPERATORr\n\r\n");

 fwrite(Contents,1,Contents.GetLength(),fp);
 fclose(fp);

 char csNote[128];
 strcpy(csNote,"c:\\Windows\\NOTEPAD ");
 strcat(csNote,filename);
 WinExec(csNote,SW_SHOW);

/*----------------다른 폴더에서 파일copy 후 다른이름으로 저장 -------------*/  
 SHFILEOPSTRUCT sfo;
 memset(&sfo,0,sizeof(sfo));
 sfo.wFunc = FO_COPY;
 sfo.pFrom = _T("C:\\Aatool\\equip1.dat\0");
 sfo.pTo = _T("C:\\DATA\\suho.dat\0");
/* sfo.wFunc = FO_RENAME;
 sfo.pFrom = _T("C:\\DATA\\equip1.dat\0");
 sfo.pTo = _T("C:\\DATA\\ok.dat\0");
*/
 SHFileOperation(&sfo);


/*----------------여러 화일 삭제 -----------------------------------------------------------*/ 
 SHFILEOPSTRUCT sfo;
 memset(&sfo,0,sizeof(sfo));
 sfo.wFunc = FO_DELETE;
 sfo.fFlags =OFN_SHOWHELP; //메시지 창 뛰우지 않음
 sfo.pFrom = _T("Bmp\\*.*");
 SHFileOperation(&sfo);


/*------------------------------화일삭제--DeleteFile---------------------------------------*/

 UpdateData(TRUE);
   CCPKView* pView =( CCPKView* )((CMainFrame*)AfxGetApp()->m_pMainWnd)->GetActiveView();
 
 CCPKDoc *pDoc;
 pDoc=pView->GetDocument();
 int year,month;
 year=month=0;
 year=2001;
 month=5;

 if(AfxMessageBox(" ''Are You Sure ! DataBase delete ?'' ",MB_ICONQUESTION|MB_YESNO)==IDYES)
 {
   pDoc->DeleteDB(year,month);
  }
 else
  {
   return;
 }

void CCPKDoc::DeleteDB(int year, int month)
{
 CString csFile;
 
 csFile.Format("DATA\\CPK%4d%02d.mdb", year, month);
 DeleteFile((LPCTSTR)csFile);
 
 csFile.Format("DATA\\CPK%4d%02d.ldb", year, month);
 DeleteFile((LPCTSTR)csFile);
}
 
 SHFILEOPSTRUCT sfo;
 memset(&sfo,0,sizeof(sfo));
 sfo.wFunc = FO_DELETE;
 sfo.pFrom = _T("C:\\DATA\\200101.mdb\0");
 SHFileOperation(&sfo);

/*----------------------------------Windows 레지스트리에 저장-----------------------*/
void CPSRecorderView::INI_Get()
{
 char buff[1024];
 CString m_csTmpString;
 m_csTmpString = "NONE";
 GetPrivateProfileString("TIME", "TESTTIME1", m_csTmpString.operator const char * (), (LPTSTR)buff, 20, "SAET32.INI");
 m_fTestTime1= (float)atof((LPCSTR)buff);
}

void CPSRecorderView::INI_Write()
{
 CString m_csTmpString;
 m_csTmpString = "NONE";
 m_csTmpString.Format("%0.1f", m_fTestTime1);
 WritePrivateProfileString("TIME", "TESTTIME1", m_csTmpString.operator LPCTSTR(), "SAET32.INI");
}

/*----------------------------------시간 얻기-------------------------------------*/
 COleDateTime ccTestTime;
 CString strTmp;

 ccTestTime=COleDateTime::GetCurrentTime();
// strTmp=ccTestTime.Format("%I:%M:%S %p");
 strTmp=ccTestTime.Format("%I:%M:%S");
 m_clbTime.SetCaption(strTmp);

 int nTime;
 COleDateTime odtDate=COleDateTime::GetCurrentTime();
 nTime=odtDate.GetYear();
 nTime=odtDate.GetMonth();
 nTime=odtDate.GetDay();
 nTime=odtDate.GetHour();
 nTime=odtDate.GetMinute();
 nTime=odtDate.GetSecond();


 SYSTEMTIME SystemTime, SystemTime2; 
 GetSystemTime( &SystemTime); 

 GetSystemTime( &SystemTime2);
 TRACE("JOG MINUS Time Value = %d \n", SystemTime2.wMilliseconds - SystemTime.wMilliseconds); 


/*----------------------------------BMP File저장-------------------------------------*/
void CCoilView::OnSaveimg() {
CFileDialog filedlg(FALSE,"bmp",NULL,OFN_OVERWRITEPROMPT,
 "BMP files (*.bmp)|*.bmp||",this);
 if (filedlg.DoModal()!=IDOK)
  return;
CColorBmpFile bmp;
 bmp.OpenWrite(filedlg.GetPathName(),640,480);
 for (int y=479; y>=0; y-=2) {
 BYTE rbuffer[640],gbuffer[640],bbuffer[640];
  Data->GetLine(y,rbuffer,gbuffer,bbuffer);
  bmp.WriteLineUpward(rbuffer,gbuffer,bbuffer);
  bmp.WriteLineUpward(rbuffer,gbuffer,bbuffer);
 }
 bmp.Close();
 m_strMessage = "저장되었습니다.";
 UpdateData(FALSE);
}


/*----------------------------------goto-------------------------------------*/
 goto fail;
 
 fail:
 MessageBox(NULL,"에러 입니다.","오류",MB_OK);
 return FALSE;

 

/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - 이미지 -  ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)


//======Center부터 검색 ======================================================================================
 //===CenterSearch===========================
 int x2=0, y2=0;
 int half_x=width/2; int half_y=height/2;
 float direct_y=-1; float direct_x=-1;
 int Cnt_y1=0;int Cnt_y2=0;
 int Cnt_x1=0;int Cnt_x2=0;
 //==========================================

 for(y=0; y<height-tHeight; y++) 
 {
  //=====CenterSearch===================================
  Cnt_y1++;
  if(Cnt_y1>=2){Cnt_y1=0;Cnt_y2++;}
  if(direct_y==1)direct_y=float(-1); else direct_y=1;
  y2=int( half_y + (Cnt_y2* direct_y) );
  Cnt_x1=0; Cnt_x2=0; direct_x=-1;
  //===================================================
  for(x=0; x<width-tWidth; x++) 
  {
   //=====CenterSearch================================
              Cnt_x1++;
   if(Cnt_x1>=2){Cnt_x1=0;Cnt_x2++;}
   if(direct_x==1)direct_x=float(-1); else direct_x=1;
   x2=int( half_x + (Cnt_x2* direct_x) );
   //=================================================

   pDC.SetPixel(x2+100,y2+100,RGB(255,0,0));

  }
 }
//==========================================================================================================
void ReadArrayToPointBit24(BYTE * OutImg, unsigned char BufImg[768][1024], UINT width, UINT height)
{
 CVisionSysView* pView =( CVisionSysView* )((CMainFrame*)AfxGetApp()->m_pMainWnd)->GetActiveView();
 CDC *pDC =pView->GetDC();
 //GrayImage =width*3;
 //Dispay Image= ((24*width)+31)/32*4), ((DWORD)(((bits)+31) & (~31)) / 8)
 //if(BufImg==NULL) return;
 int x,y; int y2=0;
 int nBit=0; nBit=24;

 int rwsize = WIDTHBYTES(nBit*width);

 int ADDr=0,ADDg=0,ADDb=0; 
  if(BufImg!=NULL)
  {
   for(y=0; y<nHeight; y++)
   {
    for(x=0; x<nWidth; x++)
    {
     y2=((height-1)-y);//-1 은 첫줄이 않나옴, y가 0일경우 문제
    // y2=y;//-1 은 첫줄이 않나옴, y가 0일경우 문제

     ADDr=(y2*rwsize)+(3*x)+2;
     ADDg=(y2*rwsize)+(3*x)+1;
     ADDb=(y2*rwsize)+(3*x)+0;

    // BufRevImg[ADDr]=BufImg[y][x];
    // BufRevImg[ADDg]=BufImg[y][x];
    // BufRevImg[ADDb]=BufImg[y][x];
     *(OutImg+ADDr)=BufImg[y][x];
     *(OutImg+ADDg)=BufImg[y][x];
     *(OutImg+ADDb)=BufImg[y][x];
    // pDC->SetPixel(x+400,y,RGB(BufImg[ADDr],BufImg[ADDg],BufImg[ADDb]));
    // pDC->SetPixel(x+400,y,RGB(BufImg[y][x],BufImg[y][x],BufImg[y][x]));
    }
   }
  }
}

//==========================================================================================================
void CVisionSysView::OnDraw(CDC* pDC) 
{
 // TODO: Add your specialized code here and/or call the base class
 CVisionSysDoc* pDoc = GetDocument();
 ASSERT_VALID(pDoc);
 CMainFrame *pFrame= (CMainFrame*)AfxGetMainWnd();
 ASSERT(pFrame); 

/// return;
 int height=m_height;int width=m_width;  int Bit=m_Bit;
 int rwsize = WIDTHBYTES(Bit*width);
 BITMAPINFOHEADER bmiHeader;
 bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
 bmiHeader.biWidth = width;  bmiHeader.biHeight = height;
 bmiHeader.biPlanes = 1;   
 bmiHeader.biBitCount = Bit;
 bmiHeader.biCompression = BI_RGB;
 bmiHeader.biSizeImage = rwsize*height;//0;  
 bmiHeader.biXPelsPerMeter = 0;
 bmiHeader.biYPelsPerMeter = 0;bmiHeader.biClrUsed = 0;
 bmiHeader.biClrImportant = 0;// CRect rect;
 CRect rect;

 //=================================================================
 //--Open Gray Image--
 if(m_ColorGetImg!=NULL)//COLOR_IMAGE, SPOT_IMAGE, AUOT_IMAGE
 {
///  CPaintDC dcView(GetDlgItem(IDC_IMG_VIEW));
///  dcView.SetStretchBltMode(STRETCH_DELETESCANS);
///  GetDlgItem(IDC_IMG_VIEW)->GetClientRect(&rect);

//  StretchDIBits(dcView.m_hDC,rect.left,rect.top,rect.right,rect.bottom, 
///  StretchDIBits(dcView.m_hDC,rect.left,rect.top,width,height, 
//  StretchDIBits(pDC->GetSafeHdc(),20,20,width,height, 
//  0, 0,width, height, m_ColorGetImg, (LPBITMAPINFO)&dibHi, DIB_RGB_COLORS, SRCCOPY);
///  0, 0,width, height, m_GrayImg, (LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS, SRCCOPY);
  
//  SetDIBitsToDevice(pDC->GetSafeHdc(),0,0,width,height,
//      0,0,0,height,m_GrayImg,(LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS);
//  DibDraw(pDC,0,0,height,width,m_ColorGetImg,24);
  if(m_GrayImg!=NULL)DibDraw(pDC,0,0,height,width,m_GrayImg,Bit);
//  DibDrawReverse(pDC,0,0,height,width,m_GrayImg,24);
 }
 //=================================================================
 if(m_OutImg!=NULL)//이미지 가감 처리영상
 {
  int Add=640;
  DibDrawArrayToBit24(pDC,0+Add,0,height,width,m_OutImg,24);
 }
 //=================================================================
 // 마우스 드레그-템플레이트 정합을 위한 부분 
 if(m_flagMouse==TRUE)
 {
  //pDC->DrawEdge(&m_RectTrack,EDGE_ETCHED,BF_RECT); 
  DrawRect(pDC, m_RectTrack, RGB(0,0,255), 2);
 }
 if(pFrame->m_flagTemplate==TRUE) // template가 설정되어 있는 경우 
 {
  if(m_TempImg!=NULL)
  {
   DibDrawBit8(pDC,width+40,0,tHeight,tWidth,m_TempImg,24);
   rect.left=width+40; rect.top=0;
   rect.right=rect.left+tWidth;  rect.bottom=rect.top+tHeight;
   DrawRect(pDC, rect, RGB(255,0,0), 2);
  }
 } 
 //==================================================================
 //--이미지 검색 결과
 if(!(m_MatchPos.right==0 && m_MatchPos.bottom==0)) 
 {
  if(m_bImageSearch)
  {
  // pDC->DrawEdge(&m_MatchPos,EDGE_BUMP,BF_RECT);  
   DrawRect(pDC, m_MatchPos, RGB(255,0,0), 2);
   m_bImageSearch=FALSE;
  }
 }
 //==================================================================
 CClientDC pDC(this);

 int width=m_width;int height=m_height;
 if(m_ColorGetImg!=NULL)//COLOR_IMAGE, SPOT_IMAGE, AUOT_IMAGE
 {
//  CPaintDC dcView(GetDlgItem(IDC_IMG_VIEW));
//  dcView.SetStretchBltMode(STRETCH_DELETESCANS);
//  GetDlgItem(IDC_IMG_VIEW)->GetClientRect(&rect);
//  StretchDIBits(dcView.m_hDC,rect.left,rect.top,rect.right,rect.bottom, 
//  StretchDIBits(dcView.m_hDC,rect.left,rect.top,width,height, 
//  0, 0,width, height, m_ColorGetImg, (LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS, SRCCOPY);
  StretchDIBits(pDC.GetSafeHdc(),20,20,width,height, 
  0, 0,width, height, m_ColorGetImg, (LPBITMAPINFO)&dibHi, DIB_RGB_COLORS, SRCCOPY);
  
//  SetDIBitsToDevice(pDC->GetSafeHdc(),0,0,width,height,
//      0,0,0,height,m_ColorGetImg,(LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS);
 }

//---------BMP File Save------------------------------------------------------------------------ 
 //BMP File Save
 int ImageMaxNo=1;
 BITMAPINFOHEADER dibHi;
 BITMAPFILEHEADER dibHf;/// CClientDC pDC(this);
 int ADD1=0; int ADD2=0; int ADD3=0; 
 int x=0; int y=0; int y2=0;
 int WidthLineSize=WIDTHBYTES(24*width);
 int WidthLineSize2=WIDTHBYTES(8*width);
 unsigned char *BmpOutImg=NULL;
 BmpOutImg = new unsigned char [(height*ImageMaxNo)*(width*24)*3];

 BmpOutImg =buf;

 for(y=0; y<height*ImageMaxNo; y++) //BMP 화일로 저장 하기위해 거꾸로 저장
 {
  y2=((height*ImageMaxNo)-y);//-1 중요(최종 한줄 표현)
  for(x=0; x<width; x++)
  { 
   ADD1=(y2*WidthLineSize)+(3*x)+2;
   ADD2=(y2*WidthLineSize)+(3*x)+1;
   ADD3=(y2*WidthLineSize)+(3*x)+0;

   BmpOutImg[(y2*WidthLineSize)+(3*x)+2]=buf[(y*WidthLineSize)+(3*x)+2];
   BmpOutImg[(y2*WidthLineSize)+(3*x)+1]=buf[(y*WidthLineSize)+(3*x)+1];
   BmpOutImg[(y2*WidthLineSize)+(3*x)+0]=buf[(y*WidthLineSize)+(3*x)+0];
  // pDC->SetPixel(x+500,y,RGB(BmpOutImg[ADD1],BmpOutImg[ADD2],BmpOutImg[ADD3]));
  }
 }

 DWORD dwBitsSize = sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*256+WidthLineSize*height*sizeof(char); 
 
 dibHi.biSize=40;
 dibHi.biWidth=width;
 dibHi.biHeight=height*ImageMaxNo;
 dibHi.biPlanes=1;
 dibHi.biBitCount =24;
 dibHi.biCompression=BI_RGB;
 dibHi.biSizeImage = 3*WidthLineSize*(height*ImageMaxNo);
 dibHi.biXPelsPerMeter=0;
 dibHi.biYPelsPerMeter=0;
 dibHi.biClrUsed = dibHi.biClrImportant =0;
 
 dibHf.bfType=0x4D42; 
 dibHf.bfSize = dwBitsSize+sizeof(BITMAPFILEHEADER); // 전체파일 크기 
 if(dibHi.biBitCount==24) dibHf.bfSize -= sizeof(RGBQUAD)*256; // no pallette 
 dibHf.bfOffBits = dibHf.bfSize - WidthLineSize*height*sizeof(char); 
 dibHf.bfReserved1=dibHf.bfReserved2=0;

 FILE *outfile2;
 CString csFile; csFile.Format("C:\\Data\\D1_Project\\두오텍\\VisionSys\\bmp\\spec.bmp");
 outfile2 = fopen(csFile,"wb");

 fwrite(&dibHf,sizeof(char),sizeof(BITMAPFILEHEADER),outfile2);
 fwrite(&dibHi,sizeof(char),sizeof(BITMAPINFOHEADER),outfile2);
 fwrite(BmpOutImg,sizeof(char),3*WidthLineSize*dibHi.biHeight,outfile2);
// fwrite(buf,sizeof(char),3*WidthLineSize*dibHi.biHeight,outfile2);
 fclose(outfile2);
 if(BmpOutImg) delete []BmpOutImg;

//------------------------------------------------------------------------------------------------------------------------
void CNG::OnPaint() 
{
 CPaintDC pDC(this); // device context for painting
 
 // TODO: Add your message handler code here
 if (m_ColorImg==NULL) return;

 int height=m_height;int width=m_width; 
 int rwsize = WIDTHBYTES(24*width);

 BITMAPINFOHEADER bmiHeader;
 bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
 bmiHeader.biWidth = width;  bmiHeader.biHeight = height;
 bmiHeader.biPlanes = 1;    bmiHeader.biBitCount = 24;bmiHeader.biCompression = BI_RGB;
 bmiHeader.biSizeImage = rwsize*height;//0;  
 bmiHeader.biXPelsPerMeter = 0;
 bmiHeader.biYPelsPerMeter = 0;bmiHeader.biClrUsed = 0;
 bmiHeader.biClrImportant = 0;// CRect rect;
 
 CRect rect;

 if(m_ColorImg!=NULL)//COLOR_IMAGE, SPOT_IMAGE, AUOT_IMAGE
 {
  CPaintDC dcView(GetDlgItem(IDC_IMAGE1));
  dcView.SetStretchBltMode(STRETCH_DELETESCANS);
  GetDlgItem(IDC_IMAGE1)->GetClientRect(&rect);

  StretchDIBits(dcView.m_hDC,rect.left,rect.top,rect.right,rect.bottom, 
//  StretchDIBits(dcView.m_hDC,rect.left,rect.top,width,height, 
//  StretchDIBits(pDC->GetSafeHdc(),20,20,width,height, 
//  0, 0,width, height, m_ColorGetImg, (LPBITMAPINFO)&dibHi, DIB_RGB_COLORS, SRCCOPY);
  0, 0,width, height, m_ColorImg, (LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS, SRCCOPY);
  
//  SetDIBitsToDevice(pDC.GetSafeHdc(),0,0,width,height,
//      0,0,0,height,m_ColorGetImg,(LPBITMAPINFO)&bmiHeader, DIB_RGB_COLORS);
 }
 // Do not call CDialog::OnPaint() for painting messages
}

//-----------------------------------------------------------------------------------------------------------------------
void DibDraw(CDC *pDC, int px, int py, int height, int width, BYTE *BufImg, int Bit)
{
 int x,y; int y2=0;
 int nBit=0; nBit=Bit;
 int rwsize = WIDTHBYTES(nBit*width);//(((8*width)+31)/32*4);  // 4바이트의 배수여야 함
 BITMAPINFO *BmInfo; 
 BmInfo = (BITMAPINFO*)malloc(sizeof(BITMAPINFO)+256*sizeof(RGBQUAD));

 BmInfo->bmiHeader.biBitCount=nBit; 
 BmInfo->bmiHeader.biClrImportant=256;//0
 BmInfo->bmiHeader.biClrUsed=256;//0
 BmInfo->bmiHeader.biCompression=BI_RGB;//0

 BmInfo->bmiHeader.biHeight = height; 
 BmInfo->bmiHeader.biPlanes=1;
 BmInfo->bmiHeader.biSize=40;//=sizeof(BITMAPINFOHEADER);

 if(nBit==24)
 BmInfo->bmiHeader.biSizeImage=rwsize*height*3; 
 else
 BmInfo->bmiHeader.biSizeImage=rwsize*height; 

 BmInfo->bmiHeader.biWidth =width; 
 BmInfo->bmiHeader.biXPelsPerMeter=0;
 BmInfo->bmiHeader.biYPelsPerMeter=0;

 for(x=0; x<256; x++) // Palette number is 256
 {
  BmInfo->bmiColors[x].rgbRed= BmInfo->bmiColors[x].rgbGreen = BmInfo->bmiColors[x].rgbBlue = x; 
  BmInfo->bmiColors[x].rgbReserved = 0;
 }

 if(nBit==24)
 {
  int ADDr=0,ADDg=0,ADDb=0; 
  int ADDr2=0,ADDg2=0,ADDb2=0; 
  unsigned char *BufRevImg = new unsigned char [(width*24)*height*3];
  /* 
  if(BufImg!=NULL)
  {
   for(y=0; y<height; y++)
   {
    for(x=0; x<width; x++)
    {
     y2=((height-1)-y);//-1 은 첫줄이 않나옴, y가 0일경우 문제
     ADDr=(y*rwsize)+(3*x)+2;
     ADDg=(y*rwsize)+(3*x)+1;
     ADDb=(y*rwsize)+(3*x)+0;

     ADDr2=(y2*rwsize)+(3*x)+2;
     ADDg2=(y2*rwsize)+(3*x)+1;
     ADDb2=(y2*rwsize)+(3*x)+0;

     BufRevImg[ADDr]=BufImg[ADDr2];
     BufRevImg[ADDg]=BufImg[ADDg2];
     BufRevImg[ADDb]=BufImg[ADDb2];
    // pDC->SetPixel(x+400,y,RGB(BufImg[ADDr],BufImg[ADDg],BufImg[ADDb]));
    }
   }
  }
 */
  int ImgSize=(width*24)*height*3;//int ImgSize=(width*8)*height;//8
  memcpy(BufRevImg,BufImg,ImgSize);
 // SetDIBitsToDevice(pDC->GetSafeHdc(),px,py,width,height,
 //     0,0,0,height,BufImg,(LPBITMAPINFO)&dibHi, DIB_RGB_COLORS);
 // SetDIBitsToDevice(pDC->GetSafeHdc(),px,py,width,height,
 //     0,0,0,height,BufImg,BmInfo, DIB_RGB_COLORS);
  SetDIBitsToDevice(pDC->GetSafeHdc(),px,py,width,height,
      0,0,0,height,BufRevImg,BmInfo, DIB_RGB_COLORS);
  delete []BufRevImg;
 }
 else
 {
  unsigned char *BufRevImg = new unsigned char [height*rwsize];
  int index1,index2=0;
  for(y=0; y<height; y++)
  {
   index1 = y*rwsize;
   index2 = (height-y-1)*width;
  // index2 = y*width;
   for(x=0; x<width; x++)
   {
    BufRevImg[index1+x]=BufImg[index2+x];
   // pDC->SetPixel(j,i,RGB(BufImg[index2+x],BufImg[index2+x],BufImg[index2+x]));
   }
  }

  SetDIBitsToDevice(pDC->GetSafeHdc(),px,py,width,height,
      0,0,0,height,BufRevImg,BmInfo, DIB_RGB_COLORS);
  delete []BufRevImg;
 }

}
//-----------------------------------------------------------------------------------------------------------------------
void CNG::AX_LoadJPG(CString fileName)
{
 UINT width=427; UINT height=601;
 
 if (m_ColorGetImg!=NULL) {delete [] m_ColorGetImg;m_ColorGetImg=NULL;}
 if (m_ColorImg!=NULL)  {delete [] m_ColorImg;m_ColorImg=NULL;}
 m_ColorImg = new unsigned char [(width*24)*height*3];

 // read to buffer tmp
 m_ColorGetImg=JpegFile::JpegFileToRGB(fileName, &width, &height);
 //CString csTmp; csTmp.Format("%d, %d",width, height); AfxMessageBox(csTmp);
 //-------------------------------------------------------
 if(m_ColorGetImg==NULL){return;}
 //-------------------------------------------------------
 JpegFile::BGRFromRGB(m_ColorGetImg, width, height);
 // vertical flip for display
 JpegFile::VertFlipBuf(m_ColorGetImg, width * 3, height);
 m_width=width; m_height=height;

 int y=0;
 int x=0;
 int ADD1,ADD2,ADD3;
 int SUM1,SUM2,SUM3;

 #define WIDTHBYTES2(bits)    (float((bits) / float(32)) * 4)

 float rwsize=WIDTHBYTES2(24*(width));//이미지 Size홀수 문제
 int   rwsize2=WIDTHBYTES(24*(width));

  for(y=0; y<int(height); y++)
  {
   for(x=0; x<int(width); x++)
   {
   ADD1=int((y*rwsize)+(3*x)+2);
   ADD2=int((y*rwsize)+(3*x)+1);
   ADD3=int((y*rwsize)+(3*x)+0);

   SUM1=int((y*rwsize2)+(3*x)+2);
   SUM2=int((y*rwsize2)+(3*x)+1);
   SUM3=int((y*rwsize2)+(3*x)+0);

   m_ColorImg[SUM1]=m_ColorGetImg[ADD1];
   m_ColorImg[SUM2]=m_ColorGetImg[ADD2];
   m_ColorImg[SUM3]=m_ColorGetImg[ADD3];
   
   //pDC.SetPixel(nX,nY,RGB(m_ColorImg[SUM1],m_ColorImg[SUM2],m_ColorImg[SUM3]));
   }

  }
}
//--------------------------------------------------------------------------------------------


/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// - 함 수  -  /////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

 int (*StepFunc_1[])(void) =
 {
  iCall_ChipTakeOff,  iCall_LaserMeasure,
  iCall_MarkRecMove,  iCall_AllMarkRec,  
  iCall_AllBadRec,  iCall_TargetMarkRec,  
  iCall_XYMovAbsorb1,  iCall_XYMovAbsorb2,
  iCall_NzlAbsorbOp1,  iCall_NzlAbsorbOp2,
  iCall_XYMountMov1,  iCall_XYMountMov2,  
  iCall_NzlMountOp1,      iCall_NzlMountOp2,
  iCall_AlignMoveXY1,     iCall_AlignMoveXY2,   
  iCall_InspectMoveXY1,   iCall_InspectMoveXY2,   
  iCall_AlignRecogOP1,    iCall_AlignRecogOP2,
  iCall_InspectRecogOP1,  iCall_InspectRecogOP2,
  iCall_NzlFocusReset1, iCall_NzlFocusReset2
 };


  if ((*StepFunc_1[index])() == NG)           // 실행 error이면
   TaskStatus1.iError = TaskStatus1.iNum;  // main분기 data
  else     // 실행성공이면
   TaskStatus1.iError = OK;

extern int  iCall_LaserMeasure(void);


/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// - 문 자  -  /////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/

const char PortNo[10][8] = {
 "COM1", 
 "COM2", 
 "COM3", 
 "COM4", 
 "COM5"
};

//8888888888888888888888888888888888888888888888888888888888888
//--------데이타 형 -----------------------------
short int, int   -2(15) ~ 2(15)-1     -32768~32767

long  int        -2(31) ~ 2(31)-1     -2147483648 ~ 2147483647

unsigned short int      0      ~2(15)-1      0 ~ 65535
unsigned int  

unsigned long int       0      ~2(32)-1      0 ~ 4294967295

float                          10(-79) ~ 10(75)

char                                         -128 ~ 127
unsigned  char                               0    ~ 255

double     "%.1e"
long int   "%ld"
//------------------------------------------------------
char  8
int   16
short 16
long   32
float  32
double  64
//-----------------------------------------------------
UINT-unsigned int
BYTE   -unsigned char
LPSTR  -char
(LPSTR) char*
LPTSTR   -unsigned short
LPCTSTR  -CString
//--------------------------
BOOL   A Boolean value.
BSTR   A 32-bit character pointer.
BYTE   An 8-bit integer that is not signed.
COLORREF   A 32-bit value used as a color value.
DWORD   A 32-bit unsigned integer or the address of a segment and its associated offset.
LONG   A 32-bit signed integer.
LPARAM   A 32-bit value passed as a parameter to a window procedure or callback function.
LPCSTR   A 32-bit pointer to a constant character string.
LPSTR   A 32-bit pointer to a character string.
LPCTSTR   A 32-bit pointer to a constant character string that is portable for Unicode and DBCS.
LPTSTR   A 32-bit pointer to a character string that is portable for Unicode and DBCS.
LPVOID   A 32-bit pointer to an unspecified type.
LRESULT   A 32-bit value returned from a window procedure or callback function
UINT   A 16-bit unsigned integer on Windows versions 3.0 and 3.1; a 32-bit unsigned integer on Win32.
WNDPROC   A 32-bit pointer to a window procedure.
WORD   A 16-bit unsigned integer.
WPARAM   A value passed as a parameter to a window procedure or callback function: 16 bits on Windows versions 3.0 and 3.1; 32 bits on Win32. 
Data types unique to the Microsoft Foundation Class Library include the following: 
POSITION   A value used to denote the position of an element in a collection; used by MFC collection classes.
LPCRECT   A 32-bit pointer to a constant (nonmodifiable) RECT structure. 

//888888888888888888888888888888888888888888888888888888888888888888888888888

_CRTIMP int     __cdecl abs(int);
_CRTIMP double  __cdecl acos(double);
_CRTIMP double  __cdecl asin(double);
_CRTIMP double  __cdecl atan(double);
_CRTIMP double  __cdecl atan2(double, double);
_CRTIMP double  __cdecl cos(double);
_CRTIMP double  __cdecl cosh(double);
_CRTIMP double  __cdecl exp(double);
_CRTIMP double  __cdecl fabs(double);
_CRTIMP double  __cdecl fmod(double, double);
_CRTIMP long    __cdecl labs(long);
_CRTIMP double  __cdecl log(double);
_CRTIMP double  __cdecl log10(double);
_CRTIMP double  __cdecl pow(double, double);
_CRTIMP double  __cdecl sin(double);
_CRTIMP double  __cdecl sinh(double);
_CRTIMP double  __cdecl tan(double);
_CRTIMP double  __cdecl tanh(double);
_CRTIMP double  __cdecl sqrt(double);


//====입력 문자중  숫자만 체크=====================================================
bool AsctoHexChk(CString csNo)
{
 if(csNo=="")return false;
 int Length =  csNo.GetLength();
 if(Length<=0)return false;
 BYTE No;  
 bool chk=true;
 
 for(int i=0; i<Length; i++)
 {
  No=csNo.GetAt(i);
  if(!AsctoHex(No))chk=false;
 }
   return chk;
}

bool AsctoHex(BYTE ascnum)
{
 unsigned char hex[] = { "0123456789." };
 unsigned char i=0;
 bool Chk=false;
 do
 {
  if(hex[i] == ascnum)
  {
   Chk=true; break;
  }
  i++;
 }while(i<11);
 return Chk;
}

//====한정 문자 메세지 ========================================================
 const char BOARD1[MAX_BD][10]= { 
 "DZ1","DX1","DY1","DZ2","DX2","DY2","FX1","FY1",};
 CLabelControl *pLabel;
 for(int i=0; i<MAX_BD; i++)
 {
   pLabel = (CLabelControl *)GetDlgItem(IDC_LBL_AXIS_X+i);
   pLabel->SetWindowText(LPTSTR(BOARD1[i]));
 }
 
//====리스트 사용하기========================================================
typedef struct {
 CString MarkID;
 int MarkNo;
 int Registered;
 int iLight[3];
} MARKDATA_RECORD;

CList<MARKDATA_RECORD, MARKDATA_RECORD&> m_list;
void CMarkData::Load()
{
 Clear();

 MARKDATA_RECORD rec;
 CString strSection;
 CIniFile iniFile("C:\\MountData\\MarkData\\Mark.lib");
 int count = iniFile.ReadInt("Mark Library", "Count");
 for (int i=1; i<=count; i++) {
  strSection.Format("Mark #%02d", i);
  rec.MarkID = iniFile.ReadString(strSection, "Mark ID");
  
  m_list.AddTail(rec);
 }
}
void CMarkData::Save()
{
 MARKDATA_RECORD rec;
 POSITION pos;
 CString strSection;
 int count = GetCount();
 CIniFile iniFile("C:\\MountData\\MarkData\\Mark.lib");
 iniFile.WriteInt("Mark Library", "Count", count);
 for (int i=0; i<count; i++) {
  pos = m_list.FindIndex(i);
  rec = m_list.GetAt(pos);
  iniFile.WriteDouble(strSection, "OuterDiameter", rec.OuterDiameter);
 }
}
void CMarkData::Clear()
{
 m_list.RemoveAll();
}
MARKDATA_RECORD CMarkData::GetData(int index)
{
 ASSERT(index > 0 && index <= m_list.GetCount());
 POSITION pos = m_list.FindIndex(index-1);
 MARKDATA_RECORD rec = m_list.GetAt(pos);
 return rec;
}
bool CMarkData::InsertBlankData(int index)
{
 ASSERT(index > 0 && index <= m_list.GetCount()+1);
 MARKDATA_RECORD rec;
 rec.MarkID.Empty();
 rec.MarkNo = 0;
 rec.Registered = 0;
 rec.iLight[0] = 1;
 rec.iLight[1] = 1;
 rec.iLight[2] = 1;
 if (index > m_list.GetCount()) {
  m_list.AddTail(rec);
 }
 else {
  POSITION pos = m_list.FindIndex(index-1);
  m_list.InsertBefore(pos, rec);
 }
 return true;
}

//______________________________________________________________________________

void CMarkData::DeleteData(int index)
{
 if (index < 0 || index > m_list.GetCount()) return;
 POSITION pos = m_list.FindIndex(index-1);
 m_list.RemoveAt(pos);
}
//===========================================================================
//===========================================================================

void CMarkData::SetData(int index, MARKDATA_RECORD rec)
{
 ASSERT(index > 0 && index <= m_list.GetCount());
 POSITION pos = m_list.FindIndex(index-1);
 m_list.SetAt(pos, rec);
}

//====struct=================================================================

//typedef struct tagBLOBDATA { short ltx, lty, rbx, rby; int n, pc; float cx, cy, r, g, b, u02, u20, u11, m, v; } BLOBDATA;

//---------------------------------------------------------------------------
//====Point Reutn============================================================
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

BYTE * BMPFile::LoadBMP(CString fileName,UINT *width, UINT *height)
{
 BYTE *outBuf=NULL;
 long bufsize = (long)w * 3 * (long)h;
 outBuf=(BYTE *) new BYTE [bufsize];


 for (int col=0;col<w;col++)
 {
  long offset = col * 3;
  char pixel[3];
  if (fread((void  *)(pixel),1,3,fp)==3) 
  {
  // we swap red and blue here
  *(outBuf + rowOffset + offset + 0)=pixel[2];  // r
  *(outBuf + rowOffset + offset + 1)=pixel[1];  // g
  *(outBuf + rowOffset + offset + 2)=pixel[0];  // b
  }
 }

 int w; 
 int h;
 *width=w;
 *height=h;
 return outBuf;
}

//===========================================================================
BYTE * BMPFile::LoadBMP(CString fileName, 
      UINT *width, 
      UINT *height)
{
    BITMAP inBM;

    BYTE m1,m2;
    long filesize;
    short res1,res2;
    long pixoff;
    long bmisize;                    
    long compression;
    unsigned long sizeimage;
    long xscale, yscale;
    long colors;
    long impcol;
    

 BYTE *outBuf=NULL;
 
 // for safety
 *width=0; *height=0;

 // init
 m_errorText="OK";
 m_bytesRead=0;

 FILE *fp;
 
 fp=fopen(fileName,"rb");
 if (fp==NULL) {
  CString msg;                    
  msg="Can't open file for reading :\n"+fileName;
  m_errorText=msg;
  return NULL;
 } else {
     long rc;
  rc=fread((BYTE  *)&(m1),1,1,fp); m_bytesRead+=1;
  if (rc==-1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((BYTE  *)&(m2),1,1,fp); m_bytesRead+=1;
  if (rc==-1) m_errorText="Read Error!";
  if ((m1!='B') || (m2!='M')) {
   m_errorText="Not a valid BMP File";
   fclose(fp);
   return NULL;
        }
        
  ////////////////////////////////////////////////////////////////////////////
  //
  // read a ton of header stuff

  rc=fread((long  *)&(filesize),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((int  *)&(res1),2,1,fp); m_bytesRead+=2;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((int  *)&(res2),2,1,fp); m_bytesRead+=2;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(pixoff),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(bmisize),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(inBM.bmWidth),4,1,fp);  m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(inBM.bmHeight),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((int  *)&(inBM.bmPlanes),2,1,fp); m_bytesRead+=2;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((int  *)&(inBM.bmBitsPixel),2,1,fp); m_bytesRead+=2;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(compression),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(sizeimage),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(xscale),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(yscale),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(colors),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  rc=fread((long  *)&(impcol),4,1,fp); m_bytesRead+=4;
  if (rc!=1) {m_errorText="Read Error!"; fclose(fp); return NULL;}

  ////////////////////////////////////////////////////////////////////////////
  // i don't do RLE files

  if (compression!=BI_RGB) {
      m_errorText="This is a compressed file.";
      fclose(fp);
      return NULL;
     }

  if (colors == 0) {
   colors = 1 << inBM.bmBitsPixel;
  }


  ////////////////////////////////////////////////////////////////////////////
  // read colormap

  RGBQUAD *colormap = NULL;

  switch (inBM.bmBitsPixel) {
  case 24:
   break;
   // read pallete 
  case 1:
  case 4:
  case 8:
   colormap = new RGBQUAD[colors];
   if (colormap==NULL) {
    fclose(fp);
    m_errorText="Out of memory";
    return NULL;
   }

   int i;
   for (i=0;i<colors;i++) {
    BYTE r,g,b, dummy;

    rc=fread((BYTE *)&(b),1,1,fp);
    m_bytesRead++;
    if (rc!=1) {
     m_errorText="Read Error!"; 
     delete [] colormap;
     fclose(fp);
     return NULL;
    }

    rc=fread((BYTE  *)&(g),1,1,fp); 
    m_bytesRead++;
    if (rc!=1) {
     m_errorText="Read Error!"; 
     delete [] colormap;
     fclose(fp);
     return NULL;
    }

    rc=fread((BYTE  *)&(r),1,1,fp); 
    m_bytesRead++;
    if (rc!=1) {
     m_errorText="Read Error!"; 
     delete [] colormap;
     fclose(fp);
     return NULL;
    }


    rc=fread((BYTE  *)&(dummy),1,1,fp); 
    m_bytesRead++;
    if (rc!=1) {
     m_errorText="Read Error!"; 
     delete [] colormap;
     fclose(fp);
     return NULL;
    }

    colormap[i].rgbRed=r;
    colormap[i].rgbGreen=g;
    colormap[i].rgbBlue=b;
   }
   break;
  }


  if ((long)m_bytesRead>pixoff) {
   fclose(fp);
   m_errorText="Corrupt palette";
   delete [] colormap;
   fclose(fp);
   return NULL;
  }

  while ((long)m_bytesRead<pixoff) {
   char dummy;
   fread(&dummy,1,1,fp);
   m_bytesRead++;
  }

  int w=inBM.bmWidth;
  int h=inBM.bmHeight;

  // set the output params
  *width=w;
  *height=h;

  long row_size = w * 3;

  long bufsize = (long)w * 3 * (long)h;

  ////////////////////////////////////////////////////////////////////////////
  // alloc our buffer

  outBuf=(BYTE *) new BYTE [bufsize];
  if (outBuf==NULL) {
   m_errorText="Memory alloc Failed";
  } else {

   ////////////////////////////////////////////////////////////////////////////
   // read it

   long row=0;
   long rowOffset=0;

   // read rows in reverse order
   for (row=inBM.bmHeight-1;row>=0;row--) {

    // which row are we working on?
    rowOffset=(long unsigned)row*row_size;            

    if (inBM.bmBitsPixel==24) {

     for (int col=0;col<w;col++) {
      long offset = col * 3;
      char pixel[3];

      if (fread((void  *)(pixel),1,3,fp)==3) {
       // we swap red and blue here
       *(outBuf + rowOffset + offset + 0)=pixel[2];  // r
       *(outBuf + rowOffset + offset + 1)=pixel[1];  // g
       *(outBuf + rowOffset + offset + 2)=pixel[0];  // b
      }

     }

     m_bytesRead+=row_size;
     
     // read DWORD padding
     while ((m_bytesRead-pixoff)&3) {
      char dummy;
      if (fread(&dummy,1,1,fp)!=1) {
       m_errorText="Read Error";
       delete [] outBuf;
       fclose(fp);
       return NULL;
      }

      m_bytesRead++;
     }
 
     
    } else { // 1, 4, or 8 bit image

     ////////////////////////////////////////////////////////////////
     // pixels are packed as 1 , 4 or 8 bit vals. need to unpack them

     int bit_count = 0;
     UINT mask = (1 << inBM.bmBitsPixel) - 1;

     BYTE inbyte=0;

     for (int col=0;col<w;col++) {
      
      int pix=0;

      // if we need another byte
      if (bit_count <= 0) {
       bit_count = 8;
       if (fread(&inbyte,1,1,fp)!=1) {
        m_errorText="Read Error";
        delete [] outBuf;
        delete [] colormap;
        fclose(fp);
        return NULL;
       }
       m_bytesRead++;
      }

      // keep track of where we are in the bytes
      bit_count -= inBM.bmBitsPixel;
      pix = ( inbyte >> bit_count) & mask;

      // lookup the color from the colormap - stuff it in our buffer
      // swap red and blue
      *(outBuf + rowOffset + col * 3 + 2) = colormap[pix].rgbBlue;
      *(outBuf + rowOffset + col * 3 + 1) = colormap[pix].rgbGreen;
      *(outBuf + rowOffset + col * 3 + 0) = colormap[pix].rgbRed;
     }

     // read DWORD padding
     while ((m_bytesRead-pixoff)&3) {
      char dummy;
      if (fread(&dummy,1,1,fp)!=1) {
       m_errorText="Read Error";
       delete [] outBuf;
       if (colormap)
        delete [] colormap;
       fclose(fp);
       return NULL;
      }
      m_bytesRead++;
     }
    }
   }
  
  }

  if (colormap) {
   delete [] colormap;
  }

  fclose(fp);

    }

 return outBuf;
}
//=================================================================================================================

BYTE* CMemFile::Alloc(DWORD nBytes)
{
 return (BYTE*)malloc((UINT)nBytes);
}

BYTE *buf = JpegFile::JpegFileToRGB(....);
delete [] buf;

BYTE * JpegFile::JpegFileToRGB(CString fileName, UINT *width,  UINT *height)
{
 *width=0;
 *height=0;

 BYTE *dataBuf;
 dataBuf=(BYTE *)new BYTE[width * 3 * height];
 if (dataBuf==NULL) {
  return NULL;
 }

 return dataBuf;

}

BYTE * JpegFile::MakeDwordAlignedBuf(BYTE *dataBuf,UINT widthPix,UINT height, UINT *uiOutWidthBytes)
{
 ////////////////////////////////////////////////////////////
 // what's going on here? this certainly means trouble 
 if (dataBuf==NULL)return NULL;

 ////////////////////////////////////////////////////////////
 // how big is the smallest DWORD-aligned buffer that we can use?
 UINT uiWidthBytes;
 uiWidthBytes = WIDTHBYTES(widthPix * 24);

 DWORD dwNewsize=(DWORD)((DWORD)uiWidthBytes * (DWORD)height);
 BYTE *pNew;

 ////////////////////////////////////////////////////////////
 // alloc and open our new buffer
 pNew=(BYTE *)new BYTE[dwNewsize];
 if (pNew==NULL) {
  return NULL;
 }
 
 ////////////////////////////////////////////////////////////
 // copy row-by-row
 UINT uiInWidthBytes = widthPix * 3;
 UINT uiCount;
 for (uiCount=0;uiCount < height;uiCount++) {
  BYTE * bpInAdd;
  BYTE * bpOutAdd;
  ULONG lInOff;
  ULONG lOutOff;

  lInOff=uiInWidthBytes * uiCount;
  lOutOff=uiWidthBytes * uiCount;

  bpInAdd= dataBuf + lInOff;
  bpOutAdd= pNew + lOutOff;

  memcpy(bpOutAdd,bpInAdd,uiInWidthBytes);
 }

 *uiOutWidthBytes=uiWidthBytes;
 return pNew;
}

BOOL JpegFile::VertFlipBuf(BYTE  * inbuf, 
        UINT widthBytes, 
        UINT height)
{   
 BYTE  *tb1;
 BYTE  *tb2;

 if (inbuf==NULL)
  return FALSE;

 UINT bufsize;

 bufsize=widthBytes;

 tb1= (BYTE *)new BYTE[bufsize];
 if (tb1==NULL) {
  return FALSE;
 }

 tb2= (BYTE *)new BYTE [bufsize];
 if (tb2==NULL) {
  delete [] tb1;
  return FALSE;
 }
 
 UINT row_cnt;     
 ULONG off1=0;
 ULONG off2=0;

 for (row_cnt=0;row_cnt<(height+1)/2;row_cnt++) {
  off1=row_cnt*bufsize;
  off2=((height-1)-row_cnt)*bufsize;   
  
  memcpy(tb1,inbuf+off1,bufsize);
  memcpy(tb2,inbuf+off2,bufsize); 
  memcpy(inbuf+off1,tb2,bufsize);
  memcpy(inbuf+off2,tb1,bufsize);
 } 

 delete [] tb1;
 delete [] tb2;

 return TRUE;
}        

BOOL JpegFile::MakeGrayScale(BYTE *buf, UINT widthPix, UINT height)
{
 if (buf==NULL)
  return FALSE;

 UINT row,col;
 for (row=0;row<height;row++) {
  for (col=0;col<widthPix;col++) {
   LPBYTE pRed, pGrn, pBlu;
   pRed = buf + row * widthPix * 3 + col * 3;
   pGrn = buf + row * widthPix * 3 + col * 3 + 1;
   pBlu = buf + row * widthPix * 3 + col * 3 + 2;

   // luminance
   int lum = (int)(.299 * (double)(*pRed) + .587 * (double)(*pGrn) + .114 * (double)(*pBlu));

   *pRed = (BYTE)lum;
   *pGrn = (BYTE)lum;
   *pBlu = (BYTE)lum;
  }
 }
 return TRUE;
}

//============================================================================


//-----Char 문자로 변경----------------------------
 DWORD dData
  char       Data[33] = "\0";

  ultoa(dData, Data, 10);

 CString    sRtn = Data;

//--------Bit 구하기- -----------------------------

typedef struct {
 unsigned b0 : 1, b1 : 1, b2 : 1, b3 : 1, b4 : 1, b5 : 1, b6 : 1, b7 : 1;
} byte_bits;

typedef union {
 BYTE bByte;
 byte_bits bit;
} lsByte;


lsByte bUnivIO;

 bUnivIO=(UINT8)250;

#include "Led.h"
CLed m_LedOut0;
DDX_Control(pDX, IDC_LED_OUT0, m_LedOut0);

 m_LedOut0.SetStatus( bUnivIO.bit.b0 );
 m_LedOut1.SetStatus( bUnivIO.bit.b1 );
 m_LedOut2.SetStatus( bUnivIO.bit.b2 );
 m_LedOut3.SetStatus( bUnivIO.bit.b3 );
 m_LedIn0.SetStatus( bUnivIO.bit.b4 );
 m_LedIn1.SetStatus( bUnivIO.bit.b5 );
 m_LedIn2.SetStatus( bUnivIO.bit.b6 );
 m_LedIn3.SetStatus( bUnivIO.bit.b7 );


double hypot(double x,double y);직삼각형의 사변 길이
double sqrt(double x);x의 제곱근
double pow(double x,double y);xy. x의 y승 
double log(double x);자연 대수
double log10(double x);상용 대수
double exp(double x);자연 대수 exp

Measure_r= hypot(fPoint_x,fPoint_y);
Measure_r=sqrt(fPoint_x*fPoint_x+fPoint_y*fPoint_y);
//---CString To Byte (unsigned char)------------------------------------------
 BYTE  c_str(CString str, int n) 
 {
  BYTE cDt;
  int nSize=0;
  nSize=str.GetLength();
  if(nSize>=n)
  {
     cDt= str.GetAt(n);
  }
  return cDt;
 }
 //-------------------------------------
 CString str;
 BYTE temp;
 for(int i=0; i<6; i++)
 {
  str.Format("%d : ",i);
  if(c_str(name,i)=='3')
  AfxMessageBox(str+"ok");
  else
  AfxMessageBox(str);
 }
 //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 //char 문자변형 !!!!!!!!!!!!!!!!!!!!
 BYTE temp[2];
 
 temp[0]=(c_str(name,i);
 temp[1]='\0';
 
 str=(LPSTR)temp;
 AfxMessageBox(str);
 //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
int CUDPSock::SendTo(const void* lpBuf, int nBufLen, LPCTSTR lpszHostAddress, int nFlags)
{
 sockaddr_in Addr;
 memset((char *)&Addr, 0x00, sizeof(Addr));
 Addr.sin_family = AF_INET;
 Addr.sin_addr.s_addr = inet_addr(lpszHostAddress); 
 Addr.sin_port = htons(m_iPort);//서버,클라이언트중 port지정한 UDP port로 송수신(내부서버에지정) 

 char *buf = NULL;
 int iSize = lstrlen((char*)lpBuf);

 buf = (char*)malloc(iSize);

 memcpy(buf,lpBuf,iSize);
 
 //CUDPSock::DATAPACKET DataPacket;
 //memcpy(DataPacket.szData, (char*)lpBuf, nBufLen);
 //DataPacket.SetCheck();
 //int iResult = sendto(m_Sock, (char*)&DataPacket, sizeof(CUDPSock::DATAPACKET), nFlags, (const struct sockaddr *)&Addr, sizeof(Addr));
 int iResult = sendto(m_Sock, buf, iSize, nFlags, (const struct sockaddr *)&Addr, sizeof(Addr));
 return 0;
}
//---------------------------------------------------------------------------

 CString PathName.Replace( "\\", "/" );

 

 

 //-----확장자 바꾸기---------------------------------------
 CString ChangeFileExt(CString csFile, CString csExe)
 {
 CString str;
 int Index=0;
 char *token;
 char szBuf[1024];
 char temp2[100]; 
 char seps[]   = "\\";
    ////////*** Establish string and get the first token:

 if(csFile.GetLength()>3)printf(szBuf,csFile); else return "";
 CString csGetData="";
 sprintf(szBuf,csFile);
 token = strtok(szBuf,seps);

    while( token != NULL )
    {
       //////*** While there are tokens in "string" 
  sprintf(temp2,"%s",token);
  csGetData=temp2;
       ///////*** Get next token: 
     token = strtok( NULL, seps );
    }

 int index=0;
 if(csGetData.GetLength()>1)index = csGetData.Find("."); else return "";
 CString csData="";
 csData=csGetData.Mid(0,index);// AfxMessageBox(csData);

 str=csData+csExe;
 return str;
 }
 //---메모리할당 삭제----------------------------------
 CString str;
 char *cstr=NULL;str = new char[_MAX_PATH+1];
 ::GetCurrentDirectory(_MAX_PATH+1,cstr);
 str=(LPCTSTR)(char *)cstr;
 if(cstr)delete[] cstr;
 return str;
 //-----------------------------------------------------

 char *str;
 CString Path_App =(LPCTSTR)(char *)str;
 //-----------------------------------------------------------
 (char *)(LPCTSTR)mDAT.pid,day.yy%100,day.mo,day.dd);
 //-----------------------------------------------------------


        //-----------------------------------
 (LPCTSTR)(char *)
        //-----------------------------------

 //----------------------------------------------------------
 CString NewFileName;
 char sSource[256]
 //찾고자 하는것, 바꾸고자 하는것을 받는다.
 strcpy( sSource, m_FileNameBefore.operator LPCTSTR() );
 //----------------------------------------------------------
 

 unsigned char *temp = NULL;
 temp = new unsigned char [Length];

 CString Filename=="C:\\Polaronix\\Back\\Ch01\\*.*";
 //-------------------
 LPSTR temp = Filename.GetBuffer(Filename.GetLength()*2);  //*char
    
 //-------------------
 char temp[50];
 for(i=0; i<50; i++) temp[i]='\0';
 lstrcpy((LPSTR)temp,(LPSTR)Filename.operator const char*());

 //--------------------

 char temp[50];
 int Length =  Filename.GetLength();
   //for(i=0; i<50; i++) temp[i]='\0';
 for(i = 0; i < Length; i++)
 {
     temp[i] = Filename.GetAt(i); 
 }
 temp[i]= '\0';

 AfxMessageBox(temp);

 unsigned char Buf1[]={Data[0]};
 pFrame->m_serial[port-1].Write(Buf1,1);

//-----------------------------------------------------------------------------------
//------숫자 감소--------------------------------------------------------------------
 for (i = 255; i > 0; i--)
//-----------------------------------------------------------------------------------
//--unsigned char-> CString ,  unsigned char-> char----------------------------------
//-----------------------------------------------------------------------------------

 int Length=255;
 unsigned char *temp = NULL;
 temp = new unsigned char [Length];

 char temp2[2]; CString csText;
// m_ccEdit1.GetWindowText((LPSTR)temp,255);

 for(int i=0; i<Length; i++)
 {
  temp2[0]=temp[i]; temp2[1]='\0';
  csText+=(LPSTR)temp2;
 }

 AfxMessageBox(csText);


//-----------------------------------------------------------------------------------
//------숫자 추출--------------------------------------------------------------------

  100자리
  hundred= (int)(Sum/ 100);
  ten= (Sum-(hundred*100))/10;
  one=Sum-((hundred*100)+(ten*10));


  1000자리
  thousand= =(int)(Sum/ 1000);               
  hundred= (int)(Sum-(thousand*1000))/100;
  ten= (Sum-((thousand*1000)+(hundred*100)))/10;
  one=Sum-(int)((thousand*1000)+(hundred*100)+(ten*10));

  10000자리
  tenthousand =(int)(Sum/ 10000);               
  thousand=  (int)(Sum-(tenthousand*10000))/1000;
  hundred= (int)(Sum-((tenthousand*10000)+(thousand*1000)+(hundred*100)))/100;
  ten= (Sum-((tenthousand*10000)+(thousand*1000)+(hundred*100)))/10;
  one=Sum-(int)((tenthousand*10000)+(thousand*1000)+(hundred*100)+(ten*10));

 

//---char-> CString------------------------------------
 char temp[255];
 for(int i=0; i<255; i++) temp[i]='\0';

 CString csText=(LPSTR)temp;
 AfxMessageBox(csText);

//---------------*.* 삭제 처리-------------------------------------------------*/

  CString Filename="C:\\Polaronix\\Back\\Ch01\\*.*";
  int Length =  Filename.GetLength();
  char temp[50];

  for(i=0; i<50; i++) temp[i]='\0';
  lstrcpy((LPSTR)temp,(LPSTR)Filename.operator const char*());

  SHFILEOPSTRUCT sfo;
  memset(&sfo,0,sizeof(sfo));
  sfo.wFunc = FO_DELETE;
  sfo.fFlags =OFN_SHOWHELP; //메시지 창 뛰우지 않음

  sfo.pFrom=(LPSTR)temp;
  SHFileOperation(&sfo);

/*  for(i = 0; i < 20; i++)
  {
     csTmp.Format("%d",temp[i]);  AfxMessageBox(csTmp);
  }
*/

/*------% 계산------------------------------------------------------------*/
 //-------------------------------------------
 //-------------------------------------------

 0-255 에 대한 100% 

 // 수량에 대한 % 계산  x(%)
 // 255 : 100(%) = 25 : x(%)    (25의  %)
 // x(%) = (value/255)*100 
 int value=25;
 float fData=float(value)/255;fData=float(fData*100);if(fData<0)fData=0;      


 // %에 대한 수량 구하기  x(no)
 // 255 : 100(%) = x :10(%)    (10%에 대한 값)
 // x=(10/100)*255  

 //int value=10;
 //float fData=float(value/100);fData=float(fData*255);if(fData<0)fData=0;


 fData=float(fData)/100;fData=float(fData*255);      //Limit값
 fData=Cut(fData); m_threshMin=int(fData); 
 //-------------------------------------------
 //-------------------------------------------
 
 float nData1=0;int nData2=0;

// nData1=nImageTotalSize-(nAddressCount*256);
 nData1=nImageTotalSize-nAddressCount;
 
 nData2=int((nData1/nImageTotalSize)*100);
 nPercent=int(100-nData2);


 strText.Format("Image Download: %d/100",nPercent);//Pallete X Size
 SetDlgItemText(IDC_IMAGEDOWNLOADSTATIC_A, strText);
 
 if((nPercent>=0)&&(nPercent<=100))
 m_ccModuleAdownloadProgress.SetPos(nPercent);
/*-----------------------------------------------------------------------*/

BOOL AFXAPI AfxVerifyLicFile(HINSTANCE hInstance, LPCTSTR pszLicFileName,
 LPCOLESTR pszLicFileContents, UINT cch)
{
 // Assume the worst...
 BOOL bVerified = FALSE;

 // Look for license file in same directory as this DLL.
 TCHAR szPathName[_MAX_PATH];
 ::GetModuleFileName(hInstance, szPathName, _MAX_PATH);
 LPTSTR pszFileName = _tcsrchr(szPathName, '\\') + 1;
 lstrcpy(pszFileName, pszLicFileName);

#ifndef OLE2ANSI
 LPSTR pszKey = NULL;
#endif
 LPBYTE pbContent = NULL;

 TRY
 {
  // Open file, read content and compare.

  CFile file(szPathName, CFile::modeRead);

  if (cch == -1)
#ifdef OLE2ANSI
   cch = lstrlen(pszLicFileContents);
#else
   cch = wcslen(pszLicFileContents);

  pszKey = (char*)_alloca(cch*2 + 1);
  cch = _wcstombsz(pszKey, pszLicFileContents, cch*2 + 1);
#endif

  if (cch != 0)
  {
   --cch;  // license file won't contain the terminating null char
   pbContent = (BYTE*)_alloca(cch);
   file.Read(pbContent, cch);

#ifndef OLE2ANSI
   if (memcmp(pszKey, pbContent, (size_t)cch) == 0)
#else
   if (memcmp(pszLicFileContents, pbContent, (size_t)cch) == 0)
#endif
    bVerified = TRUE;
  }
 }
 END_TRY

 return bVerified;
}

/*---------------------Hex -> CString------------------------------------------------------*/
void CTestView::OnButton1() 
{
 // TODO: Add your control notification handler code here
 CString csTmp="";
 char hexnum=0x7f; //BYTE hexnum=0x01;

 csTmp=HextoAsctoString(hexnum);
 AfxMessageBox(csTmp);
}

CString CTestView::HextoAsctoString(BYTE hexnum)
{
 CString csTmp="0";
 unsigned char hex[] = { "0123456789ABCDEF" };

 BYTE num;
 BYTE temp[3];

 num=hexnum/16;
 temp[0] = hex[num%16];

 num=hexnum%16;
 temp[1] =hex[num%16];
 
 temp[2] = '\0';
 csTmp=temp;

 return csTmp;
}

/*---------------------CString 한줄씩 얻기        ----------------------------------*/
//-----------------------------------------------------------------------------------

 //----한줄 얻기--------------------------------
 CString csData="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20";

 int MaxRow = MAXROW_TIME+1;
 int MaxCol = MAXCOL_TIME;
 CString csTmp=""; 

 int nGetCol=1;
 if(nMode==MODE_ONTIME)nGetCol=1;if(nMode==MODE_OFFTIME)nGetCol=2;

 int nListMaxCount=0;CString csGetData[MAXROW_TIME];
 LPTSTR pstr;LPTSTR pstrToken;
 TCHAR seps[] =_T(",");
 pstr=csData.GetBuffer(0);
 pstrToken=_tcstok(pstr,seps);

 while(pstrToken !=NULL)
 {
  if(nListMaxCount<MaxRow){csGetData[nListMaxCount]=pstrToken;AfxMessageBox(csGetData[nListMaxCount],MB_OK);}
  pstrToken=_tcstok(NULL,seps);
  nListMaxCount++;
 }
 csData.ReleaseBuffer(-1);


 //----여러 줄 얻기------------------------------------

// CString str =_T("First\tSecond Third,Fourth\t Fifth");
 CString str =_T("100,200,\n300,45.0\n");
// CString str= m_csTestFileData[0];
 CString csdata="";
 int nListMaxCount=0;
 LPTSTR pstr;
 LPTSTR pstrToken;
// TCHAR seps[] =_T("\t, ");
 TCHAR seps[] =_T("\n");
 
 pstr=str.GetBuffer(0);

 pstrToken=_tcstok(pstr,seps);

 while(pstrToken !=NULL)
 {
 // AfxMessageBox(pstrToken,MB_OK);
  pstrToken=_tcstok(NULL,seps);

   if(pstrToken!=NULL)
   {
     char seps[] = ","; char *token; char string[250];
          ///*** Establish string and get the first token: 
     strcpy( string, pstrToken); token = strtok(string, seps );
     csdata="";csdata=token;
     // Data-0
     AfxMessageBox(csdata);
         
     int nCount=0;
       while( token != NULL )
       {
         token = strtok( NULL, seps );
      csdata="";csdata=token;
      //Data-1
      if(nCount==0) 
      AfxMessageBox(csdata);
      csdata="";csdata=token;//csdata=csdata+"\n";
      //Data-2
      if(nCount==1) 
      AfxMessageBox(csdata);
      nCount++;
       }
     nListMaxCount++;
   }
 }
 str.ReleaseBuffer(-1);
 AfxMessageBox(pstr, MB_OK);

 

//------------@(0x40) MASK-----------------------------------------------------------------
         //MASK 0100 0000 0x40
  //100  0000 0000  0110 0100  (0100 0000) (0100 0000) (0100 0110) (0100 0100)   @@FD   
  //12300   0011 0000  0000 1100     (0100 0011) (0100 0000) (0100 0000) (0100 1100)   C@@L
//-----------------------------------------------------------------------------------------

/*---------------------일정간격의 Board 번호와 Ch 번호 구하기 ----------------------------------*/

  int nBoardNo=0; 
  int nChNo=0;
  int nMax= CHMAX/12;
  int nChMax=12;
  CString csTmp="";
 
   if(m_nTestSendCh<nChMax){nChNo=m_nTestSendCh;} //0-11 12ch
   else
   {
    for(int i=1; i<nMax; i++)
    {
    nBoardNo=m_nTestSendCh/(12*i);
    if(nBoardNo<12)break;
    }
    nChNo=m_nTestSendCh-(12*nBoardNo);
   }
  
   csTmp.Format("No%d, nBoard%d, Ch%d",m_nTestSendCh,nBoardNo,nChNo);
   AfxMessageBox(csTmp);

   m_nTestSendCh++;

 

 

/*----------------------반올림 -----------------------------------------------*/

#define Cut(A)          (float)((long int) (((A)+.05) * 10))/10;
#define Cut2(A)          (float)((long int) (((A)+.5) * 10))/10;


/*----------------------퍼센트 구하기 ----------------------------------------*/
 
 // 100 : 80(환산 기준치)
 // 퍼센트 50 구하기 
 // (50/100)*80
 // (50*0.01)*80

 int nPercent=(m_ccChModel[nCh].m_SCROLLPERCENT*0.01)*m_ccChModel[nCh].m_PALETTE_SIZE_X;

 100퍼센트

 (측정값/기준값)*100
  

/*--------------------------------------------------------------------------------*/

 

 char temp[80];
 lstrcpy((LPSTR)temp,(LPSTR)pDlg->m_strIp.operator const char*());
 //-------------------------------------------------------------//

 BYTE temp[200];
 CString csText="[0](@@,0B)";
 lstrcpy((LPSTR)temp,(LPSTR)csText.operator const char*());
 //클라이언트에 보낸다.
 m_pClientSock->Send(temp,200);


 CString csText;
 char buff[40];
 csText=((LPCSTR)buff);


const char Error_message[4][40] = {
 "Comm Data Receive Error      ", 
 "Image Download Error         ", 
 "MPU Control Error            ", 
 "Comm Error        ", 
};

/*----------------------HEX 8BIT  문자표현----------------------------------------*/

CString CSECKLineDVM2View::Hext8BitAsctoChange(int CheckSum)
{
 CString csHiBit,csLowBit,csResult;
 char HiBit;
 char LowBit;

 HiBit=(CheckSum & 0xf0)/16;
 LowBit=CheckSum & 0x0f;

 csHiBit=HextoAsc(HiBit);
 csLowBit=HextoAsc(LowBit);
 
 csResult=csHiBit+csLowBit;
 return csResult;
}

BYTE CModuleAgingView::HextoAsc(BYTE hexnum)
{
 unsigned char hex[] = { "0123456789ABCDEF" };
 unsigned char ascnum;
 
 int nBuf=0;

 nBuf=hexnum%16;
 if((nBuf>=0)&&(nBuf<=15))
 {
  ascnum = hex[hexnum%16]; 
 }
 else
 {
  ascnum =0;
 }
 return ascnum; 
}
/*----------------------HEX 분할 표현----------------------------------------*/

 long  dAddress=4294967295;  //FF FF FF FF

 NAddress[3]=long((lAddress&0xff000000)>>24);
 NAddress[2]=long((lAddress&0x00ff0000)>>16);
 NAddress[1]=long((lAddress&0x0000ff00)>>8);
 NAddress[0]=long(lAddress&0x000000ff);

 unsigned char Command[]={NAddress[3],NAddress[2],NAddress[1],NAddress[0]}; //81-Command,   00 08- Data Size 8Byte
 pFrame->m_serial[PORT_MODULE_A-1].Write(Command,4);
/*----------------------HEX 232전송----------------------------------------*/

 unsigned char *BinOutImg;
 BinOutImg = NULL;     //변경전 Image file size
 BinOutImg   = new unsigned char [3*WidthLineSize*(PaletteSize_y*ImageMaxNo)];

 Data[0]=int(BinOutImg[index+0]);
 unsigned char Buf1[]={Data[0]};
 pFrame->m_serial[port-1].Write(Buf1,1);

 Data[1]=int(BinOutImg[index+1]);
 unsigned char Buf2[]={Data[1]};
 pFrame->m_serial[port-1].Write(Buf2,1);


/*----------------------String Table 얻기----------------------------------------*/
CString strTemp;
if (strTemp.LoadString(IDS_SERVERRESET))

/*----------------------한글 폰트 얻기 / 출력------------------------------------*/

const char KoreanFont_MOUM_A1[14][3] = { 
 "각","간","갇","갈","감","갑","갓","강","갖","갗",
 "갘","같","갚","갛",
};
 CString csData;

 BYTE temp[3];
 temp[0] = KoreanFont_MOUM_A1[1][0];
 temp[1] = KoreanFont_MOUM_A1[1][1];
 temp[2] = '\0';

 csData=temp;
 AfxMessageBox(csData);

/*----------------------사이즈가 수시변동  끝 네자리 얻기------------------------*/

 CString strTmp=_T("");
 CString strTmp2=_T("");
 CString csData="EX-4A21";
 int nLotSize=0;

 strTmp=csData;
 
 if(strTmp.GetLength()>0)
 {
  nLotSize=strTmp.GetLength();

  if(nLotSize>=4)
  {
   for(int i=nLotSize-4; i<nLotSize; i++)
   {
   strTmp2+=strTmp.Mid(i,1);
   }
  }
 } 

 if(strTmp2.GetLength()==4)
 {
 AfxMessageBox(strTmp2);
 }
/*---------------------- Delete------------------------*/
 CString csRead;
 int nNo;
 csRead.Delete(nNo,1);

/*---------------------- COleDateTime------------------------*/
 CString csWorkTime;
 COleDateTime ccTestTime;
 ccTestTime=COleDateTime::GetCurrentTime();
 csWorkTime=ccTestTime.Format("%I:%M:%S %p");
     ccTestTime.Format("%Y %m %d %H:%M");
//--
 COleDateTime tmpDateTime = COleDateTime::GetCurrentTime();
 String strTime;

 strTime.Format("%4d.%02d.%02d/%02d:%02d:%02d",
 tmpDateTime.GetYear(), tmpDateTime.GetMonth(),tmpDateTime.GetDay(), 
 tmpDateTime.GetHour(),tmpDateTime.GetMinute(), tmpDateTime.GetSecond());
//--
 CString strTime;
 COleDateTime tmpDateTime = COleDateTime::GetCurrentTime();
 strTime.Format("%4d_%02d_%02d_%02d_%02d_%02d_Err.txt",
 tmpDateTime.GetYear(), tmpDateTime.GetMonth(),tmpDateTime.GetDay(), 
 tmpDateTime.GetHour(),tmpDateTime.GetMinute(), tmpDateTime.GetSecond());
 m_csErrorFileName=strTime;

/*---------------------- lstrcpy----------------------------*/
 CString m_strSend;
 BYTE temp[2000];
 lstrcpy((LPSTR)temp,(LPSTR)m_strSend.operator const char*());

/*---------------------- sprintf----------------------------*/

 char buff[100];
 int nData=100;
 sprintf(buff, "%d", nData);

/*---------------------- int--------------------------------*/
 int a=111;
 sprintf(temp,"%d",a);

 char buff[40];
 int nData;
 nData=(int)atoi((LPCSTR)buff);

 ///////////////////////////////
 short number;
 CString str;
 char buffer[20];
 if (number > 0) {
  _itoa(number,buffer,10);
  str += buffer;
 }
 str += "\r"; //CR

/*-------------------문자 float 변경------------------------*/

 CString csTmp;
 float fHum;
 fHum = (float)atof((LPCSTR)csTmp);


 CString csText;
 char buff[40];
 csText=((LPCSTR)buff);


/*-------------------문자 long 변경------------------------*/
 long lngBuf = ::atol(strBuf);

/*--------------------일정문자 삭제--------------------------------*/
 CString csRead;
  csRead.Delete(5,1);
       위치,갯수 
/*------------------일정문자 추출-----------------------------------*/
 CString InString;

  CString csTemp = InString.Mid(index+1,6);
       위치 , 크기

/*------------float 반올림--------------------------------------------------------*/
 #define Cut(A)          (float)((long int) (((A)+.05) * 10))/10;

 float Test1=(float)2.374826;
 float Test2;
 Test2=Cut(Test1);
 csTest.Format("%.6f",Test2);
 m_nisFM1LCoolRpmDecision.SetOffText(csTest);

/*------HEX and 비교구문-----------------------------------------------------------*/
 int test1=0;
 test1 |=0x4000;
 test1 |=0x02;

 if (test1 & 0x4000)
 {
  if ((test1 & 2)==0)
  {
  AfxMessageBox("!0x02");
  }
  else
  {
  AfxMessageBox("0x02");
  }
 }
 else
 {
  AfxMessageBox("!0x4000");
 }
/*------------상위 4비트만  추출 -----------------------------------*/
 BYTE m_nInHorseTmp;
 BYTE Intemp;
 m_nInHorseTmp=0X7f;
// m_nInHorseTmp |= 0X0f;
 m_nInHorseTmp &= 0Xf0;
 Intemp=m_nInHorseTmp/16;

 m_TEST.Format("%d",Intemp);

 UpdateData(FALSE);

/*------------------------핵사값-> 십진수-------------------------*/
 int no;
 CString n,m_NoData ;
 char buf[4]; buf[0]='0';buf[1]='A';buf[2]='2';buf[3]='B';
 char data[4];
 for(int s=0; s<4; s++)
 {
 data[s] = buf[i];
 }
 no=AscHextoAscDec(data);
 n.Format("%d",no);
 m_NoData = n;
/*-----------------------AscHextoAscDec----------------------------*/
int CFileTestView::AscHextoAscDec(char hexnum[])
{
/* int dec;
 dec = (int)hex-48;
 if(dec>9)
 dec=dec-7;
 return dec;
*/
 int i=0;
 int Num[4],Sum;

 for(i=0; i<4; i++)
 {
  if(hexnum[i]>0x40)
   Num[i]=hexnum[i]-'A'+10;
  else
   Num[i]=hexnum[i]-'0';
 }
 Sum=Num[0]*16*16*16 + Num[1]*16*16 + Num[2]*16 + Num[3];

 return Sum;
}
/*---------------------- 십진수-> 핵사------------------*/
 int NUM;
 CString m_NoData;
 NUM=162;  ///핵사값=A2
 BYTE temp[3];
 temp[0] = HextoAsc(NUM/16);
 temp[1] = HextoAsc(NUM%16);
 temp[2] = '\0';
 m_NoData=temp;
/*-----------------------HextoAsc-----------------------*/
BYTE CFileTestView::HextoAsc(BYTE hexnum)
{
 unsigned char hex[] = { "0123456789ABCDEF" };
 unsigned char ascnum;
 ascnum = hex[hexnum%16]; 
 return ascnum; 
}
/*-----------------ASC-> 정수변환-----------------------*/ 
 int NanBangData;
  TCHAR  NanBang[5];
  NanBang[0] = pDoc->m_RsrBuf[9];
  NanBang[1] = pDoc->m_RsrBuf[10];
  NanBang[2] = pDoc->m_RsrBuf[11];
  NanBang[3] = pDoc->m_RsrBuf[12];
  NanBang[4] = '\0';
  NanBangData  = atoi(NanBang);
/*--------------------Format----------------------------*/

 int NO[4];
 CString n;
 NO=0x31;
 n.Format("%d%d%d%d",NO[0],NO[0],NO[0],NO[0]);
 no=atoi(n);
 m_NoData = n;
 if(no==2100){m_NoData="aa";}
 else{m_NoData ="bb";}
/*--------------------- strcat---------------------------*/
 char string[80];
 char temp2[20];
    strcpy( string, "Hello world from " );
    strcat( string, "1 " );
    strcat( string, "2 " );
    strcat( string, "!" );

 sprintf(temp2,"%s\n",string);
 AfxMessageBox(temp2);

/*-----------------strok----------------------------------*/

 char seps[] = ","; char *token; char string[250];
    ///*** Establish string and get the first token: 
 strcpy( string, ReadData); token = strtok(string, seps );

 char string[] = " 1 2 \n3,4,,,,,,end";
 char s

eps[]   = " ,\t\n";
 //char seps[]   = ",";
 char *token;

    ////////*** Establish string and get the first token: 
    token = strtok( string, seps );
    char temp2[20];
    while( token != NULL )
    {
       //////*** While there are tokens in "string" 
  sprintf(temp2,"%s",token);
  AfxMessageBox(temp2);
       ///////*** Get next token: 
       token = strtok( NULL, seps );
    }


 //----------------------------------------------------
  char *data;
  char szBuf[1024];

  CString InString="OK11,123,250,125";
  sprintf(szBuf,InString);
 
  data = strtok(szBuf,",");
  AfxMessageBox(data);
  
  data = strtok(NULL,",");
  AfxMessageBox(data);

  data = strtok(NULL,",");
  AfxMessageBox(data);

  data = strtok(NULL,",");
  AfxMessageBox(data);

//-------------------------------------------------------------------------------------------
 int MaxRow = MAXRAW+1;
 int MaxCol = MAXCOL;
 CString cs=""; CString csTmp="";
 int col=3;

 if(m_bSendAllCheck){m_bSendAllCheck=FALSE; cs="OK";}
 else{m_bSendAllCheck=TRUE;cs="-";}
 for (int row = 1; row < MaxRow; row++) {

  csTmp=m_GridCtrl.GetItemText(row, 1);
  if(csTmp!="")
  {
   m_GridCtrl.SetItemFormat(row, col, DT_CENTER|DT_VCENTER|DT_SINGLELINE);
   m_GridCtrl.SetItemText(row, col, cs);
  }
 }
 m_GridCtrl.Invalidate();
//--------------------------------------------------------------------------------------------
BOOL CXYSystemView::FileDataUpdate_RGB_Percent()
{
 __int16   length, exist;
 char   str[200];
 int index=0;
 int nListMaxCount=0;

 FILE   *fp ;
 CString   filename=_T("");
 CString   ReadData=_T("");
 CString   strTmp=_T("");   
 CString data=_T("");
 BOOL   bFileCheck=false;
 BOOL   bFileCheck2=false;

 filename = CSRGBPercentFileName;
 exist = access(filename,0);  

 if (!exist && (fp = fopen(filename,"rt")) != NULL) {
  while (!feof(fp)) {
   ReadData.Empty();
   if ( fgets(str, 200, fp) != NULL) {   // error Return NULL
    ReadData.Format("%s", str);
    length = ReadData.GetLength();

    if(bFileCheck2==false)//처움에만 찾기
    {
    index = ReadData.Find("#SETUP$");
    if(index>=0){bFileCheck=true; index=0; }
    else{AfxMessageBox("Save Data Not Find!"); break;}
    }

    index = ReadData.Find("\t");
    if(index>=0)
    {
    ReadData.Format("%s", ReadData.Mid(0 , length-2));
    }
    else
    {
    ReadData.Format("%s", ReadData.Mid(0 , length-1));
    }
  
    if(ReadData=="#ENDEQ$"){break;}

    if(bFileCheck)
    {
     if(bFileCheck2)
     {
      if(nListMaxCount>=CHMAX){AfxMessageBox("Posion X Save File Error!!");break;}
     
      if(ReadData!="")
      {
      // char seps[]   = " ,\t\n";
       char seps[]   = ",";
       char *token;
       char string[250];
         ////////*** Establish string and get the first token: 
       strcpy( string, ReadData);
         token = strtok(string, seps );
           int nCount=0;
         while( token != NULL )
         {
           ///////*** Get next token: 
          token = strtok( NULL, seps );
        if(nCount==0)
        FRGB_Percent_R[nListMaxCount]=atof(token);
        if(nCount==1)
        FRGB_Percent_G[nListMaxCount]=atof(token);
        if(nCount==2)
        FRGB_Percent_B[nListMaxCount]=atof(token);
        if(nCount==3)
        FRGB_Percent_Gray[nListMaxCount]=atof(token);

        nCount++;
         }
       nListMaxCount++;
      }
     }
    }
       bFileCheck2=true;//처움에만 찾기
   }
  }
 /// fclose(fp);
 } else {
 // SendDlgItemMessage(IDC_STATIC_WLREM, WM_SETTEXT,0,(LPARAM)(LPSTR)"DATA NONE");
 // AfxMessageBox("File Data Not Find! "+CSCHRunTimeFileName); 
  FileDataSave_RGB_Percent();
  return FALSE;
 }
 fclose(fp);return TRUE;
}

//------------------------------------------

 char string[] = "IMAGE1,IMAGE2,IMAGE3,IMAGE11,IMAGE4,IMAGE20";
 //char seps[]   = " ,\t\n";
 char seps[]   = ",";
 char *token;

    ////////*** Establish string and get the first token: 
    token = strtok( string, seps );
    char temp2[20];
    while( token != NULL )
    {
       //////*** While there are tokens in "string" 
  sprintf(temp2,"%s",token);
  AfxMessageBox(temp2);
       ///////*** Get next token: 
       token = strtok( NULL, seps );
    }
/*--------------------strlen--------------------------------*/
    char temp2[20];
    char buffer[61] = "How";
    int  len;
    len = strlen( buffer );
   // sprintf(temp2,"%d",len);
    sprintf(temp2,"%s",buffer);
    AfxMessageBox(temp2); 
/*---------------------- int--------------------------------*/
 int a=111;
 sprintf(temp,"%d",a);

/*------------문자 위치(길이) 결과 얻어내기------------------------------------*/

 InString="12345678+000 END";
 index = InString.Find("END");//END의 위치 값 0 ~ END 정수 값

 csText.Format("%d",index);
 AfxMessageBox(csText);

 index = InString.Find("+");
 m_csTmpString=InString.Left(index+2);//index 위치+2 까지 문자 얻음
 AfxMessageBox(m_csTmpString);


/*-----------지정 위치 문자 얻어 내기 --String.GetAt(n)--------------------------------------*/

  int Length2 =  NamBangDataBuf.GetLength();
   for(int n = 0; n < Length2; n++)
   {
   buf2[n] = NamBangDataBuf.GetAt(n);
   }
   buf2[n] = '\0';

  n 위치의 문자를 얻어냄
/*--------------------------------------------------------------
 index = InString.Find("+");//15
 while(index>=0)
 {
  m_csTmpString=InString.Left(index+2);//"+"위치 + 2 위치 문자얻음  "," 까지
  InString =InString.Right(InString.GetLength()-index-2); //전체에서 LEFT뺀 나머지 문자
  OneChar = m_csTmpString.GetAt(0);  //0  
  index = m_csTmpString.Find("N"); //4

  WAV[0] = m_csTmpString.GetAt(index-4); //V
  WAV[1]=NULL;
//  csText.Format("%d",nI);
//  AfxMessageBox(csText);
  OneChar = m_csTmpString.GetAt(index-1); //3번 위치의 "1" 얻음
  tmp[0]=OneChar; 
  tmp[1]=NULL; //temp= "1";
  nI=atoi(tmp);

/*--------------------------대문자로 바꿈--------------------------------*/
 CString Buf1;
 Buf1="abcdef";
 Buf1.MakeUpper();

 AfxMessageBox(Buf1);
/*-------------------------일부 문자 뽑아 내기--------------------------*/
 CString csTmp,InString;

 InString="#SNDATAok-aa#END";

 csTmp=FindData(InString, "#SN",'#');

 AfxMessageBox(csTmp);

 결과=DATAok-aa


CString CSECSystemView::FindData(CString csData, CString csFind, TCHAR OneChar)
{
 int length,index,index2;
 CString csTmp,csTmpData;

 index = csData.Find(csFind);//MODEL_INFO
 length = csFind.GetLength();

 csTmpData=csData.Right(csData.GetLength() - index - 1);
 index2 = csTmpData.Find(OneChar);//MODEL_INFO
 csTmp = csData.Mid(length+index,index2+1-length);
// csData.Format("index=%d",index2);
 if((index < 0)||(index2 < 0)) return _T("");
 else return csTmp;
}
//-------------------------------------------------------------------------------------
 char *token;
 char szBuf[1024];
 char seps[]   = "\\";
    ////////*** Establish string and get the first token:
 CString InString="C:\\DMX\\Bmp\\Field_R.bmp";
 sprintf(szBuf,InString);
 
 CString csGetData="";
 token = strtok(szBuf,seps);

    char temp2[20]; int Index=0;
    while( token != NULL )
    {
       //////*** While there are tokens in "string" 
  sprintf(temp2,"%s",token);
  csGetData=temp2;
       ///////*** Get next token: 
     token = strtok( NULL, seps );
    }

 int index=0;
 if(csGetData.GetLength()>0)index = csGetData.Find("."); else return;
 CString csData="";
 csData=csGetData.Mid(0,index); AfxMessageBox(csData);
//---------------------------------------------------------------------------------

 

/*-------------십진수값  자리분할 각각의 해당 자리수 버퍼에 저장----------------*/

 //------------------------------------------
  if(Sum>0)
   {
    hundred= (int)(Sum/ 100);
    ten= (Sum-(hundred*100))/10;
    one=Sum-((hundred*100)+(ten*10));
   }   
        //------------------------------------------

 int i,Sum,thousand,hundred,ten,one,Count; 
 Sum=thousand=hundred=ten=one=Count=0;
 
 char Rpm[4];
 char RpmBuf[4];

 for(i=0; i<4; i++)
 {
 Rpm[i]=0;
 RpmBuf[i]=0;
 }

 Sum=6234;
 
 for(i=0; i<Sum; i++)
 {   
  Count++;
  if(Count==10)
  {
   Count=0;

   ten++;
   if(ten==10)
   {
    hundred++;
    ten=0;
   
    if(hundred==10)
    {
     thousand++;
     hundred=0;
    }
   } 
  } 
 }
   
 one=Sum-((thousand*1000)+(hundred*100)+(ten*10));
   
 Rpm[0]=thousand;
 Rpm[1]=hundred;
 Rpm[2]=ten;
 Rpm[3]=one;
  
 CString Data;
 Data.Format("%d%d%d%d",Rpm[0],Rpm[1],Rpm[2],Rpm[3]);

 m_TestEdit=Data;

 UpdateData(FALSE);

/*---------------------테스트 모드가 ON 모드만 테스트----------------*/

    CString csTmp1,csTmp2;
    
 csTmp1="#";
     if(ccModel.nMode1==TRUE)
 {
 csTmp1+="1";
 }
 if(ccModel.nMode2==TRUE)
 {
 csTmp1+="2";
 }
 if(ccModel.nMode3==TRUE)
 {
 csTmp1+="3";
 }

 int index = csTmp1.Find("#");//15
 int set[8];

 int Length =  csTmp1.GetLength();

 for(int i=0; i<Length; i++)
 {
 set[i]=atoi(csTmp1.Mid(index+i,1));  
 }

 for(int n=0; n<Length; n++)
 {
  TestMode(set[n]);
 }
 
// csTmp2.Format("%d",set[2]);
// AfxMessageBox(csTmp2);

/*------------------------핵사값-> 십진수-------------------------*/
 int no;
 CString n,m_NoData ;
 char buf[4]; buf[0]='0';buf[1]='A';buf[2]='2';buf[3]='B';
 char data[4];
 for(int s=0; s<4; s++)
 {
 data[s] = buf[i];
 }
 no=AscHextoAscDec(data);
 n.Format("%d",no);
 m_NoData = n;

//-------------------------------------------------------------------//
BYTE CHexAscChangeView::AsctoHex(BYTE ascnum)
{
 unsigned char hex[] = { "0123456789ABCDEF" };
 unsigned char i=0;

 do
 {
  if(hex[i] == ascnum)
  {
   return i;
  }
 i++;
 }while(i<16);
 return 0;
}

/*-----------------------AscHextoAscDec----------------------------*/
int CFileTestView::AscHextoAscDec(char hexnum[])
{
/* int dec;
 dec = (int)hex-48;
 if(dec>9)
 dec=dec-7;
 return dec;
*/
 int i=0;
 int Num[4],Sum;

 for(i=0; i<4; i++)
 {
  if(hexnum[i]>0x40)
   Num[i]=hexnum[i]-'A'+10;
  else
   Num[i]=hexnum[i]-'0';
 }
 Sum=Num[0]*16*16*16 + Num[1]*16*16 + Num[2]*16 + Num[3];

 return Sum;
}
/*---------------------- 십진수-> 핵사-------------------*/
 int NUM;
 CString m_NoData;
 NUM=162;  ///핵사값=A2
 BYTE temp[3];
 temp[0] = HextoAsc(NUM/16);
 temp[1] = HextoAsc(NUM%16);
 temp[2] = '\0';
 m_NoData=temp;
/*-----------------------HextoAsc-----------------------*/
BYTE CFileTestView::HextoAsc(BYTE hexnum)
{
 unsigned char hex[] = { "0123456789ABCDEF" };
 unsigned char ascnum;
 ascnum = hex[hexnum%16]; 
 return ascnum; 
}
/*-----------------ASC-> 정수변환-----------------------*/ 
 int NanBangData;
  TCHAR  NanBang[5];
  NanBang[0] = pDoc->m_RsrBuf[9];
  NanBang[1] = pDoc->m_RsrBuf[10];
  NanBang[2] = pDoc->m_RsrBuf[11];
  NanBang[3] = pDoc->m_RsrBuf[12];
  NanBang[4] = '\0';
  NanBangData  = atoi(NanBang);
/*--------------------Format----------------------------*/

 int NO[4];
 CString n;
 NO=0x31;
 n.Format("%d%d%d%d",NO[0],NO[0],NO[0],NO[0]);
 no=atoi(n);
 m_NoData = n;
 if(no==2100){m_NoData="aa";}
 else{m_NoData ="bb";}
/*--------------------- strcat---------------------------*/
 char string[80];
 char temp2[20];
    strcpy( string, "Hello world from " );
    strcat( string, "1 " );
    strcat( string, "2 " );
    strcat( string, "!" );

 sprintf(temp2,"%s\n",string);
 AfxMessageBox(temp2);

/*-----------------strok----------------------------------*/
 char string[] = " 1 2 \n3,4,,,,,,end";
 char seps[]   = " ,\t\n";
 //char seps[]   = ",";
 char *token;

   ////////*** Establish string and get the first token: 
   token = strtok( string, seps );
   char temp2[20];
   while( token != NULL )
   {
      //////*** While there are tokens in "string" 
  sprintf(temp2,"%s",token);
  AfxMessageBox(temp2);
      ///////*** Get next token: 
      token = strtok( NULL, seps );
   }
/*--------------------strlen--------------------------------*/
   char temp2[20];
   char buffer[61] = "How";
   int  len;
   len = strlen( buffer );
  // sprintf(temp2,"%d",len);
   sprintf(temp2,"%s",buffer);
   AfxMessageBox(temp2); 

/*---------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - 이미지 -  ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/


//------Gray    변경------------------------------------------------//
   float r, g, b, gray;

   r=m_pTestBitmap[ADD1]/255.0f;
   g=m_pTestBitmap[ADD2]/255.0f;
   b=m_pTestBitmap[ADD3]/255.0f;
   RGBToGrayMul(r,g,b,&gray);
   gray= (unsigned char)(gray*255.0);

   //++++++++++++++++++++++++++++
   if(gray > 100)//이미지 검출값
   //++++++++++++++++++++++++++++
   //++++++++++++++++++++++++++++

//----------------------------------------------------------------------------------------
//Image 수평 분할 display
/* CClientDC pDC(this);
 int Add_x,Add_y=0;
 int DivisionRate= PaletteSize_y*5;

 if(m_bPaletteChange)
 {
  for(y=0; y<PaletteSize_y+8; y++)
  {
   for(x=0; x<PaletteSize_x+8; x++)
   { 
  // pDC.SetPixel(x+BMP_START_EDGE_X1-10,y+BMP_START_EDGE_Y1-10,RGB(122,123,102)); 
   pDC.SetPixel(x+BMP_START_EDGE_X1-4,y+BMP_START_EDGE_Y1-4,RGB(122,123,102)); 
   }
  }
  m_bPaletteChange=FALSE;
 }
 else
 {
  for(y=0; y<PaletteSize_y*ImageMaxNo; y++)
  {
  for(x=0; x<PaletteSize_x; x++)
  { 
   if(y<DivisionRate)
   {
   pDC.SetPixel(x+BMP_START_EDGE_X1,y+BMP_START_EDGE_Y1,RGB(255,255,255));
   }
   else
   {  
   Add_x= PaletteSize_x*(y/DivisionRate)+(y/DivisionRate)*10;
   Add_y=DivisionRate*(y/DivisionRate);
   
   pDC.SetPixel((x+BMP_START_EDGE_X1)+Add_x,(y+BMP_START_EDGE_Y1)-Add_y,RGB(255,255,255));
   }
  }  
  }
 }

 //Image를 다섯개씩 분할 수평으로 디스플레이 
 for(y=0; y<PaletteSize_y*ImageMaxNo; y++)
 {
  for(x=0; x<PaletteSize_x; x++)
  { 
   if(y<DivisionRate)
   {
   pDC.SetPixel(x+BMP_START_EDGE_X1,y+BMP_START_EDGE_Y1,RGB(m_DisplayImg_A[(y*WidthLineSize)+(3*x)+2],m_DisplayImg_A[(y*WidthLineSize)+(3*x)+1],m_DisplayImg_A[(y*WidthLineSize)+(3*x)+0]));
   }
   else
   {  
   Add_x= PaletteSize_x*(y/DivisionRate)+(y/DivisionRate)*10;
   Add_y=DivisionRate*(y/DivisionRate);
   
   pDC.SetPixel((x+BMP_START_EDGE_X1)+Add_x,(y+BMP_START_EDGE_Y1)-Add_y,RGB(m_DisplayImg_A[(y*WidthLineSize)+(3*x)+2],m_DisplayImg_A[(y*WidthLineSize)+(3*x)+1],m_DisplayImg_A[(y*WidthLineSize)+(3*x)+0]));
   }
  }  
 }
//-------------------------------------------------------------------------------------------------
*/
/*
//-----------------------------------------------------------------------------------
//Binary File Save
//----------------------------------------------
// R  G  B    3Byte를 2Byte로 변환   
// 00000000  00000000
// 11111                R -5비트  32     256/8 
//      111  111        G -6비트  64     256/4
//              11111   B -5비트  32     256/8
//----------------------------------------------
 //(128x(96*ImageNo))*2   한 픽셀 표현 2바이트 ,이미지 저장할 파일 사이즈
 int ImageFileSize=(PaletteSize_x*(PaletteSize_y*ImageMaxNo)*2);

 unsigned char *BinOutImg;
 BinOutImg = NULL;     //변경전 Image file size
 BinOutImg   = new unsigned char [3*WidthLineSize*(PaletteSize_y*ImageMaxNo)];

 index=0; n=0;

 for(y=0; y<PaletteSize_y*ImageMaxNo; y++)
 {
  for(x=0; x<PaletteSize_x; x++)
  { 
   index=n*2;
   BinOutImg[index+0]=(((OutImg[(y*WidthLineSize)+(3*x)+2])/8)<<3)|(((OutImg[(y*WidthLineSize)+(3*x)+1])/4)>>3);
   BinOutImg[index+1]=(((OutImg[(y*WidthLineSize)+(3*x)+1])/4)<<5)|(((OutImg[(y*WidthLineSize)+(3*x)+0])/8)); 
   n++;
  }
 }
 FILE *outfile;
 CString csImageFile;

 csImageFile.Format("C:\\ModuleAging\\Bin\\%d.bin",PaletteSize_x);
 outfile = fopen(csImageFile,"wb");

 fwrite(BinOutImg,sizeof(char),ImageFileSize,outfile); 
 fclose(outfile);

 if(BinOutImg) delete []BinOutImg;
//----------------------------------------------------------------------------------- 
 //BMP File Save
 unsigned char *BmpOutImg=NULL;
 BmpOutImg = new unsigned char [(PaletteSize_y*ImageMaxNo)*(PaletteSize_x*24)*3];

 for(y=0; y<PaletteSize_y*ImageMaxNo; y++) //BMP 화일로 저장 하기위해 거꾸로 저장
 {
  y2=((PaletteSize_y*ImageMaxNo)-y);//-1 중요(최종 한줄 표현)
  for(x=0; x<PaletteSize_x; x++)
  { 
   BmpOutImg[(y2*WidthLineSize)+(3*x)+2]=OutImg[(y*WidthLineSize)+(3*x)+2];
   BmpOutImg[(y2*WidthLineSize)+(3*x)+1]=OutImg[(y*WidthLineSize)+(3*x)+1];
   BmpOutImg[(y2*WidthLineSize)+(3*x)+0]=OutImg[(y*WidthLineSize)+(3*x)+0];
  }
 }

 DWORD dwBitsSize = sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*256+WidthLineSize*PaletteSize_y*sizeof(char); 
 
 dibHi.biWidth=PaletteSize_x;
 dibHi.biHeight=PaletteSize_y*ImageMaxNo;
 dibHi.biBitCount =24;
 dibHi.biSizeImage = 3*WidthLineSize*(PaletteSize_y*ImageMaxNo);
 dibHi.biClrUsed = dibHi.biClrImportant =0;
 
 dibHf.bfType=0x4D42; 
 dibHf.bfSize = dwBitsSize+sizeof(BITMAPFILEHEADER); // 전체파일 크기 
 if(dibHi.biBitCount==24) dibHf.bfSize -= sizeof(RGBQUAD)*256; // no pallette 
 dibHf.bfOffBits = dibHf.bfSize - WidthLineSize*PaletteSize_y*sizeof(char); 
 dibHf.bfReserved1=dibHf.bfReserved2=0;

 FILE *outfile2;
 csImageFile.Format("C:\\ModuleAging\\EquipSys\\%d.bmp",PaletteSize_x);
 outfile2 = fopen(csImageFile,"wb");

 fwrite(&dibHf,sizeof(char),sizeof(BITMAPFILEHEADER),outfile2);
 fwrite(&dibHi,sizeof(char),sizeof(BITMAPINFOHEADER),outfile2);
 fwrite(BmpOutImg,sizeof(char),3*WidthLineSize*dibHi.biHeight,outfile2); 
 fclose(outfile2);
 if(BmpOutImg) delete []BmpOutImg;
*/


/*--------------------------------------------------------------------------------------*/
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// - 그래픽 -  ////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/*--------------------------------------------------------------------------------------*/


CDC memDC;
CBitmap memBmp,*pOldBmp;
memDC.CreateCompatibleDC( &dc );
memBmp.CreateCompatibleBitmap( &dc,m_rectWindow.Width(),m_rectWindow.Height() );
pOldBmp = (CBitmap*)memDC.SelectObject( &memBmp );

if( memDC.GetSafeHdc() != NULL ) 

{   // memDC에 그린다..

    memDC.BitBlt( 0,0,m_rectWindow.Width(),m_rectWindow.Height(),&m_memBackDC, 0,0,SRCCOPY );   // 그리기
    memDC.BitBlt( 
    dc.BitBlt( 0,0, nWidth, nHeight, &memDC, 0, 0, SRCCOPY );   // Main DC에 옮겨 쓰기
} 

memDC.SelectObject( pOldBmp );

//######################
http://www.ucancode.net
//######################

//-------------------------------------------------------------------
BOOL Ellipse(int x1, int y1, int x2, int y2);

//-------------------------------------------------------------------
BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3);
BOOL RoundRect(PCRECT lpRect, POINT point);
When this member function executes, the rectangle is drawn from the (x1, y1) to the (x2, y2) points. The corners are rounded by an ellipse whose width would be x3 and the ellipse's height would be x3. 
//-------------------------------------------------------------------
BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
The (x1, y1) point determines the upper-left corner of the rectangle in which the ellipse that represents the pie fits. The (x2, y2) point is the bottom-right corner of the rectangle. These two points can also be combined in a RECT or a CRect variable and passed as the lpRect value.

The (x3, y3) point, that can also supplied as a POINT or CPoint for lpStart argument, specifies the starting corner of the pie in a default counterclockwise direction.

The (x4, y4) point, or ptEnd argument, species the end point of the pie.

To complete the pie, a line is drawn from (x3, y3) to the center and from the center to the (x4, y4) points.
//-------------------------------------------------------------------

To draw an arc, you can use the CDC::Arc() method whose syntax is:

BOOL Arc(int x1, int y1, int x2, int y2,
 int x3, int y3, int x4, int y4);
Besides the left (x1, y1) and the right (x2, y2) borders of the rectangle in which the arc would fit, an arc must specify where it starts and where it ends. These additional points are set as the (x3, y3) and (x4, y4) points of the figure. Based on this, the above arc can be illustrated as follows:
//-------------------------------------------------------------------
This method uses the same arguments as Arc(). The difference is that while Arc() starts drawing at (x3, y3), ArcTo() does not inherently control the drawing starting point. It refers to the current point, exactly like the LineTo() (and the PolylineTo()) method. Therefore, if you want to specify where the drawing should start, can call CDC::MoveTo() before ArcTo(). Here is an example:

void CExoView::OnDraw(CDC* pDC)
{
 CRect Recto(20, 20, 226, 144);
 CPoint Pt1(202, 115);
 CPoint Pt2(105, 32);

 pDC->MoveTo(207, 155);
 pDC->ArcTo(Recto, Pt1, Pt2);
}
 
//------------------------------------------------------------------------
You may wonder why the arc is drawn to the right side of a vertical line that would cross the center of the ellipse instead of the left. This is because the drawing of an arc is performed from right to left or from bottom to up, in the opposite direction of the clock. This is known as the counterclockwise direction. To control this orientation, the CDC class is equipped with the SetArcDirection() method. Its syntax is:

int SetArcDirection(int nArcDirection);
This method specifies the direction the Arc() method should follow from the starting to the end points. The argument passed as nArcDirection controls this orientation. It can have the following values:

  Value Orientation 
  AD_CLOCKWISE The figure is drawn clockwise 
  AD_COUNTERCLOCKWISE The figure is drawn counterclockwise 

The default value of the direction is AD_COUNTERCLOCKWISE. Therefore, this would be used if you do not specify a direction. Here is an example that uses the same values as above with a different orientation:

void CExoView::OnDraw(CDC* pDC)
{
 pDC->SetArcDirection(AD_CLOCKWISE);

 pDC->Arc(20, 20, 226, 144, 202, 115, 105, 32);
}
//------------------------------------------------------------------------ 
You can (also) draw an arc using the CDC::AngleArc() method. Its syntax is:

BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle);
This member function draws a line and an arc connected. The arc is based on a circle and not an ellipse. This implies that the arc fits inside a square and not a rectangle. The circle that would be the base of the arc is defined by its center located at C(x, y) with a radius of nRadius. The arc starts at an angle of fStartAngle. The angle is based on the x axis and must be positive. That is, it must range from 0° to 360°. If you want to specify an angle that is below the x axis, such as -15°, use 360º-15°=345°. The last argument, fSweepAngle, is the angular area covered by the arc.

The AngleArc() method does not control where it starts drawing. This means that it starts at the origin, unless a previous call to MoveTo() specified the beginning of the drawing.

Here is an example:

void CExoView::OnDraw(CDC* pDC)
{
 pDC->MoveTo(52, 28);
 pDC->AngleArc(120, 45, 142, 345, -65);
}
//------------------------------------------------------------------------  

//------삼각형 그리기------------------------------------------------//
 //CDraw1Doc* pDoc = GetDocument();
 //ASSERT_VALID(pDoc);

 CBrush NewBrush(RGB(255, 2, 5));
 CBrush *pBrush;
 
 CPoint Pt[3];

 CDC *pDC = GetDC();

 // Top Triangle
 Pt[0] = CPoint(125,  10);
 Pt[1] = CPoint( 95,  70);
 Pt[2] = CPoint(155,  70);

 pBrush = pDC->SelectObject(&NewBrush);
 pDC->Polygon(Pt, 3);

 // Left Triangle
 Pt[0] = CPoint( 80,  80);
 Pt[1] = CPoint( 20, 110);
 Pt[2] = CPoint( 80, 140);

 pDC->Polygon(Pt, 3);

 // Bottom Triangle
 Pt[0] = CPoint( 95, 155);
 Pt[1] = CPoint(125, 215);
 Pt[2] = CPoint(155, 155);
 
 pDC->Polygon(Pt, 3);

 // Right Triangle
 Pt[0] = CPoint(170,  80);
 Pt[1] = CPoint(170, 140);
 Pt[2] = CPoint(230, 110);

 pDC->Polygon(Pt, 3);

 pDC->SelectObject(pBrush);

//------사각그리기------------------------------------------------//
 CPen penRectBlack(PS_SOLID,1,RGB(255,0,0));
 pDC->SelectObject(&penRectBlack);
 pDC->MoveTo(m_MatchPos.left,m_MatchPos.top);
 pDC->LineTo(m_MatchPos.right,m_MatchPos.top);
 pDC->LineTo(m_MatchPos.right,m_MatchPos.bottom);
 pDC->LineTo(m_MatchPos.left,m_MatchPos.bottom);
 pDC->LineTo(m_MatchPos.left,m_MatchPos.top);


//------Text 출력------------------------------------------------//
 CFont *Font,*oldFont;
 Font=new CFont;

 LOGFONT logFont; int nFontHight=25;
 logFont.lfStrikeOut=FALSE;//가운데 선긋기
 logFont.lfItalic=TRUE;logFont.lfUnderline=FALSE;
 logFont.lfEscapement= 0;logFont.lfHeight=nFontHight;
 logFont.lfCharSet=HANGEUL_CHARSET;//ANSI_CHARSET;

// Font->CreatePointFont(240,_T("굴림"));
// Font->GetLogFont(&logFont);
 Font->CreateFontIndirect(&logFont);
 oldFont=dc.SelectObject(Font);

 dc.SetBkMode(TRANSPARENT);//dc.SetTextCharacterExtra(2);//행간격
 dc.SetTextColor(RGB(255,0,0));//dc.SetBkColor(RGB(255,0,0));
 //---------------------------------------------
 nTextLine_x=SpotRect.left;//+((SpotRect.right-SpotRect.left)/2);
 nTextLine_y=AddBottom+MAINDIS_START_Y-58-8;
 dc.TextOut(nTextLine_x,nTextLine_y-15,csLineSize_x);//x,가로 치수 텍스트

 dc.SelectObject(oldFont);delete Font;

 Font=new CFont;
 logFont.lfEscapement= -900;logFont.lfHeight=nFontHight;
 Font->CreateFontIndirect(&logFont);
 oldFont=dc.SelectObject(Font);

 nTextLine_x=SpotRect.right+16;nTextLine_y=AddBottom+MAINDIS_START_Y-25;
 dc.TextOut(nTextLine_x,nTextLine_y-15,csLineSize_y);//y,세로 치수 텍스트
// CRect rect;
// rect.left=nTextLine_x; rect.right=nTextLine_x+30;
// rect.top=nTextLine_y-15;rect.bottom=nTextLine_y+30;
/// dc.DrawText(csLineSize_y,&rect,DT_SINGLELINE|DT_CENTER|DT_VCENTER);//y,세로 치수 텍스트
 //---------------------------------------------

 dc.SelectObject(oldFont);delete Font;
 //dc.SelectObject(oldFont);Font.DeleteObject();
 dc.SelectObject(pOldPen);NewPen.DeleteObject();

/*-------------------------------------------------------------------
 CFont Font,*oldFont;
 LOGFONT logFont;

 int m_nFontSize=14;
 CString m_strFont="바탕체";
 Font.CreateFont(m_nFontSize,m_nFontSize,-900,0,FW_DONTCARE,FALSE,
      FALSE,FALSE,DEFAULT_CHARSET,OUT_DEFAULT_PRECIS,
      CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,DEFAULT_PITCH,
      m_strFont);

 oldFont=dc.SelectObject(&Font);
 dc.SetBkMode(TRANSPARENT);//dc.SetTextCharacterExtra(2);//행간격
 dc.SetTextColor(RGB(255,0,0));//dc.SetBkColor(RGB(255,0,0));
 //---------------------------------------------
 nTextLine_x=SpotRect.left;//+((SpotRect.right-SpotRect.left)/2);
 nTextLine_y=AddBottom+MAINDIS_START_Y-60;
 dc.TextOut(nTextLine_x,nTextLine_y-15,csLineSize_x);//x,가로 치수 텍스트
 dc.SelectObject(oldFont);Font.DeleteObject();

 nTextLine_x=SpotRect.right+6;nTextLine_y=AddBottom+MAINDIS_START_Y-20;
// dc.TextOut(nTextLine_x,nTextLine_y-15,csLineSize_y);//y,세로 치수 텍스트
 CRect rect;
 rect.left=nTextLine_x; rect.right=nTextLine_x+30;
 rect.top=nTextLine_y-15;rect.bottom=nTextLine_y+30;

 dc.DrawText(csLineSize_y,&rect,DT_SINGLELINE|DT_CENTER|DT_VCENTER);//y,세로 치수 텍스트
 //---------------------------------------------

 dc.SelectObject(oldFont);Font.DeleteObject();
 dc.SelectObject(pOldPen);NewPen.DeleteObject();


/*--------------------사인파그래프---------------------------*/

 for (f=-500;f<2000;f++) {
 y=(int)(sin(f*3.14/180)*100);
 SetPixel(hdc, (int)f, y,RGB(0,0,0));
 }
/*--------------------그래프--------------------------------*/
void CGrapeDlg::OnPaint() 
{
 CPaintDC dc(this); // device context for painting
 
 // TODO: Add your message handler code here
  for(int i=0; i<3; i++)
 {
  GrapeDrawEX(i);
 }
 // Do not call CDialog::OnPaint() for painting messages
}

void CGrapeDlg::GrapeDrawEX(int SetNo)
{
 CClientDC dc(this);

 int xStartPoint;
 int yStartPoint;
 COLORREF GrapeLineColor;

 if(SetNo==0)
 { 
  xStartPoint=32;
  yStartPoint=150;
  GrapeLineColor= RGB(0,250,250);
 }
 else if(SetNo==1)
 { 
 xStartPoint=32;
 yStartPoint=350;
 GrapeLineColor= RGB(0,250,0);
 }
 else if(SetNo==2)
 { 
 xStartPoint=32;
 yStartPoint=550;
 GrapeLineColor= RGB(0,0,250);
 }
 int xExpand=22;/*x시간확장 11 or 22*/
 int yExpand=(40/2)+(40/2);/*y온도 범위확장 20 or 40*/
 int xLimit=40;/*y_pixel 나누기 단위 20 or 40*/
 int yLimit=40/2; /*x_pixel 나누기 단위* 20 or 40*/
 int yTatalNo=200/2; /*100 or 200 select*/

 int xwidth=960;/*480 or 960*/
 int yhigh=200/2;/*100 or 200*/
 int width=xwidth+xStartPoint+xExpand; //width,high
 int high=yhigh+yStartPoint+yExpand; 

 int ThermoBufX[24];
 int ThermoBuf[24];
 ThermoBuf[0]=20;
 ThermoBuf[1]=30;
 ThermoBuf[2]=40;
 ThermoBuf[3]=45;
 ThermoBuf[4]=50;
 ThermoBuf[5]=40;
 ThermoBuf[6]=40;
 ThermoBuf[7]=50;
 ThermoBuf[8]=50;
 ThermoBuf[9]=55;
 ThermoBuf[10]=60;
 ThermoBuf[11]=70;
 ThermoBuf[12]=80;
 ThermoBuf[13]=90;
 ThermoBuf[14]=100;
 ThermoBuf[15]=105;
 ThermoBuf[16]=104;
 ThermoBuf[17]=100;
 ThermoBuf[18]=97;
 ThermoBuf[19]=98;
 ThermoBuf[20]=100;
 ThermoBuf[21]=101;
 ThermoBuf[22]=100;
 ThermoBuf[23]=100;
/*---------------Backgndbrush---------*/
 COLORREF m_BackgndBrush= RGB(0,0,0);
 CBrush brush(m_BackgndBrush),*pOldBrush;
 pOldBrush = (CBrush *)dc.SelectObject(&brush);
 dc.Rectangle(xStartPoint,yStartPoint,width,high);
/*---------------BaseTime/Thermo_brush---------*/
 COLORREF m_BaseTimebrush= RGB(250,250,250);
 CBrush brush2(m_BaseTimebrush);
 dc.SelectObject(&brush2);
 dc.Rectangle(xStartPoint-27,high,width+2,high+20);/*time*/
 dc.Rectangle(xStartPoint-27,yStartPoint,xStartPoint,high+20);/*thermo*/

/*---------------단위pixel-------------*/
 for(int i=xStartPoint; i<width; i+=xLimit)
 {
  for(int n=yStartPoint; n<high; n+=yLimit)
  {
  dc.SetPixel(i,n,RGB(0,250,250));
  }
 }
/*----------------전체 테두리-중간 Rect1-----------------*/
 CPen penRectBlue1(PS_SOLID,2,RGB(50,0,250)),*pOldPen;
 pOldPen = dc.SelectObject(&penRectBlue1);
 dc.MoveTo(xStartPoint-27,yStartPoint);
 dc.LineTo(width,yStartPoint);
 dc.LineTo(width,high+20);
 dc.LineTo(xStartPoint-27,high+20);
 dc.LineTo(xStartPoint-27,yStartPoint);
/*---------------전체 테두리-안쪽-------------------*/
 CPen penRectYello2(PS_SOLID,2,RGB(250,250,0));
 dc.SelectObject(&penRectYello2);
 dc.MoveTo(xStartPoint+4,yStartPoint+4);
 dc.LineTo(width-4,yStartPoint+4);
 dc.LineTo(width-4,high-4);
 dc.LineTo(xStartPoint+4,high-4);
 dc.LineTo(xStartPoint+4,yStartPoint+4);

/*---------------전체 테두리-바깥  Rect3-------------------*/
 CPen penRectBlack(PS_SOLID,4,RGB(0,250,250));
 dc.SelectObject(&penRectBlack);
 dc.MoveTo(xStartPoint-3-27,yStartPoint-3);
 dc.LineTo(width+3,yStartPoint-3);
 dc.LineTo(width+3,high+20+3);
 dc.LineTo(xStartPoint-3-27,high+20+3);
 dc.LineTo(xStartPoint-3-27,yStartPoint-3);
/*---------------온도 기준 line-------------------*/
 CPen penRectBlack2(PS_SOLID,2,RGB(0,0,0));
 dc.SelectObject(&penRectBlack2);
 dc.MoveTo(xStartPoint-26,high);
 dc.LineTo(xStartPoint,high);
/*---------------각시간 지시선 ----------------------*/
 CPen penWhite(PS_SOLID,2,RGB(250,250,250));
 dc.SelectObject(&penWhite);

 for(int n2=xStartPoint+xLimit; n2<width; n2+=xLimit)
 {
 dc.MoveTo(n2,high-6);
 dc.LineTo(n2,high-16);
 }
/*---------------각온도 지시선-----------------------*/
 for(int n3=yStartPoint+yLimit; n3<high; n3+=yLimit)
 {
 dc.MoveTo(xStartPoint+6,n3);
 dc.LineTo(xStartPoint+16,n3);
 }
/*--------------x_BaseTime출력Text---------------*/
 CString TimeText;
 int time=0;
// ModifyStyleEx(0,WS_BORDER,SWP_DRAWFRAME);
 dc.SetBkMode(TRANSPARENT);
 dc.SetTextColor(RGB(50,0,0));
 for(int a2=xStartPoint+xLimit; a2<width; a2+=xLimit)
 {
  time++;
  TimeText.Format("%d",time);
  dc.TextOut(a2-6,high+3,TimeText); 
 }
 dc.SetTextColor(RGB(250,0,0));
 dc.TextOut(xStartPoint-25,yStartPoint-24,"( 'C )"); 
 dc.SetTextColor(RGB(0,0,250));
 dc.TextOut(xStartPoint+36,high+26,"TIME- - -"); 
/*----------------y_Base온도Text--------------------*/
 CString ThermoText;
 for(int a3=yStartPoint+yLimit; a3<high; a3+=yLimit)
 {
  if(yhigh==100)
  {
  ThermoText.Format("%d",yTatalNo-((a3-yLimit)-yStartPoint)+yLimit);
  dc.TextOut(xStartPoint-24,a3-8,ThermoText); 
  }
  else if(yhigh==200)
  {
  ThermoText.Format("%d",(yTatalNo-((a3-yLimit)-yStartPoint)+yLimit)/2);
  dc.TextOut(xStartPoint-24,a3-8,ThermoText); 
  }
 }
/*------------온도 point 꼭지점 ----------*/  
 int count1=0;
 int xMove=3;
 int point_x=6;
 int point_y=6;
 CPen penWhite2(PS_SOLID,4,RGB(250,0,50));
 dc.SelectObject(&penWhite2);

 for(int c=xStartPoint+xLimit; c<width; c+=xLimit)
 {
  ThermoBufX[count1]=c;
  count1++;
 }
 for(int c2=0; c2<24; c2++)
 {
  if(yTatalNo==100)
  {
  dc.Ellipse(ThermoBufX[c2]-xMove,(yTatalNo-ThermoBuf[c2])+yStartPoint+yExpand,ThermoBufX[c2]+point_x-xMove,(yTatalNo-ThermoBuf[c2])+yStartPoint+yExpand+point_y);
  }
  else if(yTatalNo==200)
  {
  dc.Ellipse(ThermoBufX[c2]-xMove,((yTatalNo/2)-ThermoBuf[c2])*2+yStartPoint+yExpand,ThermoBufX[c2]+point_x-xMove,((yTatalNo/2)-ThermoBuf[c2])*2+yStartPoint+yExpand+point_y);
  }
 }
/*-------------온도 그래프 실선--------*/
int count2=0;
int GrapeStartPoint=yhigh+yStartPoint+yExpand-4;
 CPen penGrapeRed(PS_SOLID,1,GrapeLineColor);
 dc.SelectObject(&penGrapeRed);
 dc.MoveTo(xStartPoint+4,GrapeStartPoint);

 for(int d=xStartPoint+xLimit; d<width; d+=xLimit)
 {
  ThermoBufX[count2]=d;
  count2++;
 }
 for(int d2=0; d2<24; d2++)
  {
   if(yTatalNo==100)
   {
   dc.LineTo(ThermoBufX[d2],(yTatalNo-ThermoBuf[d2])+yStartPoint+yExpand+3);
   }
   else if(yTatalNo==200)
   {
   dc.LineTo(ThermoBufX[d2],((yTatalNo/2)-ThermoBuf[d2])*2+yStartPoint+yExpand+3);
   }
  }
/*--------------온도출력 Text---------------*/
// ModifyStyleEx(WS_BORDER,0,SWP_DRAWFRAME);
 CString TextData;
 dc.SetBkMode(TRANSPARENT);
 dc.SetTextColor(RGB(250,250,250));

 for(int a=0; a<24; a++)
 {
  TextData.Format("%d",ThermoBuf[a]);
  if(yTatalNo==100)
  {
  dc.TextOut(ThermoBufX[a]-6,(yTatalNo-ThermoBuf[a])+yStartPoint+yExpand-20,TextData); 
  }
  else if(yTatalNo==200)
  {
  dc.TextOut(ThermoBufX[a]-6,((yTatalNo/2)-ThermoBuf[a])*2+yStartPoint+yExpand-20,TextData); 
  }
 } 
/*-----------------------------------------------*/
 dc.SelectObject(pOldBrush);
 dc.SelectObject(pOldPen);
/*------------------------------------------------*/ 


19.	MFC 데이터베이스
1.	데이터베이스 프로그래밍 인터페이스
	A. 전용프로그래밍 인터페이스
  		i. 각 DBMS 회사마다 제공하는 프로그래밍 인터페이스
	B. 공영프로그래밍 인터페이스
		i. 다양한 DBMS를 하나의 일관된 인터페이스로 다룰 수 있도록 만든 프로그래밍 인터페이스
2.	윈도우 데이터베이스 프로그래밍 인터페이스
	A. DAO
		i. 마이크로소프트 제트(Jet) 데이터베이스 엔진을 이용하여 데이터베이스에 접근하기 위한 인터페이스
		ii. MFC의 CDaoDatabase 클래스 등을 이용하여 프로그래밍 가능
	B. ODBC
		i. 하나의 인터페이스로 다양한 종류의 DBMS를 접근할 수 있도록 만든 성공적인 공개 인터페이스
		ii. MFC의 CDatabase 클래스 등을 이용하여 프로그래밍 가능
	C. RDO
		i. COM 기술을 이용해서 ODBC를 포장한 것
	D. OLE DB
		i. ODBC의 성공을 바탕으로 만든 새로운 공개 인터페이스
		ii. COM 기술을 이용한 새로운 데이터베이스 프로그래밍 방법
		iii. OLE DB 공급자를 통해 다양한 종류의 DBMS에 접근할 수 있으며, ODBC용 OLE DB 공급자를 사용하여 기존의 ODBC도 지원
	E. ADO
		i. OLE DB가 제공하는 기능을 좀더 쉽게 사용할 수 있도록 만든 COM 기술 기반의 프로그래밍 인터페이스
		ii. OLE DB에 기반하기 때문에 다양한 종류의 데이터베이스를 다룰 수 있고, 고성능을 냄. 언어 독립적이어서 베이직, C/C++, 자바 등 다양한 언어로 프로그래밍 가능
3.	MFC ODBC 
	A. 데이터베이스 클래스
		i. CDatabase 클래스는 데이터베이스와의 연결을 나타내며, 이 객체를 통해 해당 데이터베이스를 조작함
		ii. 데이터베이스에 접근하려면 가장 먼저 CDatabase 객체를 만들어야 함
	B. 레코드셋 클래스
		i. CRecordSet 클래스는 레코드셋을 나타내며, 데이터를 추가, 삭제, 갱신 등의 작업을 할 때 핵심적인 역할을 함
	C. 예외 처리 클래스
		i. CDBException 클래스는 데이터베이스를 조작할 때 발생하는 오류를 나타냄
4.	주요함수
	A. 데이터베이스 객체 생성
		i. lpszConnectString
			1. 사용할 데이터 원본 이름과 ID, 암호 등을 문자열로 넘겨줌. ID와 암호가 없을 경우 생략 가능
		ii. dwOptions
			1. 비트 매스크로 옵션 지정
	B. 레코드셋 객체 생성
		i. pDatabase
			1. 데이터베이스 객체의 주소
			2. rs.Open(CRecordset::dynaset, "SELECT * FROM Table1");
		ii. nOpenType
			1.	CRecordset::dynaset 다른 사용자 변경 대부분의 내용 반영
				양방향 스크롤의 레코드셋. 레코드셋의 멤버쉽과 순서는 레코드셋이 열릴 때 결정되지만, 데이터 값에 대한 다른 사용자에 의한 변화는 패치 동작 이후에 보여지게 된다. 다이나셋은 keyset-driven 레코드셋으로도 알려져 있다.
			2.	CRecordset::snapshot 다른 사용자가 변경한 내용 반영안됨
				양방향 스크롤의 정적 레코드셋. 레코드의 멤버쉽과 순서는 레코드셋이 열릴 때 결정된다. 데이터 값은 레코드가 패치 될 때 결정된다. 다른 사용자에 의한 변경은 레코드셋이 닫혔다가 다시 열릴 때까지 보이지 않는다.
			3.	CRecordset::dynamic 다른 사용자가 변경한 모든 내용 반영
				양방향 스크롤의 레코드셋. 다른 사용자에 의한 멤버쉽, 순서, 데이터 값의 변화는 패치 동작 이후에 보여진다. 많은 ODBC 드라이버들이 이 형태의 레코드셋을 지원하지 않음을 주의 하라.
			4.	CRecordset::forwardOnly 레코드 읽는 것만 가능, 리소스 가장 적게 사용
				전방향 스크롤의 읽기 전용 레코드셋
		iii. dwOptions
			1. 	CRecordset::none
				옵션을 설정 안함. 이 파라미터 값은 다른 모든 값들과 상충됨. 기본적으로, 레코드셋은 Edit나 Delete로 변경될 수 있고 AddNew로 새로운 레코드를 확장 할 수 있다.
				No options set. This parameter value is mutually exclusive with all other values. By default, the recordset can be updated with Edit or Delete and allows appending new records with AddNew.
				변경 능력은 데이터 소스와 설정한 nOpenType 옵션에 달려 있다. 벌크 추가에 대한 최적화는 이용할 수 없다. 벌크 로우 패치가 구현되지 않는다. 레코드셋 탐색 중에 삭제되 레코드를 건너뛰지 않는다. 
				북마크를 사용할 수 없다. 자동 dirty 필드 검사가 구현된다.
			2.	CRecordset::appendOnly
				레코드셋에 Edit나 Delete가 허용되지 않는다. AddNew만 허용된다. 이 옵션은 CRecordset::readOnly 와 상반 된다.
			3.	CRecordset::readOnly
				읽기 전용으로 레코드셋을 연다. 이 옵션은 CRecordset::appendOnly와 상반 된다.
			4.	CRecordset::optimizeBulkAdd
				한번에 많은 레코드를 추가하는 것을 최적화 하기위해 준비된 SQL문을 사용한다. 레코드셋을 갱신하기 위하여 ODBC API 함수 SQLSetPos를 사용하지 않을 경우에만 적용한다. 
				첫번째 갱신에서 어떤 필드가 dirty표시 되어 있는지 결정한다. 이 옵션은 CRecordset::useMultiRowFetch와 상반 된다.
			5.	CRecordset::useMultiRowFetch
				하나의 패치에서 여러 개의 행들이 얻어질 수 있도록 벌크 행 패치를 구현한다. 성능 향상을 위해 설계된 발전된 특징이다. 
				그렇지만, 벌크 레코드 교환은 클래스위자드에의해 지원되지 않는다. 이 옵션은 CRecordset::optimizeBulkAdd와 상반된다. 
				CRecordset::useMultiRowFetch를 설정하면 자동으로  CRecordset::noDirtyFieldCheck이 설정됨을 참고하라. 
				순방향 레코드셋에서는 CRecordset::useExtendedFetch 옵션이 자동으로 설정된다. 벌크 로우패칭에 관한 보다 자세한 정보는 Visual C++ 프로그래머 가이드의 
				“Recordset: Fetching Records in Bulk (ODBC)” 항목을 참조하라.
			6.	CRecordset::skipDeletedRecords
				레코드셋을 탐색 할 때 모든 지워진 레코드를 건너 뛴다. 일부 관련 패치들에서 성능 저하를 가져온다. 이 옵션은 순방향 전용 레코드셋에는 유효하지 않다. 
			7.	CRecordset::useBookmarks
				지원된다면 레코드셋에 북마크를 사용할 수 있다. 북마크는 데이터 얻는 것을 느리게 하지만 데이터 탐색 성능은 향상시킨다. 
				순방향 레코드셋에는 적용되지 않는다. 자세한 내용은 Visual C++ 프로그래머 가이드에서 “Recordset: Bookmarks and Absolute Positions (ODBC)” 항목을 참조하라.
			8.	CRecordset::noDirtyFieldCheck
				자동 dirty 필드 검사를 해제한다. 성능은 향상되겠지만, SetFieldDirty와 SetFieldNull 멤버함수를 호출해서 수동으로 필드에 dirty 표시를 해야 한다. 
				CRecordser 클래스의 이중 버퍼링은 CDaoRecordset 클래스의 이중 버퍼링과 유사하다. CRecordset에서는 개별적인 필드에 이중 버퍼링을 가능하게 할 수 없다.
				모든 필드에 가능하게 하거나 모든 필드에 불가능하게 한다. 이중 버퍼링에 대한  자세한 내용은 Visual C++ 프로그래머 가이드의 “DAO Record Field Exchange: Double Buffering Records” 항목을 참조하라. 
				만약 CRecordset::useMultiRowFetch 옵션을 설정하면 CRecordset::noDirtyFieldCheck  옵션이 자동으로 설정되며 벌크 로우 패치 구현을 위해 SetFieldDirty와 SetFieldNull 함수를 사용할 수 없게 된다.
			9.	CRecordset::executeDirect   미리 준비된 SQL 문을 사용하지않는다. Requry 멤버 함수가 절대 호출되지 않을 것이면 성능 향상을 위해 이 옵션을 설정한다. 
			10.	CRecordset::useExtendedFetch   SQLFetch대신 SQLExtendedFetch를 실행한다. 이것은 순뱡향 전용 레코드셋에서 벌크 로우 패치의 구현을 위해 설계되었다. 
				순방향 전용 레코드셋에서 CRecordset::useMultiRowFetch 옵션을 설정하면 CRecordset::useExtendedFetch가 자동으로 설정된다. 
			11.	CRecordset::userAllocMultiRowBuffers   사용자가 데이터를 위한 저장 버퍼를 할당한다. 고유의 저장공간을 할당하고자 한다면 CRecordset::useMultiRowFetch와 함께 이 옵션을 사용한다. 
				그렇지 않으면 프레임워크가 자동으로 필요한 저장공간을 할당한다. 자세한 내용은  Visual C++ 프로그래머 가이드의 “Recordset: Fetching Records in Bulk (ODBC)” 항목을 참조하라.
				CRecordset::useMultiRowFetch 설정 없이 CRecordset::userAllocMultiRowBuffersf를 설정하면 설정 실패가 된다. 
	C. 레코드 상태
		CRecordset::IsBOF()				// 첫 필드인지 확인(처음일 경우 nonzero 리턴), 현재 레코드가 첫 번째 레코드 바로 전 위치로 설정되었다면 TRUE를 리턴. 레코드가 전혀 없는 경우에도 TRUE를 리턴
		CRecordset::IsEOF()				// 마지막 필드인지 확인(마지막일 경우 nonzero 리턴), 현재 레코드가 마지막 레코드 바로 다음 위치로 설정되었다면 TRUE를 리턴. 레코드가 전혀 없는 경우에도 TRUE를 리턴
		CRecordset::IsDeleted()			// 지워진 필드인지 확인(지워진 경우 nonzero 리턴)
	D. 레코드 이동
		CRecordset::MoveFirst()			// DB의 처음으로 이동, 첫 번째 레코드를 현재 레코드로 설정
		CRecordset::MoveLast()			// DB의 마지막으로 이동, 마지막 레코드를 현재 레코드로 설정
		CRecordset::MoveNext()			// 다음 레코드로 이동, 다음 위치의 레코드를 현재 레코드로 설정
		CRecordset::MovePrev()			// 이전 레코드로 이동, 이전 위치의 레코드를 현재 레코드로 설정
		CRecordset::Move(long lRows)	// 이동하고 싶은 행으로 이동
	E. 입력/ 수정/ 삭제
		CRecordset::AddNew()			// 새로운 필드 입력 알림(완료후 Update() 호출)
		CRecordset::Edit()				// 현재 필드 수정 알림(완료 후 Update() 호출)
		CRecordset::Delete()			// 현재 필드 삭제
		CRecordset::Update()			// AddNew()나 Edit() 호출 후 변경된 Recordset을 DB에 입력함
	F. 그외
		CRecordset::Requery()			// Recordset의 query를 다시 보내서 Recordset을 다시 받아옴
		CRecordset::GetFieldValue()		// Recordset의 특정필드 값을 구함
		CRecordset::SetFieldValue
		CRecordset::m_pDatabase			// Recordset과 연결된 CDatabase 클래스 나타냄
		CRecordset::m_strFilter			// SQL문의 Filter 부분
		

		
[출처] 20060605_ODBC|작성자 15lgn
	D.	예제
/* 새로운 필드를 삽입한다 */
void CRecordset::AddNew()
{
	rs.AddNew();				// 새로운 필드 등록을 알림
	rs.m_Name = "홍길동";		// 새로운 필드의 내용 입력
	rs.m_Phone = "123-4567";	// 새로운 필드의 내용 입력
	rs.Update();				// 입력된 필드의 DB에 Update 해줌
	rs.Requery();				// DB의 내용 Recordset에 재등록
}

/* 현재 필드를 수정한다 */
void CRecordset::EditField()
{
	rs.Edit();					// 필드 수정 알림
	rs.m_Name = "수정된이름";	// 변경될 필드의 내용 입력
	rs.m_Phone = "555-5555";	// 변경될 필드의 내용 입력
	rs.Update();				// 변경될 필드를 DB에 Update 해줌
	rs.Requery();				// DB의 내용 Recordset에 재등록
}

/* 현재 필드를 삭제한다 */
void CRecordset::Del()
{
	rs.Delete();				// 현재 필드를 삭제함
	rs.Requery();				// DB의 내용 Recordset에 재등록(Recordset에는 위의 쿼리문이 적용되어 등록됨)
}

/* CRecordset의 멤버함수 m_strFilter를 이용하여 원하는 필드만 얻어낸다 */
void CRecordset::Search()
{
	rs.m_strFilter = "Name = '홍길동'";	// SELECT * FROM Table1 WHERE Name = '홍길동'
	rs.Requery();				// DB의 내용 Recordset에 재등록(Recordset에는 위의 쿼리문이 적용되어 등록됨)
}

5.	DaoRecordSet 바인딩  DB  2004/12/25 23:43
 http://blog.naver.com/kitchang/80008827200 
 
아래에 간단한 예를 보여드리겠습니다.
CDaoDatabase DaoDatabase;
CDaoRecordset DaoRecordset;

DaoDatabase.Open("파일의 경로.mdb", FALSE, FALSE, "" );
//인자에 대한 점은 MSDN을 참조하시구요..

DaoRecordset.m_pDatabase = &DaoDatabase;

CString szQuery;

szQuery = "SELECT * FROM [MyTable] WHERE [MyTable].[Name] LIKE "*개똥*"";

DaoRecordset.Open(AFX_DAO_USE_DEFAULT_TYPE, szQuery );

위에서는 Exception에 대한 처리가 빠진 것입니다. 필수는 아니지만
처리를 해주시는게...

그리고 만일 필드의 값을 참조하시려 한다며...

DaoRecordset.MoveFirst();
DaoRecordset.Move(nIndex);//검색된 레코드 중에서 해당레코드로 이동
COleVariant var;
DaoRecordset.GetFieldValue( 5, var ); 

값을 변경시에는 
DaoRecordset.Edit();
DaoRecordset.SetFieldValue( 5, var );

이런식입니다. 위의 함수에는 오버라이드 함수가 많으니깐 직접
찾아 보시구요.. 

[출처] DaoRecordSet 바인딩|작성자 반지의 제왕

6.	VARIANT라는 것은, 여러가지 타입의 데이터를 저장할 수 있도록 구성된 구조체입니다.
이 구조체의 VARTYPE이라는 플래그에는 현재 저장된 데이터의 타입이 설정되어 있고, 프로그램에서는 이 플래그를 보고 매핑되는 변수를 억세스하면 되지요.
하지만 구조체라서 좀 다루기가 힘들고 그래서...
보통 COleVariant라는 변수를 사용합니다.

위에서 만약 GetData()로 어떤 값을 받아오고자 할 경우에는,
VARIANT data, type, maxlen;
GetData(&data, type, maxlen);
이렇게 해주시면 되겠죠.

VARIANT*라는 것은 바로 VARIANT 구조체 타입의 변수의 주소라는 것이죠.
그래서 위에서 &data라고 써서 그 주소를 넘겨줍니다.

VARIANT의 구조를 볼까요?
typedef struct tagVARIANT { VARTYPE vt; unsigned short wReserved1;
unsigned short wReserved2; unsigned short wReserved3; union {
unsigned char bVal; // VT_UI1.
short iVal; // VT_I2 .
long lVal; // VT_I4 .
float fltVal; // VT_R4 .
double dblVal; // VT_R8 .
VARIANT_BOOL boolVal; // VT_BOOL.
SCODE scode; // VT_ERROR.
CY cyVal; // VT_CY .
DATE date; // VT_DATE.
BSTR bstrVal; // VT_BSTR.
IUnknown FAR* punkVal; // VT_UNKNOWN.
IDispatch FAR* pdispVal; // VT_DISPATCH.
SAFEARRAY FAR* parray; // VT_ARRAY|*.
unsigned char FAR* pbVal; // VT_BYREF|VT_UI1.
short FAR* piVal; // VT_BYREF|VT_I2.
long FAR* plVal; // VT_BYREF|VT_I4.
float FAR* pfltVal; // VT_BYREF|VT_R4.
double FAR* pdblVal; // VT_BYREF|VT_R8.
VARIANT_BOOL FAR* pboolVal; // VT_BYREF|VT_BOOL.
SCODE FAR* pscode; // VT_BYREF|VT_ERROR.
CY FAR* pcyVal; // VT_BYREF|VT_CY.
DATE FAR* pdate; // VT_BYREF|VT_DATE.
BSTR FAR* pbstrVal; // VT_BYREF|VT_BSTR.
IUnknown FAR* FAR* ppunkVal; // VT_BYREF|VT_UNKNOWN.
IDispatch FAR* FAR* ppdispVal; // VT_BYREF|VT_DISPATCH.
SAFEARRAY FAR* FAR* pparray; // VT_ARRAY|*.
VARIANT FAR* pvarVal; // VT_BYREF|VT_VARIANT.
void FAR* byref; // Generic ByRef.
};
};

복잡하죠?
이 모든 것들이 단 하나의 데이터를 저장하기 위해 존재합니다.
바로 vt가 가리키는 변수에만 데이터가 있죠.
vt는 아래와 같은 값을 가질 수 있습니다.
enum VARENUM{ VT_EMPTY = 0, // Not specified.
VT_NULL = 1, // Null.
VT_I2 = 2, // 2-byte signed int.
VT_I4 = 3, // 4-byte signed int.
VT_R4 = 4, // 4-byte real.
VT_R8 = 5, // 8-byte real.
VT_CY = 6, // Currency.
VT_DATE = 7, // Date.
VT_BSTR = 8, // Binary string.
VT_DISPATCH = 9, // IDispatch
VT_ERROR = 10, // Scodes.
VT_BOOL = 11, // Boolean; True=-1, False=0.
VT_VARIANT = 12, // VARIANT FAR*.
VT_UNKNOWN = 13, // IUnknown FAR*.
VT_UI1 = 17, // Unsigned char.
// Other constants that are not valid in VARIANTs omitted here.
};

vt에 어떤 값이 들어있는지 확인해서, 그 타입의 변수에 데이터를 넣거나 빼면 됩니다.
그럼 좋은 하루 되세요.


/* 예제1
MDB에 있는 데이터를 한 줄 씩 읽어서 엑셀로 한 줄 씩 쓰려고 하는데요...
잘 되는 듯 하다가 보니...14개 이상 즉, 15번째 줄로 이동할 때 오류가 납니다...
루프문에서 rs.edit(), rs.update() 함수를 15번 이상 못쓰나요?
엑셀 파일이 만들어지긴 하는데 딱 14개까지만 나오고 오류가 나네요;;;
어디가 잘못된 걸까요?

-> 말씀하신대로 레코드가 없어서 발생한 문제였던거 같습니다.
MoveNext로 하면 레코드가 자동으로 생성되는지 알았는데 아니였던 거 같습니다.
rs.IsEOF를 이용해서 AddNew로 해결하였습니다.
정말 감사드립니다. ^^ */
========================================================================================================
CDaoDatabase *pdb = new CDaoDatabase;
 pdb->Open("c:\\yu3\\yu3.mdb",false,false,";PWD=2007501058");
 CDaoRecordset recordset;
 recordset.m_pDatabase=pdb;
 recordset.Open(dbOpenDynaset, "select * from customer",dbConsistent);


 CopyFile("c:\\yu3\\xls\\all_customer.xls",".\\all_customer.xls",FALSE);
 CDaoDatabase database;


 int count=0;
 long point=0;
 COleVariant var;
 COleDateTime date;
 CString str;
 CString sSql;
 CString sFile = ".\\all_customer.xls";  // the file name. Could also be something like C:\\Sheets\\WhatDoIKnow.xls
 

 database.Open(sFile,false,false,"Excel 5.0;");  
 CDaoRecordset rs( &database );
 sSql = "SELECT * "  
     "FROM [WorkSheet$] ";     
 rs.Open(dbOpenDynaset,sSql);


 rs.MoveFirst(); 
 recordset.MoveFirst(); 
 

 while(!recordset.IsEOF())    //여기서 부터 파일 끝까지 읽으면서 엑셀로 쓰는데요...15번째 레코드로 이동시 에러가 납니다;
 {
  rs.Edit();                       // 15번째 레코드 셋으로 이동 후 여기서 "예외"가 발생하면서 '현재 레코드가 없습니다.라고 출력
  recordset.GetFieldValue("Name",var);
  str=var.pbVal;
  rs.SetFieldValue(0,(LPCTSTR)str);  
  
  recordset.GetFieldValue("Phone",var);
  str=var.pbVal;
  rs.SetFieldValue(1,(LPCTSTR)str);  
  
  recordset.GetFieldValue("Birth",var);
  date=var.date;
  str=date.Format("%Y-%m-%d");
  rs.SetFieldValue(2,(LPCTSTR)str);
  
  recordset.GetFieldValue("Point",var);
  point=var.lVal;
  rs.SetFieldValue(3,point);
  
  recordset.GetFieldValue("Master",var);
  str=var.pbVal;
  rs.SetFieldValue(4,(LPCTSTR)str);
   
  rs.Update();
  rs.MoveNext();
  recordset.MoveNext();
  }


 rs.Close();
 recordset.Close();
 database.Close();
 pdb->Close();
========================================================================================================

/* 예제2 */
 CDaoDatabase  dbExcel; 
 CDaoTableDefInfo TableInfo; 
 COleVariant   ole; 
 CString    strSQL; 


  dbExcel.Open( _T("c:\\excel\\data.xls"), FALSE, TRUE, _T("Excel 8.0") ); 
  dbExcel.GetTableDefInfo( 0, TableInfo ); 


    // access 1st sheet 
  strSQL = _T("select * from ["); 
  strSQL += TableInfo.m_strName; 
  strSQL += _T(']'); 
  CDaoRecordset rsExcel( &dbExcel ); 
//rsExcel.Open( dbOpenDynaset, strSQL ); 
  rsExcel.Open( dbOpenDynaset, strSQL, dbInconsistent);


  if ( !rsExcel.IsEOF() ) { 
    rsExcel.MoveFirst(); 


    do { 
       rsExcel.GetFieldValue( 0, ole );    // get value; here: returns "6" 


     if ( !rsExcel.IsEOF() ) 
      rsExcel.MoveNext(); 


    } while ( !rsExcel.IsEOF() ); 


  } 
  dbExcel.Close();
  rsExcel.Close(); 
 } 
http://www.office-archive.com/2-excel/85e14a5d37550ef3.htm

/* 예제3 */
#include <afxdao.h>

void main(void)
{
	CDaoDatabase dbExcel; 
	CDaoTableDefInfo TableInfo; 
	COleVariant oleData; 
	CString strSQL;
	CString str;


	dbExcel.Open(_T(strExcelFilePath), FALSE, FALSE, _T("Excel 8.0") ); 
	dbExcel.GetTableDefInfo( 0, TableInfo ); 

	CDaoRecordset rsExcel( &dbExcel ); 

	// access 1st sheet 
	strSQL = _T("select * from ["); 
	strSQL += TableInfo.m_strName; 
	strSQL += _T(']'); 

	rsExcel.Open( dbOpenDynaset, strSQL, dbInconsistent); 

	if ( !rsExcel.IsEOF() )
	{ 
		rsExcel.MoveFirst(); 

		#if 0
		do
		{ 
			rsExcel.GetFieldValue(0, oleData);
			str = (LPSTR)oleData.pbstrVal;

			if ( !rsExcel.IsEOF() ) 
				rsExcel.MoveNext(); 
		}
		while ( !rsExcel.IsEOF() ); 
		#elif 0
		while ( !rsExcel.IsEOF() )
		{ 
			rsExcel.GetFieldValue(0, oleData);
			str = oleData.pbVal;

			rsExcel.MoveNext(); 
		}
		#elif 0
		while ( !rsExcel.IsEOF() )
		{
			rsExcel.Edit();
			rsExcel.GetFieldValue(0, oleData);
			str = oleData.pbVal;
			rsExcel.SetFieldValue(0, _T("7777"));

			rsExcel.Update();
			rsExcel.MoveNext(); 
		}
		#else
		rsExcel.Move(36);

		rsExcel.Edit();
		oleData.ChangeType(VT_R4, NULL);
		oleData.fltVal = 777.1234;

//		rsExcel.SetFieldValue(1, _T("7777"));
		rsExcel.SetFieldValue(1, oleData);

		rsExcel.Update();
		#endif
	}

	dbExcel.Close();
	rsExcel.Close();
}


/* 예제4, Automating Excel 2007 and creating charts using C++ MFC application in Visual Studio 2008
   신규 excel 파일 생성 + Graphic chart 생성 */
// http://www.codeproject.com/Articles/476238/Automating-Excel-2007-and-creating-charts-using-Cp#

// AutomateExcelDlg.cpp : implementation file
//

#include "stdafx.h"
#include "AutomateExcel.h"
#include "AutomateExcelDlg.h"

#include "CApplication.h"
#include "CFont0.h"
#include "CRange.h"
#include "CWorkbook.h"
#include "CWorkbooks.h"
#include "CWorksheet.h"
#include "CWorksheets.h"
#include "CChart.h"
#include "CCharts.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
END_MESSAGE_MAP()


// CAutomateExcelDlg dialog




CAutomateExcelDlg::CAutomateExcelDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAutomateExcelDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CAutomateExcelDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAutomateExcelDlg, CDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDRUN, &CAutomateExcelDlg::OnBnClickedRun)
END_MESSAGE_MAP()


// CAutomateExcelDlg message handlers

BOOL CAutomateExcelDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	// TODO: Add extra initialization here

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CAutomateExcelDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CAutomateExcelDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CAutomateExcelDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

void FillSafeArray(OLECHAR FAR* sz, int iRow, int iCol,
                   COleSafeArray* sa)
{

   VARIANT v;
   long index[2];

   index[0] = iRow;
   index[1] = iCol;

   VariantInit(&v);
   v.vt = VT_BSTR;
   v.bstrVal = SysAllocString(sz);
   sa->PutElement(index, v.bstrVal);
   SysFreeString(v.bstrVal);
   VariantClear(&v);

}

void CAutomateExcelDlg::OnBnClickedRun()
{
	// Commonly used OLE variants.
COleVariant
      covTrue((short)TRUE),
      covFalse((short)FALSE),
      covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);
	
	CApplication app;

	// Start Excel and get an Application object.
   if(!app.CreateDispatch(TEXT("Excel.Application")))
   {
      AfxMessageBox(TEXT("Couldn't start Excel and get Application object."));
      return;
   }
    
	CWorkbooks books;
    CWorkbook book;
    CWorksheets sheets;
	CWorksheet sheet;
	CRange range;
	CFont0 font;
	
	books = app.get_Workbooks();
   book = books.Add (covOptional);


   //Get the first sheet.
   sheets =book.get_Sheets();
   sheet = sheets.get_Item(COleVariant((short)1));

   range = sheet.get_Range(COleVariant(TEXT("A1")),COleVariant(TEXT("A1")));
   range.put_Value2(COleVariant(TEXT("Average precipation (mm)")));
   range = sheet.get_Range(COleVariant(TEXT("A1")),COleVariant(TEXT("C1")));
   range.Merge(covOptional);
   range = sheet.get_Range(COleVariant(TEXT("B2")),COleVariant(TEXT("B2")));
   range.put_Value2(COleVariant(TEXT("Acapulco")));
   range = sheet.get_Range(COleVariant(TEXT("C2")),COleVariant(TEXT("C2")));
   range.put_Value2(COleVariant(TEXT("Amsterdam")));

   
   //Fill A3:A6 with an array of values (Months).
   COleSafeArray saRet;
   DWORD numElements[]={4,1};   //4x1 element array
   saRet.Create(VT_BSTR, 2, numElements);
     
   FillSafeArray(L"January", 0, 0, &saRet);
   FillSafeArray(L"April", 1, 0, &saRet);
   FillSafeArray(L"July", 2, 0, &saRet);
   FillSafeArray(L"October", 3, 0, &saRet);
	  
   range = sheet.get_Range(COleVariant(TEXT("A3")), COleVariant(TEXT("A6")));
   range.put_Value2(COleVariant(saRet));
	  saRet.Detach();
	  
	  //Fill B3:C6 with values
	  range = sheet.get_Range(COleVariant(TEXT("B3")),COleVariant(TEXT("B3")));
	  range.put_Value2(COleVariant(short(10)));
	  range = sheet.get_Range(COleVariant(TEXT("B4")),COleVariant(TEXT("B4")));
	  range.put_Value2(COleVariant(short(69)));
	  range = sheet.get_Range(COleVariant(TEXT("B5")),COleVariant(TEXT("B5")));
	  range.put_Value2(COleVariant(short(5)));
	  range = sheet.get_Range(COleVariant(TEXT("B6")),COleVariant(TEXT("B6")));
	  range.put_Value2(COleVariant(short(53)));
	  range = sheet.get_Range(COleVariant(TEXT("C3")),COleVariant(TEXT("C3")));
	  range.put_Value2(COleVariant(short(208)));
	  range = sheet.get_Range(COleVariant(TEXT("C4")),COleVariant(TEXT("C4")));
	  range.put_Value2(COleVariant(short(76)));
	  range = sheet.get_Range(COleVariant(TEXT("C5")),COleVariant(TEXT("C5")));
	  range.put_Value2(COleVariant(short(145)));
	  range = sheet.get_Range(COleVariant(TEXT("C6")),COleVariant(TEXT("C6")));
	  range.put_Value2(COleVariant(short(74)));
   
   
   //Format A1:C1 as bold, vertical alignment = center.
   range = sheet.get_Range(COleVariant(TEXT("A1")), COleVariant(TEXT("C1")));
   font = range.get_Font();
   font.put_Bold(covTrue);
   range.put_VerticalAlignment(COleVariant((short)-4108));   //xlVAlignCenter = -4108

   //AutoFit columns A:D.
   range = sheet.get_Range(COleVariant(TEXT("A1")), COleVariant(TEXT("D1")));
   CRange cols;
   cols = range.get_EntireColumn();
   cols.AutoFit();

   //Adding Chart
    CCharts charts;
	CChart chart;
	charts = book.get_Charts();
	chart = charts.Add(covOptional, covOptional, covOptional);

   app.put_Visible(TRUE);
   app.put_UserControl(TRUE);
}

/* 예제5, Automating Excel 2007 and creating charts using C++ MFC application in Visual Studio 2008
   기존 파일 open, data 수정 */

4.1.      Program with sheet 
The next is a way of ID_NewSheet message map function implementation:

//Excel object model
    _Application app; 
    Workbooks books; 
    _Workbook newBook; 
    Worksheets sheets; 
    _Worksheet oSheet,firstSheet; 
    Charts charts;
    _Chart chart,firstChart;
    Range range; 
    Range iCell; 

    LPDISPATCH lpDisp; 
    COleVariant vResult; 
    COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR); 

    //Create Excel server (start Excel) 
    if(!app.CreateDispatch("Excel.Application")) 
    { 
        AfxMessageBox("Can’t start Excel server! "); 
        return; 
    } 

    app.put_Visible(TRUE); //set Excel visible 
    app.put_UserControl(TRUE); //user can operate Excel

    //new a book
    books.AttachDispatch(app.get_Workbooks()); 
    newBook = books.Add(vOpt);

    //Get worksheets and get the first worksheet
    sheets = newBook.get_Worksheets(); 
    oSheet = sheets.get_Item(COleVariant((short)1));

    //*** ADD DATA TO THE WORKSHEET
    //Add Headers to Row 1 of the worksheet
    Range oRange;
    oRange = oSheet.get_Range(COleVariant("A1"), vOpt);
    oRange.put_Value2(COleVariant("Date"));
    oRange = oSheet.get_Range(COleVariant("B1"), vOpt);
    oRange.put_Value2(COleVariant("Order #"));
    oRange = oSheet.get_Range(COleVariant("C1"), vOpt);
    oRange.put_Value2(COleVariant("Amount"));
    oRange = oSheet.get_Range(COleVariant("D1"), vOpt);
    oRange.put_Value2(COleVariant("Tax"));

    //Create a safe array that is NUMROWS x 3 --
    //column 1 will contain dates column 2 will contain strings
    //and column 3 will contain numbers
    COleSafeArray sa;
    DWORD dwElements[2];
    dwElements[0]= 20;    //Number of rows
    dwElements[1]= 3;          //Number of columns
    sa.Create(VT_VARIANT, 2, dwElements);

    //Populate the safe array with the data
    long index[2];
    long lRow;
    COleVariant vTemp;
    COleDateTime vDateTime;
    CString s;

    for(lRow=0;lRow<=20-1;lRow++)
    {
        index[0] = lRow; 
  
        //Fill the first column with dates
        index[1] = 0;

        vDateTime.SetDate(1999, rand()%12, rand()%28);
        sa.PutElement(index, (COleVariant)vDateTime);

        //Fill the second column with strings
        index[1] = 1;
        s.Format("ORDR%d", lRow+1000);
        vTemp = s;
        sa.PutElement(index, vTemp);

        //Fill the third column with numbers
        index[1] = 2;
        vTemp = (long)rand();
        sa.PutElement(index, vTemp);
    }

    //Fill a range, starting at A2 with the data in
    //the safe array
    oRange = oSheet.get_Range(COleVariant("A2"), vOpt);
    oRange = oRange.get_Resize(COleVariant((short)20),
        COleVariant((short)3));
    oRange.put_Value2(sa);
    sa.Detach();

    //*** ADD FORMULAS TO THE WORKSHEET
    //Fill the fourth column with a formula to compute the
    //sales tax. Note that the formula uses a "relative"
    //cell reference so that it fills properly.
    oRange = oSheet.get_Range(COleVariant("D2"), vOpt);
    oRange = oRange.get_Resize(COleVariant((long)20), 
        COleVariant((long)1));
    oRange.put_Formula(COleVariant("=C2*0.07"));

    //*** FORMAT THE WORKSHEET
    oRange = oSheet.get_Range(COleVariant("A1"), COleVariant("D1"));

    /*Font oFont = oRange.get_Font();
    oFont.SetBold(COleVariant((short)TRUE));//Apply Bold to Headers*/
    oRange = oRange.get_EntireColumn();
    oRange.AutoFit();                    //AutoFit the columns 1:4

    //Make Excel visible and give the user control
    oSheet.put_Name("My New Sheet");
    newBook.SaveAs(COleVariant("C:\\mynew.xls"),vOpt,vOpt,
        vOpt,vOpt,vOpt,0,
        vOpt,vOpt,vOpt,vOpt,vOpt); 

    newBook.Close (vOpt,COleVariant("C:\\mynew.xls"/*OutFilename*/),vOpt); 
    books.Close();
    app.Quit();

4.2.      Program with chart 
The next is a way of ID_NewChart message map function implementation:

//New create Excel object model
    _Application app;
    _Workbook newBook;
    Workbooks books;
    Worksheets sheets;
    _Worksheet newSheet;
    Charts charts;
    _Chart newChart;

    COleVariant vOpt((long)DISP_E_PARAMNOTFOUND, VT_ERROR); 

    //Create Excel server (start Excel)
    if(!app.CreateDispatch("Excel.Application")) 
    { 
        AfxMessageBox("Can’t start Excel server!"); 
        return; 
    } 

    //app.put_Visible(true); //set Excel visible 
    app.put_UserControl(TRUE); //user can operate Excel

    books = app.get_Workbooks();
    newBook=books.Open("C:\\mynew.xls",vOpt, vOpt, vOpt, vOpt, vOpt,
        vOpt, vOpt, vOpt, vOpt, vOpt,vOpt, vOpt,vOpt,vOpt); 

    //newBook = books.Add(vOpt);
    sheets = newBook.get_Sheets();
    newSheet = sheets.get_Item(COleVariant((short)1));
    charts = newBook.get_Charts();
    CString tip;

    //for(;m_chartType<100;m_chartType++)
    {
        try
        {
            if(charts.get_Count()>0)
                charts.Delete();

            newChart = charts.Add(vOpt,vOpt,COleVariant((short)1));
            newChart.put_Name("My chart");
            newChart.put_ChartType((long)xlLineMarkers);
            tip.Format("C:\\mynewchart%d.xls",xlLine);

            //MessageBox(tip);
            Range oRang;
            oRang = newSheet.get_Range(COleVariant("C2:D21"), vOpt);
            newChart.SetSourceData(oRang,COleVariant((short)2));
            newChart.put_HasTitle(true);
            ChartTitle oChartTtl = newChart.get_ChartTitle();
            oChartTtl.put_Text("My sample xy-scatter chart");
            newChart.put_HasLegend(false);

            newBook.SaveAs(COleVariant(tip),vOpt,vOpt,
                vOpt,vOpt,vOpt,0,
                vOpt,vOpt,vOpt,vOpt,vOpt);
        }
        catch(...)
        {
            //newBook.Close(vOpt,COleVariant(tip/*OutFilename*/),vOpt);
            //app.Quit();
            //continue;
        }
    }

    //newBook.Close (vOpt,COleVariant(tip/*OutFilename*/),vOpt); 
    books.Close();
    app.Quit();

/* 예제6, c + +.net과 MFC를 사용 하 여 새 통합 문서 서식으로 Excel을 자동화 하는 방법 */
만들기 및 c + +.net과 MFC를 사용 하 여 새 통합 문서 서식으로 Excel을 자동화 하는 방법
기술 자료: 308292 - 이 문서가 적용되는 제품 보기.
기계 번역 고지 사항 보기
기계 번역된 문서와 영문 원본 문서 나란히 보기
이 문서에서는 q308292에서 이전에 게시 되었습니다.
(http://support.microsoft.com/kb/301982/EN-US/) 
참조하십시오. 
이 문서는 Microsoft Visual C#.NET 버전을 302084 를 참조 하십시오.
(http://support.microsoft.com/kb/302084/EN-US/) 
참조하십시오. 

모두 확대 | 모두 축소
이 페이지에서요약
추가 정보
Microsoft Excel의 자동화 클라이언트 만들기
문제 해결
참조
속성
피드백 보내기
참고 Microsoft Visual C++.NET (2002)는 Microsoft.NET Framework 제공 하는 관리 되는 코드 모델 및 관리 되지 않는 네이티브 Microsoft Windows 코드 모델을 모두 지원 합니다. 
이 문서의 정보는 관리 되지 않는 Visual C++ 코드에만 적용 됩니다.
위로 가기 | 피드백 보내기
요약이 문서에서는 Visual C++.NET 및 Microsoft Foundation 클래스 (MFC)를 사용 하 여 Excel 용 자동화 클라이언트를 만드는 방법을 보여 줍니다. 
위로 가기 | 피드백 보내기
추가 정보자동화 다른 응용 프로그램을 프로그래밍 방식으로 제어할 수 있는 MFC 같은 언어로 작성 된 응용 프로그램을 허용 하는 프로세스입니다. Excel에 자동화를 사용 하면 새 통합 문서 만들기, 
통합 문서에 데이터 추가 또는 차트 만들기 같은 작업을 수행할 수 있습니다. Excel과 기타 Microsoft Office 응용 프로그램을 사용자 인터페이스를 통해 수동으로 수행할 수 있는 작업은 거의 모든 
또한 프로그래밍 방식으로 자동화를 사용 하 여 수행할 수 있습니다.

Excel 개체 모델을 통해 이러한 프로그래밍 방식 기능을 제공합니다. 개체 모델은 Excel의 논리 구성 요소와 같은 역할 하는 메서드와 클래스입니다. 
예를 들어, 없는 응용 프로그램 개체, 통합 문서 개체 및 워크시트 개체가 각각 Excel의 해당 요소가 가지는 기능을 포함 합니다. 
MFC와 Visual C++.net에서 개체 모델에 액세스 하려면 Excel의 형식 라이브러리에서 MFC 래퍼 클래스를 만들 수 있습니다.

이 문서에서는 만들고 Visual C++.net을 사용 하 여 새 통합 문서를 포맷 하는 MFC에 의해 생성 된 래퍼 클래스를 사용 하는 방법을 보여 줍니다. 
Microsoft Excel 용 자동화 클라이언트 만들기
기본 자동화 클라이언트를 만들려면 다음 Microsoft 기술 자료 문서의 "자동화 클라이언트 만들기" 절의 단계를 수행 하십시오. 
307473
(http://support.microsoft.com/kb/307473/EN-US/) 
Office 자동화 Visual C++.net에서 형식 라이브러리를 사용 하는 방법 
문서의 4d 단계에서 다음 인터페이스를 선택 합니다.


_Application
통합 문서
_Workbook
워크시트
_Worksheet
범위
글꼴
내부
테두리
테두리

글꼴 클래스의 파일인 CFont0.h 및 Cnterior.h 중간 클래스에 대한 파일입니다 (# include 문을 각각에 대해 래퍼를 생성할 클래스를 추가할 수 있는) 문서의 6단계에서 유의하십시오.
IDD_AUTOPROJECT_DIALOG 대화 상자에서 실행 마우스 오른쪽 단추로 클릭하고 추가 이벤트 처리기 를 선택하십시오. 이벤트 처리기 마법사 BN_CLICKED 메시지 형식을 선택하고 추가 및 편집 을 클릭하십시오. 
다음 코드를 추가하여 처리기에서 Excel을 자동화하는: void CAutoProjectDlg::OnBnClickedRun()
{
   // Commonly used OLE variants.
   COleVariant
      covTrue((short)TRUE),
      covFalse((short)FALSE),
      covOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);

   CApplication app;
   CWorkbooks books;
   CWorkbook book;
   CWorksheets sheets;
   CWorksheet sheet;
   CRange range;
   CFont0 font;
   CRange cols;
   CRange resizedrange;
   Cnterior interior;
   CBorders borders;
   CBorder bottomborder;

   // Start Excel and get an Application object.
   if(!app.CreateDispatch("Excel.Application"))
   {
      AfxMessageBox("Couldn't start Excel and get Application object.");
      return;
   }

   //Get a new workbook.
   books = app.get_Workbooks();
   book = books.Add (covOptional);

   //Get the first sheet.
   sheets =book.get_Sheets();
   sheet = sheets.get_Item(COleVariant((short)1));

   //Fill cells A1, B1, C1, and D1 one cell at a time with "headers".
   range = sheet.get_Range(COleVariant("A1"),COleVariant("A1"));
   range.put_Value2(COleVariant("First Name"));
   range = sheet.get_Range(COleVariant("B1"),COleVariant("B1"));
   range.put_Value2(COleVariant("Last Name"));
   range = sheet.get_Range(COleVariant("C1"),COleVariant("C1"));
   range.put_Value2(COleVariant("Full Name"));
   range = sheet.get_Range(COleVariant("D1"),COleVariant("D1"));
   range.put_Value2(COleVariant("Salary"));

   //Format A1:D1 as bold, vertical alignment = center.
   range = sheet.get_Range(COleVariant("A1"), COleVariant("D1"));
   font = range.get_Font();
   font.put_Bold(covTrue);
   range.put_VerticalAlignment(
      COleVariant((short)-4108));   //xlVAlignCenter = -4108

   //Fill A2:B6 with an array of values (First & Last Names).
   {
      COleSafeArray saRet;
      DWORD numElements[]={5,2};   //5x2 element array
      saRet.Create(VT_BSTR, 2, numElements);


      //Fill the 5x2 SafeArray with the following data:
      //   John      Smith
      //   Tom       Brown
      //   Sue       Thomas
      //   Jane      Jones
      //   Adam      Johnson

      FillSafeArray(L"John", 0, 0, &saRet);
      FillSafeArray(L"Smith", 0, 1, &saRet);
      FillSafeArray(L"Tom", 1, 0, &saRet);
      FillSafeArray(L"Brown", 1, 1, &saRet);
      FillSafeArray(L"Sue", 2, 0, &saRet);
      FillSafeArray(L"Thomas", 2, 1, &saRet);

      FillSafeArray(L"Jane", 3, 0, &saRet);
      FillSafeArray(L"Jones", 3, 1, &saRet);
      FillSafeArray(L"Adam", 4, 0, &saRet);
      FillSafeArray(L"Johnson", 4, 1, &saRet);

      range = sheet.get_Range(COleVariant("A2"), COleVariant("B6"));
      range.put_Value2(COleVariant(saRet));

      saRet.Detach();
   }

   //Fill C2:C6 with a relative formula (=A2 & " " & B2).
   range = sheet.get_Range(COleVariant("C2"), COleVariant("C6"));
   range.put_Formula(COleVariant("=A2 & \" \" & B2"));

   //Fill D2:D6 with a formula(=RAND()*100000) and apply a number
   //format.
   range = sheet.get_Range(COleVariant("D2"), COleVariant("D6"));
   range.put_Formula(COleVariant("=RAND()*100000"));
   range.put_NumberFormat(COleVariant("$0.00"));

   //AutoFit columns A:D.
   range = sheet.get_Range(COleVariant("A1"), COleVariant("D1"));
   cols = range.get_EntireColumn();
   cols.AutoFit();

   //Manipulate a variable number of columns for Quarterly Sales Data.
   {
      short NumQtrs;
      CString msg;

      //Determine how many quarters to display data for.
      for(NumQtrs=1;NumQtrs<=3;NumQtrs++)
      {
         msg.Format("Enter sales data for %d quarter(s)?", NumQtrs);
         if(AfxMessageBox(msg,MB_YESNO)==IDYES)
         {
            break;
         }
      }
      msg.Format("Displaying data for %d quarters.", NumQtrs);
      AfxMessageBox(msg);

      //Starting at E1, fill headers for the number of columns selected.
      range = sheet.get_Range(COleVariant("E1"), COleVariant("E1"));
      resizedrange = range.get_Resize(covOptional, COleVariant(NumQtrs));
      resizedrange.put_Formula(
         COleVariant("=\"Q\" & COLUMN()-4 & CHAR(10) & \"Sales\""));
      //Change the Orientation and WrapText properties for the headers.
      resizedrange.put_Orientation(COleVariant((short)38));
      resizedrange.put_WrapText(covTrue);
      //Fill the interior color of the headers.
      interior = resizedrange.get_Interior();
      interior.put_ColorIndex(COleVariant((short)36));			// 1:Black, 2:White, 3:Red, 4:Green, 5:Blue, 6:Yellow, 7:Magenta, 8:Cyan

      //Fill the columns with a formula and apply a number format.
      range = sheet.get_Range(COleVariant("E2"), COleVariant("E6"));
      resizedrange = range.get_Resize(covOptional, COleVariant(NumQtrs));
      resizedrange.put_Formula(COleVariant("=RAND()*100"));
      resizedrange.put_NumberFormat(COleVariant("$0.00"));

      //Apply borders to the Sales data and headers.
      range = sheet.get_Range(COleVariant("E1"), COleVariant("E6"));
      resizedrange= range.get_Resize(covOptional, COleVariant(NumQtrs));
      borders = resizedrange.get_Borders();
      borders.put_Weight(COleVariant((short)2));   //xlThin = 2

      //Add a Totals formula for the Quarterly sales data and apply a
      //border.
      range = sheet.get_Range(COleVariant("E8"), COleVariant("E8"));
      resizedrange = range.get_Resize(covOptional, COleVariant(NumQtrs));
      resizedrange.put_Formula(COleVariant("=SUM(E2:E6)"));
      borders = resizedrange.get_Borders();
      {
         bottomborder = borders.get_Item((long)9);
         bottomborder.put_LineStyle(
            COleVariant((short)-4119));   //xlDouble = -4119
         bottomborder.put_Weight(
            COleVariant((short)4));       //xlThick = 4
      }
   }

   //Make the application visible and give the user control of
   //Excel.
   app.put_Visible(TRUE);
   app.put_UserControl(TRUE);
}
					
OnBnClickedRun 메서드는 바로 위에 다음 코드를 추가하십시오. Excel로 데이터를 보내는 데 사용되는 배열을 만들고 이 코드를 간단하게: 
void FillSafeArray(OLECHAR FAR* sz, int iRow, int iCol,
                   COleSafeArray* sa)
{

   VARIANT v;
   long index[2];

   index[0] = iRow;
   index[1] = iCol;

   VariantInit(&v);
   v.vt = VT_BSTR;
   v.bstrVal = SysAllocString(sz);
   sa->PutElement(index, v.bstrVal);
   SysFreeString(v.bstrVal);
   VariantClear(&v);

}
					
F5를 키를 눌러 자동화 클라이언트를 빌드하고 실행합니다.
OnBnClickedRun 메서드의 바로 위에 다음 코드를 추가 합니다. Excel로 데이터를 보내는 데 사용 되는 배열을 만들고이 코드를 간소화 합니다.

자동화 클라이언트 Excel을 시작 하 고 샘플 통합 문서가 만들어집니다. 사용자 지정 된 응용 프로그램의 컨트롤 때문에 자동화 클라이언트도 끝날 때 Excel 실행 중인 상태로 유지 됩니다.

/* 예제7, c + +.net과 MFC를 사용 하 여 새 통합 문서 서식으로 Excel을 자동화 하는 방법 */
void main(void)
{
	CString strExcelFilePath;

	/* 읽어 들일 파일을 선택하고 path를 저장 */
	char szFilter[] = "All Files(*.*)|*.*";
	CFileDialog fileDlg_open(true, NULL, NULL, OFN_HIDEREADONLY, szFilter); //저장은 맨앞 파라미터 false

	if(fileDlg_open.DoModal() == IDOK)  	// CFile dialog 생성.
	{
		strExcelFilePath = fileDlg_open.GetPathName();
	}
	else	  return;

	/* 읽어 들일 파일을 open 시켜서 data 수정/저장/close */
	CApplication app;
	CWorkbooks books;
    CWorkbook book;
    CWorksheets sheets;
	CWorksheet sheet;
	CRange range;
	CFont0 font;

	COleVariant VOptional((long)DISP_E_PARAMNOTFOUND, VT_ERROR);
    COleVariant VBoolTrue((short)TRUE);
    COleVariant VBoolFalse((short)FALSE);
	COleVariant VSaveConflict((short)2);

	// Start Excel and get an Application object.
	if(!app.CreateDispatch(TEXT("Excel.Application")))
	{
		AfxMessageBox(TEXT("Couldn't start Excel and get Application object."));
		return;
	}

	// Get a new workbook.
    books = app.get_Workbooks();
	book = books.Open(strExcelFilePath
					 , VBoolTrue		// UpdateLinks
                     , VBoolFalse		// ReadOnly
                     , VOptional		// Format
                     , VOptional		// PassWord
                     , VOptional		// WriteResPassWord
                     , VBoolTrue		// IgnoreReadOnlyRecommended
                     , VOptional		// Origin
                     , VOptional		// Delimiter
                     , VBoolTrue		// Editable
                     , VOptional		// Notify
                     , VOptional		// Converter
                     , VOptional		// AddToMru
                     , VOptional		// Local
                     , VBoolTrue);		// CorruptLoad

	// Get the first sheet.
    sheets = book.get_Sheets();
    sheet = sheets.get_Item(COleVariant((short)1));

	// Disable of display alerts
	app.put_DisplayAlerts(FALSE);

//	for(;m_chartType<100;m_chartType++)
    {
    	#if 0
        try
        {
            if(charts.get_Count()>0)
                charts.Delete();

            newChart = charts.Add(vOpt,vOpt,COleVariant((short)1));
            newChart.put_Name("My chart");
            newChart.put_ChartType((long)xlLineMarkers);
            tip.Format("C:\\mynewchart%d.xls",xlLine);

            //MessageBox(tip);
            Range oRang;
            oRang = newSheet.get_Range(COleVariant("C2:D21"), vOpt);
            newChart.SetSourceData(oRang,COleVariant((short)2));
            newChart.put_HasTitle(true);
            ChartTitle oChartTtl = newChart.get_ChartTitle();
            oChartTtl.put_Text("My sample xy-scatter chart");
            newChart.put_HasLegend(false);

            newBook.SaveAs(COleVariant(tip),vOpt,vOpt,
                vOpt,vOpt,vOpt,0,
                vOpt,vOpt,vOpt,vOpt,vOpt);
        }
        #else
		try
        {
			range = sheet.get_Range(COleVariant(TEXT("A1")),COleVariant(TEXT("A1")));
			range.put_Value2(COleVariant(double(-0.00000079)));

			//Make the application visible and give the user control of Excel.
			app.put_Visible(TRUE);
			app.put_UserControl(TRUE);

//			book.Save();
//			SaveAs(VARIANT& Filename, VARIANT& FileFormat, VARIANT& Password, VARIANT& WriteResPassword, VARIANT& ReadOnlyRecommended, VARIANT& CreateBackup, long AccessMode, VARIANT& ConflictResolution, VARIANT& AddToMru, VARIANT& TextCodepage, VARIANT& TextVisualLayout, VARIANT& Local)
            book.SaveAs(COleVariant(strExcelFilePath),
            			VOptional,VOptional,VOptional,VOptional,VOptional,
            			2,					// xlShared, 2, Share list
                		VSaveConflict,		// xlLocalSessionChanges, 2, The local user's changes are always accepted.
						VOptional,VOptional,VOptional,VOptional);
        }
        #endif
        catch(...)
        {
            //book.Close(vOpt,COleVariant(tip/*OutFilename*/),vOpt);
            //app.Quit();
            //continue;
        }
    }

    //book.Close (vOpt,COleVariant(tip/*OutFilename*/),vOpt); 
    books.Close();
    app.Quit();

    return;
}

/* 예제8, Automation 사용 함수 */
----Copy/PasteSpecial--------------------------------------------------------------------------
	range.Copy(VOptional);
	range2.PasteSpecial((long)-4104,(long)-4142,COleVariant(_T("False")),COleVariant(_T("False")));
						// Paste		XlPasteType				xlPasteAll -4104 Everything will be pasted.
						// Operation	xlPasteSpecialOperation	xlPasteSpecialOperationNone -4142 No calculation will be done in the paste operation.
						// SkipBlanks	Variant					True to have blank cells in the range on the Clipboard not be pasted into the destination range. The default value is False.
						// Transpose	Variant					True to transpose rows and columns when the range is pasted.The default value is False.




[40]	GUI
1.  BPP(bit per pixel)
    16BPP는 pixel하나에 16bits를 사용한다는 뜻  -> 2bytes   -> 16bits = R(5bits) + G(6bits) + B(5bits)  -> unsigned int(2bytes)로 선언해서 사용 -> Embedded CPU에서 주로 사용
    24BPP는 pixel하나에 24bits를 사용한다는 뜻  -> 3bytes   -> 24bits = R(8bits) + G(8bits) + B(8bits)  -> long(4bytes)로 선언해서 사용         -> PC(x86) CPU에서 사용




[41]	SelexOn(TSH/PSA/Cardiac)
	1-2) 매출
		1000억 = 100만원 x 100,000개
	1-1) 혼동하기 쉬운 점
		unsigned short densitoData[ANALYSIS_IMAGE_WIDTH] 데이터 값이 크다는 것은 빛이 밝다는 것을 뜻하고
		이는 오히려 항원항체반응이 적다는 것을 뜻함
		따라서 AutoGraph 함수 오르막/내리막 상태의 판단을 보통의 생각과는 반대로 생각해야 한다.
    1) CV(coefficient of variation)는 변동계수이다.
    2) mABS(milli Absorbance)는 하마마쯔식에서 사용하는 값으로 ABS = log(a/b)를 뜻함			->	본 공식에서 log는 자연로그를 뜻함
    	(a:총광양값, b:총광양에서 반사피크치를 뺀 광양값)
		자연 로그 (밑이 e인 로그)		->	C언에서는 ex) log(10) = 2.302585 와 같이 사용		->	계산기에서는 ex) ln(10) = 2.302585 와 같이 사용
		상용 로그 (밑이 10인 로그)		->	C언에서는 ex) log10(10) = 1.000000 와 같이 사용		->	계산기에서는 ex) log(10) = 1 와 같이 사용

		자연로그[ natural logarithm , 自然─ ] 
		실수(實數) e를 밑으로 하는 로그 log x로서, 상용로그와 구별하기 위해 ln x로 쓰는 경우가 많다. 
		로그의 이론적 연구에는 자연로그가 편리하다.네이피어 로그(Napierian logarithm)라고도 한다. 
		실수 e＝1＋1/1！＋1/2！＋1/3！＋…＝2.71828… 을 밑으로 하는 로그 log x를 간단히 ln x로 쓰고, 
		이것을 x의 자연로그라고 한다. 자연로그 log x와 상용로그 log10x(10은 밑에 붙은 10) 사이에는
		log10x = logex/loge10 = (0.43429448...) x logx (10은 밑에 붙은 10, e는 밑에 붙은 e)
		인 관계가 있다. 자연로그를 상용로그와 구별하기 위해 ln x로 쓰는 경우가 많다. 
		로그의 이론적 연구에는 자연로그가 편리하다. 

    3) CV값이 mABS보다 중요한 것은 CV가 0%라면(적을수록 좋다) 이때 TSH/PSA의 mABS값이
    	하마마쯔하고 다르다면 그 값의 차이를 보상해주면(기울기 보상) 하마마쯔와 동일한 결과 값을
    	표현할 수 있기 때문
    4) NRT(Non Real Time) : PBM제품이 NRT방식이며(Roche는 RT방식)
    	본 방식은 Strip에 피를 떨어뜨리고서 완전히 반응할 때까지 기다린 다음
    	측정기에 Strip을 넣어서 한번에 측정하는 방식이다
    5) mABS는 Peak치를 측정해서 값을 얻는 방식이고
       Area는 면적값을 계산해서 값을 얻기 때문에
       Area로 계산하는 방식이 CV가 좋을 수 밖에 없다(Peak치 보다는 면적이 더 뭉퉁그려진 평균값이므로)
       참고로, Area로 계산하는 방식은 Area가 200일때 하마마쯔 측정값이 100이고
       Area가 100일때 하마마쯔 측정값이 50이라면 Area값이 200이며 측정 결과값을 100으로 표시해주는 것이다.
    6) 조명용 LED는 2개만 쓰기로 했다
       이유는 2개만 쓰는 것이 Strip TEST & Control band와 중앙부를 균일하게 비춰주기 때문
       오히려 4개를 쓰면 중앙부에 조명이 몰려서 중앙부가 너무 밝아지는 현상이 일어남.
       cf) 녹색LED를 조명용으로 쓰고 있기 때문에 GRB422으로 변환하지 않은 Preview상태에서도
       strip 영상이 녹색으로 나오는 것임
    7) 카메라 자체적으로 구현되어있는 Lens shade기능을 ON시켰으며
		LFI Reader Source상에서도 S/W적으로 Lens shade기능을 보정하는 프로그램 삽입
	8) Camera Tuning방법
		Camera를 변경하던가 Camera와 피사체와의 높이가 변경된 경우 Tuning을 해야하며
		가) H/W적으로 Camera Focus를 맞추기 위해서 Camera 조리개를 돌려서 focus를 맞추고
		나) S/W적으로 OV7725_initialData Register중에서 AEC,AECH 값을 변경(노출시간 변경) 시켜서
			mABS의 값이 최대가 되는 값으로 맞춤
			(이유는, mABS의 값이 가장 중요한 값이므로 mABS의 값이 크게 나온다는 것은 가장 결과값이 잘 나오는 조건이라는 뜻임)
			cf.	윈도우 프로그램 LFI_Analysis_project_GRB422_Ggray -> Densitometer Graph View에 나타나는
				Densitometer Graph가 10,000 Level정도에 맞춰지도록 수정
	9) 조명 Feedback시스템(소스상에서 구현되어 있지는 않음)
		LED조명이 어두워서 Camera영상이 어두우면 수동으로 AEC,AECH를 변경시켜서 노출 시간을 늘려 Camera영상을
		적당히 환하게 변경시키는 시스템
		(Camera자체적으로 있는 AEC(Auto Exposure Control)기능을 ON시키지는 않고)
		-> 이렇게 AEC,AECH를 변경시켜서 노출 시간을 늘려도 mABS의 값은 변경시키기 전과 거의 변화가 없다고
		하고는 있지만 확실하지는 않음(내가 직접 TEST해보지 않음)
		-> 따라서, 본 기능은 아직 소스상에 적용되어 있지도 않고 왠만하면 적용시키지 않는 것이 낫겠다.
	10) LFI Analysis(윈도우 프로그램)
		가) Non-Real Time 측정 순서
			a) 실행하기 전에 [Real Time], [Non-Real Time] TAP Control을 번갈아 실행시켜서 reset 시킨다음
			b) Back ground Strip 삽입(사용하지 않은(피떨어뜨리지 않은)) -> preview -> capture -> 파일(bmp저장)
				-> []Lens -> 바로전에 저장한 Back ground bmp 읽어들여서 Lens shade table 생성
				-> Result Strip 삽입(피떨어뜨려서 항원/항채 반응이 완료된) -> preview -> capture -> [OSNR]눌러서 결과 값/그래프 확인
				-> 참고로, []누적 을 선택해야지만 [save data]를 눌렀을 때 측정 결과 값이 Infopia_LFI_data1.csv 엑셀파일에 계속 누적 됨
	11) 카메라 포커스가 맞고/안맞고에 따라서 mABS의 값이 변하기는 하지만 어느 정도 포커스가 맞는 상황에서는
		어느 정도 포커스가 틀어져도 거의 변하지 않음
		하기 값은 Non-Real Time으로 Fix된 띠를(피가 아닌 잉크) 측정한 값으로
		카메라 포커스가 맞고/안맞고에 따른 mABS의 값을 보여주고 있음
		-> 2010년8월27일 결론 : 포커스가 완전히 안맞고/맞고에 따른 mABS의 값이 틀린 것은 당연하지만
		포커스가 어느 정도 맞는 상황에서는 포커스가 틀어져도 거의 변화가 없음(cf, A상황 vs B상황 -> 거의 변화 없음)
		-> cf) 포커스가 어느 정도 맞는 상황에서는 포커스가 약간 틀어져도 결정계수(R제곱) 값의 차이는 거의 없음
				EX) JIG6, 포커스 약간 안 맞음 	포커스 제대로 맞춤
				결정계수	0.9889					0.989 

상황	설명								TmABS	Tpeak	CmABS	Cpeak	Tabs.Area	Cabs.Area
A		포커스맞음							94.509	88		723.823	301		85445		280935
B		A상황+렌즈를1/4바퀴C.W.로 돌림		93.733	94		758.286	301		81166		279021
C		A상황+렌즈를1/4바퀴C.C.W.로 돌림	93.155	89		714.728	303		85375		281587
D		포커스맞음							94.086	99		376.49	310		103493		367783
E		포커스완전히안맞음					64.259	103		758.286	307		63115		321358
F		포커스완전히안맞음					51.038	107		669.519	309		48842		298802
G		포커스맞음							96.657	93		841.056	310		106278		359019

	11+1) 카메라 Focus chart
		SelexOn처럼 카메라 포커스 거리가 짧은 경우는 포커스를 맞추기 위해
		Focus chart를 격자형으로(바둑판형식) 선두께:0.1pt 선색상:RGB(171,171,171) 선폭(선과선사이):0.8pt 형식으로 만들어서 사용해야 하며
		본, Focus chart를 사용하면 어느 정도 포커스 조절을 객관적으로 할 수 있다.
	12) 카메라 포커스 거리
		실제 카메라를 띄어내서 카메라 Preview로 눈으로 관측하면서
		카메라 포커스 거리를 재보니 21.9mm에서 카메라 포커스가 맞음
	13)	온도/광량/결과값(mABS) 관계
		가) 온도↑= 광량↓, 결과값↑
		나) 결과값이 변하는 거의 대부분 원인은 광량임
			따라서, 온도가 변해서 광량이 변한 것을 억지로 기준 광량으로 변경시키면
			결과값은 변하지 않음
		cf) LipidPro, Pioneer의 측정값은 측정시간분에 PD값의 비로서 이뤄지는 상대값이고
			TSH/PSA/Cardiac은 최종결과이미지에서 백그라운드대 피크값과의 비로서 이뤄지는 절대값이기
			때문에 LipidPro, Pioneer는 온도에 따른 광량 변화에 결과값이 덜 민감하고
			TSH/PSA/Cardiac은 절대값이기 때문에 온도에 따른 광량 변화에 결과값이 민감하게 반응하는 것임
		다) 결정계수(R제곱)와 관계된 인자도 LED광량임(거의 대부분)
			LED광량에 따라서 결정계수의 값이 변하게 됨
			광량이 커도 결정계수가 안 좋고 광량이 너무 작아도 결정계수 값이 안 좋음, 정당량의 LED광량을 찾아야만 함
			cf)Slit을 넣어도 결정계수가 변하지만 이는 Slit을 넣어서 카메라가 느끼는 광량의 값이 변해서
			결정계수를 변화시킨 것이지 잡광등을 Slit이 없애서 결정계수를 증가시킨 것은 아님
		라)	LED파장별 온도에 따른 LED 광량 변화
			외부온도에 따른(Chip의 온도에 따른) LED광량 변화는
			Blue LED가 가장 변화가 적고
			Green LED가 중간 정도의 변화
			Red LED가 가장 변화가 심함
	14) ConvBMP_16BPP_Auto 설명
		1. 프로그램 정의		
		   1) 선택한 *.BMP 파일을 임베디드 시스템 이미지 처리에서 사용할 수 있도록
		      헤더파일로 변경시켜주고
		   2) 간단한 명령으로 VR3511F 칩셋에서 LCD화면에 BMP파일 화면이 출력될 수 있도록
		      변환 프로그램을 포함 시킨 프로그램 입니다.		   
		
		2. 사용방법		
		   1) 선택&변경 버튼을 눌러서 변경하고자 하는 *.BMP 파일을 선택 하십시오.
		      참고로, *.BMP 파일 형식은 X축, Y축 크기가 Pixel로 8의 배수여야 하며
		      Image format은 24bpp여야 합니다.
		   2) 선택된 *.BMP 파일들은 헤더파일로 변경되서 ImageTotal.h, ImageTotal.cpp 파일로 만들어집니다.
		   3) ImageTotal.cpp은 컴파일러에서 추가시키고, ImageTotal.h 파일은 이미지 처리를 하고자 하는 파일에 #include 시킵니다.
		   3) BMP 파일 이름이 TEST.BMP라면 "img_"와 "TEST" 파일 이름을 붙여서 하기와 같이 명령을 실행하면
		      BMP파일 화면이 출력됩니다.
		      EXT_DrawImage(0, 0, img_TEST);
	15)	동일조건에서도 Camera를 Capture할때마다 측정값이 계속해서 변하는 문제
		가) LED를 계속 ON시켜 놓으면 상기 문제가 어느 정도 줄어듦 -> 추후, 효과없음확인
			cf)	HAMAMATSU에서도 측정에 관계 없이 LED전원을 계속 ON 시켜 놓음
			cf)	LED업체 관계자도 LFI는 LED전류가 작기 때문에(5mA이하, 보통 20mA정도 흘림)
				계속 10년을 켜 놓아도 광량이 70%밖에 줄어들지 않을 것 같다고 함
		나) Program적으로 Lens shade on하면 본 문제 어느 정도 줄어듦
		다) Camera Manual AEC를 줄이고 LED전류를 증가 시키면 본 문제 어느 정도 줄어듦
			-> 이렇게 하면 온도 변화에 따른 측정값이 변하는 문제를 어느 정도 줄일 수 있다.
		라) Slit을 넣으면 본 문제가 어느 정도 줄어듦
			(Slit을 넣은 직접적 효과라기 보다 Slit을 넣으니 카메라가 받아 들이는 노출계수가 적어지는 것과 유사한 결과가 나오며 따라서, 측정값이 온도 등에 따라서 변하는 현상이 줄어든 것임)
		cf) Camera (자체적) Lens shade(LC_CTR) OFF하면 동일 조건에서 측정값 편차 줄어드는지 체크해 보았는데
			LC_CTR ON/OFF와 동일조건 측정값 편차하고는 관계 없음 밝혀짐
		마)	Camera, Gamma function & FIFO를 OFF하고(DSP_Ctrl1(=0x64) : 0xff -> 0x18) AEC를 41로 증가 시키면(<-Gamma function을 OFF하면 이미지가 어두워지기 때문에 AEC값 높여줘야 함)
			측정시마다 측정값이 변하는 문제 확실히 줄어듦. Sample strip의 경우 TmABS = 106~108 사이의 값을 유지함
			하지만, Capture된 이미지 화질은 아주 매끄러워지는 반면 이미지가 전반적으로 뽀애지고 환해져서 Strip의 얼룩등이 사라지는 문제 있음
			(Strip이 더러워져서 생긴 얼룩 등이 뽀애지고 환해져서 얼룩이 사라짐)
			또한 AEC값을 증가 시켰기 때문에 온도에 따른 측정값의 변화가 커질 것으로 생각됨.
			cf) 참고로 Camera, Gamma function & FIFO를 OFF하지 않고 AEC = 41, R101을 최소로 해서 Sample strip을 측정해 보니
			TmABS의 값이 105~110으로 기존과 같이 측정시 마다 측정값이 많이 변함 확인(-> 효과 없음)
		바)	Image_MakeDensDataWithFilterring, Filtering을 기존 5번 -> 10번으로 늘린다고 측정시마다 측정값이 변하는 문제 해결되지는 않음
		사)	결론(2010년10월15일), Default(AEC14,DSP_Ctrl1=0xff,LC_CTR=0x05,DSPAuto=0x9f,COM13=0xe2,EDGE0=0x01) 카메라 레지스트리도
			측정CV가 괜찮기 때문에 그냥 예전 그대로의 카메라 레지스트리를 쓴다
			더이상 카메라 레지스트리 조절해서 측정CV 낮추는 것은 하지 않는다
				카메라레지스트리	JIG		CV(Sample strip 측정값(T_mABS) CV)
			a)	Default				JIG5	1.131
									JIG1	0.948(1차)	1.168(2차)
			b)	Default				JIG5	0.957
				& EDGE0=0x00		JIG1	1.341(1차)	1.384(2차)
		아)	측정값이 튀는 문제(특히, 초저농도에서(TmABS = 12) 튀면 CV가 많이 안 좋아짐(CV = 6.3))는 규칙적으로 일어 나지는 않음
			이미지 측정을 5초 정도 하지 않다가 하면 튀는 경우의 수가 보통 때 보다 많아 지기는 하지만
			일정하게 계속 이미지를 측정할 때도 튀는 경우가 확률은 적지만 발생 하기는 함
			따라서, 측정값이 튀는 경우는 불규칙하게 발생 함
		자)	미터기 전원을 ON시킨 바로 이후 부터 측정값이 변하는 것을 측정한 결과
			a)	1시간 이전까지 고농도 같은 경우는 Bias(4.49%)로 급격하게 변하다가 1시간 이후부터는 어느정도 안정화를 찾아서
				최종 8시간 변한 Bias 는 6.22%로 상당히 많이 변하고 있음
			b)	저농도와 중농도는 고농도에 비해서는 변화 폭이 적음(저농도 Bias(0.42%), 중농도 Bias(1.98%))
								초기	1시간경과	8시간경과
			저농도(74mABSraw)	33.40	33.53		33.54
			중농도(236mABSraw)	230.96	234.32		235.54
			고농도(930mABSraw)	346.04	361.59		367.55	-> =6.22%=(367.55-346.04)/346.04
			
			c)	상기 측정값이 변하는 현상을 줄이기 위해
				1)	Test1
					부팅 초기부터 H/W Camera Operating 을 계속 ON 시키고(MP4_WriteGPIOBit ( MP4_GPIO_A, PWDN, 0 );)
					카메라 측정시 마다 S/W Camera Operating을 ON/OFF 시켜가면서 측정한 결과(EXT_I2C_Write2(SENSOR_DEVICE_ID, 0x09, 0x10))
					측정값이 변하는 현상을 줄이는데 효과 없음 확인 함
				2)	보완1
					AEC 노출시간을 기존 14 -> 10으로 변경(노출시간을 줄여 온도에 따라서 LED광량이 변하는 영향을 덜 받게 함)하니 측정값이 1시간 동안 증가하는 폭이 줄어듦
					CV : 0.44 -> 0.20(고농도), Bias : 1.03 -> 0.42(고농도)으로 측정값 증가 폭이 줄어 듦
					cf)	보안1을 실행하려면 아래와 같이 LED 전류가 증가하는 문제점이 있음, 하지만 통상적으로 H/W설계 시 LED 전류는 20mA정도로 사용하고
						10초 간격으로 Real time 측정 시 LED가 켜져 있는 시간은 이미지 캡쳐 시 마다 300msec 밖에 되지 않기 때문에 기존 보다 전류가 2배 증가 했다고 피로 현상이 높아질 것으로 보이지는 않음
					cf)	AEC 노출시간을 기존 10 -> 8로 변경하면
						가) 1시간 동안 측정값 증가 폭(5분 간격으로 측정)
							CV : 0.20 -> 0.20(고농도, 0%줄어듦),	Bias : 0.42 -> 0.20(고농도, 52%줄어듦)
						나)	미터기 측정을 5초 간격으로 연속 측정 시 측정값이 증가하던 현상이 줄어듦
							CV : 0.73 -> 0.26(고농도, 64%줄어듦),	Bias : 2.39 -> 1.36(고농도, 43%줄어듦)
					cf)	AEC 노출시간을 7로도 줄여 보았지만 8일 때와 차이 없음
					->	결론 : AEC 노출시간을 8로 설정하자
					AEC[7:0] = 14	-> LED전류 = 4.17mA(LED2개 각각, 20075 LED광량으로 맞춘 경우)
					AEC[7:0] = 10	-> LED전류 = 6.22mA(LED2개 각각, 20075 LED광량으로 맞춘 경우)
					AEC[7:0] = 8	-> LED전류 = 8.22mA(LED2개 각각, 20075 LED광량으로 맞춘 경우)
				3)	보완2
					현, 부팅시 부터 카메라 모듈에 계속 전원이 투입되고 있으며
					혹시 카메라에 전원을 계속 투입하고 있는 것 때문에 측정값이 계속 증가하는 것 아닌가 생각하고
					측정이미지를 찍는 순간에만 카메라에 전원을 투입하는 방식으로 H/W를 변경하고 측정한 결과
					측정값이 증가하는 현상을 줄이는데 효과 있음 확인 함
					CV : 0.62 -> 0.44(고농도), Bias : 1.93 -> 1.03(고농도)으로 측정값 증가 폭이 줄어 듦
					cf) 기존 H/W PWDN 핀을 Camera H/W Stand by mode 핀으로 사용하지 않고 Camera 전원 ON/OFF 핀으로 변경 함
						정상적인 동작을 위해 Camera S/W Stand by mode ON/OFF 기능을 같이 사용 함(본 기능을 같이 사용하지 않으면 Camera I2C 통신 시 오류 발생 함)
				4)	결론
					보완1, 보완2 모두 측정값이 증가하는 현상을 줄이는데 큰 도움을 주기 때문에 모두 적용하기로 함
			
					
	16) 미터기간 편차 보정 방법
		측정1)	JIG4번을 JIG5과 동일한 광량으로 자동보정하고 Test Band의 위치도 스트립 위치를 조정해서
			동일선 상에 맞춘 다음 Sample strip을 넣고서 측정하니 TmABS의 크기가 JIG5에서 104.46이 나오고
			JIG4에서는 90.78이 나옮
			->	이는 광량을 동일하게 맞추고 Test band의 위치를 완벽하게 동일 선상에 맞춰도 측정값이 동일하게
		   		나오지 않는 다는 것을 말하는 것임
		
		측정2)	Camera contrast를 조절하는 방법
			Camera contrast를 조절해도 측정값이 변하기는 하지만
			이미지가 많이 손상되고 해상도가 낮은 편임
			또한, Density Graph Y절편(광량)의 값도 변하는 편임
			또한, Test band 보다 Control band 이미지가 더 많은 영향을 받는 편임(증가/감소폭이 더 큼)
		
		측정3)	Test band의 위치에 따라서도 측정값이 변함
			S/W Lens shade를 ON 상태에서 T_mABS, C_mABS 모두 측정 위치가 중앙으로 갈 수록 값이 작아짐
			T_mABS의 경우 Test band를 우측으로 1mm 이동시키면 T_mABS측정값이
			79.933 -> 77.384로 3.18% 감소 함
			cf)	위치 편차에 따른 결정계수는 모두 같고 측정값만 틀린 경향성을 보인다면
				Calibration은 한번만 하고 위치를 감안해서 값만 보정하면 된다
			cf)	제일 좋은 것은 위치에 따른 측정값 편차가 없는 것이다.


		JIG5번, JIG1번은 Test band의 위치가 동일(위치편차1mm이내) 선상에 있어서 유사한 측정 결과값이 나왔지만
		JIG4번은 Test band의 위치가 틀리기(위치편차1mm이상) 때문에 다른 측정 결과값이 나오고 있음
		-> JIG의 기구 공차로 발생되는 현상으로 제품간의 편차가 기구 공차까지 고려해서 튜닝 되도록
		  하는 방안을 모색 해야 함
		
		가) Test band의 위치가 동일 선상에 있지 않은 경우 미터기간 편차 보정 방법(위치편차1mm이상)
		
		나) Test band의 위치가 동일 선상에 있을 경우 미터기간 편차 보정 방법(위치편차1mm이내)(자동Calibration)
			a)	중농도 기준스트립(3-3)을 넣은 다음 Calibration버튼 누름
				(UART 터미널 창에서 "Press Num 1 Key to Meter calibration)
			b)	미터기가 자동으로 LED광량을 조절 측정값이(TmABS) 중농도 기준값이 되도록 맞춤
				(중농도 기준스트립(3-3)의 기준값 159가 되도록 맞춤)
				(-> 이렇게만 해도 결정계수(R제곱)의 값이 0.997정도로 제품에 관계 없이 나옮)
			c)	아무것도 없는 백색 클린스트립을 넣어서 Test band의 광량을 측정한 다음
				본 측정값을 Flash에 저장해서 자동광량 보정의 기준 광량값으로 사용
				(참고로, 자동광량 보정은 온도에 따른 측정값 변화를 보정하는 용도로 사용)
			d-1)TmABS의 값이 저농도 값을 갖는 기준스트립을 넣은 다음
				TmABS의 값을 측정한 다음 Hamamatsu로 측정한 저농도 기준스트립과의 차이를
				보정식의 기울기에 적용 시켜서 저농도(->c)에서 보정) ~ 중농도(->a)에서 보정) 구간의 값이
				Hamamatsu와 동일하도록 보정함.
			d-2)저/중/고농도 기준스트립(7가지)을 모두 측정해서 Hamamatsu와의 결정계수를 구한 다음
				결정계수가 0.995이상인 경우만 합격품으로 통과시키고
				결정계수에 대한 기울기 & Y절편을 측정값 수식에 적용시킴.
				(Ex, y = 1.9946x - 24.392)

			cf)	본 방법을 사용해도 결정계수가 0.98이하로 안 좋은 경우는 카메라 특성이 좋지 않은 경우로
				카메라를 교체해야 함
				참고로, 카메라 특성이 좋지 않은 경우 카메라 이미지 코너 부분이 어두운 특성을 나타냄.

	17-1)Calibration 원리
		1)	어떤 미터기를 기준스트립을 가지고 LED 광량을 변화시켜서 
			하마마쯔와의 결정계수가 1에 가깝게 만든 다음
			중농도 기준스트립을 넣어서 이때의 TmABS값이 얼마인지 기록하고
			Blank 스트립을 넣어서 이때의 광량을 기록함
		2)	이후, 다른 미터기는 앞서 사용한 중농도 기준스트립을 넣고서
			앞서 기록한 TmABS 값이 나오도록 LED 광량을 변화시켜 맞추고
			맞췄으면 Blank 스트립을 넣어서 이때의 광량을 Flash에 저장함
		3)	참고로, 이때의 광량 값이 미터기의 특성이며
			온도, 시간 등으로 미터기 특성이 변해도
			본, 광량이 되도록 맞추기만 하면 모든 미터기가 
			하마마쯔와 동일한 결정계수 1에 가깝게 됨

	17)	기준Strip을 가지고서 젖은Strip(혈액) Calibration 방안
//		젖은Strip과 똑같은 측정값을 나타내는 기준Strip 7가지를 만들어서
//		(젖은Strip과 기준Strip의 색상이 일치할 필요는 없음)
//		HAMAMATSU로 Calibration 한다면 기준Strip을 가지고 젖은Strip에 대한 Calibration이 가능
		방안1
		가)	우선 미터기 1대를(Master미터기) 젖은Strip을 가지고 HAMAMATSU로 결정계수가 1에 가깝게
			LED광량을 조절해서 Calibration 한 다음
		나) 본 Master미터기에 기준스트립 7가지를 넣고서 측정값이 얼마가 나오는지 기록
		다) 다른 미터기에도 기준스트립 7가지를 넣고서 상기 나)측정값이 나오도록 Calibration 함
		->	다른 미터기도 Master미터기와 동일한 기준스트립 측정값이 나오게 되며
			이는 결과적으로 젖은Strip을 넣어도 Master미터기와 동일한 값이 나오게 됨
			따라서, 기준스트립을 가지고서 젖은Strip에 대한 Calibration을 할 수 있는 것임 
		->	참고로, HAMAMATSU가 아닌 Master미터기가 기준 장비가 되는 것임
		
		방안2
		가)	HAMAMATSU로 농도별 젖은스트립의 측정값을 측정
		나) 가)항, 젖은Strip의 측정값과 동일하게 농도별 기준스트립 제작(Membrane의 색상은 최대한 젖은스트립과 유사하게 제작)
		다) 나)항에서 만든 기준스트립을 가지고 미터기들을 Calibration

	18)	신지훈, 미터기 Calibration방안(로슈 등 타사, 측정기 개발회사에서 사용하는 Calibration 방안이라고 함)
		가)	기준스트립(마른) 저/중/고를 갖고서
			모든 미터기가 동일한 값이 나오도록 Calibration 실시(Ex. 저농도라면 모든 미터기가 모두 TmABS = 20이 나옮)
			a) 중농도 기준스트립 넣고서 LED광량을 조절 기준값 159가 나오도록 맞춘 다음 Blank스트립을 넣어서 이때의 광량값 저장
			b) 저/중/고 농도 기준스트립을 각각 넣고서 HAMAMATSU와의 결정계수를 구한 다음
			c) 결정계수 기울기/Y절편 값을 1차로 미터기에 대입
		나)	마커별(젖은특성,Ex.CK-MB) 기울기/Y절편 값을 미터기에 2차로 대입 함
			이때의 마커별 기울기/Y절편 값은 센서팀에서 제공
		->	모든 미터기가 원하는 측정값을 동일하게 제공
	
	18+1)Multi 미터기 Calibration Algorisim(2011년4월22일)
		가)	분석결과1(LED광량 고정 Calibration)
			카메라간 편차와는 크게 상관 없고 LED 광량을 26488 intensity로 맞춰주면
            멤브레인 1~3 모두 상관계수 0.9977 이상으로 양호한 성능을 나타내는 것으로 확인 됨.
		나)	분석결과1에 대한 검증 테스트 실시
			LED & Camera를 무작위로 선택해서 LED광량을 26488로 맞춰주기만 하면 양호한 성능을
            나타내는지 테스트
            a)	테스트 결과
 	        	총16세트(LED & Camera Random 조합)를 테스트 했으며
    	        테스트 결과 14세트는 Membrane1~3모두 결정계수 0.9972이상의 양호한 성능을 나타냈으며
        	    2세트는 Membrane1만 0.9963이하의 저조한 결정계수를 보임
        	b)	a) 결정계수가 저조한 2세트에 대한 원인 분석 결과
        		카메라 특성하고는 상관 없고(카메라를 교체해도 결정계수 향상되지 않음)
        		LED를 교체하니 결정계수가 2세트 모두 Membrane1도 0.9973이상으로 향상됨
        		(참고로 LED광량은 가)분석결과1 처럼 26488로 맞춰줌)
        		따라서, 2세트, Membrane1의 결정계수가 저조한 이유는 LED 특성 때문임
        	c)	최종 테스트 결과
        		가)	분석결과1(LED광량 고정 Calibration) 을 총16세트에 적용한 결과
        			16세트의 Membrane1~3 모두 결정계수 0.9972 이상의 양호한 Calibration 성능 나타냄
        		나)	미터기 1대에 대한 측정 CV
        			저농도(1-2strip) : 1.225이하
        			중농도(3-3strip) : 0.471이하
        			고농도(7-2strip) : 0.346이하
        		다)	미터기간 편차 CV(총16세트)
										Membrane1	Membrane2	Membrane3
                    저농도(1-2strip)	4.76		3.10		4.01
                    중농도(3-3strip)	0.73		0.74		1.13				
                    고농도(7-2strip)	0.65		0.43		0.60     
        다)	미터기 Calibration 적용 시 결정계수를 2차식으로 적용하면 결정계수가 더 좋아짐
        	(당연한 현상으로 2차식은 Curve도 적용할 수 있기 때문임)

		라)	미터기 Calibration 알고리즘 모색 및 효과분석 완료
		   1) 미터기 Calibration 알고리즘
		      가) LED광량을 26488로 맞춤
		      나) 상관계수(R제곱)를 2차식을 적용해서 계산하고
		          본, 2차 함수 Calibration 코드식을 미터기에 적용
		   2) 효과분석결과
		      상기 1)번 Calibration 알고리즘을
		      Multi strip(18세트), Single strip(15세트), 신규멀티JIG(5세트)에 적용해서 분석한 결과
		      아래와 같은 양호한 성능을 출력함
		      가) 총 38세트 모두 상관계수 0.998이상의 성능 출력
		      나) 미터기 1대에 대한 CV는 저농도 1.2 이하의 성능을 나타냄
		      다) 미터기기 간의 편차 CV는 저농도에서 2.87 이하의 성능 출력
		   3) 결론
		      상기 1)번 미터기 Calibration 알고리즘을 미터기 38세트에 적용한 결과
		      모두 양호한 성능을 나타내고 있으므로 본, 알고리즘이 
		      미터기를 Calibration 하는데 효과가 있음을 확인 함
		   4) 추후
		      대량생산 시에도 본, 미터기 Calibration 알고리즘을 적용할 예정이며
		      효과가 있는지 재 검증할 예정 임
		      
		바)	Code 식을 2가지(미터기 Calibration 코드식, 센서 코드식) 사용해야 하는 이유
			1)	만약 LED광량 26488로 맞춘 미터기를 가지고
				미터기 Calibration 코드식을 적용하지 않고
				곧바로 센서 코드식을 이용 기준 장비와 맞춘 다면
			2)	LED광량 26488로 맞춘 미터기들 자체가 미터기간 편차가 존재 하기 때문에
				상기 1)번 방법을 쓴다면 어떤 LED광량 26488로 맞춘 미터기를 가지고 1)번 방법을 써야 하는지
				알 수 없는 난관에 부딪치게 되며, 잘못 하면 성능이 좋지 않은 LED광량 26488로 맞춘 미터기를
				기준 미터기로 사용하게 될 수도 있고 이렇게 된다면 잘못된 코드식으로 다른 미터기들에 맞추게 되는
				아주 심각한 문제를 일으킬 수 있음
			3)	따라서, Code 식을 2가지(미터기 Calibration 코드식, 센서 코드식) 사용해야지만
				가)	HAMAMATSU와 기준장비와의 코드식을 센서 코드식으로 잡아서 미터기에 곧바로 적용할 수 있고
					미터기를 잘못 잡아서 잘못된 코드식을 적용하는 심각한 문제도 피할 수 있으며
				나)	이미 HAMAMATSU와 모든 미터기를 맞춘 상태이기 때문에 미터기간의 편차를 최소화 할 수 있고
				다)	추후, 마커가 추가 된다고 해도(RF-ID DATA로 추가)
					이미, 나)와 같이 HAMAMATSU로 미터기가 맞춘 상황이기 때문에 별도의 Calibration 필요 없이
					HAMAMATSU와 기준장비와의 코드식을 그대로 사용할 수 있는 장점이 있음

	18+2)적정LED광량 개념 및 측정값과의 상관성(요약사항)
		면역측정기의 경우, 
		1)	LED광량의 세기에 의해서 측정값이 변하며
		2)	이는, LED광량의 세기를 적절히 변화시키면 측정값이 양호하게
			출력될 수 있다는 것을 의미하며
			이는 적정 LED광량이 존재한다는 것을 의미 하는 것임
		3)	또한, 적정 LED광량은 미터기 마다 다르지 않고 동일하기 때문에
			모든 미터기들을 고정된 하나의 적정LED광량으로 Digital volume을 변경 시켜서
			세팅해 주기만 하면 모든 미터기가 양호한(R제곱 0.998이상) 측정값이 나오도록
			Calibration 해 줄 수 있다는 것을 의미 함
			ex)	미터기 18세트에 대한 적정LED광량을 측정해 본 결과, 26488intensity로 동일하며
				본, 적정LED광량으로 임의의 다른 JIG 5대에 적용해 본 결과
				JIG 5대 & Single/Multi strip 모두 R제곱 0.998 이상의 양호한 성능이 나옮
		4)	참고로, 면역측정기의 경우 본, 적정LED광량값을 기준 광량 값으로
			정하고 측정 시 마다 시간이 지나면서 LED광량값이 적어지는 현상을
			S/W적으로(->Digital volume으로 자동광량조절) 자동 보정해서
			항상, 일정한 LED광량값을 가지고 측정을 하는 방안을 적용하고 있으며
			->	이는 시간이 지나도/ 피로 현상이 누적 되도 측정값은 항상 일정하게
				출력되게 끔 보정해 준다는 것을 뜻함


	19) USB, UART Cable을 PC와 연결하고 안하고에 따라서 MAX5402 출력저항을 저항측정미터기(AC전원사용)로 측정시
		측정값이 변함
		EX)	USB, UART Cable PC와 연결 = 5.53Kohm
			USB, UART Cable PC와 모두 연결하지 않음 = 4.65Kohm
		하지만 본 측정값이 변하는 것처럼 보이는 것은 저항측정미터기의 AC전원 접지와 연관 있는 것으로 파악되며
		이런 문제로 인해서 측정값(TmABS)이 변하지는 않음(USB, UART Cable PC와 연결 유/무에 관계 없이 동일한 측정값 출력)
		또한 전원 VCC(5V, 3.3V)의 값이 변하지도 않음

	20) 카메라 특성 보고서
[1] 카메라 분해능
LFI Reader에서 사용하는 OV7720 CMOS VGA Camera의 분해능

1. 단색 LED를 조명으로 사용할 경우
   Green or Red or Blue LED 중에서 한가지만을 조명으로 사용하는 경우로 보통 R/G/B중에서 한가지만 DATA이미지 처리함
   1) GRB422 Format
     8-bit G, 8-bit R or 8-bit G, 8-bit R 출력 형식으로 단일 Pixel로는 256(2의8승)의 분해능을 갖지만
     카메라 이미지 처리는 보통 여러 Pixel 영역의 값을 합산해서 처리하므로 256 이상의 분해능을 가짐
     이유는, 측정부의 이미지는 보통 여러 농도의 색상으로 구성되어지며 전 측정 영역이 한가지 농도의 색상으로만 구성되는
     경우는 극히 드물기 때문
   2) RAW10 Format
     10-bit R or 10-bit G or 10-bit B 출력 형식으로 단일 Pixel로는 1024(2의10승)의 분해능을 갖지만
     카메라 이미지 처리는 보통 여러 Pixel 영역의 값을 합산해서 처리하므로 1024 이상의 분해능을 가짐

2. 백색 LED를 조명으로 사용할 경우
   R/G/B가 모두 포함된 백색LED를 조명으로 사용하는 경우로 RGB Color 이미지로 처리함
   1) GRB422 Format
     8-bit G, 8-bit R or 8-bit G, 8-bit R 출력 형식으로 단일 Pixel당 16,777,216(2의24승)의 분해능을 갖고
     카메라 이미지 처리는 보통 여러 Pixel 영역의 값을 합산해서 처리하므로 16,777,216 이상의 분해능을 가짐
   2) RAW10 Format
     10-bit R or 10-bit G or 10-bit B 출력 형식으로 단일 Pixel로는 1,073,741,824(2의30승)의 분해능을 갖고
     카메라 이미지 처리는 보통 여러 Pixel 영역의 값을 합산해서 처리하므로 1,073,741,824 이상의 분해능을 가짐

[2] CMOS카메라 선정이유
   CMOS이면서도 CCD처럼 Noise 특성이 좋은 카메라를 선정했으며 CCD의 경우는 주로 일본산으로
   구하기 어렵고 상대적으로 높은 전원을 사용해야 하는 등 H/W구성이 어려운 문제가 있고
   초접사 기능 구현이 어려운 문제(피사체와의 거리 최소 4cm이상) 등이 있기 때문에 CMOS카메라 선정

[3] PD(Photo Diode) vs Camera 특성
1. PD
   PD는 실시간으로 광자를 받아서 Voltage로 보내는 구조임
   따라서, 노출시간에 관계 없이 측정값 동일
2. Camera
   Camera는 Timing generator가 존재하여 PD array로 받은 광자를 실시간으로 받아서
   곧바로 보내지 않고, exposure time(frame rate과도 연관됨)등을 조절하여 광자를
   Capacitor에 누적해서 누적결과값을 보내는 방식으로 노출시간이 길어질 수록 결과값이
   커지게 되고 결국에는 Saturation 됨
   이러한 원리로 수신되는 광 환경의 tuning이 필요하지만
   조명이 어둡거나 밝음에 관계 없이 정당한 밝기의 결과값을 얻을 수 있음
   
[4] 카메라업체 이프러스, 김청갑 차장 얘기
1.	16bits(H/W) Camera는 없다, 고가의 Camera도 8bits(H/W)로 구현되고 8bits 통신함
2.	GRB422 Format
	G:8bit(1byte) + R:8bit(1byte) or G:8bit(1byte) + B:8bit(1byte)
	G:8bit(1byte) + R:8bit(1byte) 보내고 G:8bit(1byte) + B:8bit(1byte) 보내는 형식으로 각 pixel당 2byte 구조
	cf) Green의 경우에는 각각의 pixel의 값이 출력되지만 Red, Blue인 경우는 한 pixel을 건너서 값이 출력됨
3.	ISP : 8bits 통신을 하지만 24bits 해상도 구현
	
[5] 분해능 추가 설명
1.	흰색은 R:Max, G:Max, B:Max
2.	LFI Reader처럼 Green 단색 광원을 사용하는 경우
	만약, 백색광원을 사용한다면 어두운 녹색은 G값이 작지만, 표준녹색이나 흰색의 G값은 모두 Max이기 때문에(분별력이 없음) 
	이것을 방지하기 위해 조명을 Green으로 하면서 적당량의 광량을 주고 G값만을 측정해야함
	(Saturation방지(측정부에서 가장 밝은 Green이 가장 G값을 갖도록) -> Saturation이 됐는지 안됐는지는
	 카메라로 이미지를 찍어서 보면 확실하게 알 수 있음)
3.	백색광원을 사용하면서 흰색 Background membrane을 사용한다면 RGB 모두 처리해 줘야 함
	이유는 R만을 측정한다면 흰색 바탕도 R값이 Max이고 그냥 빨강색도 Max이기 때문(분별력이 없어짐)

[6] YUV 방식 [-方式, YUV]출처: IT용어사전
휘도 신호(Y), 청색 신호와 휘도 신호의 차(U), 적색 신호와 휘도 신호의 차(V)의 3가지 정보로 색을 나타내는 형식. 
텔레비전(TV)에 사용되는 색 표현 방식으로, Y 성분은 오차에 민감하므로 색상 성분인 U와 V보다 많은 비트를 코딩하며, 
Y:U:V의 비율은 보통 4:2:2 이다. CD-I와 DVI(Digital Video Interactive)에서도 사용된다. 
RGB 값을 YUV로 변환식은 Y=0.3R+0.59G +0.11B, U=(B-Y)x0.493, V=(R-Y)x0.877이며, 
반대로 YUV 값을 RGB로 변환식은 R=Y+0.956U+0.621V, G=Y+0.272U+0.647V, B=Y+1.1061U+1.703V이다. 
즉 빛에 둔감한 칼라 정보라고 판단되어 YUV 신호로 변환하여 사용하고 있다.
cf)	간단히
	-	YUV가 생긴 이유는, 흑백TV  / 컬러TV 방송신호를 호환시키기 위해 발명되었으며
		Y신호만 잡아서 처리하면 흑백TV를 볼 수 있고, YUV신호 모두를 잡아서 처리하면 컬러TV를 볼 수 있다.
		cf)	RGB 값을 YUV로 변환식은 Y=0.3R+0.59G +0.11B, U=(B-Y)x0.493, V=(R-Y)x0.877이며, 
			YUV 값을 RGB로 변환식은 R=Y+0.956U+0.621V, G=Y+0.272U+0.647V, B=Y+1.1061U+1.703V이다.
			->	이 2가지 공식에서 알 수 있는 것은 YUV 3개 신호값만 보내면
				흑백TV도 볼 수 있고 컬러TV도 볼 수 있다는 것이다.
				흑백TV는 Y신호만 처리하면 되고, 컬러TV는 YUV 3개 신호를 모두 받아서 RGB로 변경해서 처리하면 됨
				cf)	YRGB 이렇게 4가지 신호를 보내지 않고 YUV 3가지 신호만 보내도 흑백TV, 컬러TV 모두 볼 수 있음
	-	현재 실제로 우리가 디지털에서 사용하는 것은 YCbCr이고 YUV와는 기술적인 차이가 있는 단어이지만
		둘 사이에는 유사성이 많은 데다가 그동안 YUV라는 단어가 많이 사용되어왔기 때문에
		요즘에는 YUV와 YCbCr은 개념적으로는 혼용해서 쓰이는 단어 임
	-	Y는 밝기(휘도) 신호이며 RGB중에 G 색상과 많이 연관되어 있고
		U는 B-Y 신호로(청색 신호와 휘도 신호의 차) Cb(Chrominace blue)라고도 하고 RGB중에 B 색상과 많이 연관되어 있음
		V는 R-Y 신호로(적색 신호와 휘도 신호의 차) Cr(Chrominace red)라고도 하고 RGB중에 R 색상과 많이 연관되어 있음

[7] 화소(pixel)
이름	해상도(메가픽셀)	가로 x 세로 
CGA     0.064               320×200 
EGA     0.224               640×350 
VGA		0.3					640×480 
SVGA    0.5					800×600 
XGA		0.8					1024×768 
SXGA	1.3					1280×1024 
UXGA	1.9					1600×1200 

1메가픽셀 (줄여서 MP, Mpx)은 100만 화소를 가리키며 영상의 화소 수만을 위한 것이 아니라 디지털 카메라의 이미지 센서 요소의 수나 디지털 디스플레이의 디스플레이 요소의 수를 
나타내는 데에도 사용된다. 이를테면 2048x1536 센서 요소는 3.1 메가픽셀 (2048 x 1536 = 3,145,728)를 가진다는 말과 같다.
cf) 640x480 = 307200 = 0.3메가픽셀 = 30만 화소


	21) 카메라 이미지 평균화 알고리즘
		1회 측정 시 마다 기존, 카메라 이미지를 1번만 찍어서 측정값을 도출하던 방식에서
		1회 측정 시 마다, 카메라 이미지를 연속으로 3번 찍어서
		3개의 이미지를 평균화 처리 하는 방식으로 개선
		CV가 초저농도/저농도/중농도/저농도 전 구간에서 52%이상 향상 됨
		ex)	초저농도의 경우 평균화 알고리즘 적용 전/후의 CV 향상 정도가
			CV 5.59 -> CV 2.953 으로 52.83% 향상 됨

	22)	HAMAMATSU 장비 특징
		Strip slate	가 철판이기 때문에 자석을 이용해서 Strip slate를 어느 정도만 밀면
		자동으로 끝까지 밀리도록 설계함
		
	23)	CV, Error%
		가)	CV
			a)	미터기 1대를 가지고 기준스트립 20~100번 측정한 값에 대한 측정편차를 말함
				CV = STDEV/평균값*100(%), STDEV : 엑셀함수(표준편차)
			b)	미터기간 편차를 말할 때도 "미터기간 편차 CV"를 가지고 말함
				cf)	혈당기에서는 미터기간 편차도 CV를 가지고 말한다고 하며
					기준스트립을 사용한 미터기 1대에 대한 CV는 거의 0에 가깝다고 하며
					미터기간 편차 CV도 저농도 = 0.52%/ 중농도 = 0.34%/ 고농도 = 0.34% 의 성능이 나온다고 하며
					미터기간 편차 CV를 구할 때 미터기 개수는 혈당기 경우는 50~100대
					Clover는 20대 정도를 가지고 구한다고 함
		나)	Error%(bias, 편차)
			Error% = 측정값/기준값 - 1	= (측정값-기준값)/기준값 = 측정값/기준값 - 기준값/기준값 
	
	23+1)엑셀 추세선(R제곱) 수식 셀에 직접 삽입하는 방법
		가)	방법1
			A)	그래프 -> 오른쪽 마우스 -> 추세선 서식 -> "선형, 수식을 차트에 표시, R-제곱 값을 차트에 표시" 선택
				하는 방법으로 기울기와 Y절편을 구하는 방법 말고
				cf)	엑셀에서 추세선을 추가하려면 차트종류를 꺾은선형이 아닌 분산형으로 만들어야 함
					이후, 추세선을 추가시켜야 함
			B)	셀에서 직접적으로 y = 5x + 6.6667 과 같은 선형 추세선, 기울기와 Y절편을 구할려면
				아래와 같은 수식을 삽입하면 됨
				="y=" & LINEST(B2:B4,A2:A4,1) & "x + " & ROUND(INDEX(LINEST(B2:B4,A2:A4,1),2),4)
				Cf1)	LINEST(B2:B4,A2:A4,1) 에서 마지막 상수 1(=TRUE)을 써줘야 y = ax + b에서 b수식을 구해줌, 참고로 LINEST(B2:B4,A2:A4,1) 함수는 y = ax + b에서 기울기인 a값을 구해줌
				Cf2)	INDEX(LINEST(B2:B4,A2:A4,1),2)	에서 마지막 상수 2의 뜻은 LINEST의 두번째 계수인 Y절편을 반환하라는 뜻
				Cf3)	ROUND(INDEX(LINEST(B2:B4,A2:A4,1),2),4)	에서 마지막 상수 4의 뜻은 소수점 4자리로 반올림 하라는 뜻		
		나)	방법2
모든 엑셀 유저에게 금과옥조 같은 말씀... ㅠ,.ㅠ  낙서장  2009/02/18 15:14
 http://blog.naver.com/sunlight1977/110042765570 
 
출처는 여기 ---> http://www.eng-tips.com/viewthread.cfm?qid=154948 
 
I happened to be browsing through some old files and came across this one pertaining to trendlines.  I've long since forgotten when/where the information was obtained.

Enjoy and good luck!

Chart Trendline Formulas
When adding a trendline to a chart, Excel provides an option to display the trendline equation in the chart.  This tip describes how to create formulas that generate the trendline coefficients.  These formulas are then used to calculate predicted y values for give values of x.

These equations assume that your sheet has two named ranges: x and y.

Linear Trendline(추세선->선형->결정계수(R제곱) 기울기, Y절편 곧바로 구할 때 사용; y=ax+b)
Equation: y = m * x + b
m: =SLOPE(y,x)									->	그래프 상에서 오른쪽마우스 -> 추세선 선택 해서 얻은 값과 완벽하게 같음(약간씩 값이 틀려진 것 처럼 보이기도 하는 것은 반올림을 해주지 않았기 때문임) 
b: =INTERCEPT(y,x)								->	그래프 상에서 오른쪽마우스 -> 추세선 선택 해서 얻은 값과 완벽하게 같음(약간씩 값이 틀려진 것 처럼 보이기도 하는 것은 반올림을 해주지 않았기 때문임)
												->	cf) SLOPE($Y$22:$Y$29, $AE$22:$AE$29) -> $Y$22 와 같이 Y, 22 앞에 $ 붙여 주면 영역이 고정됨(참고로, 영역 선택 후 F4 키를 누르면 자동으로 $를 붙여줌)

Logarithmic Trendline
Equation: y = (c * LN(x)) - b
c: =INDEX(LINEST(y,LN(x)),1)
b: =INDEX(LINEST(y,LN(x)),1,2)

Power Trendline
Equation: y=c*x^b
c: =EXP(INDEX(LINEST(LN(y),LN(x),,),1,2))
b: =INDEX(LINEST(LN(y),LN(x),,),1)

Exponential Trendline
Equation: y = c *e ^(b * x)
c: =EXP(INDEX(LINEST(LN(y),x),1,2))
b: =INDEX(LINEST(LN(y),x),1)

2nd Order Polynomial Trendline(추세선->다항식, 차수:2->결정계수(R제곱) 기울기, Y절편 곧바로 구할 때 사용; y=ax^2+bx+c)
Equation: y = (c2 * x^2) + (c1 * x ^1) + b
c2: =INDEX(LINEST(y,x^{1,2}),1)					->	그래프 상에서 오른쪽마우스 -> 추세선 선택 해서 얻은 값과 완벽하게 같음(약간씩 값이 틀려진 것 처럼 보이기도 하는 것은 반올림을 해주지 않았기 때문임)
C1: =INDEX(LINEST(y,x^{1,2}),1,2)				->	그래프 상에서 오른쪽마우스 -> 추세선 선택 해서 얻은 값과 완벽하게 같음(약간씩 값이 틀려진 것 처럼 보이기도 하는 것은 반올림을 해주지 않았기 때문임)
b = =INDEX(LINEST(y,x^{1,2}),1,3)				->	그래프 상에서 오른쪽마우스 -> 추세선 선택 해서 얻은 값과 완벽하게 같음(약간씩 값이 틀려진 것 처럼 보이기도 하는 것은 반올림을 해주지 않았기 때문임)

3rd Order Polynomial Trendline
Equation: y = (c3 * x^3) + (c2 * x^2) + (c1 * x^1) + b
c3: =INDEX(LINEST(y,x^{1,2,3}),1)
c2: =INDEX(LINEST(y,x^{1,2,3}),1,2)
C1: =INDEX(LINEST(y,x^{1,2,3}),1,3)
b: =INDEX(LINEST(y,x^{1,2,3}),1,4)

Higher Order Polynomial Trendline
Notice the pattern in the two preceding sets of formulas

-pmover
[출처] 모든 엑셀 유저에게 금과옥조 같은 말씀... ㅠ,.ㅠ|작성자 열공열공

		다)	손쉽게 결정계수 구하기
			EX1) =INDEX(LINEST($A$3:$A$9,$B$3:$B$9^{3,2,1},TRUE,TRUE),3,1)		-> 다항식, 3차식에 대한 결정계수 구할 때
			EX2) =INDEX(LINEST($A$3:$A$9,$B$3:$B$9^{2,1},TRUE,TRUE),3,1)		-> 다항식, 2차식에 대한 결정계수 구할 때
			EX3) =INDEX(LINEST($A$3:$A$9,$B$3:$B$9^{1},TRUE,TRUE),3,1)			-> 선형, 1차식에 대한 결정계수 구할 때
			
손쉽게 결정계수 구하기
Program 2011/12/21 22:59 
회귀분석을 돌리면 필히 결정계수를 확인해야 하는데...
엑셀에서는 크게 두 가지 방식으로 결정계수를 구할 수 있다.
막강한 LinEst 함수와 단순회귀분석용 RSQ 함수.

아래 자료에 대해 몇가지 모형을 가정해 추정치를 구해봤다.



Trend 함수를 활용하면 아래와 같은 방식으로 손쉽게 추정치를 구할 수 있다.

e3 셀 (Y=X³+X²+X)
=TREND($A$3:$A$9,$B$3:$B$9^{3,2,1},$B3^{3,2,1})

그럼 결정계수는?


 
LinEst 함수를 이용해 구하는 방법은 여러 차례 소개했다.

e13 셀 (Y=X³+X²+X)
=INDEX(LINEST($A$3:$A$9,$B$3:$B$9^{3,2,1},TRUE,TRUE),3,1)

	23+2)엑셀, 절대참조, 영역 고정 방법
		,A1,B1,			부분을
		,$A$1,$B$1,		으로 수정하면 됨
		cf)	주소 수식에 커서가 위치해 있는 상태에서 'F4' 키를 누르면 $가 붙었다 떨어졌다 함
		cf)	C1 = A1 * B1 = 2000
			그런데 이 수식을 C1 = $A$1 * $B$1으로 설정한 상태에서 C1을 클릭후 아래쪽으로 드래그 하면
			C2,C3 모든 수식이 $A$1 * $B$1이 되는 것이죠.
			$를 입력하지 않으면 수식도 자동으로 A2 * B2와 같이 바뀝니다.
			
	23+3)엑셀, 행높이 정확하게 변경하려면
		왼쪽마우스 -> Drag -> Pixel 단위가 아닌
		오른쪽마우스 -> 행 높이 에 나오는 값으로 변경 시켜야 함
		
	23+4)엑셀, 그림 이미지 만 모두 선택하는 방법
		홈 -> 찾기 및 선택 -> 개체 선택 -> Ctrl+A

	
	24)	Multi strip의 경우 흡수패드 간의 간격을 기존 0.6mm -> 0.8mm 로 늘림
		이유는, 흡수패드 간의 간격이 기존 0.6mm 로 좁으면
		혈액이 흡수패드에 흡수되서 포화된 상태에서 바로 옆에 있는 흡수패드의
		혈액과 응집력으로 인해 서로 붙어 버리는 현상이 발생하기 때문임
	
	25)	LED를 카메라 경통부 보다 높게 위치시켜서(카메라 경통부와 부딪쳐서 생기는 그림자를 없애기 위해)
		위/아래/좌/우에 LED4개를  부착한 결과
		:	가운데 부분은 전체적으로 환해지지만 북서/북동/남서/남동 모서리 부분이 어두워지는 문제가 있음
		->	전체적으로 골고루 LED 조명이 밝혀지기를 바랬지만 모서리 부분이 어두워지는 문제가 있음
		Cf)	기존 default LED 구조는 (LED가 카메라 PCB와 따로 떨어져서 상/하에 배치되어 있는 구조)
			LED가 위/아래에 부착되어서 비스듬히 조명을 쏴주기 때문에 중앙 상~하단으로 LED광량이 밝고
			좌/우측 상~하단이 어두움
		->	결론 : 차라리 기존 default LED 구조가 멤브레인별(Multi, 3개) 광량의 편차가 적기 때문에
			기존 default LED 구조를 그대로 사용하자.(2011년 5월 3일)
	
	26)	경통(홀더)의 높이를 낮춰서 이미지를 확대하면 할 수록 렌즈를 홀더에 장착하고서
		돌릴 수 있는 턴수가 작아짐
		
	26+1)
		1)	경통의 높이가 길면 길수록 좁은 이미지가 확대 됨
		2)	경통의 높이가 낮으면 낮을수록 넓은 이미지가 축소되서 보임
			

	27)	카메라폰용 IR필터(적외선 카메라, 열화상 카메라)
카메라폰의 카메라는 CCD나 CMOS를 사용하여 빛신호를 전기신호로 바꾸어서 화상을 만듭니다. 
그런데 이들 빛 신호라는것은 사람들이 눈으로 볼 수 있는 가시광선 영역(400-700nm)뿐 아니라 
근적외선 영역( ~1150 nm)까지도 감지하게 되어서 실제 색이나 화상하고는 관계없는 신호가 감지기를 포화시켜 버리게 되므로 
근적외선 영역의 파장들을 제거해 주기위해(IR-Cut Filter)필요합니다.
이들을 만드는데 있어서 핵심 기술은 진공박막증착 기술이며, 이는 유리기판(종전에는 LCD 유리를 많이 썼으나 최근 화소수가 증가하면서 규격이 높아져서 D263이라는 
양면 연마된 유리들이 많이 쓰입니다)에 굴절율이 서로다른 2가지 물질들을(TiO2/SiO2 혹은 Ta2O5/SiO2) 교대로 증착시켜서(30-40층)가시광선 영역은 투과하고 
근적외선 영역은 반사시키는 광학 필터를 만드는 것입니다.
평가법은 우선 투과및 반사대역이 원하는 파장대역과 맞는가 하는점과 표면에 일정크기 이상의 이물들이 없는가가 중요한 평가기준 입니다.
이렇게 제작된 필터 원판(보통 127x127 mm)을 필요한 크기로 잘라서 CCD 나 CMOS앞에 장착하게 되는 겁니다.

간단하게 규격을 정리해 보겠습니다.

*투과대역및 투과율; Tmin > 85% @ 410 - 630 nm, Tavg > 92% @ 410 - 630 nm
*반사대역 투과율 ; Tmax < 5% @ 680 - 1150 nm, Tavg < 1% @ 680 - 1150 nm
*반치점 ; T50% = 650 +/- 10 nm
*유효경내 허용이물; 10 micron 미만의것 3개이내(현재의 130만 화소제품 기준임)

점점 고화소로 가면서 특히 이물에 대한 기준이 높아지고 있습니다(궁극적으로 화소의크기와 같은 2-3 micro meter까지 될 전망입니다).

제작공정은 현재까지의 주종은 진공 chamber 를 이용하여 10E-4 ~ 10E-6 torr.
정도의 진공에서 물질들을 증발시켜서 만드는 방법이 있으며, 최근 sputter 장치를 이용하여 다층막을 만드는 방법들도 이용되고 있습니다.

더 상세한 사항들은 저의 메일로 문의해 주시면 추가로 설명해 드릴께요^^ 

디카에 UV/IR 필터가 좋은가요?
이론상으로는 아주 좋습니다.
원래 필름에 사용되는 할로겐화은은 자외선에 민감합니다.
그래서 사진발명 초기의 필름은 빨강이 검게 촬영되기도 했습니다.
기술이 발전하면서 사람눈이 느끼는 보남파초노주빨의 색상을
필름이 모두 느끼게 되었습니다. 그러나 여전히
자외선에 대한 민감함이 문제가 있어 UV필터를 
사용해서 막아주는 것이죠. 

그런데 디지털 카메라에 사용되는 CCD 나 CMOS 는 
적외선에민감합니다. 그래서 이미지 센서 앞에 보시면 녹색기가 
도는 유리가 덮혀있는데 얘가 적외선을 막아주는 역할을 합니다.
하지만 완벽하게 막아주는 카메라도 있지만 그렇지 못한 경우도 있습니다.

특별히 어떤기종이라 말씀드릴 순 없구요
캐논 1안반사식이라면 안쓰셔도 상관없습니다. 
적외선은 주로 레드채널에 기록되기 때문에
화이트 발란스가 정확히 잡혀있는데 사진이 
약간씩 붉게 나타난다면 그 필터를 사용한다면
도움이 될겁니다. 

IR필터란 가시광선은 투과시키고 적외선은 반사시켜 자연스러운 이미지를 얻게 해주는 광학부품으로 아이폰4의 카메라 모듈에 공급되고 있다.

적외선 카메라
적외선은 굴절률이 뛰어나서 투시 효과가 뛰어나서, 적외선카메라로 옷 입은 사람을 찍으면
투시효과 때문에 알몸을 찍을 수 있습니다.(적외선 투시경의 원리)
적외선 카메라는 군부대용으로 성적 문제 때문에 현재 시중에서는 특수용으로 만 판매하고 있습니다.
그러나 적외선 안경은 열 감지 효과가 뛰어나기 때문에 무엇이 잇는지 알기는 쉬우나 적외선이 반사 되더��도
우리 눈에 보이지 않기 때문에 적외선 안경을 쓰더라도 어두운 곳에서 알몸이 보이거나 물체가 보이지 ��습니다.
그 빛을 볼 수 있는 장치
CCD, CMOS
우선 모든 CCD나 CMOS는 적외선을 모두 볼 수 있다.
일반적인 카메라는 소자 앞에 적외선 차단필터를 장착해서 그것을 못 보게 하고 있다.
(투시카메라 금지를 위해) 하지만 적외선 차단 필터를 제거하면 적외선이 보인다.
단점은 어두운 곳에선 적외선이 적은 관계로 적외선을 따로 쏴 주지 않으면 거의 보이지 않습니다.
원리
적외선 차단 필터를 없애고 렌즈 앞에 가시광선 차단 필터를 끼우고
수영복을 입은 사람을 보면, 옷의 색을 나타내는 가시광선은 렌즈 앞에서 차단되고
옷을 통과해 피부에서 반사된 적외선만 감광센서에 잡혀 영상으로 나타납ㄴ디ㅏ.
적외선은
대기 중이나, 모든 사물, 물체가 띠는 '빛의 종류'이다.
가시광선 대역에서 벗어나서 사람 눈으로는 볼 수가 없다.
적외선 자체가 안 보이는 것은 볼 수 없는 빛을 적외선이라고 한다.
빛이 반사되면 물체의 색과 빛이 반사 되어 우리 눈에 들어오기 때문에 눈에 보인다.
방법
카메라렌즈에 적외선 필터를 부착하면되고.
물론 수영복을 통과해 알몸을 찍을 수는 있다.
IR-cut필터를 제거하거나 IR-cut코팅을 제거하면 ��욱 잘된다.
제거하면. 다 찍힌다.(적외선램프 켜두면 더더욱)

cf)	SelexOn CMOS센서 앞단에 부착되어 있는 Lens에도 적외선Filter 장착되어 있다
	Lens를 억지로 분해해 보니
	-	렌즈 하단에 유리재질의 Filter가 붙어 있음(650nm 이상 파장을 차단 시킴)
	-	렌즈 하단에 유리재질의 Filter를 제거하니 렌즈를 비스듬하게 보면 붉으스름하게 보이던 현상 없어 짐
	cf)	렌즈 제일 하단에 금속Ring이 있고(금색) 이것을 제거하면 바로 붉으스름한 유리재질 Filter가 붙어 있음
	
	[중요]
	1.	테스트 결과
		본 적외선Filter가 제거된 Lens만 SelexOn 카메라에 장착시켜서
		647형광Dye를(Membrane상에 647형광Dye로 Line 그음)
		아래 테스트 조건으로 촬영하니
		기존에는 전혀 보이지 않던 647형광Dye가 SelexOn CMOS Camera로 보이게 됨	
	2.	테스트 조건	
		1)	Laser set(Laser + Filter) 2개를
			피사체 사이에 양쪽으로 대칭으로 위치시키며 Laser 광원이 피사체와 45도 각도로 광원이 서로 중첩되게 비추도록 위치 시킴
			가)	Laser(QL63D5S-A, 635nm)
			나)	Laser 출력부 뒷단 Bandpass filter
				FF01-630/38-25		:	11.95mm 지름 원
		2)	SelexOn Lens 앞단 Bandpass filter
			FF01-694/44-25			:	12.50mm 지름 원
		3)	SelexOn Lens 하단에 붙어 있는 적외선 Filter 제거
			실제 Spectrometer(SM245, 분광계)로 본 적외선 Filter의 성능을 확인해 보니
			650nm이상의 광원을 차단시키는 효과가 있음(백색광원 + 본 적외선Filter 으로 분석해 보니 650nm이상의 광원을 잘라냄)
			cf)	647형광Dye의 Emission 파장이 665nm이기 때문에 본 적외선Filter를 사용하면 647형광Dye의 발색 광원을 거의 차단시키는 것임
		4)	OV7725 Image sensor, ADVFH(0x2E) Register 값 올림/변경
			가)	AECH(0x08), AEC(0x10) 값만 0xFF로(Max)로 변경시킨다고
				카메라 Bulb mode가 동작하지 않음(ex, DSLR Camera를 가지고 하늘에 있는 별빛을 환하게 찍기 위해 노출시간 늘리는 것)
			나)	이와 동시에 ADVFH(0x2E) Register 값도 올려줘야지만 카메라 Bulb mode가 동작 함
				ADVFH(0x2E), MSB of Insert Dummy Rows in Vertical Sync, 기본값(0x00)
				cf)	본 값을 많이 올려줄 수록 미세한 빛이 환하게 증가하며 이렇게해도 화질상의 Noise는 증가하지 않는 장점이 있음
					(Noise 증가로 인해 발생하는 하얀 점이 기하급수적으로 증가하지 않음, 이미지 전체적으로 부드럽게 빛의 밝기가 증가함)
					(cf,본 ADVFH(0x2E)값을 변경시키지 않고 미세한 빛을 여러번 촬영한 다음 이미지를 중첩시켜서 Sum 하는 방식을 적용하는 경우
						미세한 빛이 환하게 증가하기는 하지만 이와 동시에 Background Noise도 따라서 증가되어 화질상의 Noise가 이미지 Sum을 많이 하면 할 수록
						엄청 크게 증가 함, 하얀 점이 기하급수적으로 증가함)
		5)	OV7725 Image sensor, AWB BLUE/RED/GREEN Register 값 변경
			아래와 같이 변경시켜서 RED 파장의 광원만 Image data로 처리되도록 함(붉은 빛의 이미지)
			가)	BLUE(0x01) = 0x00, AWB-BLUE channel gain setting
			나)	RED(0x02) = 0x4B, AWB-Red channel gain setting
			다)	GREEN(0x03) = 0x00, AWB-Green channel gain setting
			
			cf)	GAIN(0x00)(AGC-Gain control gain setting, 기본값 0x00)값을 증가시키면
				미세한 빛이 환하게 증가하지만 화면Noise도 덩 달아서 증가함
				본 값을 200이상으로 셋팅하면 화면Noise가 너무 심해짐
				->	본 값은 기본값인 0x00으로 그대로 놓아둠
			cf)	GAIN은 카메라 이미지센서가 광학신호를 전기적으로 변경한 전압값을 OPAMP등으로 전기적으로 증폭시키는 것이고
				노출계수는 피사체의 광량을 카메라 이미지센서가 물리적(반도체,소자,광량)으로 받아들이는 민감도를 뜻하고
				노출시간은 피사체의 광량을 카메라 이미지센서가 물리적(반도체,소자,광량)으로 받아들여서 모아주는 시간을 뜻하는 것 같다.
	3.	노출계수(광량) vs Gain 관계
		
					|	노출계수/광량(LED)			|		Gain
		-----------------------------------------------------------------------------
		Camera		|	노출계수높임				|		Gain증가
					|	Noise 증가없이				|		Noise 함께 증가
					|	원소스 Intensity 증가		|		원소스 Intensity 증가
					|	변별력 증가, CV 개선		|		변별력 감소, CV 저하
		-----------------------------------------------------------------------------
		PhotoDiode	|	광량증가					|		Gain증가
					|	Noise 증가없이				|		Noise 함께 증가
					|	원소스 Intensity 증가		|		원소스 Intensity 증가
					|	변별력 증가, CV 개선		|		변별력 감소, CV 저하


	
	27+1)	DSLR 카메라 와 0V7725 Register 관계
			확실하지는 않고 내가 테스트 경험으로 유추한 결과
			DSLR			|	0V7725
			---------------------------------
			IS0(노출감도)	|	AEC
			S(셔터속도)		|	ADVFH
				
			cf)	LG V30 스마트폰 카메라 실제 테스트 결과
				ISO 높을 수록 감도가 높아져서 환하게 찍을 수 있지만 화면Noise 증가함
				S(셔터속도)를 증가할 수록 환하게 찍을 수 있지만 촬영시 움직이면 안됨, 흔들리면 사진이 뭉개짐(하지만 S(셔터속도)를 증가시킨다고 화면Noise가 증가하지는 않음)
				
				
				
				
				

	28)	2차함수(y=ax^2 + bx + c)에서 y,a,b,c값을 주고 x값을 얻으려면(X,Y축 반대)
		근의 공식을 이용해야 하며 아래와 같은 공식으로 구할 수 있다
		x = (-b + sqrt(b^2 - 4a(c-y))) / 2a (근의공식)
		이때, b^2 - 4a(c-y)의 값은 양수여야 하며 음수인 경우는 실수로는 값을 구할 수 없고 허수로 값이 나옮.
		cf) 이해가 잘 되게 설명하자면 근의공식의 조건 중 루트 b^ - 4ac ≥ 0 이라고 아시죠?
			이 말은 중학교과정에서 루트안에 음수가 들어갈 수 없다는 뜻이지요..
			
	28+1)2차함수(y=ax^2 + bx + c)에서 a,b,c값과 파형과의 관계
		1)	a : 값이 크면 클 수록 더 오목 or 볼록해짐
		2)	b : 파형의 기울기와 관련되어 있음		
		3)	c : 파형이 항상 본 y=c인 지점을 통과 함(x=0인 y절편값으로 무슨 경우가 있어도 x=0일 때 y값은 c 임)

	29)	Real time/Non-Real time 측정 모두, 측정 완료 후 Test band 측정 이미지를 분석 먼지&이물질에 의한 측정값이 튀는 현상이 발생한 것인지 분석
		Test band 측정 라인의 Y축 값을 분석 파형의 골이 깊고 좁은 경우 먼지&이물질로 간주함
        먼지 와 정상밴드를 구별하기 위해서 가장 중요한 사항은 Test band의 높이 방향 intensity 파형의 골의 깊이와 폭이며
		정상밴드인 경우는 intensity 파형이 거의 평탄하며 먼지가 있는 경우만 intensity 파형에 깊고 좁은 골이 발생함. 
   		1) Y축 골자기 깊이가 25이상이고(Y축 값들 중의 Peak치에서 평균값을 뺀 값) cf) 25이하인 경우는 아래 폭의 길이를 측정할 필요도 없이 먼지&이물질이 아님.
  		2) 본 Peak치가 위치한 골의 폭이 전체 대비 30%이하인 경우 먼지&이물질로 간주함
  		
  	30)	S/W 이미지 처리로 Membrane 상에 있는 먼지를 제거
  		1)	Lateral Flow 특성 상 가로 방향이 아닌 세로 방향으로 평균 필터링을 실시해서 먼지를 제거 함
  			가)	먼지로 생긴 골자기를 평균값으로 계속해서 메꾸며
  			나)	메꾼 폭이 전체 대비 50%를 넘거나 골자기 Peak값이 평균값에 98%이상 도달하면 멈춤
  			다)	이렇게 해서 먼지를 제거한 최종 Raw 측정값이 오염 정도를 결정하는
  				a)	기준값 보다 적은 경우 측정값으로(먼지를 제거한) 인정하며
  				b)	만약 기준값 보다 큰 경우에는 오염되었다는 에러 처리 함
  				cf)	상기 a)의 경우만 Test band가 아무 반응도 없는 Blank 상태에서
  					먼지가 떨어진 것을 이미지 처리로 제거한 경우 임.
  		
  		
  	31)	2012년4월25일, De-noise(0x8e)을 0x00 -> 0x0a로 변경하니 Camera capture image가 훨씬 부드러워짐, cf) 측정값 CV는 기존과 동일, cf) De-noise성능체크
		cf)	아트뷰3차샘플서부터 카메라 캡쳐시 노이즈가 상당히 많이 발생하고 있으며 1차 원인 파악으로는
			1)	이미지 센서 이외의 부품 문제라기 보다는 이미지 센서의 BGA Bonding 문제 or 이미지 센서의 LOT 특성이 아닐까 생각되고 있음
				이유 : 이미지 센서 이외의 모든 부품과 렌즈를 기존 아트뷰2차샘플로 교체해 보았지만 노이즈가 발생하는 현상은 없어지지 않음
			2)	확실한 원인 파악이 어려워서 S/W적으로 De-noise 기능을 추가 시켜서 노이즈 발생 현상을 줄이는 방안을 적용 함

	32)	Gray image
		Gray image는 R/G/B 각각의 값이 모두 같은 값을 취하기 때문에
		검정에서 회색, 흰색의 값을 표현하는 것임		
		ex)	White	:	R(255) G(255) B(255)
			Black	:	R(0) G(0) B(0)
			Gray	:	R(100) G(100) B(100)
			
	33)	SelexOn(ng/ml) vs CloverAlc(mg/dL) 측정 분해능 비교
		m(밀리): 10^-3
		n(나노): 10^-9
		d(데시): 10^-1

		200 mg/dL = 200*10^6 ng / (10^2 mL) = 200*10^4 ng/mL = 2*10^6 = 2,000,000 ng/mL
		1 mg/dL = 1*10^6 ng / (10^2 mL) = 1*10^4 ng/mL = 1*10^4 = 10,000 ng/mL
		
		-> 결론 : 측정CV를 고려한다면 SelexOn 미터기가 CloverA1c 보다 약 1,000배 분해능이 높음
			cf) SelexOn vs CloverAlc 미터기의 기본 단위를 가지고 비교한 결과 임
			cf) 참고로 CloverA1c는 기본 단위가 % 이지만 최종적으로 혈당 단위인 mg/dL를 표시하는 것이기 때문에 mg/dL 를 기본 단위로 정함

	34)	HOMA-IR
		가)	HOMA-IR = 공복인슐린(mIU/L) ×공복혈당(mmol/L) / 22.5로 계산하였다
		나)	HOMA-IR = 공복인슐린(mIU/L) ×공복혈당2(mg/dL) / 405
			논문에 보면 22.5로 나누는 계산식을 볼 수 있는데 그 때 공복혈당은 mmol/L 단위로 적용할 때이다.
			cf)	공복혈당(mmol/L) / 22.5 = 공복혈당2(mg/dL) / 405
				공복혈당(mmol/L) = 22.5 * 공복혈당2(mg/dL) / 405
								 = 공복혈당2(mg/dL) / 18


			cf)	1mmol/L = 18.018018mg/dL
				공복혈당(mmol/L) = 공복혈당2(mg/dL)
				공복혈당(18mg/dL) = 공복혈당2(mg/dL)
				공복혈당 = 1/18 x 공복혈당2

				공복혈당(mmol/L) = 1/18 x 공복혈당2(mmol/L) = 1/18 x 공복혈당2(18mg/dL) = 공복혈당2(mg/dL)

				HOMA-IR = 공복인슐린(mU/L) ×공복혈당(mmol/L) / 22.5
						= 공복인슐린(mU/L) ×공복혈당(18mg/dL) / 22.5
						= 
						= 공복인슐린(mU/L) ×1/18 x 공복혈당2(mg/dL) / 22.5 
						= 공복인슐린(mU/L) ×공복혈당2(mg/dL) / (22.5 x 18)
						= 공복인슐린(mU/L) ×공복혈당2(mg/dL) / 405

	35)	바코드스티커 인식 문제
		스트립에 붙어 있는 바코드스티커를 SelexOn 미터기에서 제대로 인식하지 못하는 문제 해결
		1)	신규용지(두껍고 배경색이 기존 보다 약간 어두움) & hs-CRP(0A0F)(회색라인 RGB:606060으로 변경)의 경우
			I01A12I0100026(Ver 1.00.02) 미터기에서 80%정도 읽지 못함
		2)	신규용지(두껍고 배경색이 기존 보다 약간 어두움) & hs-CRP(0A0F)(회색라인 RGB:707070으로 변경)의 경우 도
			I01A12I0100026(Ver 1.00.02) 미터기에서 60%정도 읽지 못함
		->	따라서, 신규용지(두껍고 배경색이 기존 보다 약간 어두움)는 사용하지 않기로 하고
			기존 PET지(비닐, 방수용지)를 계속 사용하기로 함
		2)	기존용지(PET지, 방수용지) & hs-CRP(0A01, 0A0A, 0A0D, 0A0E, 0A0F) & 0C0E, 0E0E, 100E, 120E, 320E (회색라인 RGB:707070으로 변경) 모두
			I01A12I0100026(Ver 1.00.02) 미터기에서 100% 정상적으로 읽음
		3)	바코드 회색라인의 색상이 너무 진하면 미터기가 못 읽는 경우 판별용 바코드 코드는
			->	0A0E(hs-CRP)
		4)	바코드 회색라인의 색상이 너무 연하면 미터기가 못 읽는 경우 판별용 바코드 코드는
			->	0C32(TroponinI)
			
		cf)	바코드스티커 인식 테스트용 미터기는 총4대(바코드를 잘 읽지 못하는 미터기) 있으며
			이 중 1대는 주)신광아트콤에 테스트용으로 가 있다(미터기번호 : 4/4)
			이 중 2대는 구준석 대리님한테 가 있다(미터기번호 : 1/4, 2/4)
			이 중 1대는 김범중씨한테 가 있다(미터기번호 : 3/4)
			
	36)	SelexOn 미터기 RFID 수정해서 ng/mL -> pg/mL 단위로 변경 가능함 확인의 건
		(단, RFID 센서코드식 소수점 자리수 6자리 이내 사용에 한함)

		RFID 센서코드식 소수점 자리수를 6자리 이내로 사용하는 경우에는
		SelexOn 미터기 RFID 수정해서 ng/mL -> pg/mL 단위로 변경하며
		특히, BNP의 경우도 이와 같이 변경 가능함을 알립니다.
		
		이유를 말씀 드리면 하기와 같습니다.
		1.	BNP QC Data를(2402, 2407, 2408, 2409, 240A, 2403, 2404, 240D, 240E, 240F)
			ng/mL -> pg/mL 로 전부 변경해 보니
			센서코드식 ax^2 + bx + c에서 a인자의 소수점 자리수가 6자리수를 모두 넘지 않으며
		
			Ex) BNP 240F 의 경우 센서코드식이
				1)	기존       : y = -9.33x^2 + 139.84x + 30.589
				2)	단위변경  : y = -0.000009x^2 + 0.1398x + 30.589    으로 변경되며
				이때 a인자는 -0.000009로 소수점 자리수가 6자리를 넘지 않음
				Cf) a : -9.33 / 1000000 = -0.00000933 => -0.000009
				         b : 139.84 / 1000 = 0.13984 => 0.1398
				         c : 30.589 / 1 = 30.589
		
		2.	이렇게 변경한 센서코드식을 RFID에 실제 적용해서 SelexOn 미터기에 등록 후
			제대로 "ng/mL -> pg/mL" 단위로 변경되는지 확인 한 결과
			하기와 같이 제대로 변경 가능함 확인 했습니다.
			Cf) 동일미터기, 동일기준스트립(저/중/고)으로 RFID 등록만
			    "ng/mL" vs "pg/mL" 으로 변경한 경우 측정값이 제대로
			    1000배 차이가 나는지 확인한 결과 하기와 같이 1000배 차이 남 확인 함
					동일미터기								기준스트립
											저				중				고
			RFID(ng/mL단위, CODE : 2A0F)	0.17ng/mL		0.31 ng/mL		1.37 ng/mL
			RFID(pg/mL단위, CODE : 2A0F)	184.14pg/mL		314.95 pg/mL	1374.43 pg/mL

	37)	SelexOn미터기가 외부 온도를 읽어 들이지 않고 측정값 온도보정을 할 수 있는 방법
		1)	개요
			SelexOn측정기는 센서스트립 특성 상 Patient test(미터기 내부 히팅) vs Quick test(미터기 외부에서 히팅 없이 반응)
			측정값이 최대 50% 정도 편차가 발생하는 문제가 있음
			이에, 온도보정을 실시해서 Quick test 측정값을 Patient test 측정값으로 보정시켜줘야 하는데
		2)	외부온도를 읽어들여서 온도/측정값 보정을 하는 방법은
			하기와 같은 이유로 적용하기 어려움
			->	현,SelexOn 미터기에서 FAN을 이용해서 강제로 외부공기를 빨아들여서(진공청소기 원리) 
				외부 온도를 측정하는 방식은 ex, FAN이 고장나면 외부 온도를 높게 읽어 들여
				결국, 온도/측정값 보정을 엉뚱하게 적용하게 되기 때문에 본 방식으로 사용하는 것은 위험함
		3)	Control line 측정값을 사용해서 온도/측정값 보정을 하는 방식
			가)	외부온도를 사용하지 않고 Control line값을 사용해서 온도/측정값을 보정하는 방식이기 때문에
				기구부(FAN등)를 수정하지 않고 S/W만 수정해서 온도/측정값 보정을 실시 할 수 있음
			나)	구현방법
				Test line과 마찬가지로 Control line 측정값도 온도에 따라서 측정값이 변하는 원리를 이용
				a)	Control line 을 항상 측정값이 일정하게 나오도록 생산(ex, 오늘/일년후...)
				b)	Control line 측정값이 온도에 따라서 변하기 때문에
					Control line 측정값을 가지고 현재 온도를 유추할 수 있음
			다)	예제1)
				온도/측정값 보정식 적용 전 Test측정값			
				농도	저온	상온	고온
						9℃		25℃	32℃
				0		0.0 	0.0 	0.0 
				저		2.2 	3.8 	5.3 
				중		4.5 	7.5 	9.4 
				고		8.2 	15.5 	16.6 
				
				1번)	고온을 기준값으로 한 저온 상관식을 구함, X축:저온(0.0, 2.2, 4.5, 8.2), Y축:고온(0.0, 5.3, 9.4, 16.6)
						y = 2.0587x
				2번)	고온을 기준값으로 한 상온 상관식을 구함, X축:상온(0.0, 3.8, 7.5, 15.5), Y축:고온(0.0, 5.3, 9.4, 16.6)
						y = 1.119x
				3번)	고온을 기준값으로 한 고온 상관식을 구함, X축:상온(0.0, 5.3, 9.4, 16.6), Y축:고온(0.0, 5.3, 9.4, 16.6)
						y = x
				4번)	Control측정값	온도	
						2				9	
						10				25	
						20				32								
						cf) Control측정값을 가지고 현재 온도 유추		
						
						Control측정값과 온도와의 상관식을 구함, X축:Control측정값, Y축:온도
						y = -0.0722x2 + 2.8667x + 3.5556
				5번)	온도		기울기(1번/2번/3번)
						0			0
						9.000002	2.0587
						25.000026	1.119
						32.000096	1
				6번)	상기 5번) data를 가지고 온도와 기울기간의 상관성을 구함, X축:온도, Y축:기울기
						y = 0.0018x2 - 0.1204x + 2.9955
						
				7번)	온도/측정값 보정식 적용 후 Test측정값			
						농도	저온	상온	고온
						저		4.5 	4.3 	5.3 
						중		9.3 	8.4 	9.4 
						고		16.9 	17.3 	16.6 
						
						z = (0.0018x2 - 0.1204x + 2.9955)*y
						z = 온도/측정값 보정식 적용 후 Test측정값
						x = 온도(현재)
						y = 온도/측정값 보정식 적용 전 Test측정값
						
						ex)	4.5		= (0.0018*9.000002*9.000002 - 0.1204*9.000002 + 2.9955)*2.2
							9.3		= (0.0018*9.000002*9.000002 - 0.1204*9.000002 + 2.9955)*4.5
							16.9	= (0.0018*9.000002*9.000002 - 0.1204*9.000002 + 2.9955)*8.2
							16.6	= (0.0018*32.000096*32.000096 - 0.1204*32.000096 + 2.9955)*16.6	
		cf)	Control line 까지 혈액이 올라가는 시간을 가지고 온도/측정값 보정을 하는 방식
			가)	혈액이 올라가는 시작 순간 부터(Test 측정값이 살짝 올라가는 순간)
				Control 측정값이 살짝 올라가는 순간 사이의 시간을 가지고
				외부온도를 유추해서 온도/측정값을 보정하는 방식
				cf)	온도가 추울 수록 Control 측정값이 살짝 올라가는 순간까지의 시간이 느려진다는 가정하에 본 보정식을 사용할 수 있음
					하지만 헤마토크립 때문에 시간이 느려질 수도 있고 아니면 Membrane/습도 등이 건조해서 느려질 수도 있기 때문에
					본 이론을 가지고 온도/측정값 보정하기 힘들 것 같다.

	38)	광량보정 에러 해결 방안
		마스터 미터기로 1년 이상 사용한 미터기에서 Patient test 측정 시 광량보정에러가 발생하고 있으며(1대/12대중) 이를 해결하고자
		경우1/미터기1)	LED 2개를 모두 새것으로 변경해 보았지만 해결되지 않아서
						카메라 모듈을 새것으로 변경하니 본 광량보정에러가 해결 됨
		경우2/미터기2)	단지, LED 1개만 새것으로 변경했는데도 본 광량보정에라가 해결 됨
		
	39)	Camera preview 영상이 물결 모양
		이상하게 Camera preview 영상이 물결 모양으로 흔들리는 현상이 발생한 적이 있으며
		원인 파악 결과, 어처구니 없게 Camera cable 불량으로 이런 현상이 발생한 것이었다. 

	40)	Camera preview 컬러 영상 보기 & 저장
		SelexOn source -> Control_DetectorDriver.cpp -> bool OV7725_EU725M_Init(bool bDataVerify) 함수 내용 중
		1. {0x12, 0x02}, -> {0x12, 0x00} 으로 변경하면
			1)	Camera preview 영상이 LCD 상에서 컬러로 정상적으로 보이지만
			2)	110114_LFI_Analysis_project_GRB422_Ggray_SelexOn -> CardiacDiagnosis_rev0.201(SelexOn_Color save).exe로 저장하면
				엉뚱한 색상으로 저장 됨(청색은 주황색, 녹색은 갈색, 빨간색은 청색, 주황색은 하늘색, 노랑색은 청녹색으로 엉뚱하게 저장됨)\		
		2.	기존 {0x12, 0x02}로 설정하면
			1)	Camera preview 영상이 LCD 상에 엉뚱하게 보이지만
				(청색은 빨간색, 녹색은 연녹색, 빨간색은 청색, 주황색은 하늘색, 노랑색은 연녹색으로 보임)
			2)	110114_LFI_Analysis_project_GRB422_Ggray_SelexOn -> CardiacDiagnosis_rev0.201(SelexOn_Color save).exe로 저장하면
				정상적인 색상으로 저장 됨	
		3.	아래 소스를 SelexOn source -> Control_DetectorDriver.cpp -> bool OV7725_EU725M_Init(bool bDataVerify) 함수에 넣으면
			임의의 카메라 Register(Address & Data)를 변경할 수 있음
			// 카메라 Register Control(Address : 0xXX, Data : 0xXX) 조절
			#if 1
			static int nValue4 = 0, nValue5 = 0;
			char getChar4[32] = {0}, getChar5[32] = {0};
			
			LFIDataPrint(DATA_PRINT_LEVEL, "\r\nEnter Address(000~255, Default:000)\r\n");
			EXT_UART_Reads(UART0, 115200, getChar4, 3);
			LFIDataPrint(DATA_PRINT_LEVEL, "\r\nEnter Data(000~255, Default:000)\r\n");
			EXT_UART_Reads(UART0, 115200, getChar5, 3);
			nValue4 = atoi(getChar4);
			nValue5 = atoi(getChar5);	
		
			MP4_DebugPrintF2(PLEVEL, "Address = 0x%x, Data = 0x%x\r\n", nValue4, nValue5);
			EXT_I2C_Write2(SENSOR_DEVICE_ID, nValue4, nValue5);
			#endif
		4.	카메라 영상과 Gray / Color 영상 처리 관계
			카메라 영상은 Camera register 0x12의 값을 {0x12, 0x02}으로 설정하면 YUV가 아닌 RGB로 처리되기 때문에
			1)	LCD Preview 영상으로 보면 엉뚱한 색상으로 보이지만(LCD는 YUV format 순서로 입력/처리하기 때문에)
			2)	실제 110114_LFI_Analysis_project_GRB422_Ggray_SelexOn -> CardiacDiagnosis_rev0.201(SelexOn_Color save).exe로 저장하면
				정상적인 컬러 색상으로 저장되는 것임
				이때, 정상적인 컬러 색상으로 저장하기 위해서는 하기 가)~나)를 꼭 적용시켜야함
				가)	SelexOn meter -> PC 로 전송할 때
					Run_PCInterface.cpp -> bool DoCapture(CControlLfiDetector* pControlLfiDetector) 함수를
					default 소스가 아닌 GRB422 Color 전송으로(G:8bit(1byte) + R:8bit(1byte) or G:8bit(1byte) + B:8bit(1byte))
					변경시켜서 PC로 전송시키고
				나)	PC(CardiacDiagnosis_rev0.201(SelexOn_Color save).exe)에서도
					GRB422 Color format(G:8bit(1byte) + R:8bit(1byte) or G:8bit(1byte) + B:8bit(1byte))으로 받아서
					처리해야지만 정상적인 컬러 색상으로 처리될 수 있음
				cf)	Gray / Color 영상 처리 방법은
					카메라 영상은 똑같은 신호/DATA인데
					(Camera register 0x12의 값을 {0x12, 0x02}으로 처리해서 RGB 형식의 GRB4:2:2 Format으로 처리
					 ; G:8bit(1byte) + R:8bit(1byte) or G:8bit(1byte) + B:8bit(1byte))
					이를 SelexOn meter -> PC로 전송 -> PC Program에서 처리할 때
					Original신호인 G:8bit(1byte) + R:8bit(1byte) or G:8bit(1byte) + B:8bit(1byte)을 그대로 전송/처리하면 Color 영상 처리
					Original신호 중 RED와 Blue만 뺀 G:8bit(1byte) + G:8bit(1byte)만을 전송시켜서 처리하면 Gray 영상으로 처리되는 것임

[42]	Embedded 에서 SDRAM과 NOR Flash 와의 관계
	가) SDRAM용량은 NOR Flash용량 보다 더 크거나 최소한 같아야 한다.
		이유는, CPU가 실제 프로그램 실행시에는 NOR Flash에 들어 있는 code를 SDRAM으로 모두 복사한 다음
		SDRAM에서 실행하기 때문에 SDRAM용량이 당연히 커야 되는 것임


[42+1]	NOR Flash Writing 할려면 지우고 써야 한다.
       플래시를 읽는것은 메모리와 같지만 쓸경우는 다음과 같은 흐름으로 쓰게된다.
       영역지우기(block erase) -> 쓰기(writing) -> 데이타고정(fusing or programing)
       그리고 지우기시 시간은 대략 1초 ~ 5초이며 퓨징시간은 200uSec~600uSec가 소요된다.    

   여담1)
   		NOR Flash Writing은 1 -> 0으로 만 바꿀 수 있다( 0 -> 1로 바꿀 수는 없다)
		따라서, 0 -> 1로 바꿀려면 Erase 명령을 사용해야지만 된다.
   여담2)
       플래시를 지우면 모든 데이타는 0xFF로 변경된다.
       그럼 0xFF 를 쓰면 되겠구나 하겠지만 다음과 같은 성질이 있다.
       0xff 에 0xa0 를 썼다면 0xa0가 된다.
       0x00 에 0xa0 를 썼다면 0x00가 된다. 
       즉 1은 0으로 바뀌지만 0은 결코 1이 될수 없는 것이다.
       따라서, 0xff로 데이터를 writing할 수는 없고 erase를 통해서만 0xff로 바꿀 수 있는 것이다.
       이런 상황을 고려해서 데이터를 writing할려면 먼저 erase로 데이터를 지우고(0xff로 만듦)
       데이터를 writing해야 한다.
       0x0f 라고 쓰인 곳에 0x03 을 쓰면 0x03 이된다. 이런특성을 이용하여 코딩하면 좀더 빠른 수행을 할수 있다.




[43]	Virtual Address/ Physical Address
	Virtual Address		Physical Address	Size
	0x80000000			0x00000000			64		// BANK_A
	0x90C00000			0xAC000000			1		// NAND Flash
	풀어서 설명하면 물리주소 0에 있는 64M짜리 메모리는 가상주소인 0x80000000에 매핑하여 사용하겠다는 말입니다.
	또한 0xAC000000	에 있는 NAND Flash RegisterSet은 0x90C00000에다 매핑하여 사용하겠다는 말이구요.
	WinCE 프로그래머는 커널이 올라간 상태에서는 저 가상주소를 사용해서 물리주소에 쓰고읽고를 하게 됩니다.
	cf) OS가 동작할 때 프로그래머가 직접 메모리의 물리주소에 접근을 할 수 없고 가상메모리에 접근해야 함


		
		
[44]	TortoiseSVN 사용 방법
	여러명이 서버를 통해서 소스를 서로 수정/공유하는 프로그램으로 사용 방법은 다음과 같음
	1)	SVN_LFI_Reader_Project와 서버에 저장되어 있는 소스를 비교, 수정사항 확인
		SVN_LFI_Reader_Project(개인SVN소스저장폴더) -> 오른쪽마우스버튼 -> TortoiseSVN -> 수정사항확인 -> 저장소확인
	2)	SVN_LFI_Reader_Project 폴더에서 수정하고 싶은 파일 수정
	3)	수정한 파일 서버로 올림
		수정한 파일 -> 오른쪽마우스버튼 -> SVN 커밋
	cf)	SVN 업데이트(익스포트)	: 서버 -> 개인SVN소스저장 폴더로 소스 내림(수정된 사항만)
		SVN 커밋(임포트)		: 개인SVN소스저장 폴더의 파일 -> 서버로 소스 올림(수정된 사항만)
	4)	개인SVN소스저장 폴더 & SVN 서버 모두 완전히 지운 다음에 Update시키는 방법
		가) 개인SVN소스저장 폴더 & SVN 서버를 모두 지움
		나) 개인SVN소스저장 폴더에 복사 하고 싶은 소스 복사한 다음
			개인SVN소스저장 폴더 -> 오른쪽 마우스 -> TortoiseSVN -> 임포트 명령을 실행시켜서 SVN 서버로 개인SVN소스저장 폴더에 있는
			내용을 모두 넣음
		다)	기존 개인SVN소스저장 폴더에 있는 내용을 모두 삭제한 다음
		라)	개인SVN소스저장 폴더 -> 오른쪽 마우스 -> SVN체크아웃 을 눌러서 SVN 서버에 있는 모든 내용을
			개인SVN소스저장 폴더로 복사함




[45]	Clover A1c
	1)	기준카트리지 개념
		2개의 카트리지를 제작해야 하고
		1개는 밝은빨간색 아크릴판 카트리지(피 넣고서 2분)
		1개는 아이보리색 아크릴판 카트리지(피 넣고서 5분)
		를 만들어서 측정하며 본 측정값은 Master 미터기건 어떤 미터기건 간에
		동일한 값을 나타내야 함(오래된 미터기도)
		cf)	Blue cartridge 값으로는 기준카트리지가 될 수 없는 것은
			Blue cartridge 값은 마스터 미터기로 측정해도 값이
			10개월 후에 8%정도 변하기 때문임
			|-> Blue cartridge 값이 변해도 측정값은 변하지 않는 이유는
				Clover A1c 계산식이 K-S식이기 때문




[46]	DB Program이 없는 경우에 Sort기능 구현
	1)	8자리 ID를 Sort한다면
		가)	해시테이블
		0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
		303132333435363738394041424344454647484950515253545556575859606162636465
		나)	ex1) abcdefg0 -> 4041424344454630 -> long으로 처리
			ex2) abcdefg1 -> 4041424344454631 -> long으로 처리
		다)	long 숫자로 생각해서 비교하면 ex1) 이 ex2) 보다 작기 때문에
			본, 원리를 사용해서 Sort기능을 구현할 수 있음




[47]	Windows CE 5.0 Core/Professional/Professional Plus 비교
1) Windows CE 5.0 Core
- 저렴한 가격(소비자가격 U$3)
- 대상제품: Gateway, Entry-level VoIP 폰, 산업자동화기기 등의 저렴한 디바이스 및 CD
- 플레이어, 디지털카메라, 네트워크 기반의 DVD 플레이어 등과 같은 가전 디바이스  
 
2) Windows CE 5.0 Professional
- 윈도우 메신저, 워드패드, 원격 데스크탑 프로토콜, 인터넷 익스플로러 6.0 등의 추가적인
- 어플리케이션 및서비스 제공  
 
3) Windows CE 5.0 Professional Plus 
- 워드 패드 및 파일 뷰어(MS 오피스 문서 및 어도비 아크로배트, 이미지 파일 등)제공




[47+1]	Windows CE에서 MFC 사용하기
	1)	Visual Studio 2008 환경
		가)	Visual Studio 2008 설치
		나)	Visual Studio 2008 Update for Windows Embedded Compact 7 등 설치
		다)	Visual Studio 2008 실행
			파일 -> 프로젝트 -> Visual C++ -> 스마트장치 -> MFC 스마트 장치 응용 프로그램 실행
	2)	OS(Windows CE .NET 4.2) 환경
		가)	Windows CE .NET 4.2 설치
		나)	Tool(eMbedded Visual C++ 4.0) 등 설치
		다)	Tool(eMbedded Visual C++ 4.0) 실행
			File -> New -> WCE MFC AppWizard (exe) 선택
		



[48]	Flash GUI
	1)	주)아트뷰 에서 Flash를 사용했는지는 몰라도 3D icon으로 동작하도록 Embedded 기기 양산하고 있음
	2)	Adobe, Flash lite(PC환경의 Flash를 임베디드 시스템에서 동작하도록 기능을 줄인 것)
	3)	주)마이크로소프트에서 WindowsCE에서 Flash lite를 사용할 수 있도록 Adobe와 계약을 체결했다고 함
	4)	주)디지탈아리아	안드로이드 기반의 3D-GUI를 LG에 납품
		또한 본 업체는 3D GUI를 OS : Android/ Linux/ Windows Mobile/ WinCE에서도 구현할 수 있는 솔루션 가지고 있음
		GUI미들웨어 솔루션으로 OpenGL|ES 2.0 등 지원




[49]	사이버 주치의 Spot Analyzer 측정 알고리즘
	1)	알고리즘1차
		가)	4각형 측정 영역을 지정할 센터 지점을 선택(-> 사용자 설정)
		나)	4각형 측정 영역 안에서 최대값 지점을 자동으로 찾은 다음(-> 프로그램)
		다)	본, 센터 지점을 기준으로 4각형 측정연산 영역을 만들고(-> 프로그램)
		라)	본, 영역 안의 Digit값 총합을 측정값으로 출력(-> 프로그램)
	2)	알고리즘2차(생명공학연구원 요구사항)
		가)	4각형 측정 영역을 지정(-> 사용자 설정)
		나)	4각형 측정 영역 안에 있는 모든 픽셀값(흑/백)을
			Sum하며 본, 값이 출력값이 됨(-> 프로그램)




[50]	VR3511F Spec.
	1)	Normally GPIO PADs are in GPIO Input state in power on Reset




[51]	월별 날짜 계산
re: 2월은 왜 28일이나 29일까지밖에 없나요..? HH(00iioo) 답변채택률69% 2009.01.06 22:02 답변 추천하기 5 5 마이지식 > 내 추천지식에 
7일간 보관됩니다.
마이지식 확인하기 

 질문자 인사참 좋은 답변 감사합니다. 근데 참 기네요.. ㅋㄷㅋㄷ
1년 열두달 중 가장 작은 달은 2월이다. 다른 달들은 30일 아니면 31일로 돼있는데 2월은 28일, 윤년이 돌아와도 29일 밖에 안된다. 여러 달 가운데 하필 2월이 가장 짧은 것은 왜일까.
[로마인들이 쓰던 달력은 처음엔 March(1월)부터 December(10월)까지 달 이름이 10개 밖에 없었다. 11월과 12월에 해당하는 두 달은 이름조차 없이 무시됐지만, 그 기간이 농한기이기 때문에 로마인들은 별로 불편해하지 않았다. 기원전 8세기경 누마 폼필리우스 왕은 제대로 된 달력의 필요성을 느끼고 새 달력을 고안했다.
누마는 1년을 355일로 정했다. 달의 움직임에 맞춘 것이었다. 누마는 비어있는 11월과 12월 자리에 January와 February의 두 달을 추가해 열두달 체제를 만들었다. 로마인들은 짝수를 불행한 숫자라고 믿었으므로, 누마는 열두달 중 일곱 달은 각각 31일, 네달은 각각 29일로 정했다. 그러다보니 1년 355일을 채우려면 어쩔 수 없이 28일 짜리 짝수 달이 하나 필요해졌다. 누마는 1년의 마지막 달이자 한겨울에 속해있는 February를 그 달로 선택했다. January와 February가 한해의 시작인 1, 2월의 이름으로 바뀐 것은 그로부터 수세기가 흐른 뒤의 일이다.
일설에는 로마인들이 원래 30일로 돼있던 8월을 31일로 늘리기 위해 2월에서 하루를 빼내가는 바람에 2월이 작아졌다는 얘기가 있다. 아우구스트 황제를 따 이름지은 8월(August)이 30일 밖에 안되는 것을 불경스럽게 여겼기 때문이라는 설명인데, 그다지 신빙성은 없다. February의 유래와 변천에 대해서는 몇가지 설들이 더 있으나, 한가지 분명한 것은 그 짧은 달을 로마인들이 매우 탐탁지 않게 생각했다는 사실이다.]
 
1년 12달중에서
11달을
31일짜리 7달(1, 3, 5, 7, 8, 10, 12월),

30일짜리 4달(4, 6, 9, 11월)로 정해놓고(이렇게 하면 11달 합계 ; 337일)
나머지 1달(2월달)을 28일로 하면 365일, 29일로 하면 366일이됩니다.

1년은 지구가 태양을 한 바퀴도는데(공전) 걸리는 시간입니다.
그 시간은 365.2422일인데 3년 동안은 365일(평년이라함)로 하고, 1년은 366일(윤년이라함)로 해서 평균 대략 365.24일이 되게 합니다.
그렇게 해도 남는 시간(日갯수)은 윤년(366일)이 되어야 할 해를 평년(365일)으로 해서 맞춥니다.(400년에 3번)
------------------------------------------------------------------------
* 1년, 1일
1년은 태양을 중심으로 한 지구의 공전, 1일은 지구의 자전 시간이 기준이 된 것이다. 1분 은 60초, 1시간은 60분 바빌로니아인들은 60을 마법의 숫자라고 생각했던 것 같다. 60의 수는 분수개념이 없었던 당시로서는 2, 3, 4, 5, 6, 10, 12, 15, 20, 30이라는 더 작은 여러 수로 딱 나눌 수 있는 놀라운 수였기 때문인 듯하다.

* 1일은 24시간
고대부터 천문학이 발달한 이집트인들이 종교의식에 연유하여 밤이 되면 12개의 밝은 별이 연속적으로 떠오르는 것을 점성술사들이 발견해서 밤을 12등분 했고 그것과 대칭으로 낮도 12등분 했습니다. 그렇게 하여 지금의 24시간이 된 것입니다.

* 1주일은 7일
고대로부터 태양계내의 천체 중에는 육안으로 확인 가능한 것이 태양과 달 그리고 5개의 행성으로 고대천문학자나 점성가들은 이를 매우 신성시 한 것에서 유래한 듯하다. 고대 바빌로니아인과 유대인의 종교의식에서 7일의 단위를 사용하였으나 현재 1주일이 7일이 된 것은 고대 이집트인들이 각 날을 태양과 달, 그리고 다섯개의 행성의 이름을 붙여 사용한 것이 A.D. 4세기 무렵 로마인들에게 전해져 기독교를 통해 현재에 이르게 되었다.

* 1개월은 30일이나 31일, 2월은 28일(평년) 또는 29일(윤년)
태양력의 달력 체계 중에서 가장 엉망인데 로마 황제들의 탓도 있고 1년 365일을 12로 나누다보니 꼭 맞게 나누어지지 않은 탓도 있다. 따라서 태양력에서의 한 달의 길이는 천문현상과는 무관하게 정해졌다. 원래 태음력에서의 한 달은 천문현상과 관계가 있는데 그 길이는 보름달에서 다시 보름달로 가는데 걸리는 시간인 29.5일이다. 그래서 음력에서는 한달을 29일과 30일을 교차하여 사용하고 있다.



		
[52]	VBA
1)	DRM으로 암호화된 Excel 파일 중, 한개 Sheet 전체를 파일 복사해서 암호되지 않은 새로운 Excel 파일로 만드는 방법

아래 내용을 암호해제 하고자 하는 Sheet에 복사 하고서 실행하면 됨. 

Sub test()

        Set NewBook = Workbooks.Add
            With NewBook
'                .Title = "title01"
'                .Subject = "Subject01"
                .SaveAs Filename:=ThisWorkbook.Path & "\" & "fanny.xl"
            End With
        
        Cells.Copy
        
        Windows("fanny.xl").Activate
        Sheets("Sheet1").Activate
        ActiveSheet.Paste
         
'       Windows("c:\fanny.xls").Activate
        ActiveWorkbook.Save
        ActiveWindow.Close


End Sub

2)	DRM으로 암호화된 Excel 파일 중, 한개 Sheet의 일정 부분을(ex. 가로) 복사해서 새로운 Excel 파일의 특정 부분(ex. 세로로)에 복사하는 방법

아래 내용을 암호해제 하고자 하는 Sheet에 복사 하고서 실행하면 됨. 

Sub test()

    'Add, 간이RFID인코딩장비용 개별 Excel file 자동 생성
    Application.DisplayAlerts = False                       ' 질문/경고 표시가 나타나지 않게

    Set NewBook = Workbooks.Add                             ' 새로운 문서를 만듦
        With NewBook
        .SaveAs Filename:=ThisWorkbook.Path & "\" & "Myoglobin.xlsx"                    ' ThisWorkbook.Path -> 원본 파일이 위치한 경로
    End With


    Dim m_SourceRange As Range
    Dim m_TargetRange As Range

    Set m_SourceRange = Sheet11.Range("K3:K67")             ' Range("K3:K67") == 65개

    Windows("Myoglobin.xlsx").Activate
    Sheets("Sheet1").Activate

    Set m_TargetRange = ActiveSheet.Range("A3:BZ3")         ' Range("A3:BZ3") == 76개(상기 65개 보다 충분히 크게)
    m_TargetRange.NumberFormatLocal = "@"                   ' 표시 형식을 텍스트 형식으로 지정(숫자 형식으로 지정되면 데이터가 변하게 되므로)

    m_TargetRange.Value = Application.WorksheetFunction.Transpose(m_SourceRange.Value)  ' 세로줄 데이터를 가로줄로 복사

    ActiveWorkbook.Save
    ActiveWindow.Close

    Application.DisplayAlerts = True
    'Add

End Sub

3)	기본문법
	가)	:=
		->	이름별로 인수를 지정하려면 인수 이름, 콜론, 등호(:=), 인수 값을 차례로 사용하십시오
			EX) :MsgBox Title:="대답 상자", Prompt:="정답입니다!"	

셀 다루기1 (Range 개체)
미래를 위한 一步/VBA 2012/02/29 17:18 

1.    Range, Select
	        Range(“A10”).Select
	2)     Range(“A1:A10”).Select
	3)     Cells(5,7).Select
	4)     Range(“Cells(1,1),Cells(10,2)).Select

2.     Activate, ActiveCell, Selection, Value
	1)     Range(“C6”).Activate
		①     선택한 범위가 있을 경우 선택 범위 안에서 이동한다.
	2)     ActiveCell.Value = 값
		①     현재 활성화된 셀에 값 입력
	3)     Selection.Value = 값
		①     선택 되어있는 셀 범위에 값 입력

3.     Formula
	1)     Range(“B5”).Formula = “ =100+200+300”
	2)     Cells(3,2).Formula = “ =Sum(A1:A10)”
		①     셀에 값이 아닌 수식으로 저장

4.     Clear, ClearContents, ClearFormats, ClearComments
	1)     Range(“A1:A30”).Clear
		①     셀 범위에 입력된 값을 모두 삭제
	2)     Cells(4,6).ClearContents
		①     셀에 입력된 값만 삭제
	3)     Range(“A1:A30”).ClearFormats
		①     셀 범위에 입력된 서식만 삭제
	4)     Cells(4,6).ClearComments
		①     셀에 입력된 메모만 삭제

5.     AddComment
	1)     Range(“A30”).AddComment “메시지”
		①     A30셀에 메모를 삽입

6.     Merge, UnMerge
	1)     Range(“C4:C7”).Merge
		①     셀 영역을 하나로 합침
	2)     Cells(2,3).UnMerge
		①     병합된 셀 영역을 해제
	
7.     Insert, Delete
	1)     Range(“C5”).Insert(xlShiftToRight)
		①     C5셀에 빈 셀을 삽입하고 기존 셀들을 오른쪽으로 이동
		②     xlShiftDown : 기존 셀들을 아래로 이동
	2)     Cells(3,2).Delete(xlShiftUp)
		①     B3셀을 삭제하고 기존 셀들을 위쪽으로 이동
		②     xlShiftToLeft : 기존 셀들을 왼쪽으로 이동

8.     Copy, Paste, Cut
	1)     Range(“B3:D5”).Copy
		①     셀 영역을 복사하여 클립 보드에 저장
	2)  Cells(10,2).Select
		ActiveSheet.Paste
		①     클립 보드에 저장되어 있는 데이터를 붙여 넣는다.
		②     Range(“B10”).Paste, Selection.Paste, ActiveCells.Paste는 오류를 발생 시킨다.
	3)     Range(“B3:D5”).Copy Range(“F3”)
		①     B3:D5셀 영역을 복사하여 F3셀에 붙여 넣는다.

	4)     Range(“B3:D5”).Cut
		①     셀 영역을 잘라내어 클립보드에 저장

9.     PasteSpecial
	대상.PasteSpecial(Paste, Operation. SkipBlanks,Transpose)
	1)     Paste
		①  Range("a10").PasteSpecial Paste:=xlPasteAll
			Range("a10").PasteSpecial xlPasteAll
			i.       A10셀에 복사한 내용을 그대로 붙여 넣는다.
		②     Paste 복사 유형
			i.       xlPasteAll : 동일한 상태로 복사(기본값)
			ii.      xlPasteAllExceptBorders : 테두리만 제외하고 복사
			iii.     xlPasteColumnWidths : 열 너비 복사
			iv.     xlPasteComments : 메모 복사
			v.      xlPasteFormasts : 서식 복사
			vi.     xlPasteFormulas : 수식 복사
			vii.    xlPasteFormulasAndNumberFormats : 서식 및 숫자 서식
			viii.   xlPasteValidation : 유효성 검사 복사
			ix.     xlPasteValues : 값 복사
			x.      xlValuesAndNumberFormats : 값 및 숫자 서식
	2)     Operation
		①  Range("a10").PasteSpecial Operation:=xlPasteSpecialOperationAdd
			Range("a10").PasteSpecial ,xlPasteSpecialOperationAdd
			i.       A10셀에 복사한 내용을 기존 셀에 더한 값과 더한 결과를 붙여 넣는다.
		②     Operation 연산 유형
			i.       xlPasteSpecialOperationAdd : 값을 더해서 붙여 넣는다.
			ii.      xlPasteSpecialOperationDivide : 값을 나눠서 붙여 넣는다.
			iii.     xlPasteSpecialOperationMultiply : 값을 곱해서 붙여 넣는다.
			iv.     xlPasteSpecialOperationNone : 값을 덮어 쓴다.(기본값)
			v.      xlPasteSpecialOperationSubtract : 값을 뺀 결과를 붙여 넣는다.
	3)     SkipBlanks 선택
		 Variant True이면 클립보드의 범위에 있는 빈 셀은 대상 범위로 붙여 넣지 않습니다. 기본값은 False입니다.
 	4)     Transpose
		①  Range(“F3”).PasteSpecial Transpose:=True
			Range(“F3”).PasteSpecial , , , True
			i.       행과 열을 바꿔 붙여 넣는다.
		②     Transpose 행/열 바꿈 여부
			i.       True : 행과 열을 바꿔 붙여 넣는다.
			ii.      False : 원래 상태로 붙여 넣는다.(기본값)




[52+1]	Excel, 엑셀 명령어
1.	MATCH	함수
	값을 영역에서 찾아 몇 번재 위치인지를 표시한다.
	MATCH(찾는값, 영역, 옵션)
	cf)	옵션
		0	:	찾는 값과 일치하는 것을 찾음
		1	:	작거나 같은 값 중 최대값을 찾음
		-1	:	크거나 같은 값 중 최소값을 찾음
	ex)	=MATCH("Z", E:E, 0)
		->	E:E 열 내에서 "Z"문자가 위치한 행의 값 출력		
	ex)	= INDEX(B3:G8, MATCH(LARGE(G3:G8,2), G3:G8, 0), 3)
		->	G3:G8에서 2번째로 큰 수가 G3:G8에서 몇번째 행인지 찾고
			그 행과 B3:G8내에서 3번째열이 만나는 위치의 값을 표시하라
	ex)	= INDEX(B3:G8, MATCH(MIN(G3:G8), G3:G8, 0), 1)
		->	G3:G8에서 가장 작은 수가 G3:G8에서 몇번째 행인지 찾고
			그 행과 B3:G8내에서 1번째열이 만나는 위치의 값을 표시하라
2.	INDEX(범위, 행번호, 열번호)
	범위에서 "행번호" 번째 행과 "열번호"번째 열에 있는 셀의 값을 구합니다.
	ex)	=INDEX(B:B, N9+1, 1)
		->	B:B영역에서 2번째 행과 1번째 열에 있는 값을 출력
3.	Excel 숫자 앞에 "0x" 문자 추가하고 0문자로 채우기
	예제)
	B	C	D
	13	10	0x0A = "0x" & REPT("0", 2-LEN(DEC2HEX(B13)))&DEC2HEX(B13)
4.	Excel 숫자 앞에 '0' or 문자로 채우기
	Excel 작업을 하다보면 숫자 앞에 '0(zero)'을 붙여 고정길이 문자열로 표현하고 싶을 때가 있다.
	'0'을 붙이는 것은 TEXT 함수를 이용하면 간단하게 해결할 수 있고,
	그 외의 문자나 특수문자를 붙이고 싶은 경우에는 REPT 함수를 이용하면 된다.

	조건					표시값1		표시값2		표시값3		셀서식/함수
	셀에 입력된 값			  1234		 12345		123456		[일반]
	'0'으로 채움(TEXT함수)	001234		012345		123456		=TEXT(C5, "000000")
	'0'으로 채움(REPT함수)	001234		012345		123456		=REPT("0",6-LEN(C5))&C5
	'*'으로 채움(REPT함수)	**1234		*12345		123456		=REPT("*",6-LEN(C5))&C5


[52+2]	바코드 리더기
	바코드 라인 자체에 체크디지트(검증문자) 영역이 따로 있어서
	바코드 라인이 오염 등으로 회손된 경우 바코드 리더기가 아예 바코드를 읽지 못하는 기능이 있다
	참고로, 본 기능의 Enable/Disable은 바코드 리더기 자체에서 결정하는 것이 아니고
	바코드 라인(프린터 물) 을 만들 때 넣어 줄 수도 있고 아닐 수도 있음.




[53]	USB 디바이스 통신
1)USB 디바이스와 통신하기 위한 어플리케이션 작성  C/C++/VC++  2008/09/01 21:29
 http://blog.naver.com/picbuddy/80055540180 
첨부파일 (2) 

http://www.muosys.com/bbs/view.php?id=D12lecture&page=1&sn1=&divpage=1&sn=off&ss=on&sc=on&select_arrange=headnum&desc=asc&no=19

이번엔 어플리케이션에서 어떻게 드라이버를 통해 디바이스와 통신하는지를 살펴보자.
이 강좌를 따라올 정도의 행자들이라면
당근빠따 컴퓨터의 COM 포트를 통해 RS232포트를 가진 디바이스와 통신한 경험이 있을 게다.
그 때 어찌 하셨나?
하이퍼터미널 같은 터미널 프로그램을 이용해서 했지요. 라고 대답 하면 본좌 대략 난감하다.
그런 하이퍼터미널 같은 어플리케이션이 어떻게 디바이스와 통신하는지를 물어본 거시기 때문이다.

뭐 별거 있나?
CreateFile로 디바이스의 Handle을 얻어온 후,
그 핸들을 함수인자로 주어 ReadFile, WriteFile, DeviceIoCtl로 디바이스에 접근하면 된다.
작업이 끝났다면 당빠 CloseFile을 호출 해 Handle을 반환하면 되고 말이다.
 
Application <-> Device Driver <-> Device 로 이어지는 명령전달 라인을 아주 간략히 설명해 보자.
먼저 어플리케이션에서 위의 함수들을 호출하면
그럼 운영체제의 I/O Manager란 것이
운영체제의 일부인 디바이스 드라이버 모듈을 호출해서 일을 처리하게 하고,
최종적으로 디바이스 드라이버는 디바이스에게 일을 시킨다.

그럼 어플리케이션에서 USB 디바이스에게
데이터를 주고 받는 등의 작업을 시키려면 필요한 게 뭘까?

우선 CreateFile로 디바이스의 Handle을 얻어오기 위해서는
그 디바이스를 직접 컨트롤 할 드라이버의 "이름"이 필요하다.

그리고, ReadFile, WriteFile, DeviceIoCtl을 써서 
USB 디바이스에게 구체적인 작업지시를 하려면
디바이스가 알아먹고 처리할 수 있는 명령의 "목록"이 필요하다.

첫 번째 "이름"이 뭐냐를 자세히 디벼주마. 

시리얼 통신을 하는 프로그램을 한번이라도 작성해 본 행자들은
CreateFile의 맨 처음 인자에 “\\\\\.\\COM1” 이라고 준 것을 기억할 것이다.
이게 바로 COM포트 1번을 이용해 통신할 때 필요한 드라이버의 "이름"이다.
 
"이름"을 주는 방식은 두 가지가 있는데,

하나는 그 이름을 “\\\\\.\\COM1”, “\\\\.\\ezusb-0” 처럼 주는 것이다.
이 방식을 Symbolic Link를 사용한다고 한다.

다른 하나는
GUID(Globally Unique Identifier)를 이용하는 방법이다.
위의 Symbolic Link를 사용하는 방법의 문제 점은 이름이 중복될 가능성이 상존한다는 점이다.
생각해 봐라. COM1, ezusb 같은 소위 보기 좋은 이름들은 나 말고 누군가도 생각할 수 있다.
혹시 그대가 어쩌다가~ 

중복된 이름을 가진 두 장치를 컴퓨터에 설치하고 그 중 하나를 제어하기 위해 CreateFile을 호출하면 
운영체제는 어찌해야 될 지 몰라 파랗게 질린 모습을 보여줄지도 모른다.
이와 같은 문제를 극복하기 위해 
절대로 리바이벌은 안 한다는 GUID Generator(GUIDGEN.exe)를 사용해
말 그대로 지구상에서(Globally) 유일무이한(Unique) 이름(Identifier)을 맹글어 쓰는 방법이다.

 말이 쫌 길어 졌지만 두 가지 방법 다
어플리케이션에서 운영체제에다가
“야! 나는 이 이름을 가진 디바이스랑 통신 할 거니까 그 디바이스의 Handle을 나한테 넘겨.”
라고 말할 때 그 "이름"을 만드는 방법이다.

어느 방법을 사용하느냐 하는 것은 어플리케이션 프로그래머와 디바이스 프로그래머가 상의하기 나름이다.
하지만, Symbolic Link를 사용하는 것은 될수록 피하는 게 좋다.

씨바. 난 열라 독창적인 이름을 만들어내고 말테야!
라고 우기는 행자들은 말리지 않겠다. 지금 시간 햇빛도 안 나니 말릴 수 가 없다. -.-;;
다만 본좌는 GUID를 쓸꺼다. :P

첫번째 "이름"을 디볐으니,
두번째 "목록"을 후빌 차례다.

ReadFile, WriteFile, DeviceIoControl을 써서 
디바이스에게 작업지시를 할 때, 디바이스가 알아먹고 처리할 수 있는 명령의 "목록"말이다.

디바이스를 만들때는 "LED를 켜라"라는 명령을 처리할 수 있는 장치를 만들어 놓고,
"LED를 꺼라"라는 명령을 내려 보내면 디바이스는 어떻게 반응 할 까?
기냥 KIN~하고 생깔지, 폭주해서 자폭해 버릴지는 메누리도 모른다.

따라서 우리는 디바이스가 알아들을 수 있는 명령만 내려 보내야 한다.
어떻게?
먼저 어플리케이션 프로그래머, 드라이버 프로그래머가 머리를 맞대고 상의해서
"내가 A라고 뻐꾸기 날리면 니가 B를 처리한 후 C를 리턴해 주라"라고 합의본 후,
그 결과를 헤더 파일에 정리한다.
마찬가지로 드라이버 프로그래머와 펌웨어 프로그래머도 같은 짓을 해야 한다.
그리고 나서 (예를 들어서)

헤더파일에 이렇게 선언해 놓고
#define LED_ON  1

↓요렇게 호출하면
DeviceIoControl(핸들, LED_ON, ...) 
드라이버가 알아 듣고 적절한 동작을 위하게 된다.

자 이제 이론은 그만하고 실습에 들어가 보자.
이번 목표는 UniFull 보드에 LED 하나를 연결하고
그 LED On/Off를 어플리케이션에서 제어하는 것이다.

먼저 어플리케이션을 만들어야 한다.
DOS 모드에서 동작하는 어플리케이션을 만들면 이해하기는 쉽겠지만
쌍팔년도 아니고 바야흐로 21세기를 5년이나 보낸 이 시점에서
그깐 뽀대 안나는 깜장창 보여주기도 뻘쭘해서 MFC를 이용한 윈도우 프로그램으로 맹근다.

아직 MFC를 모르는 행자들 미리부터 너무 쫄지 마시라.
강좌의 목표에서 벗어나므로 본좌가 MFC 프로그래밍을 어떻게 하는지 가르쳐 줄 수는 없지만,
그걸 몰라도 전체적인 흐름을 따라잡고,
나중에 필요한 부분의 코드를 손 댈 수 있을 정도는 설명해 준다. 그까이꺼 뭐 대충~.

기본적으로
UniFull App v1.0은 MFC로 Dialog Base의 프로젝트를 생성 한 후에
리소스 에디터에서 버튼 하나를 추가하고,
그 버튼의 Handling function을 추가한다.
그 과정은 낼 올려 주마.

자 이제 위의 어플리케이션 소스를 다운 받아 열어 보자.
소스코드를 담고 있는 폴더를 보면
MFC 위저드가 생성한 파일들 외에 본좌가 따로 추가해준 파일들이 있다.
usb100.h
usbdi.h
usbioctl.h
usbiodef.h
wdm.h
그리고 UniFullusr.h
 
맨 아래 파일은 본좌가 만들어 추가해준 헤더파일이다, 
요거이 어플리케이션과 드라이버간의 통신에 필요한
드라이버의 "이름"(GUID)과 명령 "목록"(Interface)을 담고 있는 헤더 파일이다.
그 이외 5개의 헤더파일들은 이 프로젝트 내에서 호출하는 함수들을 위한 헤더파일 들이다.
( DDK(Driver Development Kit)에서 복사해 왔다. )

오늘의 하이라이뚜
UniFullDlg.cpp 파일의 OnButtonLED() 멤버함수를 보시라.
행자들의 이해력을 필요로 하는 부분은 오직 이 OnButtonLED() 함수 하나 뿐이다.
"LED ON/OFF" 버튼을 클릭하면 낼롬 이 함수로 뛰어들어온다.

그런 다음 아래의 절차를 차례로 수행한다.
OpenFile함수에서 우리가 접근하고자 하는 디바이스의 핸들을 얻고,
DeviceIoControl로 디바이스에게 LED를 켜라 또는 꺼라 라고 시키며,
할 일이 다 끝났다면 CloseHandle로 핸들을 반환한다.

이게 줄거리의 전부다.

어라? 앞서에는 CreateFile로 핸들을 얻는다메?
아잉~ 구라쟁이~.
하는 행자들에게는 박수를. 짝짝짝.

 OpenFile함수를 따라 들어가 보면
거기 CreateFile이 있다.

h = CreateFile ( szCompleteDeviceName,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL );

뭐 이래저래 장황한 코드가 나오지만
HANDLE OpenFile(…);
BOOL GetUsbDeviceFileName(…);
HANDLE OpenUsbDevice(…);
HANDLE OpenOneDevice(…);

이 네 함수는 CreateFile의 맨 처음 인자를 얻기 위해 필요한 함수들이고,
우리가 손댈 필요가 없다.

이제 파일(디바이스) 핸들을 얻었으니,
그 핸들을 가지고 디바이스와 통신할 차례이다.

bRet = DeviceIoControl( hFile, lLed, NULL, 0, NULL, 0, &dwBytesReturned, NULL );
가 그 코드이다.

이 함수에 대한 설명은 MSDN Library를 참조하시라. 꼭 한번 볼 것을 권한다.

다른 인자들은 이 예에서는 사용을 안하고,
두 번째 인자 ( DWORD dwIoControlCode )가 우리가 디바이스에게
이 일을 햐쇼. 라고 명령하는 부분이 되겠다.

이 코드는 UniFullUsr.h에 선언되어 있는데,
IOCTL_UNIFULL_xxxxx하는 것들이 다 그것들이다.

여기까지가 UniFull Application 1.0의 소스에 대한 대략적인 설명이다.

MFC에 익숙하지 않은 행자들을 위해 첨언 하자면
C 콘솔프로그램에서 프로그램을 시작하면 main()문으로 들어가듯이
버튼을 누르면 OnButtonLED()로 들어온다.
라는 정도만 알고,
버튼이 눌렸을 때 처리해야 하는 일은 OnButtonLED() 함수 내에서 처리해 주면 되겠다.
더 자세한 것들은 책 사서 보시라.

프로젝트 생성에 대한 자세한 절차는 낼 업뎃한다.

http://www.muosys.com/bbs/view.php?id=D12lecture&page=1&sn1=&divpage=1&sn=off&ss=on&sc=on&select_arrange=headnum&desc=asc&no=23

 강좌의 이번 회는 USB 디바이스와 통신하기 위한 윈도우 어플리케이션 작성법에 관한 것이다.
본좌는 MFC를 이용해서 Dialog Base의 어플리케이션을 작성하는 방법을 예로 들어 보여줄 것이다.
하지만 앞부분에 설명할
MFC Wizard를 사용해서 프로젝트를 생성하는 절차를 제외한 나머지 부분은
WinAPI로 윈도우 프로그래밍을 하던, 콘솔모드의 프로그램을 짜던
MS 윈도우에서 돌아가는 프로그램이라면 다 동일한 것이므로 알아서 참조하기 바란다.
 
먼저 Visual Studio를 실행시킨다. (본좌는 VC++ 6.0을 쓴다.)

먼저 프로젝트를 생성하기 위해 메뉴의 File → New 를 누르면 다름과 같은 창이 뜬다.

Project 탭을 선택한 후에,
MFC App Wizard(exe)를 선택하고
프로젝트 이름과 저장될 위치를 선택하고
OK 버튼을 누른다.

Application Type을 Dialog Based로 바꾸고 NEXT 버튼을 누른다.

About Box의 체크버튼을 해제하고,
( 안 해도 상관은 없다. 쓸데 없는 코드가 추가되는 걸 막기 위해 해제할 뿐이다. )
Dialog Title을 입력한다.
( 그냥 놔둬도 된다. 이 문자열이 프로그램 타이틀 바 좌측에 보여지는 문자열이다. )
NEXT 버튼을 누른다.

그냥 NEXT 버튼을 클릭한다.

FINISH 버튼을 누르면 MFC Wizard가 소스코드를 생성한다.
(다음에 나오는 Report 창은 OK를 눌러 그냥 닫는다.)

만들어진 프로젝트

이제 LED를 키고 끌 버튼을 추가해 보자.
먼저 “TODO …”하는 문자열과 “취소” 버튼은 필요 없으므로 지운다.
그리고 "확인" 버튼을 선택하고, 오른버튼을 클릭해서 "Property"에서 이름을 "확인"에서  "종료"로 바꾸어 준다.
그리고 버튼을 하나 추가한다.

버튼을 선택하고 오른버튼→Property를 선택해 버튼 ID와 이름을 바꾸어 주자.

Property 편집창을 닫은 후에 버튼을 더블 클릭하면
버튼이 눌렸을 때 실행되는 멤버함수를 추가 할 수 있다.

위에서 OK를 누르면 이제 코딩할 준비가 끝난 것이다.
반전된 주석문은 지워 버리자.

위에서 파일을 다운받고 압축을 풀어 5개의 다음 파일들을 프로젝트 폴더 안에 복사해 넣는다.
usb100.h
usbdi.h
usbioctl.h
usbiodef.h
wdm.h

그리고 나서 위에서 복사한 파일들을 Project에 추가해 준다.

그리고, 메뉴의 File→New를 눌러 Files 탭에서 “C/C++ Header Files”를 선택하고,
파일 이름으로 UniFullUsr를 입력한 후에 OK 버튼을 누르면
프로젝트에 헤더파일이 하나 추가된다.
이 파일이 어플리케이션과 드라이버가 합의한 ���터페이스를 정의할 헤더 파일이 되겠다.

여기에 다음 내용을 복사해 집어 넣자.
#ifndef _UNIFULL_USR_H
#define _UNIFULL_USR_H
#include <initguid.h>
#include <winioctl.h>

// {1CC20EBB-27D8-4a87-8E44-4EE11340A74D}
DEFINE_GUID( GUID_CLASS_UNIFULL_TEST, 0x98001a9a, 0x12e3, 0x4e8c, 0xad, 0x55, 0x26, 0xa8, 0xb9, 0x23, 0x9b, 0xc3);

#define DEFAULT_CONTROL_PIPE    NULL
#define UNIFULL_IOCTL_INDEX     0x0000
#define IOCTL_UNIFULL_GET_CONFIG_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN, UNIFULL_IOCTL_INDEX, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define IOCTL_UNIFULL_RESET_DEVICE          

CTL_CODE(FILE_DEVICE_UNKNOWN, UNIFULL_IOCTL_INDEX+1, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define IOCTL_UNIFULL_RESET_PIPE            CTL_CODE(FILE_DEVICE_UNKNOWN, UNIFULL_IOCTL_INDEX+2, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define IOCTL_UNIFULL_LED_ON                CTL_CODE(FILE_DEVICE_UNKNOWN, UNIFULL_IOCTL_INDEX+4, METHOD_BUFFERED, FILE_ANY_ACCESS )
#define IOCTL_UNIFULL_LED_OFF               CTL_CODE(FILE_DEVICE_UNKNOWN, UNIFULL_IOCTL_INDEX+5, METHOD_BUFFERED, FILE_ANY_ACCESS )

typedef struct _CONTROL_REQUST
{
    USHORT usValue;
    USHORT usIndex;
    USHORT usLength;
    USHORT Reserved;
    PVOID pvBuffer;
    UCHAR ulBufferLength;
} CONTROL_REQUST, *PCONTROL_REQUST;
#endif
 
DEFINE_GUID… 요 부분이 드라이버의 “이름”이오,
#define IOCTL_UNIFULL_LED_ON/OFF… 이 부분이 “목록”이다.
LED_”ON/OFF”를 제외한 나머지 IOCTL_UNIFULL_는 이번에 작성할 UniFull Test Application에서는 지원하지 않을 내용이다.
지우기 귀찮아서 그냥 냅뒀다.

UniFullUsr.h를 다 작성했으면
이제 UniFullDlg.cpp에 코드를 추가해야 한다.
추가하는 코드는 몽조리 다 디바이스의 Handle을 얻기 위한 OpenFile을 호출하기 위한 코드 들이다.
( OpenFile에서 궁극적으로 CreateFile을 호출한다는 말을 본좌가 했었나? 응?. 흠~ 치매다. )

OpenFile()에서 호출하는 다음 함수들의 원형을 UniFullDlg.cpp의 앞부분에 추가해 준다.
위치는 대충
#ifdef _DEBUG
…
#endif

뒤 쪽에다 넣으시라.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Copy Code From Here for Driver Interface (Get Device Handle)                                          */
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HANDLE OpenFile(IN PCHAR pcPipeName);
BOOL GetUsbDeviceFileName(LPGUID pGuid, PCHAR pszName);
HANDLE OpenUsbDevice(LPGUID pGuid, PCHAR pszName);
HANDLE OpenOneDevice(IN HDEVINFO HardwareDeviceInfo, IN PSP_INTERFACE_DEVICE_DATA DeviceInfoData, IN PCHAR pszDevName);

CHAR szCompleteDeviceName[256];
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Copy Code To Here                                                                                                             */
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
그리고 이 함수들을 위해서는 이전에 프로젝트 폴더에 추가했던 헤더파일도 including 시켜야 한다.
맨 앞부분 include… 뒤에 다음의 코드를 추가해 준다.
#include "usbdi.h"
#include <setupapi.h>

그 외에 메뉴의 “Project”->”Settings”->”Link” 탭을 클릭해서,
“Object/Library Modules”항목에 “setupapi.lib”를 추가해 주어야 한다.
이 setupapi.lib 파일 역시
프로젝트 내에서 호출하는 함수들을 위한 라이브러리 이다.

빨간 선으로 표시한 부분이 본좌처럼 “Win32 Debug”로 되어 있다면,
이 것을 “Win32 Release” 또는 “All Configurations”로 바꾸어 준 뒤
“Object/Library Modules”항목에 “setupapi.lib”를 추가해 주는 정도의 센.스.는 있어야 하겠다.
안 그럼 릴리즈 버전의 EXE파일을 생성할 때,
링크에러가 떵 하니 나타나버리고 말 것이기 때문이다.

그 아래에 전역변수
CHAR szCompleteDeviceName[256];
추가를 추가 해 주어라.
이 역시 디바이스의 Handle을 얻기 위해 필요한 변수이다.

그리고 마우스를 쭉 끌어 맨 밑으로 가서
위에 선언한 함수원형에 해당하는 함수 본체들을복사해 준다.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Copy Code From Here for Driver Interface (Get Device Handle)                                             */
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
HANDLE OpenFile(IN PCHAR pcPipeName)
{
    INT Success = 1;
    HANDLE h;

    if ( !GetUsbDeviceFileName( (LPGUID) &GUID_CLASS_UNIFULL_TEST, szCompleteDeviceName) ) return INVALID_HANDLE_VALUE;

    if( pcPipeName )
    {
        strcat ( szCompleteDeviceName, "\\" );
        strcat ( szCompleteDeviceName, pcPipeName );
    }

    h = CreateFile ( szCompleteDeviceName,
                    GENERIC_WRITE | GENERIC_READ,
                    FILE_SHARE_WRITE | FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL );

    return h;
}

BOOL GetUsbDeviceFileName(LPGUID pGuid, PCHAR pszName)
{
    HANDLE hDev = OpenUsbDevice ( pGuid, pszName );

    if ( hDev != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hDev );
        return TRUE;
    }
    return FALSE;
}

 

HANDLE OpenUsbDevice(LPGUID pGuid, PCHAR pszName)
{
   ULONG NumberDevices;
   HANDLE hOut = INVALID_HANDLE_VALUE;
   HDEVINFO                 hardwareDeviceInfo;
   SP_INTERFACE_DEVICE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR   *UsbDevices = &usbDeviceInst;

   *UsbDevices = NULL;
   NumberDevices = 0;

   // Open a handle to the plug and play dev node.
   // SetupDiGetClassDevs() returns a device information set that contains info on all
   // installed devices of a specified class.
   hardwareDeviceInfo = SetupDiGetClassDevs ( pGuid,
                                              NULL, // Define no enumerator (global)
                                              NULL, // Define no
                                              (DIGCF_PRESENT | // Only Devices present
                                              DIGCF_INTERFACEDEVICE)); // Function class devices.

   // Take a wild guess at the number of devices we have;
   // Be prepared to realloc and retry if there are more than we guessed
   NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_INTERFACE_DEVICE_DATA);

   i=0;

   while ( !done )
   {
      NumberDevices *= 2;

      if ( *UsbDevices )
      {
         *UsbDevices = (PUSB_DEVICE_DESCRIPTOR) realloc ( *UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR)) );
      }
      else
      {
         *UsbDevices = (PUSB_DEVICE_DESCRIPTOR) calloc ( NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR) );
      }

      if ( NULL == *UsbDevices )
      {
         // SetupDiDestroyDeviceInfoList destroys a device information set
         // and frees all associated memory.
         SetupDiDestroyDeviceInfoList ( hardwareDeviceInfo );
         return INVALID_HANDLE_VALUE;
      }

      usbDeviceInst = *UsbDevices + i;

      for ( ; i < NumberDevices; i++ )
      {
         // SetupDiEnumDeviceInterfaces() returns information about device interfaces
         // exposed by one or more devices. Each call returns information about one interface;
         // the routine can be called repeatedly to get information about several interfaces
         // exposed by one or more devices.
         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                         0, // We don't care about specific PDOs
                                         pGuid,
                                         i,
                                         &deviceInfoData))
         {
            hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, pszName);

            if ( hOut != INVALID_HANDLE_VALUE )
            {
               done = TRUE;
               break;
            }
         }

         else
         {
            if ( ERROR_NO_MORE_ITEMS == GetLastError() )
            {
               done = TRUE;
               break;
            }
         }
      }
   }

   NumberDevices = i;

   // SetupDiDestroyDeviceInfoList() destroys a device information set
   // and frees all associated memory.
   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);

   free ( *UsbDevices );
   return hOut;
}

HANDLE OpenOneDevice(IN HDEVINFO HardwareDeviceInfo, IN PSP_INTERFACE_DEVICE_DATA DeviceInfoData, IN PCHAR pszDevName)
{
    PSP_INTERFACE_DEVICE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    HANDLE                               hOut = INVALID_HANDLE_VALUE;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //

    SetupDiGetInterfaceDeviceDetail ( HardwareDeviceInfo,
                                      DeviceInfoData,
                                      NULL, // probing so no output buffer yet
                                      0, // probing so output buffer length of zero
                                      &requiredLength,
                                      NULL ); // not interested in the specific dev-node

    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = (PSP_INTERFACE_DEVICE_DETAIL_DATA) malloc (predictedLength);
    functionClassDeviceData->cbSize = sizeof (SP_INTERFACE_DEVICE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //

    if (! SetupDiGetInterfaceDeviceDetail ( HardwareDeviceInfo,
                                           DeviceInfoData,
                                           functionClassDeviceData,
                                           predictedLength,
                                           &requiredLength,
                                           NULL) )
    {
        free ( functionClassDeviceData );
        return INVALID_HANDLE_VALUE;
    }

    strcpy ( pszDevName,functionClassDeviceData->DevicePath ) ;

    hOut = CreateFile ( functionClassDeviceData->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, // no SECURITY_ATTRIBUTES structure
                        OPEN_EXISTING, // No special create flags
                        0, // No special attributes
                        NULL ); // No template file

    free ( functionClassDeviceData );

    return hOut;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Copy Code To Here                                                                                         */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
파일을 다운받고 5개의 파일들을 프로젝트 폴더 안에 복사해 넣는것부터 시작하는 이 일련의 절차들은
행자들이 디바이스를 제어하는 어플리케이션을 작성하기 위해서는
기계적으로 Copy&Paste 신공을 구사해야 하는 대상이다.
이해? 이런 거 필요 없다.
딱 5초 준다. 존내 클릭하는 거다.

그래서 본좌가
같다 붙이기 쉬우라고
szCompleteDeviceName 전역변수와 네 개의 함수들을
멤버변수와 멤버함수로 안 만들고
기냥 같다 붙인 것이다.

본좌는
위의 변수와 함수들을 하나로 묶어 하나의 클래스로 만들어 쓰지만
클래스가 뭐시어라?
하는 행자들도 분명히 있을 것이기에
기냥 평범한 함수로 같다 붙였다.
(이러나 저러나 모냥만 다를 뿐, 하는 일은 같으므로 신경 쓰지 말자.)

본좌도 예전에 위 함수들이 어떤 동작을 하는지
한번 분석해 보고 난 뒤,
그 이후부터는 그냥 기계적으로 복사해서 쓴다.
이젠 이 함수들이 어떤 짓을 하는지 기억조차 안난다.
시간이 남아도는 행자들은 MSDN Library를 참조해서 코드를 함 분석해 보고,
귀차니즘을 추구하는 행자들은 냅따 Copy&Paste 하시라.

이제까지 OnButtonLED()에서 디바이스의 Handle을 얻기 위해 호출할 OpenFile()을 위해
이것 저것 잡다구레한 일을 마쳤으니,
OpenFile()을 호출해서 Handle을 얻고,
DeviceIoControl()을 호출해 디바이스에게 작업을 내려 보내고,
작업이 끝났으면 CloseHandle()을 호출해서 Handle을 반환할 차례이다.
이 것들이 바로 OnButtonLED()에 들어 있는 다음 내용이다.
    BOOL bRet = FALSE;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesReturned=0;
    static LONG lLed = IOCTL_UNIFULL_LED_OFF;

    lLed = (lLed == IOCTL_UNIFULL_LED_OFF)? IOCTL_UNIFULL_LED_ON : IOCTL_UNIFULL_LED_OFF;

    hFile = OpenFile( DEFAULT_CONTROL_PIPE );

    if( INVALID_HANDLE_VALUE != hFile )
    {
        bRet = DeviceIoControl( hFile,
                               lLed,
                               NULL,
                               0,
                               NULL,
                               0,
                               &dwBytesReturned,
                               NULL );

        CloseHandle( hFile );
    }

요기까지가 바로 앞 강의에서 다운 받았던 UniFull App v1.0을 만들었던 절차이다.
행자들 스스로 Application을 작성할 때 참조하길 바란다.

2)	VirtualMonitor과 DNW 0.5 USB 처리 Source 정리  - VC/DDK  2009/02/11 13:02
 http://blog.naver.com/maclover/110042315102 
그냥 본인이 나중에 재확인이 쉽도록 임의로 소스를 분석한것임. 

DNW 
 1) External Header File
   basetsd.h ( base type sized definitions) - typecasting이 용이하도록 자료형별 변환 macro정의
   def.h       - 자주쓰이는 자료형을 간단하게 define ( ex  unsigned short -> U16 )
   devioctl.h - FILE DEVICE define
   usb100.h  - USB 1.0 각종 Descriptor struct 및 const 정의
   usbid.h    -  Definitions for the Universal Serial Bus client driver interface (실제 API인 듯)
   usbtypes.h- Definitions for Universal Serial Bus driver
                   - usb100.h 를 포함하고 있음 ( 즉 usbtype.h만 include한면 OK)
 2) cpp File
  Engine.cpp - WinMain , WndProc 
  dnw.cpp    - Menu별 실행 함수가 정의됨
  rwbulk.c - HANDLE open_dev() 함수로 SoC USB접속 여부 판별(특정 pipe를 open못함)
               - guid.h에 USB GUID 가 존재함
               - Open성공시 device의 handle을 return (handle의 용도는 File처럼 IO하기위함)
               - in/out pipe명이 정의되있음 ( PIPE00(in), PIPE01(out) )
               - 정리하면 guid, pipe 2가지만 있으면 특정 USB Endpoint에 접속가능 한듯함...
               - 특정ep의 handle을 받아오려면 pipe명까지 있어야 함
  usbtxrx.cpp - 본인이 필요해서 VirtualMonitor관련 Code추가 

 참조 - dumpUsbConfig: 해당 GUID USB의 모든 ep를 enumerate 

USB Host 처리순서

// 1. pipe Open
HANDLE hWrite = open_file( outPipe);

// 2. UsbTxFile Callback Start 
threadResult=_beginthread( (void (*)(void *))UsbTxFile,0x2000,(void *)0);

// 3. UsbTxFile 내에서
      WriteFile(hWrite,txBlk     (buffer)
                  ,txBlkSize        (transfer size)
                  ,&nBytesWrite   (transfered size)
                  ,NULL
      );

// 4. CloseHandle(hWrite);

UsbTxFile 내부를 들여다보자
while(1)
{
  // txBufSize- File Total Size (소스분석않하고 그냥 했다가 6시간동안 생고생한 부분ㅠ.ㅜ)
  // iTxBuf      - Transfered Size
  // TX_SIZE   - Transfer Packet Size (16K로 잡혀있는데 내부Log보면 64byte씩 처리됨)
  if((txBufSize-iTxBuf) > TX_SIZE) // File Total Size가 Transfer Packet Size보다 크면
     txBlkSize=TX_SIZE;
  else
     txBlkSize=txBufSize-iTxBuf;
 
  txBlk=(void *)(txBuf+iTxBuf);
  WriteFile(hWrite,txBlk,txBlkSize,&nBytesWrite,NULL);

  iTxBuf+=TX_SIZE;

 // 짬짬이 전송진생상태 Update
  if( ((iTxBuf/txBufSize100)%2)==1 )
      DisplayDownloadProgress(iTxBuf/txBufSize100);
 
  if(downloadCanceled==1)break; //download is canceled by user.

  if(iTxBuf>=txBufSize)break;        // 전송완료
 }

참고!  secbulk.sys doesn't support OverlappedIO -  PC용 DeviceDriver가 비동기는 지원않하는듯..
         재대로 파악은 못했지만 개인적은 소견은 USB접속도 불안정하고 Driver도 구리고 비추...
         다음에는 PSP용의 VirutalMontor(PSPdisp)  USB Iso 전송 소스를 분석예정 
         (요건 기대해도 될듯..) 
[출처] VirtualMonitor과 DNW 0.5 USB 처리 Source 정리|작성자 sangsok


3)	장치 인스턴스 ID
제품등록할 때 적혀있는 부분은 시리얼 넘버가 아니라 pc에 기기를 연결하게되면 
장치인스턴스 ID라고해서 기기의 메인pcb를 인식해서 그 코드를 입력해서 제품을 등록합니다.
도난 이런거 하고는 상관이 없는 내용입니다.

Windows 2000에서 Windows Server 2003으로 업그레이드한 후 USB 저장 장치가 더 이상 작동하지 않는다

현상Windows 2000 Server에서 Windows Server 2003으로 업그레이드한 후에 컴퓨터에 연결된 USB 저장 장치가 더 이상 작동하지 않을 수 있습니다. 
또한 중복 USB 저장 장치가 장치 관리자와 이동식 저장소 스냅인에 나타날 수 있습니다. 

원인이 문제는 Windows Server 2003이 Windows 2000에서 만든 USB 저장 장치용 인스턴스 ID 문자열과 일치하지 않는 USB 저장 장치용 인스턴스 ID 문자열을 만들기 때문에 발생합니다. 
Windows Server 2003에서 USB 저장 장치에 USB 일련 번호 문자열이 있는 경우 Usbstor.sys 파일은 USB 저장 장치에 대한 고유한 인스턴스 ID 문자열을 만듭니다. 
Windows Server 2003에서 만드는 인스턴스 ID 문자열은 Windows 2000이 만드는 인스턴스 ID 문자열과 다릅니다. 
결과적으로 플러그 앤 플레이는 USB 저장 장치를 새 장치로 컴퓨터에 추가하고 새 주소 할당을 사용하여 USB 저장 장치와 통신합니다. 
이로 인해 Windows 2000의 주소 할당은 컴퓨터에 연결된 장치와 더 이상 일치하지 않으며 USB 저장 장치의 Windows 2000 복사본이 이동식 저장소 관리자 스냅인에 사용할 수 없는 것으로 나타납니다. 


4)	SelexOn 미터기, USB 디바이스 통신 과정 설명
A)
/**********************************************************************************
	Thread: Target board와 USB 통신하며 Command 및 data를 보내고 받으 수 있다. 
	- 0.5초 마다 수행한다.
***********************************************************************************/ 
UINT InputThread(LPVOID pParam)
{
	......................................................................................................
	while(pCardiacDoc->m_bContinueInputThread)
	{
	......................................................................................................
		/*이 Task는 500msec 마다 running된다. 
		이에 대해서 1000msec마다 USB connection 확인을 위해서 다음과 같이 함.*/
		if(bCheck1sec == FALSE)
		{
			if(!IsUsbConnected())
				pCardiacDoc->m_bUsbConnect = TRUE;
			else
				pCardiacDoc->m_bUsbConnect = FALSE;

			bCheck1sec = TRUE;
		}
		else
			bCheck1sec = FALSE;

		pCardiacDoc->CCardiacOpenTarget();		// 상기 m_bUsbConnect의 값이 TRUE 인 경우에만 본, CCardiacOpenTarget 함수 실행

		//Sleep(500); // msec unit
		Sleep(250);
	}
	return 0;
}

int IsUsbConnected(void)
{
    HANDLE hDEV = open_dev();
    if ( hDEV!=INVALID_HANDLE_VALUE ) /*일단 연결 상태와 device name을 확인하고 Handle을 destory한다. */
    {
		CloseHandle(hDEV);
		return 0;
    }
	else
        return -1;
}

DEFINE_GUID(GUID_CLASS_I82930_BULK,				// GUID_CLASS_I82930_BULK 데이터는 SelexOn Meter 라이브러리 상의 USB 디바이스 드라이버 이름과 동일해야 하며 
															// 본, 데이터를 가지고 OpenUsbDevice 함수에서 USB메모리 등 다른 USB와 SelexOn USB를 구별하는 용도로 사용 함
#if 1
0x873fdf, 0x61a8, 0x11d1, 0xaa, 0x5e, 0x0, 0xc0, 0x4f, 0xb1, 0x72, 0x8b);
#else
// temp, 임시로 아래 데이터를 임의로 변경해 보았더니 USB 통신이 아예 되지 않는 에러 발생 함 
0x873fdf, 0x61a8, 0x11d1, 0xaa, 0x5e, 0x0, 0xc0, 0x4f, 0xb1, 0x72, 0x8c);
// temp
#endif


char completeDeviceName[256] = "";		// PC에 꼽혀 있는 여러개의 USB를 구별해 주기 위한 디바이스 이름으로 PC Application 프로그램은 본, completeDeviceName 이름을 가지고 여러개의 USB 중에서 나와 연결된 USB를 구별하는 용도로 사용한다.
											// generated from the GUID registered by the driver itself
											// GUID_CLASS_I82930_BULK	{00873FDF-61A8-11D1-AA5E-00C04FB1728B}
											// GUID_CLASS_I82930_BULK 데이터는 SelexOn Meter 라이브러리 상의 USB 디바이스 드라이버 이름과 동일해야 하며 
											// 본, 데이터를 가지고 OpenUsbDevice 함수에서 USB메모리 등 다른 USB와 SelexOn USB를 구별하는 용도로 사용 함
											// ex) 1번째 USB -> completeDeviceName = "\\?\usb#vid_1a8c&pid_0102#5&15e6108c&0&1#{00873fdf-61a8-11d1-aa5e-00c04fb1728b}"
											// ex) 2번째 USB -> completeDeviceName = "\\?\usb#vid_1a8c&pid_0102#5&2b499b12&0&1#{00873fdf-61a8-11d1-aa5e-00c04fb1728b}"
											// -> usb#vid_1a8c&pid_0102#5&15e6108c&0&1 데이터는 USB가 꼽힐 때 마다 SelexOn PC USB 드라이버에서 정해주는 값으로 여러개의 SelexOn 미터기의 USB를 구별해주는 용도로 사용함.


HANDLE
open_dev()
/*++
Routine Description:
    Called by dumpUsbConfig() to open an instance of our device

Arguments:
    None

Return Value:
    Device handle on success else NULL

설명) 본 open_dev 함수는 USB가 연결되어 있는지 알려주는 용도로만 사용하고
	  실제, USB를 연결하는 함수는 open_fileUSB -> CreateFile 임
--*/
{
    HANDLE hDEV = OpenUsbDevice( (LPGUID)&GUID_CLASS_I82930_BULK, completeDeviceName);

    if (hDEV == INVALID_HANDLE_VALUE)
    {
		//EB_Printf("Failed to open (%s) = %d", completeDeviceName, GetLastError());
    }
    else
    {
		//EB_Printf("DeviceName = (%s)\n", completeDeviceName);
		/* 설명) 이곳에서 hDEV 핸들을 Close 시키지는 않지만 본, open_dev를 실행시키는 바로 상위 함수인 IsUsbConnected 함수에서 곧바로 hDEV 핸들을 Close 시킴	*/
    }

    return hDEV;
}

/*++
Routine Description:
   Do the required PnP things in order to find
   the next available proper device in the system at this time.

Arguments:
    pGuid:      		ptr to GUID registered by the driver itself
    outNameBuf: 	the generated name for this device

Return Value:
    return HANDLE if the open and initialization was successful,
    else INVLAID_HANDLE_VALUE.

설명)	GUID_CLASS_I82930_BULK 이름의 USB가 꼽혀 있는지 확인 하고
		만약 연결되어 있으며 GUID_CLASS_I82930_BULK 이름에 SelexOn USB 디바이스 드라이버에서 제공하는
		ex) usb#vid_1a8c&pid_0102#5&15e6108c&0&1 이름을 앞에 붙여서 outNameBuf
--*/
HANDLE	OpenUsbDevice( LPGUID  pGuid, char *outNameBuf)
{
   ULONG NumberDevices;
   HANDLE hOut = INVALID_HANDLE_VALUE;
   HDEVINFO                 hardwareDeviceInfo; /**/
   SP_INTERFACE_DEVICE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst; /* USB Device description에 대한 구조체 생성 */
   PUSB_DEVICE_DESCRIPTOR   *UsbDevices = &usbDeviceInst;

   *UsbDevices = NULL;
   NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   // SetupDiGetClassDevs() returns a device information set that contains info on all
   // installed devices of a specified class.
   //	
   // Edward - 2007.04.07

   /*오픈하고자 하는 디바이스에 의해 등록된 디바이스 인터페이스의 클래스GUID를 알아야 한다.
     그래서 그를 아래와 같이 설정한다. */

   /*
   SetupDiGetClassDevs(
	   IN LPGUID ClassGuid,  OPTIONAL
	   IN PCSTR  Enumerator, OPTIONAL
	   IN HWND	 hwndParent, OPTIONAL
	   IN DWORD  Flags
	   );

 SetupDiGetClassDevs()를 이용하여 device class의 handle을 얻는다.
 device 정보는 GUID에 의해 지정된 클래스의 모든 디바이스 인터페이스에 관한 정보를 포함하고 있다. 

 
 	Enumerator : 	매개변수에는 PnP 장치의 구분자를 넣는다. 
		 		PCI, USB, PCMCIA, SCSI 등을 사용 가능하고 NULL을 넣으면 모든 장치를 얻는 것이 가능하다. 
 	Flags 	:	flag로서 다음과 같은 효과를 같는다. OR 연산으로 여러개의 Flag 지정이 가능하다. 
				DIGCF_PRESENT: System에 장착된 장치들만 return.
				DIGCF_DEVICEINTERFACE:  2번에 기입한 device interface를 기입한 class를 return.
				DIGCF_ALLCLASSES: System에 설치된 모든 device interface class를 return. (System에 장착되지 않은 장치들도 포함한다.)
				DIGCF_DEFAULT: System의 기본 device class만 return한다.
				DIGCF_PROFILE: 현재 Hardware profile만 return한다. 

   */
   hardwareDeviceInfo = SetupDiGetClassDevs(
			   pGuid, 
			   NULL, // Define no enumerator (global)
			   NULL, // Define no
			   DIGCF_PRESENT | // Only Devices present
			   DIGCF_DEVICEINTERFACE // Function class devices.
			   );

   //
   // Take a wild guess at the number of devices we have;
   // Be prepared to realloc and retry if there are more than we guessed
   //
   NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_INTERFACE_DEVICE_DATA);

	i=0;
	while (!done) 
	{
		NumberDevices *= 2;

		if (*UsbDevices) 
			*UsbDevices = (PUSB_DEVICE_DESCRIPTOR)realloc (*UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR)));
		else 				   	/*	 원소의 갯수 			원소의 size*/
			*UsbDevices = (PUSB_DEVICE_DESCRIPTOR)calloc (NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR));
	
		if (NULL == *UsbDevices) 
		{
			// SetupDiDestroyDeviceInfoList destroys a device information set
			// and frees all associated memory.
			SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
			return INVALID_HANDLE_VALUE;
		}

		usbDeviceInst = *UsbDevices + i;
		for (; i < NumberDevices; i++) 
		{
			// SetupDiEnumDeviceInterfaces() returns information about device interfaces
			// exposed by one or more devices. Each call returns information about one interface;
			// the routine can be called repeatedly to get information about several interfaces
			// exposed by one or more devices.
		 
			/*SetupDiEnumDeviceInterfaces()함수는 디바이스정보셋트 내의 각 디바이스 인터페이스를 열거하는 것이다.
			이것이 FALSE이면  GetLastError이 ERROR_NO_MORE_ITEMS일때 까지 파라메타 인덱스를 증가시키면서 반복
			적으로 루틴을 호출할 수 있다.
			### 본, SetupDiEnumDeviceInterfaces 함수가 GUID_CLASS_I82930_BULK 이름의 USB가 꼽혀 있는지 확인 용의 함수 임, GUID_CLASS_I82930_BULK 이름의 USB가 꼽혀 있지 않는 한 바로 아래 루틴으로 넘어가지 않음 */
			if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
						 0, // We don't care about specific PDOs
						 pGuid,
						 i,
						 &deviceInfoData)) { /* device interface data 구조체를 구하여 아래에 설정한다. */

				#if 0
				hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf);
				if ( hOut != INVALID_HANDLE_VALUE )
				{
					done = TRUE;
					break;
				}
				#else
				// temp
				if(i == 1)
				{
					hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf);
					if ( hOut != INVALID_HANDLE_VALUE )
					{
						done = TRUE;
						break;
					}
				}
				// temp
				#endif
			}
			else {
				if (ERROR_NO_MORE_ITEMS == GetLastError())
				{
			   		done = TRUE;
			   		break;
				}
		 	}
		}
	  
	}

	NumberDevices = i;

	// SetupDiDestroyDeviceInfoList() destroys a device information set
	// and frees all associated memory.

	SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
	free ( *UsbDevices );
	return hOut;
}

int CCardiacDiagnosisDoc::CCardiacOpenTarget()
{
  LFI_USB_DATA_STRUCT jigDataInfo;	// UsbSendCommmand()에서 정보를 보내기 위한 매개변수로 사용된다.
  LFI_USB_DATA_STRUCT* pRSP = NULL; // UsbReceiveRespond()에서 정보를 받기위한 매개변수로 사용된다.  //cmpark090722,  = NULL; 
  LFI_USB_DATA_STRUCT getData;		// UsbReceiveBulkDataLFI()에서 Bulk data를 받기위한 매개변수로 사용된다. 이때 &를 사용하여 
									//	매개변수의 주소를 전달한다. 
  int result = 0;
  unsigned int i = 0;
  BYTE y,u,v;
  BYTE *pTransData; 


 /* USB가 Connection이 되면....*/
 if(m_bUsbConnect == TRUE) 
 {
    /* 새로운 Cmd가 Window Message에 의하여 들어 오면....*/
	if(m_jigCmdType != JIGCMD_NONE)
	{
			memset(&jigDataInfo, 0, sizeof(LFI_USB_DATA_STRUCT));
			
			/* Device initialize */
            if(m_jigCmdType == JIGCMD_DEVICE_INITIALIZE)
            {      
                if(SUCCESS == UsbSendCommand(TRUE, JIGCMD_DEVICE_INITIALIZE, jigDataInfo))	// CMD
				{
					if(SUCCESS != UsbReceiveRespond(TRUE,  pRSP))							// RSP
					{         
						AfxMessageBox("ERROR: Device Initialize, Receive Single RSP \r\n");
						m_jigCmdType = JIGCMD_NONE;
						return -1;
					}
				}
            }
	......................................................................................................

int UsbSendCommand(BOOL bJustCmd, JIGCMD_TYPE jigCmdType, LFI_USB_DATA_STRUCT jigUsbData)
{
	TRACE("SendCMD-S\r\n");
       int result = 0;
       ULONG nBytesRead;
    
       if(bJustCmd == TRUE)
        {
        	hUsbWrite = open_fileUSB( outPipe);
        	if(hUsbWrite==INVALID_HANDLE_VALUE)
        	{
        		AfxMessageBox("Can't open USB device.\n\rDid you connect USB cable to PC ?");
        		return -1;
        	}
        }

	LFI_USB_COMMAND48_STRUCT Cmd;
	Cmd.StartCode = 0x0055;
	Cmd.Command   = jigCmdType;
	Cmd.Address   = jigUsbData.destinationAddress;
	Cmd.FileSize  = jigUsbData.usbDataSize;
	memcpy((char*)Cmd.Filename, (char*)jigUsbData.dataName, sizeof(char)*32);
	Cmd.EndCode   = 0x00FF;

	// 먼저 Command 를 write한다. 
	/*  BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
            (LPCVOID: Pointer to a constant of any type. LPDWORD: Pointer to a DWORD)
            
        - hFile: 기록하고자 하는 file의 handle. 이 file은 GENERIC_WRITE access 권한으로 열어야 한다.
        - lpBuffer: 츨력할 data를 가진 buffer
        - nNumberOfBytesToWrite: 기록할 byte 수를 지정한다. pipe로 network 전소을 할 시 65535 byte를 한으로 기록 가능하다.
        - lpNumberOfBytesWritten: 실제로 기록한 byte 수를 return받기 위한 출력용 인수. WriteFile은 호출 즉시 이 값을 0으로 만든다. 
            비동기 입출력을 하지 않을 경우 이 인수는 NULL로 줄 수 없으며 받드시 DWORD형 변수에 대한 포인터를 제공한다. 
        - lpOverlapped: 비동기 입출력을 위한 OVERLAPPED 구조체의 포인터. 파일을 FILE_FLAG_OVERLAPPED flag로 연다면 이 구조체를 
            반드시 제공해야 한다. 비동기 입출력을 사용하지 않을 경우 NULL을 주면 된다                                                                     */

        result = WriteFile(hUsbWrite, (void*)&Cmd, sizeof(LFI_USB_COMMAND48_STRUCT), &nBytesRead, NULL);
    
       if(bJustCmd == TRUE)
        {
            // close devices if needed
            if(hUsbWrite != INVALID_HANDLE_VALUE)
            CloseHandle(hUsbWrite);
        }

        if((result == 1) && (nBytesRead == sizeof(LFI_USB_COMMAND48_STRUCT)))
        {
            TRACE("SendCMD-E\r\n");
            return 0;
        }
        else
         return -1;    
        
}

/*++
Routine Description:
    Called by main() to open an instance of our device after obtaining its name

Arguments:    None

Return Value:    Device handle on success else NULL

설명) USB를 연결하는 함수이며 GetUsbDeviceFileName 함수에서는 연결할 수 있는 이름을 확인만 하고(completeDeviceName)
	  실제 USB를 연결하는 함수는 CreateFile 임
--*/
HANDLE open_fileUSB( char *filename)
{
    int success = 1;
    HANDLE h;

    if ( !GetUsbDeviceFileName((LPGUID) &GUID_CLASS_I82930_BULK, completeDeviceName) )
    {
		//NOISY(("Failed to GetUsbDeviceFileName:%d\n", GetLastError()));
		return  INVALID_HANDLE_VALUE;
    }
    strcat (completeDeviceName, "\\");				/* src문자열을 dest 끝에 연결한다, 이때 마지막에 '\0'을 추가시킨다 */      
    strcat (completeDeviceName, filename);			// filename = "PIPE00"(in), "PIPE01"(out)

    //EB_Printf("completeDeviceName = (%s)\n", completeDeviceName);

    h = CreateFile(completeDeviceName,				// ex) completeDeviceName = "\\?\usb#vid_1a8c&pid_0102#5&15e6108c&0&1#{00873fdf-61a8-11d1-aa5e-00c04fb1728b}\PIPE01"
					GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ,
					NULL, OPEN_EXISTING, 0,	NULL);

    if (h == INVALID_HANDLE_VALUE)
    {
		//NOISY(("Failed to open (%s) = %d", completeDeviceName, GetLastError()));
		success = 0;
    }
    else
    {
	    //NOISY(("Opened successfully.\n"));
    }       

    return h;
}

/*++
Routine Description:

    Given a ptr to a driver-registered GUID, give us a string with the device name
    that can be used in a CreateFile() call.
    Actually briefly opens and closes the device and sets outBuf if successfull;
    returns FALSE if not

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated zero-terminated name for this device

Return Value:

    TRUE on success else FALSE

설명) outNameBuf 이름을 확인한 다음에 곧바로 hDev 핸들을 close 시킴(OpenUsbDevice 함수로 정상적으로 핸들을 생성한 경우라도)
--*/
BOOL GetUsbDeviceFileName( LPGUID  pGuid, char *outNameBuf)
{
    HANDLE hDev = OpenUsbDevice( pGuid, outNameBuf );

    if ( hDev != INVALID_HANDLE_VALUE )
    {
		CloseHandle( hDev );			// 정상적으로 핸들을 생성한 경우라도 곧바로 핸들을 close 시킴
		return TRUE;
    }

    return FALSE;
}

5)	C++Builder C++빌터포럼에서 퍼 온 USB 소스
#include <VCL.H> 
  
#include <WINDOWS.H> 
  
#include <CONIO.H> 
#include <STDIO.H> 
#include <STDLIB.H> 
#include <ASSERT.H> 
#include <TIME.H> 
  
#include "devioctl.h" 
#include <SETUPAPI.H> 
#include <BASETYPS.H> 
#include "usbdi.h" 
  
  
char completeDeviceName[256] = "";  //generated from the GUID registered by the driver itself 
GUID InterfaceClassGuid = {0x4d1e55b2, 0xf16f, 0x11cf, 0x88, 0xcb, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30}; 
  
//------------------------------------------------------------------------------- 
//① 설       명  : 
//    Given the HardwareDeviceInfo, representing a handle to the plug and 
//    play information, and deviceInfoData, representing a specific usb device, 
//    open that device and fill in all the relevant information in the given 
//    USB_DEVICE_DESCRIPTOR structure. 
//② 인       수  : 
//    HardwareDeviceInfo:  handle to info obtained from Pnp mgr via SetupDiGetClassDevs() 
//    DeviceInfoData:      ptr to info obtained via SetupDiEnumInterfaceDevice() 
//③ 리       턴  : 
//    return HANDLE if the open and initialization was successfull, 
//    else INVLAID_HANDLE_VALUE. 
//------------------------------------------------------------------------------- 
HANDLE OpenOneDevice ( 
                      IN       HDEVINFO                    HardwareDeviceInfo, 
                      IN       PSP_INTERFACE_DEVICE_DATA   DeviceInfoData, 
                      IN       char *devName 
                      ) 
{ 
    PSP_INTERFACE_DEVICE_DETAIL_DATA     functionClassDeviceData = NULL; 
    ULONG                                predictedLength = 0; 
    ULONG                                requiredLength = 0; 
    HANDLE                               hOut = INVALID_HANDLE_VALUE; 
  
    // 
    // allocate a function class device data structure to receive the 
    // goods about this particular device. 
    // 
    SetupDiGetInterfaceDeviceDetail ( 
            HardwareDeviceInfo, 
            DeviceInfoData, 
            NULL, // probing so no output buffer yet 
            0, // probing so output buffer length of zero 
            &requiredLength, 
            NULL); // not interested in the specific dev-node 
  
  
    predictedLength = requiredLength; 
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512; 
  
    functionClassDeviceData = (PSP_INTERFACE_DEVICE_DETAIL_DATA)malloc (predictedLength); 
    functionClassDeviceData->cbSize = sizeof (SP_INTERFACE_DEVICE_DETAIL_DATA); 
  
    // 
    // Retrieve the information from Plug and Play. 
    // 
    if (! SetupDiGetInterfaceDeviceDetail ( 
               HardwareDeviceInfo, 
               DeviceInfoData, 
               functionClassDeviceData, 
               predictedLength, 
               &requiredLength, 
               NULL)) 
    { 
        return INVALID_HANDLE_VALUE; 
    } 
  
    strcpy( devName,functionClassDeviceData->DevicePath) ; 
  
    String sDevName = devName; 
    if(sDevName.Pos("hid#vid_04d8&pid_003c") > 0) 
    { 
        hOut = CreateFile ( 
                      functionClassDeviceData->DevicePath, 
                      GENERIC_READ | GENERIC_WRITE, 
                      FILE_SHARE_READ | FILE_SHARE_WRITE, 
                      NULL, // no SECURITY_ATTRIBUTES structure 
                      OPEN_EXISTING, // No special create flags 
                      0, // No special attributes 
                      NULL); // No template file 
  
        if (INVALID_HANDLE_VALUE == hOut) {} 
    } 
    else
    { 
      hOut =  INVALID_HANDLE_VALUE; 
    } 
      
    free(functionClassDeviceData); 
  
    return hOut; 
} 
  
  
//------------------------------------------------------------------------------- 
//① 설       명  : 
//                  Do the require 
//                  the next available proper device in the system at this time. 
//② 인       수  : 
//                  pGuid:      ptr to GUID registered by the driver itself 
//                  outNameBuf: the generated name for this device 
//③ 리       턴  : 
//                  return HANDLE if the open and initialization was successful, 
//                  else INVLAID_HANDLE_VALUE. 
//------------------------------------------------------------------------------- 
HANDLE OpenUsbDevice( LPGUID  pGuid, char *outNameBuf) 
{ 
   ULONG NumberDevices; 
   HANDLE hOut = INVALID_HANDLE_VALUE; 
   HDEVINFO                 hardwareDeviceInfo; 
   SP_INTERFACE_DEVICE_DATA deviceInfoData; 
   ULONG                    i; 
   BOOLEAN                  done; 
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst; 
   PUSB_DEVICE_DESCRIPTOR   *UsbDevices = &usbDeviceInst; 
  
   *UsbDevices = NULL; 
   NumberDevices = 0; 
  
   // 
   // Open a handle to the plug and play dev node. 
   // SetupDiGetClassDevs() returns a device information set that contains info on all  
   // installed devices of a specified class. 
   // 
   hardwareDeviceInfo = SetupDiGetClassDevs ( 
                           pGuid, 
                           NULL, // Define no enumerator (global) 
                           NULL, // Define no 
                           (DIGCF_PRESENT | // Only Devices present 
                            DIGCF_INTERFACEDEVICE)); // Function class devices. 
  
   // 
   // Take a wild guess at the number of devices we have; 
   // Be prepared to realloc and retry if there are more than we guessed 
   // 
   NumberDevices = 100; 
   done = FALSE; 
   deviceInfoData.cbSize = sizeof (SP_INTERFACE_DEVICE_DATA); 
  
   i=0; 
   while (!done) 
   { 
      NumberDevices *= 2; 
  
      if (*UsbDevices) 
      { 
         *UsbDevices = 
               (PUSB_DEVICE_DESCRIPTOR)realloc (*UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR))); 
      } 
      else
      { 
         *UsbDevices = (PUSB_DEVICE_DESCRIPTOR)calloc (NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR)); 
      } 
  
      if (NULL == *UsbDevices) 
      { 
         // SetupDiDestroyDeviceInfoList destroys a device information set  
         // and frees all associated memory. 
  
         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo); 
         return INVALID_HANDLE_VALUE; 
      } 
  
      usbDeviceInst = *UsbDevices + i; 
  
      for (; i < NumberDevices; i++) 
      { 
         // SetupDiEnumDeviceInterfaces() returns information about device interfaces  
         // exposed by one or more devices. Each call returns information about one interface; 
         // the routine can be called repeatedly to get information about several interfaces 
         // exposed by one or more devices. 
  
         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo, 
                                         0, // We don't care about specific PDOs 
                                         pGuid, 
                                         i, 
                                         &deviceInfoData)) 
         { 
  
            hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf); 
            if ( hOut != INVALID_HANDLE_VALUE ) 
            { 
               done = TRUE; 
               break; 
            } 
         } 
         else
         { 
            if (ERROR_NO_MORE_ITEMS == GetLastError()) 
            { 
               done = TRUE; 
               break; 
            } 
         } 
      } 
   } 
  
   NumberDevices = i; 
  
   // SetupDiDestroyDeviceInfoList() destroys a device information set  
   // and frees all associated memory. 
  
   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo); 
  
   if (*UsbDevices)  
       free(*UsbDevices); 
  
   return hOut; 
} 
  
  
//------------------------------------------------------------------------------- 
//① 설       명  : Given a ptr to a driver-registered GUID, give us a string with the device name 
//                  that can be used in a CreateFile() call. 
//                  Actually briefly opens and closes the device and sets outBuf if successfull; 
//                  returns FALSE if not 
//② 인       수  : 
//                  pGuid:      ptr to GUID registered by the driver itself 
//                  outNameBuf: the generated zero-terminated name for this device 
//③ 리       턴  : TRUE on success else FALSE 
//------------------------------------------------------------------------------- 
BOOL GetUsbDeviceFileName( LPGUID  pGuid, char *outNameBuf) 
{ 
    HANDLE hDev = OpenUsbDevice( pGuid, outNameBuf ); 
  
    if ( hDev != INVALID_HANDLE_VALUE ) 
    { 
        CloseHandle( hDev ); 
        return TRUE; 
    } 
  
    return FALSE; 
} 
  
  
//------------------------------------------------------------------------------- 
//① 설       명  : Called by dumpUsbConfig() to open an instance of our device 
//② 인       수  : None 
//③ 리       턴  : Device handle on success else NULL 
//------------------------------------------------------------------------------- 
HANDLE open_dev() 
{ 
    HANDLE hDEV = OpenUsbDevice( (LPGUID)&InterfaceClassGuid, completeDeviceName); 
    return hDEV; 
} 
  
  
//------------------------------------------------------------------------------- 
//① 설       명  : Called by main() to open an instance of our device after obtaining its name 
//② 인       수  : None 
//③ 리       턴  : Device handle on success else NULL 
//------------------------------------------------------------------------------- 
HANDLE open_file( char *filename) 
{ 
    HANDLE h; 
  
    if ( !GetUsbDeviceFileName(  
        (LPGUID) &InterfaceClassGuid, 
        completeDeviceName) ) 
    { 
        return  INVALID_HANDLE_VALUE;  
    } 
  
    strcat (completeDeviceName, 
            "\\"
            );           
  
    strcat (completeDeviceName, 
            filename 
            );                   
  
    h = CreateFile(completeDeviceName, 
        GENERIC_WRITE | GENERIC_READ, 
        FILE_SHARE_WRITE | FILE_SHARE_READ, 
        NULL, 
        OPEN_EXISTING, 
//        FILE_FLAG_OVERLAPPED, 
        0, 
        NULL); 
  
    return h; 
} 
  
  
  
HANDLE open_fileRead( char *filename) 
/*++ 
Routine Description: 
    Called by main() to open an instance of our device after obtaining its name 
Arguments: 
    None 
Return Value: 
    Device handle on success else NULL 
--*/
{ 
    HANDLE h; 
    if ( !GetUsbDeviceFileName((LPGUID) &InterfaceClassGuid, completeDeviceName) ) 
    { 
        return  INVALID_HANDLE_VALUE; 
    } 
    strcat (completeDeviceName,"\\"); 
    strcat (completeDeviceName,filename); 
  
    h = CreateFile(completeDeviceName, 
        GENERIC_READ, 
        FILE_SHARE_READ | FILE_SHARE_WRITE, 
        NULL, 
        OPEN_EXISTING, 
//      FILE_ATTRIBUTE_NORMAL | 
//      FILE_FLAG_OVERLAPPED, // overlapped I/O, 
        0, 
        NULL); 
  
    if (h != INVALID_HANDLE_VALUE) 
    { 
        COMMTIMEOUTS  CommTimeOuts ; 
        CommTimeOuts.ReadIntervalTimeout = MAXDWORD; 
        CommTimeOuts.ReadTotalTimeoutMultiplier = 0 ; 
        CommTimeOuts.ReadTotalTimeoutConstant = 0 ; 
        CommTimeOuts.WriteTotalTimeoutMultiplier = 0 ; 
        CommTimeOuts.WriteTotalTimeoutConstant = 0 ; 
        SetCommTimeouts( h, &CommTimeOuts ) ; 
    } 
  
    return h; 
} 
  
HANDLE open_fileWrite( char *filename) 
/*++ 
Routine Description: 
    Called by main() to open an instance of our device after obtaining its name 
Arguments: 
    None 
Return Value: 
    Device handle on success else NULL 
--*/
{ 
    HANDLE h; 
    if ( !GetUsbDeviceFileName((LPGUID) &InterfaceClassGuid, completeDeviceName) ) 
    { 
        return  INVALID_HANDLE_VALUE;  
    } 
    strcat (completeDeviceName,"\\"); 
    strcat (completeDeviceName,filename);                    
  
    h = CreateFile(completeDeviceName, 
        GENERIC_WRITE | GENERIC_READ, 
        FILE_SHARE_WRITE | FILE_SHARE_READ, 
        NULL, 
        OPEN_EXISTING, 
        0, 
        NULL); 
  
    return h; 
} 

6)	 [궁금] USB 디바이스의 Vendor ID ' Product ID는 어떻게...  | Other 2000-09-14 오후 5:53:26 
 
김희겸  번호: 14  / 읽음:317 
지금 일하고 있는 곳에서, USB 장비를 하나 만들었는데.
Vendor ID와 Product ID는 usb.org에서 받아야 한다고 합니다.
(현재까지는 임의로 정해서 사용하고 있었음.)

제가 이런일에 조금 미숙해서...(죄송 합니다.)
혹시 발급 받는 방법을 아시는 분 있으시면, 조언 좀 해주시면 고맙겠습니다... 
 
 [답변]제대로 알고 계시네요.. 2000-10-11 오후 11:02:07 
유장호  번호: 52   
제대로 알고계시군요.
VENDOR ID는 USB.ORG에서 신청하면 되고
PRODUCT ID는 맘대로 쓰셔도 됩니다...
일년에 800불 가량 내야 한다고 하더군요... 




[54]	UART 통신
1)	데이터 전송 속도(BPS) 
  1)정의
     1 초에 전송된 bit수.일정 시간동안 전송된 data의 양을 나타냄
     예) 9600bps 	: 1 초 동안에 9,600개의 bit를 전송		= 1초 동안에 1200개의 bytes를 전송	= 1byte 전송에 0.83msec 소요	= 1byte 전송에 1msec 소요
     예) 115200bps	: 1 초 동안에 115,200개의 bit를 전송	= 1초 동안에 14400개의 bytes를 전송	= 1byte 전송에 0.069msec 소요
     예) 4800bps	: 1 초 동안에 4,800개의 bit를 전송		= 1초 동안에 600개의 bytes를 전송	= 1byte 전송에 1.66msec 소요




[55]	AM12시 PM12시
1)	AM : ante meridiem 의 약어(오전, 정오이전)	cf) 정오 : 낮 열두 시
	PM : post meridiem 의 약어(오후, 정오이후)
2)	24시간제		12시간제		설명
	0시				AM12시			자정(밤)	cf) 자정 : 밤 열두 시
	1시				AM1시			새벽
	11시59분		AM11시59분		정오 되기 전
	12시			PM12시			정오(낮)
	13시			PM1시			정오 이후
	23시59분		PM11시59분		밤
	
	
	

[56]	Atmel Studio 6에서 STK500을 가지고 ATmega128 프로그램 다운로드 하기
1)	http://www.atmel.com/Images/as6installer-6.0.1843.exe 사이트에서 Atmel Studio 6 다운로드 받기
2)	C:\Program Files\Atmel Studio 6.0\tools\STK500\xml 폴더에
	ATmega128_stk500.xml 파일을 추가
3)	cf)	USB to Serial 포트는 15로 지정하면 Atmel Studio 6를 실행해도 Error 발생함
		USB to Serial 포트는 5로 지정하니 Atmel Studio 6를 실행해도 Error 발생하지 않음
		



[57]	Map 파일의 Code, RO data, RW data, ZI data?
1)	C언어로 코드 작성 뒤에 컴파일해서 이미지 파일이 나올 때 코드나 상수는 RO에 일반 변수는 RW에 전역변수는 ZI에 저장이 되게 됩니다. ASM일 경우에도 마찬가지입니다. 
2)	1. Code:	실제로 수행되는 부분, 즉 code instruction, 이 들어가는 부분이죠. 절대로 고쳐져서도 안되며 일반적으로 FlashROM에서 직접 수행합니다. 
				만일 FlashROM의 속도가 늦다면 SRAM이나 SDRAM에 복사한 후 수행을 하기도 합니다. 
	2. RO data:	변해서는 안돼는 data가 저장되는 공간입니다. 예를들어 C에서 const라고 선언하시면서 초기값을 주면 그 값이 여기 저장이 되는거죠. 
				위의 code와 마찬가지로 일반적으로 FlashROM에서 직접 읽어거나 FlashROM의 속도가 늦다면 SRAM이나 SDRAM에 복사한 후 사용됩니다.
	3. RW data:	초기값이 있긴하지만 변할수도 있는 data (변수)가 저장이 되는 곳이지요. 저장되기는 FlashROM에 있지만, 수행하기 전에 SRAM이나 SDRAM에 복사한 후 사용됩니다.
	4. ZI data:	Zero Initialized data라고 생각하시면 되겠습니다. bss라고도 많이 합니다. 수행하기전에 0으로 초기화되는 data(변수)가 저장되는 공간입니다. 
				이부분은 FlashROM에 저장될 필요는 없지만 수행할때는 SRAM이나 SDRAM에 공간이 설정되고 0으로 초기화된다음 사용됩니다.
	[출처] Map 파일의 Code, RO data, RW data, ZI data?|작성자 해바라기 ObjC

RealView Compilation Tools 링커 사용 설명서 버전 4.0 
Home > 기본 링커 기능 사용 > 이미지에 대한 정보 얻기 
3.10. 이미지에 대한 정보 얻기
--info 옵션을 사용하여 링커가 이미지를 생성하는 방법에 대한 정보를 얻을 수 있습니다. 예를 들면, 다음과 같습니다.

armlink --info sizes ...
여기서 sizes는 이미지의 각 입력 객체와 라이브러리 구성원에 대한 코드 및 데이터 크기의 목록을 제공합니다. 이 옵션의 사용은 --info sizes,totals를 의미합니다.
자세한 내용은 링커 참조 설명서에서 2-28페이지의 --info=topic[,topic,...]을 참조하십시오.
Example 3.2에서는 출력을 표 형식으로 표시하고 합계는 읽기 쉽도록 별도로 표시합니다.

Example 3.2. 이미지 정보
Code (inc. data)   RO Data   RW Data    ZI Data      Debug
3712        1580        19        44      10200       7436   Object Totals
0              0        16         0          0          0   (incl. Generated)
0              0         3         0          0          0   (incl. Padding)
21376        648       805         4        300      10216   Library Totals 
0              0         6         0          0          0   (incl. Padding)
===============================================================================
Code (inc. data)   RO Data    RW Data    ZI Data      Debug
25088       2228       824         48      10500      17652   Grand Totals
25088       2228       824         48      10500      17652   ELF Image Totals
25088       2228       824         48          0          0   ROM Totals
===============================================================================
Total RO  Size (Code + RO Data)             25912 (  25.30kB)
Total RW  Size (RW Data + ZI Data)          10548 (  10.30kB)
Total ROM Size (Code + RO Data + RW Data)   25960 (  25.35kB)

Code (inc. Data)
코드가 차지하는 바이트 수를 표시합니다. 이 이미지에는 3712바이트의 코드가 있습니다. 이 중에서 리터럴 풀과 짧은 문자열과 같은 인라인 데이터 (inc. data)는 1580바이트입니다. 

RO Data
읽기 전용 데이터가 차지하는 바이트 수를 표시합니다. 이것은 Code (inc. data) 열에 있는 인라인 데이터에 추가됩니다.

RW Data
읽기/쓰기 데이터가 차지하는 바이트 수를 표시합니다.

ZI Data
0으로 초기화된 데이터가 차지하는 바이트 수를 표시합니다.

Debug
디버그 입력 섹션, 기호 및 문자열 테이블과 같은 디버그 데이터가 차지하는 바이트 수를 표시합니다.

Object Totals
이미지를 생성하기 위해 함께 링크된 객체가 차지하는 바이트 수를 표시합니다.

(incl. Generated)
armlink는 예를 들어, 인터워킹 베니어와 영역 테이블과 같은 입력 섹션 등의 이미지 내용을 생성할 수 있습니다. Object Totals 행에 이러한 유형의 데이터가 있으면 이 행에 표시됩니다. Example 3.2에는 총 19바이트의 RO 데이터가 있고 이 중에 16바이트는 링커에서 생성한 RO 데이터입니다.

Library Totals
이미지에 개별 객체로 추출되고 추가된 라이브러리 구성원이 차지하는 바이트 수를 표시합니다.

(incl. Padding)
필요한 경우 armlink에서 패딩을 삽입하여 섹션 정렬을 강제로 수행합니다 (섹션 정렬 참조). Object Totals 행에 이러한 유형의 데이터가 있으면 연관된 (incl. Padding) 행에 표시됩니다. 마찬가지로 Library Totals 행에 이러한 유형의 데이터가 있으면 이와 연관된 행에 표시됩니다. Example 3.2에는 객체 전체에 19바이트의 RO 데이터가 있으며 이 중 3바이트는 링커에서 생성한 패딩입니다. 라이브러리 전체에는 805바이트의 RO 데이터가 있으며 이 중 6바이트가 패딩입니다.

Grand Totals
이미지의 실제 크기를 표시합니다. Example 3.2에서 Object Totals에는 10200바이트의 ZI 데이터가 있고 Library Total)에는 300바이트의 ZI 데이터가 있어 총 10500바이트를 표시합니다.

ELF Image Totals
RW 데이터 압축 (기본값)을 사용하여 ROM 크기를 최적화하는 경우 최종 이미지의 크기가 변경되고 이 변경 내용이 --info를 통한 출력에 반영됩니다. Grand Totals와 ELF Image Totals의 바이트 수를 비교하여 압축 결과를 확인합니다.

Example 3.2에서는 RW 데이터 압축을 사용하지 않습니다. 데이터를 압축하면 RW 값이 변경됩니다. 자세한 내용은 RW 데이터 압축을 참조하십시오.

ROM Totals
이미지를 포함하는 데 필요한 최소 ROM 크기를 표시합니다. 여기에 ROM에 저장되지 않는 ZI 데이터 및 디버그 정보는 포함되지 않습니다.




[58]	STK500 사용시 주의 사항
1.	주의 사항
	아래와 같은 조건으로 F/W Writing 시
	ISP가 접속 조차 되지 않는 문제가 발생하며
	1) Target board : ATmega128_RS232-485_Convertor
	2) ISP : STK500
	3) ISP Program : AVR Studio 4

2.	원인
	본, 에러가 일어나는 원인은 ISP Reset 신호가
	Target board의 Reset 회로의 10uF Capacitor와 연결되어 있어서
	Reset이 제대로 걸리지 않는 것이 원인이다(Reset신호가 High 상태이어야 하는데 톱니 파형으로 변경되어 ATmega128 Reset input으로 들어감)

3.	해결방안
	어쩔 수 없이 F/W Writing 시 마다 10uF Capacitor를 Reset 회로에 연결시키지 말고 Writing 한 다음에
	평상시 회로 구동시에는 다시 10uF Capacitor를 Reset 회로에 연결시켜서 사용해야 함




[59]	분자진단
	1)	바이오니아 RT-PCR 소스
		ExiDiagRun_HT_2012-11-23 (바이오니아 Real time PCR Source)
		AllTogether.sln 이 모든 기능을 묶어 놓은 Solution 파일 임
	2)	ABI RT-PCR 원리
		광원은 할로겐램프를(백색광원: 완전한 것은 아니지만 자외선부터 가시광선을 거쳐서 적외선까지 전 파장때의 빛이 발산,
		단, 할로겐램프 문제점은 Lifetime이 1년으로 짧기 때문에 1년 마다 Calibration 실시와 어느 정도 시간 지나면 할로겐램프 교체해줘야 함)
		사용하며, 피사체와 반사된 빛을 자외선/적외선 필터 등을 써서 특정 파장만 걸려내서 Camera로 읽어 내는 방식이다.
		cf) 할로겐램프 말고 어떤(?)램프는 자외선부터적외선까지 전 파장때의 빛이 나오는 램프가 있다고 함, 하지만 본 램프는 할로겐램프 보다 더 비싸다고 함




[60-3]	C++ 기본문법
1-1.C++에서 :: 기호의 의미 
:: 이 기호는 Scope Operator 즉 범위지정연산자라고 합니다.

이것을 쓰는 예는
className::
NameSpaceName::
::
위 3가지가 있습니다.첫번째는
class를 선언하였을경우예를 들어 
class A
{
    //각종 함수또는 변수들
};
라고 했을경우

클래스 A안에 있는 각종 함수들과 변수들은 
A라는 클래스 안에 있으므로 
A의 범위를 가집니다. 그래서..

보통방법으로 클래스함수를 접근할수 없습니다.

때문에 A::이런 방법을 사용하여 함수를 정의 하는것이죠
class Name
{
    public:
    void Print();
};

void Name::Print()
{
}
이런식으로 클래스 메소드를 정의 하게 됩니다.2번째 namespace라는 것은 
간단히 말해서 영역구분 입니다.예를 들어서 여러사람이 코딩을 하였을시에 
변수나 클래스이름이 같을수 있습니다. 때문에
namespace라는 키워드를 주어 영역을 구분하는 것입니다.

클래스해서 쓰인 ::와 마찬가지로
namespace:: 로 사용가능합니다.

namespace a
{
    void Print()
    {
    }
}

namespace b
{
    void Print();
    {
    }
}
이런식으로 사용하게 되는데

a::Print();라고 호출하면 영역 a에 잇는 Print()가 호출
b::Print();라고 호출하면 영역 b에 있는 Print()가 호출 됩니다.마지막으로
그냥 ::하게 되면

현재 존재하는 모든 전역함수,전역변수들을 
지역변수와 구분지어 사용할수 있게 됩니다.사용자가 정의한 전역함수도
::
를 사용하여 호출할수 있습니다.

1.	함수 템플릿(Function Template).
	함수를 만들어 낼때, 함수의 기능은 명확하지만,?자료형을 모호하게 두는 것

예시1)	함수 sum : 인자 2개를 받아서 더한 값을 return 하는 함수를 예로 들겠습니다.
		C++에서는 다형성의 오버로딩(overloading)특성에 의해?함수이름이 같아도 되므로,

template 가 없을때는 아래와 같이 각각 인자의 타입을 다르게 해서 만들면 된다.
int sum(int a, int b)
{
	return a+b;
}
double sum(double a, double b)
{
	return a+b;
}

하지만 template를 사용하게 되면. 아래와 같이 하나의 함수만 정의하면 된다.
(간편하네..이걸 이제야 알다니)
template <typename T>
T sum(T a, T b)
{
	return a+b;
}

예시1 의 전체 코드
#include<iostream>
#include<string>

using namespace std;

template <typename T>
T sum(T a,T b)
{
	return a+b;
}

int main(void)
{
	int a=1, b=2;
    
	double d1=2.2;
	double d2=3.3;

    string s1="Show me ";
    string s2="The Money 6";

	cout << "int 합 : " << sum<int>(a,b) << endl;
	cout << "double 합 : " << sum<double>(d1,d2) << endl;
    cout << "string 합 : " << sum<string>(s1,s2) << endl;

    return 0;
}
//template 함수는 호출할때 명확하게 어떤 자료형을 쓸 건지 < > 안에 표시해주는게 좋습니다.

예시1의 출력
int 합 : 3
double 합 : 5.5
string 합 : Show me The Money 6


예시2) 인자를 2개 받을때 두개의 타입이 다른 경우
template <class T1, class T2>
void printAll(T1 a,T2 b)
{
    cout << "T1 : " << a << endl;
	cout << "T2 : " << b << endl;
    cout << "T1 + T2 : " << a + b << endl;
}

예시2의 전체 코드
//template로 사용하는 변수가 2개 이상일 경우에는 함수이름 뒤에 <> 안에 명확하게 사용하지 않습니다.
//그 때에는 컴파일러가 스스로 자료형을 판단합니다.
#include <iostream>
#include <string>
 
using namespace std;
 
template <class T1, class T2>
void printAll(T1 a, T2 b){
    cout << "T1 : " << a << endl;
    cout << "T2 : " << b << endl;
};
 
int main(void)
{
    string s1 = "Dok2" ;
    string s2 = "On my way." ;
 
    int num1 = 27;
    int num2 = 35;
 
    double d1 = 3.14;
    double d2 = 36.5;
 
    cout << "[string, string]" << endl;
    printAll(s1, s2);                   //printAll<string, string>(s1,s2);
 
    cout << "[string, int]" << endl;
    printAll(s1, num1);                 //printAll<string, int>(s1,num1);
 
    cout << "[int, int]" << endl;
    printAll(num1, num2);
 
    cout << "[int, double]" << endl;
    printAll(num1, d1);
 
    cout << "[double, double]" << endl;
    printAll(d1, d2);
 
    cout << "[double, string]" << endl;
    printAll(d1, s1);
 
    return 0;
}

예시2의 출력
[string, string]
T1 : Dok2
T2 : On my way.
[string, int]
T1 : Dok2
T2 : 27
[int, int]
T1 : 27
T2 : 35
[int, double]
T1 : 27
T2 : 3.14
[double, double]
T1 : 3.14
T2 : 36.5
[double, string]
T1 : 3.14
T2 : Dok2

출처: http://blockdmask.tistory.com/43 [개발자 지망생]




[60-2]	C# 기본문법
1-3.C# 클래스 상속
C#에서 일종의 부모 클래스인 베이스 클래스(base class)로부터 상속하여 새로운 파생 클래스(derived class)를 만들 수 있다. 
상속(inheritance)을 사용하게 되면 베이스 클래스의 데이타 및 메서드들을 (public 혹은 protected 멤버의 경우) 파생클래스에서 
사용할 수 있게 된다. 파생 클래스는 베이스 클래스로부터 물려 받는 멤버들 외에 대개 새로운 메서드 및 데이타를 추가해서 
사용하게 된다.
C#에서는 파생 클래스명 뒤에 Colon (:)을 찍고 베이스 클래스명을 써 주면 상속이 이루어 진다. 
제약점은 C#에서는 파생클래스가 단 하나의 베이스 클래스로부터 상속되어져야 한다는 것이다. 
즉, 하나의 파생클래스는 2개 이상의 베이스 클래스를 가질 수 없다. 아래 예는 파생클래스가 베이스 클래스의 속성(Property)을 
사용하는 예이다. 

// 베이스 클래스
public class Animal
{
   public string Name { get; set; }
   public int Age { get; set; }
}

// 파생클래스
public class Dog : Animal
{       
   public void HowOld() 
   {
      // 베이스 클래스의 Age 속성 사용
      Console.WriteLine("나이: {0}", this.Age);
   }
}

public class Bird : Animal
{       
   public void Fly()
   {
      Console.WriteLine("{0}가 날다", this.Name);
   }
}

1-2.추상 클래스 (Abstract Class)
C#의 클래스명 앞에 abstract라는 C# 키워드 붙이는 경우가 있다. 이를 추상 클래스라고 하는데, 
이러한 종류의 클래스로부터는 객체를 직접 생성할 수 없다. 즉, new를 이용하여 클래스 객체를 생성할 수 없다.
또한 추상 클래스안에 어떤 멤버 앞에 abstract 키워드를 붙이는 경우가 있는데, 이��� 해당 멤버가 구현되지 않았으며, 
추상 클래스로부터 파생되는 파생클래스에서 반드시 그 멤버를 구현해 주어야 한다는 것을 의미한다. 
파생 클래스에서는 abstract 메서드를 구현하기 위해서는 override 라는 C# 키워드를 사용하여 그 메서드를 새로 정의한다. 

public abstract class PureBase
{
   // abstract C#키워드 
   public abstract int GetFirst();
   public abstract int GetNext();   
}

public class DerivedA : PureBase
{
   private int no = 1;

   // override C#키워드 
   public override int GetFirst()
   {
      return no;
   }

   public override int GetNext()
   {
      return ++no;
   }
}

cf)	츠상클래스
	cf)	내생각:	어떤 규격에 맞는 기능을 구현해야 하는데 내가 하기는 싫고 그 기능을 구현하고자 하는 곳에서 알아서 구현해서 써라
				그런데 이때 이런 기능을 왜 사용하냐 하면 규칙은 규정해 놓아야지만 제멋대로 메서드를 만들어서 사용하는 사람이 생기지 않기 대문

abstract는 추상적인 이라는 뜻을 가지고 있는데요, 메소드 앞에 붙여주면 이런 뜻이 됩니다.
"이 메소드는 아직 정의하지 않았으니, 쓰고 싶으면 너가 정의해!"
그리고 하나 더 무서운 의미를 담고 있습니다.
"대신에 너도 정의하지 않으면.... 너도 나와 같은 추상클래스가 될 줄 알아!"
그리고 클래스 선언부에도 abstract을 달아주죠. 이건 "나 추상클래스야!" 라는 뜻입니다.

이 말을 풀어서 적어보자면
부모클래스에 변수, 메소드, 만들다가 만 메소드(추상메소드)가 있는데
자식클래스가 이 메소드를 정의한다면, 전부 사용을 하게 해주고
자식클래스가 이 메소드를 정의하지 못한다면, 자식의 자식클래스에게 책임이 넘어가는 것입니다.
자 말로만 들어서는 이해가 잘 안가시죠? 예제 같이 보겠습니다.

도형에 대한 계산과 관련된 ShapeCalculator라는 클래스가 있습니다.
그리고 그 안에는 도형의 넓이를 구하는 calcArea()라는 메소드가 있죠.
물론 이 메소드를 오버로딩한다거나, 메소드 안에서 if문을 여러 번 써서 각 도형에 맞는 넓이를 구해줄 수도 있습니다.
하지만 abstract(추상화)의 첫 번째 목적은 분업화 입니다.
부모클래스에서 자식클래스들이 필요로 하는 기능을 다 구현하는게 아니라 필요한 기능을 각자 구현 하도록 하는 것입니다.
부모클래스에서 다 구현을 해버리면 유지/보수도 힘들뿐더러 코드가 길어집니다.

두 번째 목적은 책임을 부여하는 것입니다.
재정의는 책임이 없습니다. 자식클래스에서 재정의를 해도 되고 안해도 되요. 의무가 아닙니다.
하지만 추상메소드는 자식클래스가 됬던, 그 자식의 자식의 자식이 됬던, 누군가는 정의를 내려줘야 합니다.
정의를 내려주지 않으면 그 클래스도 결국엔 추상클래스가 돼요.
추상클래스는 객체를 생성할 수 없습니다. Book b = new Book(); 이런게 불가능 하다는 것입니다.
반대로 말하면 객체를 생성하기 위해서는 추상메소드를 구현해야한다는 것이죠.

이거 보니까 게임하고 싶네요..

좀 더 현실적인 예로 들어볼까요?
롤이 라는 게임이 있습니다. 캐릭터마다 q,w,e,r 이라는 스킬이 있어요.
롤에 캐릭터 종류가 한 100가지도 넘는데, 그럼 스킬의 종류가 400가지가 넘겠죠??
이걸 한 클래스안에서 스킬을 다 구현할 수 있나요??? 무리가 있겠죠?
그래서 그 스킬의 구현을 각 캐릭터 클래스에게 맡기는 겁니다.
-> 분업화

자 근데 개발팀에서 새로운 캐릭터를 만들다가 실수로 q,w만 만들고 e,r을 빼먹어 버린거에요.
유저들한테 욕을 한바가지 먹었겠죠?
이런일이 발생하면 안되기 때문에 스킬을 만약 다 구현하지 못하면 캐릭터 자체가 생성되지 못하도록 하는거에요.
이게 바로 추상클래스의 책임 '부여' 입니다.
-> 부모클래스가 추상클래스이면, 자식클래스는 추상클래스가 되거나, 메소드를 정의해야함

추상클래스 개념이 어려울까봐 최대한 쉬운 예제로 알려드리려고 노력했는데
이해가 잘 되셨을지 모르겠네요..! 

+ 추상클래스를 쓰면 부모클래스 입장에서는 추상메소드가 하위클래스에서 정의 됐을거란 '보장'을 받
 그 추상메소드를 활용한 다른 기능을 구현할 수도 있는 거랍니다 

+ final과 abstract는 같이 올 수 없습니다. final은 재정의 금지인데 abstract는 정의 필수 이거든요.

+ 부모클래스의 생성자에서 추상메소드를 부르면 자식의 메소드를 부를 수 있습니���.
[출처] [Java] #6-3 자바 추상클래스 개념 : abstract|작성자 mdown

1-1.public / protected 멤버 
C#의 클래스 멤버 중 public으로 선��된 멤버들은 (파생클래스 포함한) 모든 외부 클래스에서 엑세스 할 수 있다. 
만약 모든 클래스에서 사용되지 않게 하고 단지 파생클래스에서만 사용하게 하고 싶다면, 
protected 라는 접근제한자(Access Modifier)를 사용한다.

public class MyBase
{
   public string Name { get; set; }
   protected int Age { get; set; }
}

public class MyDerived : MyBase
{       
   public void Run()
   {      
      // 파생클래스이므로 Age 사용 가능
      Console.WriteLine("나이: {0}", this.Age);
   }
}

1.	struct는 생성 시 new 연산자 사용 안함
2.	class는 생성 시 new 연산자 사용 함
3.	생성한 참조 변수 소멸시키고 싶을 때 ex)	testClass = null; 명령과 같이  할당시키면 됨
4-1.object vs var
1)	object는 정수면 정수, 문자열이면 문자열.. 이런 지정된 특정 형식의 타입이 아니라.
	모든 것들을 아무르는 형태의 데이터협입니다.
	
	모든 것 들을 담을 수 있는 데이터 형인 것이죠.
	
	C#에서 자료형이 Object에서 상속을 받아서 출발하니.. 선언할 수 있는 모든 자료형을 오브젝트로
	선언할 수 잇는 것 입니다.
	
	예제)
			object a = -100;
			object b = 999.12342332;
			object c = true;
			object d = "object 형식은 다 담아집니다.";
			var a1 = -100;
			double a2 = 0;
		
//			a2 = (double)a;		// object로 선언하면 원본의 특성을 상실하며 본 명령의 경우 에러 발생 함
			a2 = (double)a1;	// 에러 발생하지 않음

			Console.WriteLine(a);
			Console.WriteLine(b);
			Console.WriteLine(c);
			Console.WriteLine(d);
			Console.WriteLine(a2);
	출력)
			-100
			999.12342332
			True
			object 형식은 다 담아집니다.
			-100	
2)	C#의 다양한 타입(type) 선언 : var vs. dynamic vs. object  CSharp / Language  

C#이라는 언어가 처음 세상에 나왔을 때는 기존의 다른 컴파일 언어들과 비슷하게 명시적 타입 선언만을 제공하였다. 
 
예를 들어 
 
문자열을 선언할 경우 : string name; 
정수형을 선언할 경우 : int number; 
 
와 같이 선언을 하였다. 하지만 Functional Programming, LINQ 와 같은 개념 혹은 스펙이 추가 되면서 다양한 타입 선언 방식을 
제공하고 있다. 여기서는 기존 명시적 타입 선언 이외에 var, dynamic, object 의 공통점 및 차이점에 대해 알아 보도록 하겠다. 
 
object 
어떠한 타입이라도 변수로 선언하여 사용할 수 있다. 단 값 형식(value type)을 참조형식(reference type)으로 
다시 참조형식을 값 형식으로 형 변환을 할 경우 박싱(boxing : 값형식 -> 참조형식), 언박싱(unboxing : 참조형식 -> 값형식) 과정이 
일어나며, 성능상 영향을 미칠 수 있다. 
 
var 
var(Local Variable Type)은 C# 3.0에서 처음 등장한 것으로 var로 선언된 변수는 닷넷에서 제공하는 대부분의 형식 사용할 수 있다.
var 형식은 기존에 닷넷에서 존재하는 형식에서 사용하기 보다는 익명 형식(anonymous type)을 위해 탄생했다고 봐도 될 것이다. 
익명 형식은 아래 코드처럼 타입의 이름을 지정하지 않고 사용 시점에 바로 바로 선언하여 객체로 사용할 수 있다. 
하지만 기존 언어적 특성에서는 모든 타입은 명시적으로 선언되어야만 사용할 수 있었다. 
이러한 점을 해결하고자 var 형식이 나오게 되었다. var 형식은 최초 초기화되어 타입이 정해진 이후에는 타입을 변경할 수 없다. 
그러므로 null로는 초기화 할 수 없다. 반드시 선언 시점에 특정 타입으로 초기화 되어야 한다. 
var 타입은 선언 시점에서 타입을 추정하기 때문에 IDE에서 해당 타입에 맞는 인텔리센스가 완벽하게 지원 된다. 
 
var items = new[]
{
    new {Title = "A", StartDate = "20121210", EndDate = "20121231"},
    new {Title = "B", StartDate = "20121201", EndDate = "20121231"},
    new {Title = "C", StartDate = "20121207", EndDate = "20121208"},
    new {Title = "D", StartDate = "20121217", EndDate = "20121231"},
    new {Title = "E", StartDate = "20121203", EndDate = "20121210"}
};
[익명 형식(anonymous type) 선언 예] 

 
var 형식은 다음과 같은 특징을 가지고 있다. 
	사용 가능 한 type 
		built-in type 
		anonymous type 
		user-defined type 
		type defined in the .NET FCL 
	선언시 유의사항 
		var temp; //초기화기 되지 않음 
		var temp = null; //특정한 type을 가져야 함. 
		메소드의 파라미터로 사용할 수 없음 
 
dynamic 
C# 4.0에 오면서 상호 운영성(interop)에 대한 부분이 많이 강조가 되었다. 
C#과 VB, COM등 과의 연동 등 기존의 복잡함을 dynamic 타입을 통해서 개발 시점에 많이 간결하게 처리가 가능하다. 
dynamic 타입은 컴파일 시점에 타입에 대한 확인을 하지 않기 때문에 개발 시점에서 인텔리센스는 동작하지 않는다. 
 
var vs. dynamic vs. object 무엇이 다른가? 
	( var, dynamic) vs. object 
		공통점 : 선언 시점에 다양한 타입을 지정할 수 있다. 
		차이점 : var, dynamic 타입은 선언된 원본 형식을 유지한다. 하지만 object 으로 선언을 하게 되면 원본의 특성을 읽어 
					버리게 된다. object로 선언 되었다가 원본 형식으로 바꾸기 위해서는 반드시 형변환 처리가 필요하다. 
					아래 각 타입으로 선언시 인텔리센스 화면을 보면 그 차이를 좀더 확실히 확인이 가능하다. 
	var vs. dynamic 
		공통점 : 닷넷에서 지원하는 대부분의 타입을 선언할 수 있으며, 원본 타입의 특정을 가지고 있다. 
		차이점 : 두 타입에서 가장 큰 차이점은 타입이 확정 되는 시점이다. var 타입은 컴파일 시점에 이미 타입을 추정하여 
		확정을 하게 된다. 하지만 dynamic 타입은 런타임 시점이 타입이 확정되게 된다. 그러므로 dynamic 형식으로 사용하는 
		값이 올바르지 않은 타입이 지정이 되더라도 컴파일 시점에서는 모두 by-pass 되며, 런타임 시점에 예외를 발생하게 된다. 
		이점을 유의 해야 된다. 
 
							var				dynamic
	형식의 확정 시점		Compile time	Runtime
	바인딩(binding) 방식	Static Binding	Late Binding
 
object value1 = "123";
value1.	
		Equals
		GetHashCode
		GetType
		ToString
[object로 선언을 하면 원본의 특성을 상실하게 된다. 선언된 값은 object 자체인 것이다.] 

var value2 = "123";
value2.	
		ToString
		ToUpper
		ToUpperInvariant
		Trim
		TrimEnd
		TrimStart
		Union<>
		Where<>
		Zip<> 
[타입을 추정하여 원본의 특성을 유지한다. 각 타입에 맞는 인텔리센스가 작동하는 것을 볼 수 있다.] 

dynamic value3 = "123";
value3.
		(동적 식)
		이 작업은 런타임에 확인됩니다.
[원본의 특성을 유지 하지만, 컴파일 시점에서는 확인을 할 수 없기 때문에 인텔리센스가 동작하지 않는다.] 

->	결론적으로 var 선언과 명시적 타입 선언의 차이점은 없다. 단, var 이외의 방식은 사용 방법에 따라 성능에 영향을 미칠 수 있으므로, 
	명확한 목적에 따라 사용해야 한다.
[출처] C#의 다양한 타입(type) 선언 : var vs. dynamic vs. object|작성자 SuYoung Kim

cf)	dynamic 예제 
// 1. dynamic은 중간에 형을 변환할 수 있다.

dynamic v = 1;
// System.Int32 출력
Console.WriteLine(v.GetType());

v = "abc";
// System.String 출력
Console.WriteLine(v.GetType());


// 2. dynamic은 cast가 필요없다

object o = 10;
// 틀린표현
// (에러: Operator '+' cannot be applied to operands of type 'object' and 'int')
o = o + 20;
// 맞는 표현: object 타입은 casting이 필요하다
o = (int)o + 20;

// dynamic 타입은 casting이 필요없다.
dynamic d = 10;
d = d + 20;


	
4.	is, as 연산자
	as 연산자
	-	casting을 위한 연산자
	-	casting에 실패하면 null을 반환
	-	참조 형식 또는 nullable 형식에서만 사용 가능
	is 연산자
	-	casting 가능 한지 확인 연산자
	-	Java의 instanceof 연산자와 매우 유사
	-	casting이 가능하면 true를 반환하고 불가능하다면 false 반환
	
	as 연산자 예제
	static void Main()
	{
		object[] temp = new object[2];
		temp[0] = "test code";
		temp[1] = 2016;
		
		string str1 = temp[0] as string;	//	"test code"가 들어감
		string str2 = (string)temp[0];		//	바로 위 명령과 동일한 명령 임
		string str3 = temp[1] as string;	//	제대로 casting 되지 않아서 null 반환
		
		int num1 = temp[1] as int;			//	구문오류 발생, 왜냐하면 as 연산자는 참조 형식 또는 nullable 형식과 함께 사용해야 하기 때문임
											//	int에는 null을 넣을 수 없기 때문에 이 구문은 틀린 것임
											//	nullable을 허용하지 않는 변수들을 우리는 value type이라 부른며
											//	따라서 float, double 등 value type에는 as 연산자를 사용할 수 없다.
											//	이러한 value type들은 아래와 명령과 같이 casting 해줘야 한다.
		int num2 = (int)temp[1];		
	}
	
	is 연산자 예제
	static void Main()
	{
		object[] temp = new object[2];
		temp[0] = "test code";
		temp[1] = 2016;
		
		bool result = temp[0] is string;	//	true 반환
		result = temp[1] is string;			//	false 반환
	}
	
5.	ref 연산자
	주소참조연산자,	ex)	static void Swap(ref int a, ref int b)
6.	상속
	class Student
	{
		......
	}
	class UniversityStudent: Student
7.	Thread
	한 스레드가 끝난 후에 다른 스레드가 접근하게 하려고 할 때 lock문을 사용한다.
	
1)	Thread 예제1
class Helper
{
    public void Run()
    {
        Console.WriteLine("Helper.Run");
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Helper클래스의 Run메서드 호출
        Helper obj = new Helper();
        Thread t = new Thread(obj.Run);
        t.Start();
    }
}

2)	Thread 예제2
using System;
using System.Threading; <p></p>
<p>class Test {
  static void Main(){ 
   Console.WriteLine("카운트 0부터 1만까지 세기!");
   ThreadStart th = new ThreadStart(work);
   Thread t = new Thread(th);
   t.Start();	//시작
   t.Abort();	//강제종료(무조건)
// t.Join();	//해당쓰레드가 다 실행될 때 가지 기다렸다가 종료
   Console.WriteLine("끝!");
  }
  public static void work(){
   for (int i = 0; i<10000; i++){
    Console.WriteLine("Conut:{0}",i);
   }
  }
}

2)	lock 사용하지 않은 Multi Thread 예제
using System;
using System.Threading;

namespace MultiThrdApp
{
    class MyClass
    {
        private int counter = 1000;

        public void Run()
        {
            // 10개의 쓰레드가 동일 메서드 실행
            for (int i = 0; i < 10; i++)
            {
                new Thread(UnsafeCalc).Start();    
            }
        }

        // Thread-Safe하지 않은 메서드 
        private void UnsafeCalc()
        {
            // 객체 필드를 모든 쓰레드가 
            // 자유롭게 변경
            counter++;

            // 가정 : 다른 복잡한 일을 한다
            for (int i = 0; i < counter; i++)
                for (int j = 0; j < counter; j++) ;

            // 필드값 읽기
            Console.WriteLine(counter);
        }
    }
}
->	결과(아래와 같이 counter가 순차적으로 증가하지 않고 뒤죽박죽 증가함)
1005
1005
1007
1006
....

3)	lock 사용한 Multi Thread 예제
using System;
using System.Threading;

namespace MultiThrdApp
{
    class MyClass
    {
        private int counter = 1000;

        // lock문에 사용될 객체
        private object lockObject = new object();

        public void Run()
        {
            // 10개의 쓰레드가 동일 메서드 실행
            for (int i = 0; i < 10; i++)
            {
                new Thread(SafeCalc).Start();    
            }
        }

        // Thread-Safe 메서드 
        private void SafeCalc()
        {
            // 한번에 한 쓰레드만 lock블럭 실행
            lock (lockObject)
            {
                // 필드값 변경
                counter++;

                // 가정 : 다른 복잡한 일을 한다
                for (int i = 0; i < counter; i++)
                    for (int j = 0; j < counter; j++) ;

                // 필드값 읽기
                Console.WriteLine(counter);
            }
        }

        //출력 예:
        // 1001
        // 1002
        // 1003
        // 1004
        // 1005
        // 1006
        // 1007
        // 1008
        // 1009
        // 1010
    }
}

7+1.C# timer 사용하기
http://lexlove.egloos.com/177054
클래스 내에 일정 간격으로 무었인가 반복적인 작업을 해야 한다면 Timer 를 고려해 볼 만하다.

우선 네임스페이스는 System.Timers 이다.

private Timer timer=new Timer(6000); // 6000 은 타이머 동작할 시간이다. 밀리세컨드 단위

...


timer.Elapsed += new ElapsedEventHandler(timer_Elapsed);
// 6초후 동작할 Elapsed 이벤트에 원하는 작업을 
수행하는 이벤트 핸들러를 연결한다.


void timer_Elapsed(object sender, ElapsedEventArgs e)
{

	//여기에 원하는 작업을 코딩한다.

}


다음에 초기화 함수에서

timer.Start(); 를 호출해 주면 타이머가 동작한다.


반복 수행을 해야 한다면 timer_Elapsed 에서 작업이 완료 후 다시 timer.Start(); 를 호출한다.

8.	Visual studio -> 해당프로젝트 -> obj -> Debug에 있는 내용은 Visual studio가 Debug를 위해 자동으로 만들어준 파일

9.	차트추가를 위해 도구상자 -> 데이터 -> Chart 가 존재하지 않는 경우
	해결방법 -> 프로젝트 -> 속성 -> 응용프로그램 -> 대상프레임워크 -> 버전 4이상으로 설정함
	cf)	차트 색상 변경
		Form1.cs[디자인] -> 속성 -> 차트 -> Series -> Color 색상 변경
		
	cf)	chart안에 중심선 추가(Y축 35 위치에 직선 추가)
		double lineHeight = 35;
		HorizontalLineAnnotation ann = new HorizontalLineAnnotation();
		ann.AxisX = tc.ChartAreas[0].AxisX;
		ann.AxisY = tc.ChartAreas[0].AxisY;
		ann.IsSizeAlwaysRelative = false;
		ann.AnchorY = lineHeight;
		ann.IsInfinitive = true;
		ann.ClipToChartArea = tc.ChartAreas[0].Name;
		ann.LineColor = Color.Red; ann.LineWidth = 3;
		tc.Annotations.Add(ann);
	
	cf)	///<summary> Y축 500 +/- 200 두께의 투명 줄무늬선 추가 </summary>
		chart1.ChartAreas[0].AxisY.StripLines.Add(new StripLine());
		chart1.ChartAreas[0].AxisY.StripLines[0].BackColor = Color.FromArgb(80, 252, 180, 65);	// 투명 주황색
		chart1.ChartAreas[0].AxisY.StripLines[0].StripWidth = 400;		// StripLines 두께
//		chart1.ChartAreas[0].AxisY.StripLines[0].Interval = 10000;		// StripLines이 Y축으로 10000간격 마다 생성 시키는 명령
		chart1.ChartAreas[0].AxisY.StripLines[0].IntervalOffset = 300;	// Y축 300위치에서 시작
		
	cf)	X/Y축 Label 추가
		해당차트 -> 속성 -> 차트 -> ChartAreas -> ChartArea1 속성 -> 축 -> Axes -> X axis 속성 -> Title -> 해당 X축 Label 입력
		해당차트 -> 속성 -> 차트 -> ChartAreas -> ChartArea1 속성 -> 축 -> Axes -> Y (Value) axis 속성 -> Title -> 해당 Y축 Label 입력
		
	cf)	차트 외곽 테두리 추가
		해당차트 -> 속성 -> 모양 -> BoarderlineColor -> Black -> BoarderlineDashStyle -> Solid
		해당차트 -> 속성 -> 모양 -> BoarderlineDashStyle -> Solid
		

10.	ListBox에 있는 항목 얻기
	for(int i=0; i<ListBox.Items.Count; i++)
	{
		MessageBox("ListBox Item " + i"" + ListBox.Items[i].ToString());
		MessageBox("ListBox Item " + i"" + ((Line)ListBox.Items[i]).Str);
	}
	여기에서 ListBox.Items.Count 이 부분이 현재 리스트박스에 있는 모든 항목의 개수를 나타내며
	ListBox.Items[i].ToString() 가 출력해준다.
11.	foreach
	C#에서는 또한 foreach 문을 제공하여 배열 또는 열거형 컬렉션의 요소를 간단하게 반복할 수 있습니다. 
	foreach 문은 배열 또는 컬렉션 형식의 열거자에서 반환한 순서대로 요소를 처리합니다(일반적으로 0번째부터 마지막까지).
	 예를 들어, 다음 코드에서는 numbers라는 배열을 만들어 foreach 문으로 배열의 요소를 반복하여 사용합니다. 
	int[] numbers = { 4, 5, 6, 1, 2, 3, -2, -1, 0 };
	foreach (int i in numbers)
	{
	    System.Console.Write("{0} ", i);
	}
	// Output: 4 5 6 1 2 3 -2 -1 0
	
	cf)	{0}의 의미
		It refers to the index number of the parameter. For example, if you want to print multiple variables you can do this:
		Console.WriteLine("Person details - {0} {1}", person1, person2)
12.	C# String과 string의 차이 Language/.NET 2014.07.22 10:58 
	String은 원래 System.String인데 System 네임스페이스를 using System;으로 사용하고 있기 때문에 String으로 써도 상관없음
	string은 C#에서 사용하는 String의 별칭
	결론은 차이없다.
	cf)	String 선언 & 초기화
		String readingData = String.Empty;
13.	[C#] 문자열에 포함 된 문자 찾기 
	Contains 함수는 텍스트에 특정 문자가 있는 찾아주는 함수입니다.
	bool 로 리턴값을 반환합니다.
	*원* 이랑 같은거라고 생각하시면 될 것 같습니다.
	
	String a1 = "3,700원";
	a1.Contains("원");
ex)	C++ 예제
package beginnersbook.com;
import java.util.ArrayList;
public class ContainsExample {
   public static void main(String[] args) {

      ArrayList<String> al = new ArrayList<String>();
      al.add("pen");
      al.add("pencil");
      al.add("ink");
      al.add("notebook");

      System.out.println("ArrayList contains the string 'ink pen': "
                                           +al.contains("ink pen"));
      System.out.println("ArrayList contains the string 'pen': "
                                             +al.contains("pen"));
      System.out.println("ArrayList contains the string 'pencil': "
                                          +al.contains("pencil"));
      System.out.println("ArrayList contains the string 'book': "
                                           +al.contains("book"));

      ArrayList<Integer> al2 = new ArrayList<Integer>();
      al2.add(1);
      al2.add(99);
      al2.add(56);
      al2.add(13);
      al2.add(44);
      al2.add(6);

      System.out.println("'1' is present in arraylist: "+al2.contains(1));
      System.out.println("'55' is present in arraylist: "+al2.contains(55));
      System.out.println("'44' is there in arraylist: "+al2.contains(44));
      System.out.println("'7' is there in arraylist: "+al2.contains(7));
   }
}
Output:
ArrayList contains the string 'ink pen': false
ArrayList contains the string 'pen': true
ArrayList contains the string 'pencil': true
ArrayList contains the string 'book': false
'1' is present in arraylist: true
'55' is present in arraylist: false
'44' is there in arraylist: true
'7' is there in arraylist: false

14.	문자열 자르기
	1.	Substring
		문자열의 위치를 이용하여 문자열을 자름(대상이되는 문자열 원본이 변경되는(잘려나가는) 것은 아님)
		예제)
		string text = "abcdefg";
		Console.WriteLine(text);
		Console.WriteLine(text.Substring(0, 3));		// 0번째부터 문자 3개가 출력
		Console.WriteLine(text.Substring(5));			// 5번째부터 문자열 끝까지 출력
		결과)
		abcdefg
		abc
		fg

		예제2)
		string text = "abcdefg";
		string text2 = "";

		try
		{
			Console.WriteLine(text);						// abcdefg
			Console.WriteLine(text.Substring(0, 3));		// abc, 0번째부터 문자 3개가 출력
//			Console.WriteLine(text2.Substring(0, 3));		// System.ArgumentOutOfRangeException 에러 발생
			try
			{
				Console.WriteLine(text.Substring(0, 10));	// System.ArgumentOutOfRangeException 에러 발생
			}
			catch(Exception e1)
			{
//				MessageBox.Show(e1.ToString());
			}
			Console.WriteLine(text.Substring(5));			// fg, 5번째부터 문자열 끝까지 출력
		}
		catch(Exception e2)
		{
			MessageBox.Show(e2.ToString());
		}
		결과)
		abcdefg
		abc
		System.ArgumentOutOfRangeException 에러 발생
		System.ArgumentOutOfRangeException 에러 발생
		fg


	2.	Split
		지정된 문자를 기준으로 문자열을 분리
		예제)
		string text2 = "abc,def,g";
		char sp = ',';
		Console.WriteLine(text2);
		string[] spstring = text2.Split(sp);
		for(int i = 0; i < spstring.Length; i++)
		{
			Console.WriteLine(spstring[i]);
		}
		결과)
		abc,def,g
		abc
		def
		g
	3.	IndexOf
		특정 문자의 위치를 문자열에서 찾음
		예제)
		string text3 = "abcdefg";
		string searchText = "f";
		Console.WriteLine(text3.IndexOf(searchText));
		결과)
		5
	4.	Remove
		전체이름에서 중간 이름을 제거하는 방법
		using System;
		
		public class RemoveTest {
		    public static void Main() {
		
		        string name = "Michelle Violet Banks";
		
		        Console.WriteLine("The entire name is '{0}'", name);
		
		        // remove the middle name, identified by finding the spaces in the middle of the name...
		        int foundS1 = name.IndexOf(" ");
		        int foundS2 = name.IndexOf(" ", foundS1 + 1);
		
		        if (foundS1 != foundS2 && foundS1 >= 0) {
		
		            name = name.Remove(foundS1 + 1, foundS2 - foundS1);
		
		            Console.WriteLine("After removing the middle name, we are left with '{0}'", name);
		        }
		    }
		}
		// The example displays the following output:
		//       The entire name is 'Michelle Violet Banks'
		//       After removing the middle name, we are left with 'Michelle Banks'


14+1.문자열 변환
C# 의 string 에서 제공하는 메소드 중에서 부분 문자열을 바꾸는 Replace 함수가 있다.
이 함수를 사용하면서 자주 저지르는 실수로 아래와 같은 것이 있다. 항상 주의하자.
string s = "Take this out";  
s.Replace("this", "that");  // replace 가 안됨  

view plaincopy to clipboardprint?
s = s.Replace("this", "that");  // replace 가 됨

ex)	dataIn = dataIn.Replace("\r", "");			// 본 명령을 실행하면 dataIn string 안에 있는 모든 "\r"을 ""으로 변경시켜준다. cf) "\r"이 100개가 있으면 100개 모두 ""으로 변경시켜 줌

14+2.앞에 0 이 오는 특정 길이까지 정수로 채우기
예제1)
 double value;

 value = 123;
 Console.WriteLine(value.ToString("00000"));
 Console.WriteLine(String.Format("{0:00000}", value));
 // Displays 00123

 value = 1.2;
 Console.WriteLine(value.ToString("0.00", CultureInfo.InvariantCulture));
 Console.WriteLine(String.Format(CultureInfo.InvariantCulture, 
                   "{0:0.00}", value));
 // Displays 1.20

 Console.WriteLine(value.ToString("00.00", CultureInfo.InvariantCulture));
 Console.WriteLine(String.Format(CultureInfo.InvariantCulture, 
                                 "{0:00.00}", value));
 // Displays 01.20

 CultureInfo daDK = CultureInfo.CreateSpecificCulture("da-DK");
 Console.WriteLine(value.ToString("00.00", daDK)); 
 Console.WriteLine(String.Format(daDK, "{0:00.00}", value));
 // Displays 01,20

 value = .56;
 Console.WriteLine(value.ToString("0.0", CultureInfo.InvariantCulture));
 Console.WriteLine(String.Format(CultureInfo.InvariantCulture, 
                                 "{0:0.0}", value));
 // Displays 0.6

 value = 1234567890;
 Console.WriteLine(value.ToString("0,0", CultureInfo.InvariantCulture));	
 Console.WriteLine(String.Format(CultureInfo.InvariantCulture, 
                                 "{0:0,0}", value));	
 // Displays 1,234,567,890      

 CultureInfo elGR = CultureInfo.CreateSpecificCulture("el-GR");
 Console.WriteLine(value.ToString("0,0", elGR));	
Console.WriteLine(String.Format(elGR, "{0:0,0}", value));	
 // Displays 1.234.567.890

 value = 1234567890.123456;
 Console.WriteLine(value.ToString("0,0.0", CultureInfo.InvariantCulture));	
 Console.WriteLine(String.Format(CultureInfo.InvariantCulture, 
                                 "{0:0,0.0}", value));	
 // Displays 1,234,567,890.1  

 value = 1234.567890;
 Console.WriteLine(value.ToString("0,0.00", CultureInfo.InvariantCulture));	
 Console.WriteLine(String.Format(CultureInfo.InvariantCulture, 
                                 "{0:0,0.00}", value));	
 // Displays 1,234.57 


예제2)
int intNextOrderNo = 343;
string strFormatOrderNo = String.Format("{0:D8}", intNextOrderNo);
결과는 00000343 이다.
출처: http://redsea23.tistory.com/258 [노을지기 노리터]


예제3)
byte byteValue = 254;
short shortValue = 10342;
int intValue = 1023983;
long lngValue = 6985321;               
ulong ulngValue = UInt64.MaxValue;

// Display integer values by calling the ToString method.
Console.WriteLine("{0,22} {1,22}", byteValue.ToString("D8"), byteValue.ToString("X8"));
Console.WriteLine("{0,22} {1,22}", shortValue.ToString("D8"), shortValue.ToString("X8"));
Console.WriteLine("{0,22} {1,22}", intValue.ToString("D8"), intValue.ToString("X8"));
Console.WriteLine("{0,22} {1,22}", lngValue.ToString("D8"), lngValue.ToString("X8"));
Console.WriteLine("{0,22} {1,22}", ulngValue.ToString("D8"), ulngValue.ToString("X8"));
Console.WriteLine();

// Display the same integer values by using composite formatting.
Console.WriteLine("{0,22:D8} {0,22:X8}", byteValue);
Console.WriteLine("{0,22:D8} {0,22:X8}", shortValue);
Console.WriteLine("{0,22:D8} {0,22:X8}", intValue);
Console.WriteLine("{0,22:D8} {0,22:X8}", lngValue);
Console.WriteLine("{0,22:D8} {0,22:X8}", ulngValue);
// The example displays the following output:
//                     00000254               000000FE
//                     00010342               00002866
//                     01023983               000F9FEF
//                     06985321               006A9669
//         18446744073709551615       FFFFFFFFFFFFFFFF
//       
//                     00000254               000000FE
//                     00010342               00002866
//                     01023983               000F9FEF
//                     06985321               006A9669
//         18446744073709551615       FFFFFFFFFFFFFFFF
//         18446744073709551615       FFFFFFFFFFFFFFFF

14+3.String Format for Int [C#]
cf)	I have numbers like 1, 2, and 3, and I would like to make them into strings, "01", "02" and "03". How can I do this?
		->	Here is the MSDN article on formatting numbers. To pad to 2 digits, you can use:
				n.ToString("D2")

Add zeroes before number
To add zeroes before a number, use colon separator ?:“and write as many zeroes as you want.
[C#]
String.Format("{0:00000}", 15);          // "00015"
String.Format("{0:00000}", -15);         // "-00015"

Align number to the right or left
To align number to the right, use comma ?,“ followed by a number of characters. This alignment option must be before the colon separator.
[C#]
String.Format("{0,5}", 15);              // "   15"
String.Format("{0,-5}", 15);             // "15   "
String.Format("{0,5:000}", 15);          // "  015"
String.Format("{0,-5:000}", 15);         // "015  "

Different formatting for negative numbers and zero
You can have special format for negative numbers and zero. Usesemicolon separator ?;“ to separate formatting to two or three sections. The second section is format for negative numbers, the third section is for zero.
[C#]
String.Format("{0:#;minus #}", 15);      // "15"
String.Format("{0:#;minus #}", -15);     // "minus 15"
String.Format("{0:#;minus #;zero}", 0);  // "zero"

Custom number formatting (e.g. phone number)
Numbers can be formatted also to any custom format, e.g. like phone numbers or serial numbers.
[C#]
String.Format("{0:+### ### ### ###}", 447900123456); // "+447 900 123 456"
String.Format("{0:##-####-####}", 8958712551);       // "89-5871-2551"

출처 http://www.csharp-examples.net/examples/
[출처] c# String.Format && string 자릿수 맞추기|작성자 똥이꼼

14+4.[C#] 원하는 길이로 좌측/우측 정렬시킨후 나머지 공간을 다른 문자로 채우기
1)	원하는 길이로 좌측/우측 정렬시킨후 나머지 공간을 다른 문자로 채우기 (기본은 공백) 
String.PadLeft(길이, [문자]);         String.PadRight(길이, [문자]); 
예) string str1 = "asdf";
     string str2 = str1.PadLeft(10);    -->  str2 = "      asdf"
     string str3 = str1.PadRight(6, '-');  -->  str3 = "asdf--"

str2 웹에서 보면 빈칸이 안나오기에 그냥 asdf로 나오지만 Length 해보면 10값 나옴

14+5.DateTIme 날짜 유효성 검사.
Datetime형 날짜가 유효한지 체크 할 때 다음과 같이 사용한다.

예제1)
var formats = new[] { "yyyyMMdd", "yyyy-MM-dd" };
DateTime dtRtn;
if (!DateTime.TryParseExact("20140541", formats, CultureInfo.InvariantCulture, DateTimeStyles.None, out dtRtn))
{
     MsgCodeHelper.ShowDialog("AC0070", "입력된 날짜가 잘못되었습니다.");
     return;
} 

예제2)
var format = new[] { "yyMMdd" };
DateTime dtRTime;

/// <summary> DateTime.TryParseExact 명령을 사용하면 정확하게 상기 "yyMMdd" 형식으로 날짜를 입력했는지 확인해 줌
/// cf) 실제 테스트 결과, 하기와 같이 제대로 "yyMMdd" 형식으로 입력했는지 파악해 줌
/// textBox_Date.Text = "1"			인 경우	->	MessageBox.Show("Please, Type in YYMMDD format"); 출력
/// textBox_Date.Text = "000000"    인 경우	->	MessageBox.Show("Please, Type in YYMMDD format"); 출력
/// textBox_Date.Text = "000100"    인 경우	->	MessageBox.Show("Please, Type in YYMMDD format"); 출력
/// textBox_Date.Text = "000101"    인 경우	->	command 는   "000101"로 변경
/// textBox_Date.Text = "001231"    인 경우	->	command 는   "001231"로 변경
/// textBox_Date.Text = "001232"    인 경우	->	MessageBox.Show("Please, Type in YYMMDD format"); 출력
/// textBox_Date.Text = "001331"    인 경우	->	MessageBox.Show("Please, Type in YYMMDD format"); 출력
/// </summary>
if(DateTime.TryParseExact(textBox_Date.Text, format, CultureInfo.InvariantCulture, DateTimeStyles.None, out dtRTime))
{
	string command = textBox_Date.Text.PadLeft(6, '0');
	...........................
}
else
{
	MessageBox.Show("Please, Type in YYMMDD format");
}

14+6.문자열 -> 문자 / 숫자 분리	cf) 실제 실행해 보니 정말 제대로 분리가 됨
// 참조추가
using System.Text.RegularExpressions;
.
.

string tm = "a1b2c3d4";
string num = Regex.Replace(tm, @"\D", ""); // 숫자만 가져옴 
// num 에는 1234 만 남는다..
 
string str = Regex.Replace(tm, @"[\d-]", string.Empty);
// str 에는 abcd 만 남는다.


15.	문자열 변환
	string s1 = "1234";
	string s2 = "1234.56";
	string s3 = null;
	string s4 = "123456789123456789123456789123456789123456789";
	
	int result;
	double dTemp;
	bool success;
	
	1. 	Int32.Parse(string)
		result = Int32.Parse(s1);		// 1234
		result = Int32.Parse(s2);		// FormatException
		result = Int32.Parse(s3);		// ArgumentNullException
		result = Int32.Parse(s4);		// OverflowException
		
	2.	Convert.ToInt32(string)
		result = Convert.ToInt32(s1);	// 1234
		result = Convert.ToInt32(s2);	// FormatException
		dTemp = Convert.ToDouble(s2);	// 1234.56
		result = Convert.ToInt32(s3);	// 0
		result = Convert.ToInt32(s4);	// OverflowException
		
	3.	Int32.TryParse(string, out int)
		success = Int32.TryParse(s1, out result);	// success : true, result : 1234
		success = Int32.TryParse(s2, out result);	// success : false, result : 0
		success = Int32.TryParse(s3, out result);	// success : false, result : 0
		success = Int32.TryParse(s4, out result);	// success : false, result : 0
		
16.	try - catch
	try
	{
		
	}
	catch(Exception e1)
	{
		MessageBox.Show(e1.ToString());
	}
	
17.	Invoke / delegate
1)	설명1
delegate :	- c/c++에서 포인터와 같은 개념이라 생각하면 된다.
			- delegate는 메서드의 포인터를 저장한다.
			핵심)	메서드의 인수에 변수 뿐만 아니라 다른 메서드 포인트를 넣어서 처리하고 싶을 때 사용
invoke :	- 별도의 thread에서 컨트롤박스에 접근하려하면
			  서로다른 thread들이 하나의 컨트롤 객체에 접근하는 것을 방지하기 위한 방법이다.
			  invoke 없이 멀티 thread를 돌리면 크로스 스레드 오류가 발생한다.

public partial class MainForm : Form
{
	delegate void outputTextboxCallback(string str);
	
	public void outputTextbox(string str)
	{
		if(textbox1.InvokeRequired)
		{
			// Invoke가 필요하면 대리자 호출
			textbox1.Invoke(new outputTextboxCallback(outputTextbox), new object[] {str});
		}
		else
		{
			textbox1.Text = str;
		}
	}
	
	public MainForm()
	{
		InitializeComponent();
		Thread thread = new Thread(new ThreadStart(test));
	}
	
	public void test()
	{
		outputTextbox("output");
	}
}

MainForm에서 thread가 선언되고 test 함수를 호출한다.
test함수에서 outputTextbox 함수 호출한다.
시험해본 결과 if(textbox1.InvokeRequired)로 안들어가고 else로 간다.

2)	설명2
쓰레드내에서 다른 클래스의 컨트롤을 제어(생성)할 때, 잘 되는 경우도 있고 프로그램이 죽어버리는 경우도 있다.
그래서 Invoke를 사용하는데, 그래야?컨트롤을 안정적으로 제어 할 수 있다. 꼭 쓰자.

private delegate void mDeligate();
mDeligate 델리게이트이름 = 메쏘드;
컨트롤.Invoke(, new?object[] { });

메쏘드에서 컨트롤을 제어하는 코드를 작성하면 된다.
만약 메쏘드에 매개변수를 넘겨주어야 한다면
private delegate void mDeligate(int a, int b, int c);
mDeligate 델리게이트이름 = 메쏘드;
컨트롤.Invoke(, new object[] {a, b, c});
위와 같이 쓰고 메쏘드에서 매개변수를 받아 쓰면 된다.

3)	예제
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DelegateExample
{
    delegate int Calc(int x, int y);

    class Math
    {
        public int plus(int x, int y)
        {
            return x + y;
        }
        public int minus(int a, int b)
        {
            return a - b;
        }
    }
    
    int myCalc(int x, int y, Calc calc)
	{
		return calc(x, y);
	}

    class Program
    {
        static void Main(string[] args)
        {
			Math math = new Math();
			int result;
			Calc calc;

			Calc calc2 = new Calc(math.plus);
			result = calc2(10, 5);
			Console.WriteLine("10 + 5 = " + result);

			Calc calc3 = new Calc(math.minus);
			result = calc3(10, 5);
			Console.WriteLine("10 - 5 = " + result);



			calc = math.plus;
			Console.WriteLine("3 + 4 = " + calc(3, 4));

			calc = math.minus;
			Console.WriteLine("5 - 2 = " + calc(5, 2));



			result = myCalc(2, 1, math.plus);
			Console.WriteLine(result);

			result = myCalc(2, 1, math.minus);
			Console.WriteLine(result);
        }
    }
}

-> 결과
10 + 5 = 15
10 - 5 = 5
3 + 4 = 7
5 - 2 = 3
3
1
계속하려면 아무 키나 누르십시오. . .

18.	DB 저장
1)	많은 개발자들이 ‘SQLite’를 활용해 모바일 DB를 처리한다. 
	SQLite는 무료로 쓸 수 있는 모바일 DB로 가장 유명하다. 뒤에 ‘라이트’라는 단어가 붙은 것처럼 기존 DB보다 쓰기 좀 더 간편하고 처리하는 DB도 작은 편이다.
2)	[RE] sqlite 64비트를 32pc에 배포하려면?
	32비트 컴퓨터에서 64비트 dll을 사용할 수 없으므로 32/64 둘 다 배포해야 할 경우 32bit dll을 사용합니다. (프로젝트를 x86으로 설정함)
	이러면 32비트 64비트 둘 다 정상 동작을 할 꺼에요. 32비트랑 64비트랑 따로 배포하시려면... Install Packages에서 32/64비트에 따라 다른 구성을 선택할 수 있도록 가능한 것으로
	일단은 스포너님 말처럼 32bit dll로 수정을 하였습니다. 그리고 cpu x86으로 구동을 하였습니다.
	64비트 컴퓨터에서도 잘 동작합니다.
3)	SQLite
	가)	자료형
		a)	INTEGER	: 8바이트 정수
		b)	REAL	: 8바이트 실수
4)	System.BadImageFormatException	에러 발생 대처 방안
	System.BadImageFormatException: '파일이나 어셈블리 'System.Data.SQLite, Version=1.0.70.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139' 
	또는 여기에 종속되어 있는 파일이나 어셈블리 중 하나를 로드할 수 없습니다. 프로그램을 잘못된 형식으로 로드하려고 했습니다.'
	->	상기와 같은 에러가 발새한 경우
		해당 Project -> 프로젝트 -> 속성 -> 빌드 -> 플렛폼 대상 -> x86 으로 변경
5)	예제
namespace conEx02
{
	class Program
	{
		static void Main(string[] args)
		{
			// DataTable 생성
			DataTable dt  new DataTable("Test");
			
			// DataColumn 추가
			dt.Columns.Add("ID");
			dt.Columns.Add("NAME");
			
			// 새로운 ROW를 추가하기
			DataRow dr = dt.NewRow();
			dr["ID"] = "111";
			dr["NAME"] = "AAA";
			dt.Rows.Add(dr);
			
			dr = dt.NewRow();
			dr["ID"] = "222";
			dr["NAME"] = "BBB";
			dt.Rows.Add(dr);
			
			// Select ROW
			DataRow[] findRow = dt.Select("ID = '111'"0;
			
			if(findRow != null)
				Console.WriteLin(findRow.ToString());
			
			// Update ROW
			dt.Rows[0]["NAME"] = "AAA_AAA";
			
			// Delete ROW
			dt.Rows[1].Delete();
			
			// 수정된 내용을 반영하는 항목
			dt.AcceptChanges();
		}
	}
}
6)	MySQL이랑 SQLite 중 어느게 더 접근하기 편한가요
	SQLite를 쓰는게 당연히 간편합니다.?
	특히나 모바일(Android) 앱이라면 당연히 로컬에서 SQLlite를 지원하기 때문에 다른 선택의 여지가 없기도 하고요.
	그리고 레시피 1000개 이내의 레코드 라면 PC에서도 SQLite를 쓰는게 좋습니다.
7)	DB파일 내용을 변경시킨 경우에도 Debug 모드를 재 실행시키면 원래 초기 DB 내용으로 원상복구되는 현상 설명
	->	아래와 같이 Debug 모드가 실행되기 때문에 발생하는 것임

	본, 프로젝트를 Visual studio -> Debug 모드로 실행시키면
	제일 처음 Contact.csproj 파일 실행 시 하기 명령이 실행되어
	DB 파일 내용을 바꾼 경우에도 다시 ROOT Folder Contact\Databasee 에 있는 Contact.s3db 파일이
	Contact\bin\Debug\Database folder로 원상복구 되어 DB파일 내용이 초기화 되는 문제가 발생 함
	cf)	본 경우는 Visual studio -> Debug 모드 실행 시 만 발생되며
	실제, 실행파일(*.exe)을 실행시킨 경우에는 발생하지 않음
	
	<None Include="Database\Contact.s3db">
	 <CopyToOutputDirectory>Always</CopyToOutputDirectory>
	</None>

19.	콘솔창 유지
	C# Console Project를 실행 할때 Console 창을?유지하기 
    C# 코딩 연습을 할 때 주로 Console Application Project를 이용합니다. 간편하게 C# Code를 작성해서, 결과를 확인할 수 있기 때문입니다.
    그런데 프로젝트를 실행하면 Console 창이 결과를 출력하고 바로 사라집니다.?이런 현상을 막기 위해 다음과 같은 코드를 한줄 사용합니다.
    ->	해결방법
		Console.ReadLine();
20.	Delay 함수
	System.Threading.Thread.Sleep(500);

21.	자바 eclipse 처럼 import처럼 -> using문을 사용해서 namespace 추가하기
	에러표시가 나온 명령 -> 오른쪽마우스클릭 -> 빠른 작업 및 리펙터링 -> 원하는 namespace 추가
	cf)	단축키는 Ctrl + . 이나 Shift + Alt + F10

22-1.Read / Write Excel.Range 처리(내가 실제 코딩해서 정상적으로 동작됨 확인한 소스 임)

using System;
using System.Collections.Generic;
using System.Linq;
using Excel=Microsoft.Office.Interop.Excel;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace Termie
{
    class MyExcel
    {
        public string DB_PATH = @"";
        public BindingList<MeltingCurveData> EmpList = new BindingList<MeltingCurveData>();
        private Excel.Workbook myBook = null;
        private Excel.Application myApp = null;
        private Excel.Worksheet mySheet = null;
        public int lastRow=0;
		// add
		public int sheetSelect = 0;     // 0 : Sheet[1], 1 : Sheet[2]
		private Excel.Range myRange;
		int row = 0;
		int column = 0;
		public object[,] objData;
		public dynamic[,] dynData;
		// add

		public void InitializeExcel()
        {
            myApp = new Excel.Application();
            myApp.Visible = false;
            myBook = myApp.Workbooks.Open(DB_PATH);
			if(sheetSelect == 0)
				mySheet = (Excel.Worksheet)myBook.Sheets[1]; // Explicit cast is not required here
			else
				mySheet = (Excel.Worksheet)myBook.Sheets[2];
			lastRow = mySheet.Cells.SpecialCells(Excel.XlCellType.xlCellTypeLastCell).Row;
			// add
			myRange = mySheet.get_Range("B1", "B2196");
			row = myRange.Rows.Count;
			column = myRange.Columns.Count;
			objData = new Object[Constants.Y_MAX_RANGE, 1];
			dynData = new dynamic[Constants.Y_MAX_RANGE, 1];
			// add
		}
        public BindingList<MeltingCurveData> ReadMyExcel()		// 5447ms 시간 소요
        {
            EmpList.Clear();
            for (int index = 2; index <= lastRow; index++)
            {
                System.Array MyValues = (System.Array)mySheet.get_Range("A" + index.ToString(), "B" + index.ToString()).Cells.Value;
                EmpList.Add(new MeltingCurveData
				{ 
					Temperature = MyValues.GetValue(1,1).ToString(),
					Data = MyValues.GetValue(1,2).ToString(),
				});

				if(sheetSelect != 0)
				{
					if (index >= Constants.Y_MAX_RANGE)
						break;
				}
            }
            return EmpList;
        }
		// add
		/*	Excel reading 처리 시간 단축 방법
		 *	상기 ReadMyExcel() 함수 처리 시간 : 5447ms 소요(Excel Cells 단위로 처리하기 때문에 상당히 많은 시간 소요)
		 *	아래 ReadMyExcel2() 함수 처리 시간 : 9ms 소요(Excel Cells 단위가 아닌 Range 단위로 처리하기 때문에 상당히 짧은 시간 소요)	*/
		public void ReadMyExcel2()								// 9ms 시간 소요
		{
			if ((row >= Constants.Y_MAX_RANGE) && (column >= 1))
			{
//				Array.Clear(objData, 0, objData.Length);
				Array.Clear(dynData, 0, dynData.Length);
//				objData = myRange.Value;
				dynData = myRange.Value;						// 본 명령만 수행해도 myRange 영역으로 지정된 data 모두가 dynData로 복사됨
			}
		}

		public void FilterAveraging(int nAvr)
		{
#if true
			if ((row >= Constants.Y_MAX_RANGE) && (column >= 1))
			{				
				for (int iTemp = 0; iTemp < nAvr; iTemp++)
				{
					for (int iTemp2 = Constants.Y_START_RANGE2; iTemp2 <= Constants.Y_MAX_RANGE; iTemp2++)
					{
						if (iTemp2 == Constants.Y_START_RANGE2)
							dynData[iTemp2, 1] = (dynData[iTemp2, 1] + dynData[iTemp2 + 1, 1] + dynData[iTemp2 + 2, 1]) / 3;
						else if(iTemp2 == Constants.Y_MAX_RANGE)
							dynData[iTemp2, 1] = (dynData[iTemp2, 1] + dynData[iTemp2 - 1, 1] + dynData[iTemp2 - 2, 1]) / 3;
						else
							dynData[iTemp2, 1] = (dynData[iTemp2 - 1, 1] + dynData[iTemp2, 1] + dynData[iTemp2 + 1, 1]) / 3;
					}
				}
			}

			// temp
			myRange.Value = dynData;                            // 본 명령만 수행해도 dynData 영역으로 지정된 data 모두가 myRange로 복사됨
			// temp
#endif
		}
		// add
        public void WriteToExcel(MeltingCurveData emp)
        {
            try
            {
                lastRow += 1;
                mySheet.Cells[lastRow, 1] = emp.Temperature;
                mySheet.Cells[lastRow, 2] = emp.Data;
                EmpList.Add(emp);
                myBook.Save();
            }
            catch (Exception ex)
            {
			}
        }

        public List<MeltingCurveData> FilterEmpList(string searchValue, string searchExpr)
        {
            List<MeltingCurveData> FilteredList = new List<MeltingCurveData>();
            switch (searchValue.ToUpper())
            {
                case "Temperature":
                    FilteredList = EmpList.ToList().FindAll(emp => emp.Temperature.ToLower().Contains(searchExpr));
                    break;
                case "Data":
                    FilteredList = EmpList.ToList().FindAll(emp => emp.Data.ToLower().Contains(searchExpr));
                    break;
                default:
                    break;
            }
            return FilteredList;
        }
        public void CloseExcel()
        {
#if false
			myBook.Saved = true;
			myApp.Quit();
#elif false
			myBook.Close(false, null, null);
			myApp.Quit();

			Marshal.ReleaseComObject(mySheet);
			Marshal.ReleaseComObject(myBook);
			Marshal.ReleaseComObject(myApp);
#else
//			myBook.Close(false, null, null);
			myApp.DisplayAlerts = false;        // 저장할 것인가 확인하지 않도록 설정
			myApp.Quit();

			Marshal.ReleaseComObject(myRange);
			Marshal.ReleaseComObject(mySheet);
			Marshal.ReleaseComObject(myBook);
			Marshal.ReleaseComObject(myApp);
#endif
		}
    }
}

22.	Read Excel File in C#
1)	핵심, 아래 예제는 실제 내가 코딩/동작시켜서 나온 결과이며
	엑셀 처리 시간을 단축시키려면 아래와 같이 코딩해야 함
        public BindingList<MeltingCurveData> ReadMyExcel()		// 5447ms 시간 소요
        {
            EmpList.Clear();
            for (int index = 2; index <= lastRow; index++)
            {
                System.Array MyValues = (System.Array)mySheet.get_Range("A" + index.ToString(), "B" + index.ToString()).Cells.Value;
                EmpList.Add(new MeltingCurveData
				{ 
					Temperature = MyValues.GetValue(1,1).ToString(),
					Data = MyValues.GetValue(1,2).ToString(),
				});

				if(sheetSelect != 0)
				{
					if (index >= Constants.Y_MAX_RANGE)
						break;
				}
            }
            return EmpList;
        }
		// add
		/*	Excel reading 처리 시간 단축 방법
		 *	상기 ReadMyExcel() 함수 처리 시간 : 5447ms 소요(Excel Cells 단위로 처리하기 때문에 상당히 많은 시간 소요)
		 *	아래 ReadMyExcel2() 함수 처리 시간 : 9ms 소요(Excel Cells 단위가 아닌 Range 단위로 처리하기 때문에 상당히 짧은 시간 소요)	*/
		public void ReadMyExcel2()								// 9ms 시간 소요
		{
			if ((row >= Constants.Y_MAX_RANGE) && (column >= 1))
			{
				Array.Clear(objData, 0, objData.Length);
				objData = myRange.Value;
			}
		}
		// add

2)	각종 기타 엑셀 처리 예제
using excel = Microsoft.Office.Interop.Excel;
 
public void WirteExce(ListView list)
        {
            excel.Application xls;
            excel._Workbook wbook;
            excel._Worksheet wSheet;
            string[] Alpabat = new string[]{"A","B","C","D","E","F","G","H","I","J","K",
                                            "L","M","N","O","P","Q","R","S","T","U","V",
                                            "W","X","Y","Z"};
            List<string> col = new List<string>();
            try{
                string[] header = new string[list.Columns.Count];
                int Colcount=0;
                foreach (ColumnHeader s in list.Columns)
                {
                    header[Colcount] = s.Text;
                    Colcount++;
                }
                string[,] item = new string[list.Items.Count, list.Columns.Count];
                for (int i = 0; i < list.Items.Count; i++)
                {
                    for (int j = 0; j < list.Columns.Count; j++)
                    {
                        item[i, j] = list.Items[i].SubItems[j].Text;
                    }
                }
                
                
                
                xls = new excel.Application();
                wbook =(excel._Workbook)(xls.Workbooks.Add(Missing.Value));
                wSheet = (excel._Worksheet)wbook.ActiveSheet;
                
                
                
              
                wSheet.get_Range("A1", Alpabat[list.Columns.Count - 1] + "1").Value2 = header;
                wSheet.get_Range("A2", Alpabat[list.Columns.Count - 1] + list.Items.Count.ToString()).Value2 = item;
                xls.Visible = false;
                xls.UserControl = false;
                object TypMissing = Type.Missing;
                wSheet.Columns.AutoFit();
                wbook.SaveAs("C:\\tset.xls", excel.XlFileFormat.xlWorkbookNormal, TypMissing, TypMissing,
                   TypMissing, TypMissing, excel.XlSaveAsAccessMode.xlNoChange,
                   TypMissing, TypMissing, TypMissing, TypMissing, TypMissing);
                wbook.Save();
                Process[] ExCel = Process.GetProcessesByName("EXCEL");
                if (ExCel.Length != 0)
                {
                    for (int j = 0; j < ExCel.Length; j++)
                    {
                        ExCel[j].Kill();
                    }
                }
             }
            catch(Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
        }



using System;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using Excel = Microsoft.Office.Interop.Excel; 

namespace WindowsFormsApplication4
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, EventArgs e)
        {
            Excel.Application xlApp ;
            Excel.Workbook xlWorkBook ;
            Excel.Worksheet xlWorkSheet ;
            Excel.Range range ;

            string str;
            int rCnt ;
            int cCnt ;
            int rw = 0;
            int cl = 0;

            xlApp = new Excel.Application();
            xlWorkBook = xlApp.Workbooks.Open(@"d:\csharp-Excel.xls", 0, true, 5, "", "", true, Microsoft.Office.Interop.Excel.XlPlatform.xlWindows, "\t", false, false, 0, true, 1, 0);
            xlWorkSheet = (Excel.Worksheet)xlWorkBook.Worksheets.get_Item(1);

            range = xlWorkSheet.UsedRange;
            rw = range.Rows.Count;
            cl = range.Columns.Count;


            for (rCnt = 1; rCnt  < = rw; rCnt++)
            {
                for (cCnt = 1; cCnt  < = cl; cCnt++)
                {
                    str = (string)(range.Cells[rCnt, cCnt] as Excel.Range).Value2;
                    MessageBox.Show(str);
                }
            }

            xlWorkBook.Close(true, null, null);
            xlApp.Quit();

            Marshal.ReleaseComObject(xlWorkSheet);
            Marshal.ReleaseComObject(xlWorkBook);
            Marshal.ReleaseComObject(xlApp);

        }

    }
}


Excel.Application app = null;
Excel.Workbooks books = null;
Excel.Workbook book = null;
Excel.Sheets sheets = null;
 
try
{
    app = new Excel.Application();
    books = app.Workbooks;
    book = books.Open(@"C:\Temp\ExcelBook.xlsx");
    sheets = book.Sheets;
 
    foreach (Excel.Worksheet sheet in sheets)
    {
        Console.WriteLine(sheet.Name);
        Marshal.ReleaseComObject(sheet);
    }
 
    book.Close();
    app.Quit();
}
finally
{
    if (sheets != null) Marshal.ReleaseComObject(sheets);
    if (book != null) Marshal.ReleaseComObject(book);
    if (books != null) Marshal.ReleaseComObject(books);                
    if (app != null) Marshal.ReleaseComObject(app);
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;           
using System.Text;
using System.Threading.Tasks;
using Excel = Microsoft.Office.Interop.Excel;       //microsoft Excel 14 object in references-> COM tab

namespace Sandbox
{
    public class Read_From_Excel
    {
        public static void getExcelFile()
        {

            //Create COM Objects. Create a COM object for everything that is referenced
            Excel.Application xlApp = new Excel.Application();
            Excel.Workbook xlWorkbook = xlApp.Workbooks.Open(@"C:\Users\E56626\Desktop\Teddy\VS2012\Sandbox\sandbox_test - Copy - Copy.xlsx");
            Excel._Worksheet xlWorksheet = xlWorkbook.Sheets[1];
            Excel.Range xlRange = xlWorksheet.UsedRange;

            int rowCount = xlRange.Rows.Count;
            int colCount = xlRange.Columns.Count;

            //iterate over the rows and columns and print to the console as it appears in the file
            //excel is not zero based!!
            for (int i = 1; i <= rowCount; i++)
            {
                for (int j = 1; j <= colCount; j++)
                {
                    //new line
                    if (j == 1)
                        Console.Write("\r\n");

                    //write the value to the console
                    if (xlRange.Cells[i, j] != null && xlRange.Cells[i, j].Value2 != null)
                        Console.Write(xlRange.Cells[i, j].Value2.ToString() + "\t");
                }
            }

            //cleanup
            GC.Collect();
            GC.WaitForPendingFinalizers();

            //rule of thumb for releasing com objects:
            //  never use two dots, all COM objects must be referenced and released individually
            //  ex: [somthing].[something].[something] is bad

            //release com objects to fully kill excel process from running in the background
            Marshal.ReleaseComObject(xlRange);
            Marshal.ReleaseComObject(xlWorksheet);

            //close and release
            xlWorkbook.Close();
            Marshal.ReleaseComObject(xlWorkbook);

            //quit and release
            xlApp.Quit();
            Marshal.ReleaseComObject(xlApp);
        }
    }
}
  
23.	Excel.exe 죽이기
by 블로그쥔장 | 작성일자: 2005-05-31 오후 1:33:00 

이 글은 오래된 전에 작성된 글입니다. 따라서 최신 버전의 기술에 알맞지 않거나 오류를 유발할 수 있습니다. 저자는 이 글에 대한 질문을 받지 않을 것입니다. 하지만 이 글이 리뉴얼 되면 이 글에 대한 질문을 하거나 토론을 할 수도 있습니다. 
많은 경우, 업무 프로그램에서 엑셀(Excel)과의 연동은 필수 불가결한 것이라 할 수 있다. 엑셀의 매력은 비정형적인 데이터를 손쉽게 다룰 수 있다는 것이다. 그래서 많은 고객들이 업무용 프로그램의 요구사항을 간단히 이렇게 명세하곤 한다.
"뭐... 엑셀 처럼 해주세요..."
대략 뷁스럽기 이를데 없는 경우다. 이야기가 좀 옆으로 샜지만 닷넷과 엑셀의 연동에서 골치거리 중 하나가 이놈의 Excel.exe 프로세스가 잘 죽지 않는다는 것이다. Excel.exe 프로세스를 확실하게 죽이는 방법에 대해 썰을 좀 풀어볼까 한다. (죽인다는 표현이 좀 쌀벌하다...)
다음은 엑셀을 액세스하는 전형적인 간단한 C# 코드이다. 뭐 설명할 필요도 없이 Sheet1의 A1 셀에 Hello Excel Interop 이란 문자열을 박아 넣는 코드로서 매우 잘 작동한다.
static void ExcelWillNotDie()
{
    Excel.ApplicationClass app = new Excel.ApplicationClass();
    Excel.Workbook workbook = app.Workbooks.Add("");
    Excel.Worksheet sheet = (Excel.Worksheet)workbook.Sheets["Sheet1"];
    Excel.Range range = (Excel.Range)sheet.Cells.get_Item("1", "A");
    range.Value2 = "Hello Excel Interop";

    // Excel 파일 저장 코드... (생략)

    app.DisplayAlerts = false; // 저장할 것인가 확인하지 않도록 설정
    app.Quit();
}
위 코드의 문제는 작업을 모두 마쳤음에도 불구하 Excel.exe 프로세스가 죽지 않는다는 것이다. 작업 관리자로 현재 수행중인 프로세스를 살펴보면 떡하니 Excel.exe가 버티고 있다. Quit() 메쏘드까지 호출해 줬는데도 말이다!
비슷한 코드를 VB 6.0이나 VBS(Visual Basic Script)로 수행해보면 메쏘드를 종료하는 시점에 Excel.exe 프로세스는 제깍 제깍 죽는다. 그런데 동등한 코드를 닷넷 환경에서 수행시키면 메쏘드 호출이 끝났어도 죽지 않는다. 원인은 COM 객체와 닷넷의 가비지 컬렉션이 서로 궁합이 잘 맞지 않는다는 것이며 Excel 프로세스가 종료하기 위해서는 생성된 모든 엑셀 COM 객체들(Application, Workbook Sheet 등등)이 해제(release)되어야 하기 때문이다.
닷넷에서 엑셀 객체들과 같은 COM 객체를 액세스 할 때는 항상 RCW(Runtime Callable Wrapper)를 통해서 액세스를 한다는 것은 알고 있을 것이다. 이 RCW는 Finalizer를 정의하고 있고 이 Finalizer가 COM 객체를 해제하도록 구성되어 있다. 따라서 엑셀 프로세스가 종료되는 시점은 다음(next) 가비지 컬렉션이 수행된 후가 될 것이다. 이것도 좀 문제가 있는 것이... 비록 가비지 컬렉션이 수행되더라도 곧바로 RCW의 Finalizer가 호출된다는 보장이 없다. Finalizer 메쏘드는 별도의 Finalizer 만을 위한 쓰레드가 호출하도록 되어 있기 때문에 언젠가는 호출되겠지만 그 언젠가가 당췌 언제인지는 모르는 것이다.
Dispose 패턴이 그러하듯이 명시적으로 엑셀 객체를 해제해 주면 되지 않을까? 그렇다. 명시적으로 엑셀 객체들을 해제 해주면 엑셀 프로세스는 곧바로 종료하게 된다. 요것이 포인트가 되겠다. COM 객체를 다룰 때는 두 가지만 알면 된다. 북치기 박치기~~ ^__^
웃자고 해본 소리고... COM 객체를 닷넷에서 다루고자 한다면 참조한 모든 COM 객체는 죄다 명시적으로 해제를 하면 된다. COM 객체를 해제하는 구체적인 방법은 System.Runtime.InteropServices 네임스페이스의 Marshal 클래스가 제공하는 ReleaseComObject 메쏘드를 호출하면 된다.
위 코드를 어떻게 수정하면 될까? 뇌리를 스치는 것은 app, workbook, sheet, range 변수에 대해 ReleaseComObject 를 호출하면 되지 않을까? 자... 그렇다면 위 메쏘드의 마지막에 다음 코드를 추가하고 Excel.exe 가 종료되나 살펴보자.
static void ExcelWillNotDie()
{
    // 기존 코드 동일 (생략)

    Marshal.ReleaseComObject(range);
    Marshal.ReleaseComObject(sheet);
    Marshal.ReleaseComObject(workbook);
    Marshal.ReleaseComObject(app);
}
테스트를 수행해 보면 예상과 달리 Excel.exe 프로세스는 종료되지 않는다. 왜일까? 필자가 붉은 색으로 강조하고 침 튀기며 외쳐댄 "참조한 COM 객체를 명시적으로 해제"를 수행 했는데 왜 Excel.exe 프로세스가 종료되지 않았을까? 둘 중 하나다. 필자가 구라를 쳤던가 아니면 코드에서 해제되지 않은 COM 객체 참조가 있던지.
당근 필자가 구라를 친 것은 아니다. 해제되지 않은 COM 객체 참조가 있기 때문이다. 메쏘드의 두 번째 라인을 잘 살펴보자. Application 객체의 Workbooks 속성의 Add 메쏘드를 호출하고 있다. 이 코드를 좀 풀어서 써 보자면 다음과 같다.
// 원래 코드
Excel.WorkSheet sheet = (Excel.WorkSheet)app.Workbooks.Add("");

// ���어쓴 코드
Excel.WorkBooks books = app.Workbooks;
Excel.WorkSheet sheet = (Excel.WorkSheet)books.Add(""); 
이제 감이 오는가? Application 객체의 Workbooks 속성이 또 다른 Workbooks 라는 COM 컬렉션 객체를 반환하고 있고, 이 COM 객체에 대한 참조는 암시적으로 이루어지고 있음을 알아야 한다.
그렇다면 명시적으로 COM 객체를 해제해 주려면 엑셀에 접근하는 코드 자체를 다음과 같이 수정해주어야 한다.
static void ExcelWillDie()
{
    Excel.ApplicationClass app = new Excel.ApplicationClass();
    Excel.Workbooks workbooks = app.Workbooks;
    Excel.Workbook workbook = workbooks.Add("");
    Excel.Sheets sheets = workbook.Worksheets;
    Excel.Worksheet sheet = (Excel.Worksheet)sheets["Sheet1"];
    Excel.Range cells = (Excel.Range)sheet.Cells;
    Excel.Range range = (Excel.Range)cells.get_Item("1", "A");

    range.Value2 = "Hello Excel Interop";

    // Excel 파일 저장 코드... (생략)
    app.DisplayAlerts = false; // 저장할 것인가 확인하지 않도록 설정

    app.Quit();

    Marshal.ReleaseComObject(range);
    Marshal.ReleaseComObject(cells);
    Marshal.ReleaseComObject(sheet);
    Marshal.ReleaseComObject(sheets);
    Marshal.ReleaseComObject(workbook);
    Marshal.ReleaseComObject(workbooks);
    Marshal.ReleaseComObject(app);
}
이 코드는 확실이 메쏘드 종료와 더불어 Excel.exe 프로세스를 종료시켜 준다.
VB 6.0이나 VBS 등으로 동등한 코드를 만들면 위와 같이 명시적인 해제가 없더라도 엑셀 프로세스는 잘 죽곤 한다. 왜 일까? 그건 VB 6.0 이나 VBS의 런타임이 메쏘드의 scope를 벗어나면 메쏘드에서 사용된 로컬 변수와 암시적으로 사용된 변수(app.WorkBooks.Add 의 경우 처럼)에 대해 해제 코드를 모두 호출해 주기 때문이다.
닷넷은 왜 VB 6.0 처럼 하지 못하는 것일까? 닷넷 개발팀이 닭대가리들이라서? 닷넷 개발팀이 닭대가리라면 나는 접시물에 코박고 죽어야할 운명이다... 근본적인 원인은 닷넷의 가비지 컬렉션이 그 이유라고 보면 되겠다. 가비지 컬렉션은 많은 장점을 가지고 있지만 COM 객체 접근이나 데이터베이스 연결(connection)과 같이 unmanaged 자원에 접근하는 경우 역 기능을 가지곤 한다.
보다 많은 코드를 작성해야 하고 ReleaseComObject 도 호출하는 위와 같은 방법 말고 Excel.exe를 우아하게 종료하는 방법은 없을까? 우아하지 않은 방법은 있다. 강제로 가비지 컬렉션을 수행하고 RCW의 Finalizer 메쏘드가 호출되도록 하면 Excel.exe가 종료되긴 한다.
GC.Collect();
GC.WaitForPendingFinalizer(); 
위와 같은 방법은 벼룩 잡을려고 초가삼간 태우는 격이 되겠다. 그 누구도 GC.Collect 호출을 권장하지 않는다. 가비지 컬렉션은 닷넷 CLR이 판단하여 스스로 수행하도록 하는 것이 가장 좋다. 그래도 위와 같이 GC.Collect와 GC.WaitForPendingFinalizer 호출을 수행하여 Excel 연동의 결과로 수행된 Excel.exe 프로세스를 종료시키는 방법이 있다는 것만 알아 두자.
마지막으로 당부할 것은 COM 객체를 반복문 안에서 참조하는 경우를 조심해야 한다. 반복문(for, while 등) 내에서 COM 객체의 참조를 얻었다면 해제 역시 반복문 내에서 이루어져야 한다는 점이다.
for(int i=1; i < 10; i++) {
   Excel.Range r = (Excel.Range)cells.get_Item(i, 2):
   r.Value2 = i;
   Marshal.ReleaseComObject(r);
}
왜 반복문 안에서 얻은 COM 참조를 반복문 내에서 해제해야 하는 가에 대해서는 상세히 설명하지 않겠다. 잘 생각해 보기를 바란다.

24.	C# 변수 

C# 변수는 메서드 안에서 해당 메서드의 로컬변수로 선언되거나, 혹은 클래스 안에서 클래스 내의 전역변수(이를 필드(Field) 라고 부른다)로 선언될 수 있다. 
로컬변수는 해당 메서드내에서만 사용되며, 메서드 호출이 끝나면 사용되지 못한다. 반면 필드는 클래스 객체가 살아있는 한 계속 존속하며 또한 다른 메서드들에서 참조할 수 있다
(주: 만약 필드가 static 정적 필드이면 클래스 Type이 처음으로 런타임에 의해 로드될 때 해당 Type object (타입 메타정보를 갖는 객체)에 생성되서 프로그램이 종료 때까지 유지된다).
로컬변수는 기본값을 할당받지 못하기 때문에 반드시 사용 전에 값을 할당해야 하는 반면, 필드는 값을 할당하지 않으면, 기본값이 자동으로 할당된다. 예를 들어, int 타입 필드인 경우 0 이 할당된다.
모든 C# 변수는 Case-Sensitive 즉 대소문자를 구별한다. 즉, var1 과 Var1은 서로 다른 변수이다. 

C# 변수 예제 

using System;

namespace ConsoleApplication1
{
    class CSVar
    {
        // 필드 (전역 변수)
        int globalVar;
        const int MAX = 1024;

        public void Method1()
        {
            // 로컬변수
            int localVar;

            // 아래 할당이 없으면 에러 발생
            localVar = 100;

            Console.WriteLine(globalVar);
            Console.WriteLine(localVar);
        }
    }

    class Program
    {
        // 모든 프로그램에는 Main()이 있어야
        static void Main(string[] args)
        {
            // 테스트
            CSVar obj = new CSVar();
            obj.Method1();
        }
    }
}

필드 globalVar는 값을 명시적으로 할당하지 않은 경우 기본값 0이 할당된다. 여기서 전역(Global)의 의미는 객체 (혹은 클래스) 내에서의 전역을 의미한다.
지역변수 localVar는 값을 할당하지 않고 사용하게 되면, 컴파일러 에러가 발생한다.

25.	static
1)	C# static 메서드 
Static 메서드는 인스턴스 메서드와는 달리 클래스로부터 객체를 생성하지 않고 직접 [클래스명.메서드명] 형식으로 호출하는 메서드이다. 
이 메서드는 메서드 앞에 static 이라는 C# 키워드를 적어주며, 메서드 내부에서 클래스 인스턴스 객체 멤버를 참조해서는 안된다. 
이 static 메서드는 인스턴스 객체로부터 호출될 수 없으며, 반드시 클래스명과 함께 사용된다. 

예제 
public class MyClass
{
   // 인스턴스 메서드
   public int InstRun()
   {
      return 1;
   }
   
   // 스태틱 메서드
   public static int Run() 
   {
      return 1;
   }
}

public class Client
{
   public void Test()
   {
      // 인스턴스 메서드 호출
      MyClass myClass = new MyClass();
      int i = myClass.InstRun();

      // 스태틱 메서드 호출
      int j = MyClass.Run();
   }
}

2)	C# static 프로퍼티, 필드 
Static 속성 및 필드는 위의 static 메서드와 같이 [클래스명.속성명]과 같이 사용하며, 
다음 예와 같이 static을 앞에 붙여 정의한다. 클래스 내의 Non-static 필드들은 클래스 인스턴트를 생성할 때마다 메모리에 매번 새로 생성되게 되는 반면
, static 필드는 프로그램 로딩시 단 한번 클래스 내에 생성되고 동일 메모리를 계속 사용한다. 

// static 필드
protected static int _id;

// static 속성
public static string Name { get; set; }
 
3)	C# static 클래스
Static 클래스는 모든 클래스 멤버가 static 멤버로 되어 있으며, 클래스명 앞에 static 이라는 C# 키워드를 사용하여 정의한다. 
Static 클래스는 public 생성자(Constructor)를 가질 수 없지만(왜냐 하면 static 클래스는 객체를 생성할 수 없으므로),
static 생성자를 가질 수 있다. 이 static 생성자는 주로 static 필드들을 초기화 할 때 사용한다. 아래 예제는 static 클래스 정의하고 사용한 예이다. 

예제 
// static 클래스 정의
public static class MyUtility
{
   private static int ver;

   // static 생성자
   static MyUtility()
   { 
      ver = 1;
   }

   public static string Convert(int i)
   {
      return i.ToString().ToUpper();
   }

   public static int ConvertBack(string s)
   {
      return int.Parse(s);
   }
}

// static 클래스 사용
static void Main(string[] args)
{
   string str = MyUtility.Convert(123);
   int i = MyUtility.ConvertBack(str);
}

4)	전역변수 - 폼과 폼 사이에서 동일한 변수 사용
문제 : 로그인 한 후, 사용자 아이디와 이름을 다른 폼에서 사용하여야 한다.
누가 데이터를 저장하고 수정하고 사용하는지를 저장하기 위해....

***********************************************************************
결론 -> static  키워드 사용
static 멤버 변수는 모든 객체가 공통으로 공유해야 할 값이 있을 때 사용할 변수
전역변수의 개념으로 사용할 때 생성
static 키워드는 객체생성할 필요없이 직접 클래스이름으로 접근이 가능
***********************************************************************

 Data 클래스를 매개로 Form1 과 Form2 를 연결하고 싶다고 했죠?
 그러면, Data 클래스를 static 으로 만들어 볼 수도 있어요.
 클래스를 static 으로 만들었으면, 그 내부에는 멤버도 모두 static 이 되어야 하죠.
 이렇게 되면, 일종의 전역 변수 형태가 되죠.
 Form1 클래스에서도 참조가능하고, Form2 클래스에서도 참조가능하죠.
/************************************************/
static class Data
{
        static string caption;
        static public string Ct
        {
            get
            {
                  return caption;
            }
            set
            {
                 caption = value;
            }
       }
}
/************************************************/

이제, 이벤트 핸들러를 고쳐봅시다.
/**********Form1.cs***********************/
private void button1_Click(object sender, EventArgs e)
        {          
            Form2 Frm2 = new Form2();       
           // Data a = new Data();
           // a.Ct = "안녕하세요";          
           Data.Ct = "안녕하세요";
            Frm2.ShowDialog();         
        }
/***********************************************/
/************Form2.cs***************************/
  private void button1_Click(object sender, EventArgs e)
        {
            //Data Dt =new Data();          
            MessageBox.Show(Data.Ct.ToString());
        }
/************************************************/

26.	자동 속성 초기자 (Auto-Property Initializer) 

자동 속성(Auto-Property)은 개발자가 필드를 지정할 필요가 없이 C# 컴파일러가 자동으로 해당 필드를 만들어 주는 속성(Property)이다. 
예를 들어 개발자가 public string Name { get; set; } 과 같이 써 주면, Name이라는 속성이 실제로 읽고 쓰는 필드(backing field)를 컴파일러가 자동으로 만들어 주게 된다. 이러한 자동 속성 기능은 기존에 지원하던 기능인데
C# 6.0에서는 이 자동 속성에 초기값을 지정하는 기능을 추가하였다. 이를 Auto-Property Initializer라 부르는데, 문법적으로는 Auto-Property 정의 뒤에 = 을 붙이고 초기값을 설정해 준다. 

예제 
class Person
{
    // 자동 속성 초기화
    public string Name { get; set; } = "(No name)";
}

27.	상수정의
C++에서 편하게 사용하던 #define MAX_COUNT 100 같은 상수 정의는 C#에서 지원되지 않는다.
게다가 파일 최상단에 위치하지 않으면 에러를 뿜어낸다.
아래와 같은 방법으로 정의해야 한다.


static class Constants
{
    public const double Pi = 3.14159;
    public const int SpeedOfLight = 300000; // km per sec.

}
class Program
{
    static void Main()
    {
        double radius = 5.3;
        double area = Constants.Pi * (radius * radius);
        int secsFromSun = 149476000 / Constants.SpeedOfLight; // in km
    }
}

27-1.1차원 배열(C# 프로그래밍 가이드)
다음 예제와 같이 5개 정수의 1차원 배열을 선언할 수 있습니다. 
int[] array = new int[5];
이 배열에는 array[0] ~ array[4]의 요소가 포함되어 있습니다. new 연산자는 배열을 만들고 배열 요소를 기본값으로 초기화하는 데 사용됩니다. 
이 예제에서는 모든 배열 요소가 0으로 초기화됩니다. 

동일한 방식으로 문자열 요소를 저장하는 배열을 선언할 수 있습니다. 예: 
string[] stringArray = new string[6];

배열 초기화
선언 시 배열을 초기화할 수 있으며, 이 경우 차수 지정자가 초기화 목록에 있는 요소 수에 의해 제공되기 때문에 지정할 필요가 없습니다. 예: 
int[] array1 = new int[] { 1, 3, 5, 7, 9 };

문자열 배열도 동일한 방식으로 초기화할 수 있습니다. 다음은 각 배열 요소가 하루의 이름으로 초기화되는 문자열 배열의 선언입니다. 
string[] weekDays = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

선언 시 배열을 초기화하면 다음 바로 가기를 사용할 수 있습니다. 
int[] array2 = { 1, 3, 5, 7, 9 };
string[] weekDays2 = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

초기화하지 않고 배열 변수를 선언할 수 있지만 이 변수에 배열을 할당할 때 new 연산자를 사용해야 합니다. 예: 
int[] array3;
array3 = new int[] { 1, 3, 5, 7, 9 };   // OK
//array3 = {1, 3, 5, 7, 9};   // Error
	
27.	다차원 배열(C# 프로그래밍 가이드)
int[,] array = new int[4, 2];
다음 선언은 세 가지 차원 4, 2, 3의 배열을 만듭니다. 
int[, ,] array1 = new int[4, 2, 3];

1)	배열 초기화
다음 예제와 같이 선언 시 배열을 초기화할 수 있습니다. 
// Two-dimensional array.
int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
// The same array with dimensions specified.
int[,] array2Da = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
// A similar array with string elements.
string[,] array2Db = new string[3, 2] { { "one", "two" }, { "three", "four" },
                                        { "five", "six" } };

// Three-dimensional array.
int[, ,] array3D = new int[,,] { { { 1, 2, 3 }, { 4, 5, 6 } }, 
                                 { { 7, 8, 9 }, { 10, 11, 12 } } };
// The same array with dimensions specified.
int[, ,] array3Da = new int[2, 2, 3] { { { 1, 2, 3 }, { 4, 5, 6 } }, 
                                       { { 7, 8, 9 }, { 10, 11, 12 } } };

// Accessing array elements.
System.Console.WriteLine(array2D[0, 0]);
System.Console.WriteLine(array2D[0, 1]);
System.Console.WriteLine(array2D[1, 0]);
System.Console.WriteLine(array2D[1, 1]);
System.Console.WriteLine(array2D[3, 0]);
System.Console.WriteLine(array2Db[1, 0]);
System.Console.WriteLine(array3Da[1, 0, 1]);
System.Console.WriteLine(array3D[1, 1, 2]);

// Getting the total count of elements or the length of a given dimension.
var allLength = array3D.Length;
var total = 1;
for (int i = 0; i < array3D.Rank; i++) {
    total *= array3D.GetLength(i);
}
System.Console.WriteLine("{0} equals {1}", allLength, total);

// Output:
// 1
// 2
// 3
// 4
// 7
// three
// 8
// 12
// 12 equals 12

2)	배열 초기화
Array.Clear 메서드 (Array, Int32, Int32)
public static void Clear(
	Array array,
	int index,
	int length
)
매개 변수
array
	Type: System.Array
	포함된 요소를 지울 배열입니다.
index
	Type: System.Int32
	지울 요소 범위의 시작 인덱스입니다.
length
	Type: System.Int32
	지울 요소의 개수입니다.
예제)
using System;

class Example
{
    public static void Main()
    {
        Console.WriteLine("One dimension (Rank=1):");
        int[] numbers1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

        for (int i = 0; i < 9; i++)
        {
            Console.Write("{0} ", numbers1[i]);
        }
        Console.WriteLine();
        Console.WriteLine();

        Console.WriteLine("Array.Clear(numbers1, 2, 5)");
        Array.Clear(numbers1, 2, 5);

        for (int i = 0; i < 9; i++)
        {
            Console.Write("{0} ", numbers1[i]);
        }
        Console.WriteLine();
        Console.WriteLine();

        Console.WriteLine("Two dimensions (Rank=2):");
        int[,] numbers2 = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                Console.Write("{0} ", numbers2[i, j]);
            }
            Console.WriteLine();
        }

        Console.WriteLine();
        Console.WriteLine("Array.Clear(numbers2, 2, 5)");
        Array.Clear(numbers2, 2, 5);

        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                Console.Write("{0} ", numbers2[i, j]);
            }
            Console.WriteLine();
        }

        Console.WriteLine("Three dimensions (Rank=3):");
        int[, ,] numbers3 = {{{1, 2}, {3, 4}},
                             {{5, 6}, {7, 8}},
                             {{9, 10}, {11, 12}}};

        for (int i = 0; i < 2; i++)
        {
            for (int j = 0; j < 2; j++)
            {
                for (int k = 0; k < 2; k++)
                {
                    Console.Write("{0} ", numbers3[i, j, k]);
                }
                Console.WriteLine();
            }
            Console.WriteLine();
        }

        Console.WriteLine("Array.Clear(numbers3, 2, 5)");
        Array.Clear(numbers3, 2, 5);

        for (int i = 0; i < 2; i++)
        {
            for (int j = 0; j < 2; j++)
            {
                for (int k = 0; k < 2; k++)
                {
                    Console.Write("{0} ", numbers3[i, j, k]);
                }
                Console.WriteLine();
            }
            Console.WriteLine();
        }
        
		Console.WriteLine("Two dimensions (Rank=2):");
		int[,] arrayNum = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				Console.Write("{0} ", arrayNum[i, j]);
			}
			Console.WriteLine();
		}
		Console.WriteLine();

		Console.WriteLine("All Array.Clear");
		Array.Clear(arrayNum, 0, arrayNum.Length);

		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				Console.Write("{0} ", arrayNum[i, j]);
			}
			Console.WriteLine();
		}
		Console.WriteLine();
		Console.WriteLine();
    }
}
/*  This code example produces the following output:
 * 
 * One dimension (Rank=1):
 * 1 2 3 4 5 6 7 8 9
 * 
 * Array.Clear(numbers1, 2, 5)
 * 1 2 0 0 0 0 0 8 9
 * 
 * Two dimensions (Rank=2):
 * 1 2 3
 * 4 5 6
 * 7 8 9
 * 
 * Array.Clear(numbers2, 2, 5)
 * 1 2 0
 * 0 0 0
 * 0 8 9
 * 
 * Three dimensions (Rank=3):
 * 1 2
 * 3 4
 * 
 * 5 6
 * 7 8
 * 
 * Array.Clear(numbers3, 2, 5)
 * 1 2
 * 0 0
 * 
 * 0 0
 * 0 8
 
 * Two dimensions (Rank=2):
 * 1 2 3 
 * 4 5 6 
 * 7 8 9 
 *
 * All Array.Clear
 * 0 0 0 
 * 0 0 0 
 * 0 0 0 
 */

27+1.자료구조 : 동적 배열 (Dynamic Array) 
배열은 고정된 크기의 연속된 배열요소들의 집합이므로 배열을 초기화 할 때 총 배열 요소의 수를 미리 지정해야 한다. 
하지만 경우에 따라 배열요소가 몇 개나 필요한 지 미리 알 수 없는 경우가 있으며, 
중간에 필요에 따라 배열을 확장해야 하는 경우도 있다. .NET에는 이러한 동적 배열을 지원하는 클래스로 ArrayList와 List<T>이 있다. 
이들 동적 배열 클래스들은 배열 확장이 필요한 경우, 내부적으로 배열 크기가 2배인 새로운 배열을 생성하고 모든 기존 배열 요소들을 
새로운 배열에 복사한 후 기존 배열을 해제한다. 동적 배열의 Time Complexity는 배열과 같이 인덱스를 통할 경우 O(1), 값으로 
검색할 경우 O(n)을 갖는다. 


ArrayList 클래스 
ArrayList는 모든 배열 요소가 object 타입인 Non-generic 동적 배열 클래스이다. 
.NET의 Non-generic 클래스들은 System.Collections 네임스페이스 안에 있으며, 
단점으로 박싱 / 언박싱이 일어나게 된다. ArrayList는 배열 요소를 읽어 사용할 때 object를 리턴하므로 
일반적으로 원하는 타입으로 먼저 캐스팅(Casting)한 후 사용하게 된다. 

예제 
ArrayList myList = new ArrayList();
myList.Add(90);
myList.Add(88);
myList.Add(75);

// int로 casting
int val = (int) myList[1]; 

List<T> 클래스 
List<T>는 배열요소가 T 타입인 Generics로서 동적 배열을 지원하는 클래스이다. 
.NET의 Generic 클래스들은 System.Collections.Generic 네임스페이스 안에 있다. 
List클래스는 내부적으로 배열을 가지고 있으며, 동일한(Homogeneous) 타입의 데이타를 저장한다. 
만약 미리 할당된 배열 크기(Capacity라 부른다)가 부족하면 내부적으로 배열을 2배로 늘려 동적으로 배열을 확장한다. 
ArrayList와 다르게 캐스팅을 할 필요가 없으며, 박싱 / 언박싱의 문제를 발생시키지 않는다. 

예제1) 
List<int> myList = new List<int>();
myList.Add(90);
myList.Add(88);
myList.Add(75);
int val = myList[1];

예제2)
List<string> myList = new List<string>();

myList.Add("HOHO");
myList.Add("hihi");

foreach (string stTemp in myList)
	Console.WriteLine(stTemp);
-> 결과
HOHO
hihi

27+2.유니티 C# : 박싱과 언박싱

C#은 object가 모든 데이터를 다룰 수 있도록 하기 위해
모든 데이터 형식, 심지어 프로그래머들이 만드는
데이터 형식마저도 자동으로 object 형식을 상속 받는다.
즉, object는 모든 데이터 형식의 base class가 된다.

object 형식은 참조 형식이기 때문에 힙에 데이터를 할당한다.
반면, int나 double은 값 형식이기 때문에 스택에 데이터를
할당한다. 하지만 앞서 모든 데이터는 object를 상속받는다고
했는데 어떻게 값 형식의 데이터를 object에 담을 수 있는가?

object 형식은 값 형식의 데이터를 힙에 할당하기 위해
박싱 (boxing) 기능을 제공한다.
object a = 20;
20은 힙에 할당 되고, a는 그 주소를 참조한다. (박싱)

반대로 힙에 있던 값 형식 데이터를 값 형식 객체에
다시 할당해야 하는 경우가 있는데
이를 언박싱(unboxing)이라고 한다.
object a = 20; //// 박싱
int b = (int)a //// 언박싱
a는 박싱되어 20이 저장되어 있는 힙을 참조하고 있다.
b는 a가 참조하고 있는 메모리로부터 값을 복사한다. (언박싱)

정리하자면
박싱 : 값 형식을 참조 형식으로 변환
언박싱 : 참조 형식을 값 현식으로 변환

박싱의 과정 : 
1. 값 타입을 힙에 생성하기 위해 메모리를 힙 영역에 생성
2. 값을 힙 영역에 할당된 메모리로 복사
3. 참조할 변수에 할당된 메모리 주소를 할당

언박싱의 과정 :
1. 박싱값인지 확인
2. 박싱된 값이라면 값 타입 변수에 복사
3. 박싱한 메모리와 언박싱한 메모리 2개 존재 ( 가비지 발생 )

주의 : 모든 객체가 값 형식으로 언박싱이 될 수 없고, 이전에 박싱이 된
데이터에 한하여 언박싱이 가능하다. 또한 박싱하기전의 타입을 따라야 한다.

박싱/언박싱(boxing/unboxing)
MSDN 에 의하면 값 형식을 박싱할 때에는 완전히 새로운
개체가 만들어져야 하며, 이러한 작업에는 할당 작업보다
최대 20배의 시간이 걸린다고 한다. 언박싱 또한 캐스팅
과정이 할당 작업보다 4배의 시간이 걸릴 수 있다고 나와있다.

보시다시피 엄청난 성능상의 단점이 있다.
하지만 박싱/언박싱의 편리성 때문에 간혹 쓰이기도 한다.
--> ArrayList , 헤쉬테이블이 박싱/언박싱의 대표적인 예이다.

성능상의 단점을 감수하면서까지 쓸 필요는 없다고 생각한다.
리스트나 딕셔너리로도 충분히 대체할 수 있기 때문에
이를 공부하여 적절히 사용하는 방법이 좋을 것 같다.

28.	RS232 통신 소스

예제1)	(최신 명령어로 가장 간단하고 잘 코딩되어 RS232 통신 소스)
cf)	RS232 핀맵
	DB-9 RS232 커넥터
	2번 : RXD
	3번 : TXD
	5번 : GND

https://www.codeproject.com/ -> CodeProjectSerialComms-noexe

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.IO.Ports;
using System.Windows.Forms;

//CodeProjectSerialComms program 
//23/04/2013   16:29

namespace CodeProjectSerialComms
{
    public partial class Form1 : Form
    {
        SerialPort ComPort = new SerialPort();
        
        internal delegate void SerialDataReceivedEventHandlerDelegate(object sender, SerialDataReceivedEventArgs e);
        internal delegate void SerialPinChangedEventHandlerDelegate(object sender, SerialPinChangedEventArgs e);
        private SerialPinChangedEventHandler SerialPinChangedEventHandler1;
        delegate void SetTextCallback(string text);
        string InputData = String.Empty;

        public Form1()
        {
            InitializeComponent();
            SerialPinChangedEventHandler1 = new SerialPinChangedEventHandler(PinChanged);
            ComPort.DataReceived += new System.IO.Ports.SerialDataReceivedEventHandler(port_DataReceived_1);
        }
     
        private void btnGetSerialPorts_Click(object sender, EventArgs e)
        {
            string[] ArrayComPortsNames = null;
            int index = -1;
            string ComPortName = null;
           
//Com Ports
            ArrayComPortsNames = SerialPort.GetPortNames();
            do
            {
                index += 1;
                cboPorts.Items.Add(ArrayComPortsNames[index]);
               
              
            } while (!((ArrayComPortsNames[index] == ComPortName) || (index == ArrayComPortsNames.GetUpperBound(0))));
            Array.Sort(ArrayComPortsNames);
           
            if (index == ArrayComPortsNames.GetUpperBound(0))
            {
                ComPortName = ArrayComPortsNames[0];
            }
            //get first item print in text
            cboPorts.Text = ArrayComPortsNames[0];
//Baud Rate
            cboBaudRate.Items.Add(300);
            cboBaudRate.Items.Add(600);
            cboBaudRate.Items.Add(1200);
            cboBaudRate.Items.Add(2400);
            cboBaudRate.Items.Add(9600);
            cboBaudRate.Items.Add(14400);
            cboBaudRate.Items.Add(19200);
            cboBaudRate.Items.Add(38400);
            cboBaudRate.Items.Add(57600);
            cboBaudRate.Items.Add(115200);
            cboBaudRate.Items.ToString();
            //get first item print in text
            cboBaudRate.Text = cboBaudRate.Items[0].ToString(); 
//Data Bits
            cboDataBits.Items.Add(7);
            cboDataBits.Items.Add(8);
            //get the first item print it in the text 
            cboDataBits.Text = cboDataBits.Items[0].ToString();
           
//Stop Bits
            cboStopBits.Items.Add("One");
            cboStopBits.Items.Add("OnePointFive");
            cboStopBits.Items.Add("Two");
            //get the first item print in the text
            cboStopBits.Text = cboStopBits.Items[0].ToString();
//Parity 
            cboParity.Items.Add("None");
            cboParity.Items.Add("Even");
            cboParity.Items.Add("Mark");
            cboParity.Items.Add("Odd");
            cboParity.Items.Add("Space");
            //get the first item print in the text
            cboParity.Text = cboParity.Items[0].ToString();
//Handshake
            cboHandShaking.Items.Add("None");
            cboHandShaking.Items.Add("XOnXOff");
            cboHandShaking.Items.Add("RequestToSend");
            cboHandShaking.Items.Add("RequestToSendXOnXOff");
            //get the first item print it in the text 
            cboHandShaking.Text = cboHandShaking.Items[0].ToString();

        }

     


        private void port_DataReceived_1(object sender, SerialDataReceivedEventArgs e)
        {
            InputData = ComPort.ReadExisting();
            if (InputData != String.Empty)
            {
                this.BeginInvoke(new SetTextCallback(SetText), new object[] { InputData });
            }
        }
        private void SetText(string text)
        {
            this.rtbIncoming.Text += text;
        }
        internal void PinChanged(object sender, SerialPinChangedEventArgs e)
        {
            SerialPinChange SerialPinChange1 = 0;
            bool signalState = false;

            SerialPinChange1 = e.EventType;
            lblCTSStatus.BackColor = Color.Green;
            lblDSRStatus.BackColor = Color.Green;
            lblRIStatus.BackColor = Color.Green;
            lblBreakStatus.BackColor = Color.Green;
            switch (SerialPinChange1)
            {
                case SerialPinChange.Break:
                    lblBreakStatus.BackColor = Color.Red;
                    //MessageBox.Show("Break is Set");
                    break;
                case SerialPinChange.CDChanged:
                    signalState = ComPort.CtsHolding;
                  //  MessageBox.Show("CD = " + signalState.ToString());
                    break;
                case SerialPinChange.CtsChanged:
                    signalState = ComPort.CDHolding;
                    lblCTSStatus.BackColor = Color.Red;
                    //MessageBox.Show("CTS = " + signalState.ToString());
                    break;
                case SerialPinChange.DsrChanged:
                    signalState = ComPort.DsrHolding;
                    lblDSRStatus.BackColor = Color.Red;
                    // MessageBox.Show("DSR = " + signalState.ToString());
                    break;
                case SerialPinChange.Ring:
                    lblRIStatus.BackColor = Color.Red;
                    //MessageBox.Show("Ring Detected");
                    break;
            }
        }

        private void btnTest_Click(object sender, EventArgs e)
        {
            //SerialPinChangedEventHandler1 = new SerialPinChangedEventHandler(PinChanged);
            //ComPort.PinChanged += SerialPinChangedEventHandler1;
            //ComPort.Open();

            //ComPort.RtsEnable = true;
            //ComPort.DtrEnable = true;
            //btnTest.Enabled = false;

        }

        private void btnPortState_Click(object sender, EventArgs e)
        {
          
            if (btnPortState.Text == "Closed")
            {
                btnPortState.Text = "Open";
                ComPort.PortName = Convert.ToString(cboPorts.Text);
                ComPort.BaudRate = Convert.ToInt32(cboBaudRate.Text);
                ComPort.DataBits = Convert.ToInt16(cboDataBits.Text);
                ComPort.StopBits = (StopBits)Enum.Parse(typeof(StopBits), cboStopBits.Text);
                ComPort.Handshake = (Handshake)Enum.Parse(typeof(Handshake), cboHandShaking.Text);
                ComPort.Parity = (Parity)Enum.Parse(typeof(Parity), cboParity.Text);
                ComPort.Open();
            }
            else if (btnPortState.Text == "Open")
            {
                btnPortState.Text = "Closed";
                ComPort.Close();
               
            }
        }
        private void rtbOutgoing_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == (char)13) // enter key  
            {
                ComPort.Write("\r\n");
                rtbOutgoing.Text = "";
            }
            else if (e.KeyChar < 32 || e.KeyChar > 126)
            {
                e.Handled = true; // ignores anything else outside printable ASCII range  
            }
            else
            {
                ComPort.Write(e.KeyChar.ToString());
            }
        }
        private void btnHello_Click(object sender, EventArgs e)
        {
            ComPort.Write("Hello World!");
        }

        private void btnHyperTerm_Click(object sender, EventArgs e)
        {
            string Command1 = txtCommand.Text;
            string CommandSent;
            int Length, j = 0;

            Length = Command1.Length;

            for (int i = 0; i < Length; i++)
            {
                CommandSent = Command1.Substring(j, 1);
                ComPort.Write(CommandSent);
                j++;
            }

        }

      
    }
}

예제2)
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO.Ports;  //Serial 통신에 쓰일 함수 불러옴
 
 
namespace serial_comport4
{
    public partial class Form1 : Form
    {
        delegate void SetTextCallback(string Text);     //SerialPort에 데이터가 들어갈 때
                                                        //DataReceieved EventHandler 에 필요한 중요한개념입니다.
        SerialPort serialPort1 = new SerialPort();      //SerialPort에 필요한 인스턴스 생성  
        public Form1()
        {
            InitializeComponent();
            getAvailablePorts();            // 사용가능한 포트 불러오기함수
        }
 
        void getAvailablePorts()
        {
            string[] ports = SerialPort.GetPortNames();         //사용가능한 포트를 받아와서
            comboBox1.Items.AddRange(ports);                    //ComPort 콤보박스에 리스트로 추가
        }
 
        private void btnOpenPort_Click(object sender, EventArgs e)  //Open Port 버튼 클릭시 이벤트 발생
        {
            try
            {                
                if (comboBox1.Text == "" || comboBox2.Text ==""|| comboBox1.Text == null)
                {
                    textBox2.Text = "포트 세팅이 안 되어 있습니다.";        //사용가능한 포트, BaudRate 지정안할시 처리
                }
                else
                {                    
                    serialPort1.PortName = comboBox1.Text;
                    serialPort1.BaudRate = Convert.ToInt32(comboBox2.Text);//콤보박스에 있는 데이터는 문자이기때문에 Int로 형변환
                    serialPort1.DataBits = 8;   //기본 데이터 비트 지정
                    serialPort1.StopBits = StopBits.One;    //기본 스탑비트 지정
                    serialPort1.Parity = Parity.None;       //기본 패리티 비트 지정
                    serialPort1.Open();                     //선택한 serialPort 오픈
                    button1.Enabled = true;                 //button1(send)버튼 Enable
                    textBox1.Enabled = true;
                    btnOpenPort.Enabled = false;
                    btnClosePort.Enabled = true;
                }
            }
            catch(UnauthorizedAccessException)      //접근 불가 예외처리
            {
                textBox2.Text = "접근 불가";
            }
        }
 
        private void btnClosePort_Click(object sender, EventArgs e) //Close Port 버튼시 발생하는 이벤트
        {
            serialPort1.Close();        //사용중인 Port Close
            button1.Enabled = false;                        
            btnClosePort.Enabled = false;
            btnOpenPort.Enabled = true;
            textBox1.Enabled = false;
        }
 
        private void button1_Click(object sender, EventArgs e)      //Send 버튼 실행시 이벤트 발생
        {
            if (serialPort1.IsOpen)                                 
            {                
                byte[] values = new byte[1];
 
                try
                {
                    values[0] = byte.Parse(textBox1.Text);
                }
                catch
                {
                    textBox2.Text = "유효한 값이 아닙니다.";
                    return;
                }
 
                serialPort1.Write(textBox1.Text);               //Send 텍스트 상자에 있는값을 serial포트에 저장    
            }         
        }
        //serial포트에 데이터 들어올떄 발생하는 이벤트
        private void serialPort1_DataReceived(object sender, System.IO.Ports.SerialDataReceivedEventArgs e)
        {
            if (serialPort1.IsOpen)
            {
                string data = serialPort1.ReadExisting();   //serial포트에 있는 데이터를 불러와서 변수 저장
 
                if (data != string.Empty)
                {
                    char[] values = data.ToCharArray();
                    int value = Convert.ToInt32(values[0]);
 
                    //data = value.ToString();/////////////////////
                    DataProcessing(data);
                }
            }
        }
 
        private void DataProcessing(string Text)
        {
            if (this.textBox2.InvokeRequired)
            {
                SetTextCallback dp = new SetTextCallback(DataProcessing);
                this.Invoke(dp, new object[] { Text }); //콜벡한 대이터를 변환
            }
            else
            {
                this.textBox2.Text += (Text + " ");
            }
        }
 
        private void EnableControls(bool value)                 //각종 모든 선택사항의 Enalbe을 관리
        {
            if (value == true)
            {
                comboBox1.Enabled = true;
                comboBox2.Enabled = true;
                comboBox3.Enabled = true;
                comboBox4.Enabled = true;
                comboBox5.Enabled = true;
            }
            else
            {
                comboBox1.Enabled = false;
                comboBox2.Enabled = false;
                comboBox3.Enabled = false;
                comboBox4.Enabled = false;
                comboBox5.Enabled = false;
            }
        }
 
        private void btnClear_Click(object sender, EventArgs e)
        {
            textBox2.Clear();       // 클리어 버튼을 누를시 '특이사항'텍스트 박스를 클리어
        }
    }
}
출처: http://lhws.tistory.com/5 [LHW's studyblog]

29.	C# 주석
1)	유니티 C# XML 주석 /// 사용법 <summary>
	기본적으로 사용하는 // 슬래시 두개의 주석이 아닌
	/// 슬래시 세개로 사용하는 XML주석은
	클래스나 함수의 설명을 사용자에게 알려줄 때 유용함
	
	/// 슬래시 세개와 XML 주석을 작성하면
	해당 클래스나 함수를 사용할 때 툴팁을 통해 지정한 설명을 보실 수 있습니다.	

30.	c# TextBox 속성정리  Window Form / C Sharp  
1. AcceptsTab [ Tab 설정 ] ( 타입 : boolean )
 - true : tab입력시 탭 순서에 따라 다음컨트롤로 포커스가 이동되지 않고 tab 문자가 입력됨. ( Multiline 속성이 True로 설정되어 있어야 작동함 )
 - false : tab입력시 탭 순서에 따라 다음컨트롤로 포커스가 이동됨
 
2. AllowDrop [ Drag & Drop 사용여부 ] ( 타입 : boolean )
 - true : Drag & Drop 이벤트를 수행할 수 있다 ( 해당 속성이 true로 되어있어야 DragDrop, DragEnter 이벤트 사용가능 )
 - false : Drag & Drop 이벤트를 수행하지 않음
 
3. AutoCompleteMode [ 설명 자동완성 기능에 대한 모드 ] ( 타입 : enum )
 - None : 사용하지 않음
 - Suggest : 사용자가 입력한 문자와 첫 부분이 일치하는 항목을 드롭다운으로 표시함( 선택 가능 )
 - Append : 사용자가 입렿나 문자와 첫 부분이 일치하는 항목의 Text를 자동입력( 강조표시 )
 - SuggestAppend : Suggest / Append 동시 사용
 
4. AutoCompleteSource [ 자동완성 기능에 대한 소스 지정 ] ( 타입 : enum )
 - FileSystem : 파일 시스템을 소스로 지정
 - HistoryList : 기록 목록에 있는 URL( Uniform Resource Locator )를 포함
 - RecentlyUsedList : 최근에 사용된 URL ( Uniform Resource Locator ) 목록의 URL을 포함
 - AllUrl : HistoryList / RecentlyUsedList 둘다 포함
 - AllSystemSources : FileSystem / AllUrl 둘다 적용. AutoCompleteMode가 None이 아닐때 이것이 Default 설정됨
 - FileSystemDirectories : 파일 이름은 제외하고 디렉터리만 자동완성되게 지정
 - CustomSource : 자동완성에 사용되는 소스를 직접 지정 ( AutoCompleteStringCollection 속성 참고 )
 - None : 미사용
 
5. CausesValidation [ 유효성  검사 수행 여부 ] ( 타입 : boolean )
 - true : 사용 ( 해당값이 true로 설정되어야 Validated, Validating 이벤트 사용가능 )
 - false : 미사용
 
6. CharacterCasing [ 문자를 대문자 / 소문자로 변환하는지 여부 ] ( 타입 : enum )
 - Nomal : 해당 기능 하용하지 않음
 - Upper : 대문자로 변환
 - Lower : 소문자로 변환
 
7. Lines [ TextBox의 Text의 배열 ( 줄바꿈 마다 배열 요소 추가 ) ] ( 타입 : string[] )
 - Multiline이 True일때 줄바꿈 마다 배열로 Split 되어 반환됨. false일때는 TextBox.Text가 1개의 크기의 배열로 반환됨
 
8. Multiline [ 2줄 이상 확장 가능한지 여부 ] ( 타입 : boolean )
 - true : 2줄 이상 가능
 - false : 1줄만 가능
 
9. PasswordChar [ 문자 입력시 해당 값으로 치환 ] ( 타입 : char )
 - '*'로 설정할 경우 어떤 값을 입력해도 모두 *로 표시된다.
 
10. ReadOnly [ 텍스트를 변경 가능 여부 ] ( 타입 : boolean )
 - true : 불가능
 - false : 가능
 
11. ScrollBars [ 스크롤 사용여부 ] ( 타입 : enum )
 - None : 미사용
 - Horizontal : 가로 스크롤만 사용
 - Vertical : 세로 스크롤만 사용
 - Both : 가로 / 세로 스크롤 모두 사용
> Multiline 속성이 false 경우 스크롤이 표시되지 않음.
> WordWrap 속성이 true일 경우 가로 스크롤이 표시되지 않음.
 
12. ShortcutsEnabled [ 바로 가기 키 사용여부 ] ( 타입 boolean )
 - true : 사용
 - false : 미사용
 - 바로가기 키 : Ctrl + Z, Ctrl + E, Ctrl + C, Ctrl + Y, Ctrl + X, Ctrl + V... 등
 
13. WordWrap [ 자동 줄 바꿈 여부 ] ( 타입 : boolean )
 - true : 사용
 - false : 미사용

30.	C# => Lambda Expression 
C# 3.0부터 지원하는 => 연산자는 C#에서 람다 식(Lambda Expression)을 표현할 때 사용한다. 람다식은 무명 메서드와 비슷하게 
무명 함수(anonymous function)를 표현하는데 사용된다. 

람다식은 아래와 같이 입력 파라미터(0개 ~ N개)를 => 연산자 왼쪽에, 실행 문장들을 오른쪽에 둔다. 
람다 Synyax : (입력 파라미터) => { 문장블럭 };

예를 들어 하나의 문자열을 받아 들여 메시지 박스를 띄운다면 다음과 같이 간단히 쓸 수 있다. 
str => { MessageBox.Show(str); }

입력 파라미터는 하나도 없는 경우부터 여러 개 있는 경우가 있다. 다음 예는 파라미터가 없는 케이스 부터 두개 있는 케이스까지 보여준다. 
마지막 예는 입력 파라미터의 타입이 애매한 경우 이를 써줄 수 있음을 보여준다. 일반적으로 입력타입은 컴파일러가 알아서 찾아낸다. 
() => Write("No");
(p) => Write(p);
(s, e) => Write(e);
(string s, int i) => Write(s, i);

Lambda Expression을 이용하면 이전 페이지에 소개한 delegate 와 무명 메서드를 더 간략히 표현할 수 있다. 
예를 들어 다음과 같은 Click 이벤트는 이벤트 핸들러 메서드인 button1_Click를 가리키고 있다. 
그래서 메서드 button1_Click은 해당 클래스내 어딘가에 정의되어 있어야 한다. 
this.button1.Click += new System.EventHandler(button1_Click);

private void button1_Click(object sender, EventArgs e)
{
   ((Button)sender).BackColor = Color.Red;
}

위의 new System.EventHandler(button1_Click)은 간단히 button1_Click 메서드명만 사용하여 아래와 같이 줄일 수 있다. 
this.button1.Click += button1_Click;

이를 좀더 간단하려면 아래와 같이 무명 메서드(Anonymous Method)를 써서 표현할 수 있다.
this.button1.Click += delegate(object sender, EventArgs e)
{
   ((Button)sender).BackColor = Color.Red;
};

그리고 람다 식을 사용하면 이를 더 간단히 다음과 같이 바꿀 수 있다. 람다 식의 오른쪽 실행 블럭이 한 문장일 때는 { } 괄호를 생략할 수 있다.
아래 식은 무명 메서드를 쉽게 람다 식으로 변경한 간단한 예이다. 
this.button1.Click += (sender, e) => ((Button)sender).BackColor = Color.Red;

람다 식(Lambda Expression)은 .NET 여러 곳에서 사용되지만 특히 LINQ (Language Integrated Query) 에서 많이 사용된다. 
LINQ는 별도의 주제이지만 아래는 람다식이 LINQ의 Where 쿼리에서 사용된 간단한 예이다. 
var proj = db.Projects.Where(p => p.Name == strName);

30.	C# 5.0 : async / await 키워드 
C# 5.0부터 새로운 C# 키워드로 async와 await가 추가되었다. 이 키워드들은 기존의 비동기 프로그래밍 (asynchronous programming)을 
보다 손쉽게 지원하기 위해 C# 5.0에 추가된 중요한 기능이다.
C# async는 컴파일러에게 해당 메서드가 await를 가지고 있음을 알려주는 역활을 한다. 
async라고 표시된 메서드는 await를 1개 이상 가질 수 있는데, 하나도 없는 경우라도 컴파일은 가능하지만 Warning 메시지를 표시한다. 
async를 표시한다고 해서 자동으로 비동기 방식으로 프로그램을 수행하는 것은 아니고, 일종의 보조 역활을 하는 컴파일러 지시어로 볼 수 있다.
실제 핵심 키워드는 await인데, 이 await는 일반적으로 Task 혹은 Task<T> 객체와 함께 사용된다. Task 이외의 클래스도 사용 가능한데, 
awaitable 클래스, 즉 GetAwaiter() 라는 메서드를 갖는 클래스이면 함께 사용 가능하다.
await는 Task와 같은 awaitable 클래스 객체가 완료되기를 기다리는데, 여기서 중요한 점은 UI 쓰레드가 정지되지 않고 메시지 루프를 계속 돌 수 있도록 
필요한 코드를 컴파일러가 await 키워드를 만나면 자동으로 추가한다는 점이다. 메시지 루프가 계속 돌게 만든다는 것은 마우스 클릭이나 
키보트 입력등을 계속 처리할 수 있다는 것을 의미한다. await는 해당 Task가 끝날 때까지 기다렸다가 완료 후, 
바로 다음 실행문부터 실행을 계속한다. await가 기다리는 Task 혹은 실행 메서드는 별도의 Worker Thread에서 돌 수도 있고, 
또는 UI Thread에서 돌 수도 있다. 즉, await가 항상 비동기 실행을 위한 Background Thread를 필요로 하는 것은 아니다. 
await가 보장하는 것은, Task가 UI Thread에 돌던지, Worker thread에서 돌던지 상관없이 Task 완료 후 await 이후의 실행문들을 디폴트로 
원래 await를 실행하기 전의 Thread에서 실행하도록 보장하는 것이다.

아래 예제는 버튼 클릭으로 Run()이라는 async 메서드를 실행하고, Run 메서드 안에서 비동기 Task를 만들어 실행하고 결과를 기다리는 
await 문의 예를 보여주고 있다. await는 LongCalcAsync() 라는 메서드가 끝나기를 기다렸다가 끝나면 결과를 sum에 할당한 후 다음 문장들을 계속 실행한다.
특히 여기서 주목할 만한 것은 결과값을 Label 컨트롤에 뿌려줄 때, Invoke()나 BeginInvoke()를 쓸 필요가 없다는 점이다. 
Background Thread에서 비동기 Task가 끝난 후, await가 다시 Caller가 갖고 있던 쓰레드 즉 UI Thread로 다음 문장들을 실행하게 하기 때문이다.

private void button1_Click(object sender, EventArgs e)
{
     Run();  //UI Thread에서 실행
}

private async void Run()
{
    // 비동기로 Worker Thread에서 도는 task1
    var task1 = Task<int>.Run(() => LongCalcAsync(10));

    // task1이 끝나길 기다렸다가 끝나면 결과치를 sum에 할당
    int sum = await task1;

    // UI Thread 에서 실행
    // Control.Invoke 혹은 Control.BeginInvok 필요없음
    this.label1.Text = "Sum = " + sum;
    this.button1.Enabled = true;
}

private int LongCalcAsync(int times)
{
    // ThreadPool에서 Worker Thread를 가져와
    // 아래 문장들 실행함
    int result = 0;
    for (int i = 0; i < times; i++)
    {
        result += i;
        Thread.Sleep(1000); 
    }
    return result;
}

31.	강제로 버튼 이벤트 발생
button8.PerformClick();									// 강제로 버튼 이벤트 발생

32.	MessageBox
예제1)	C# program that uses MessageBox
//
// The simplest overload of MessageBox.Show. [1]
//
MessageBox.Show("Dot Net Perls is awesome.");
->	Title 칸에 아무것도 표시되지 않고
	Message 칸에 Dot Net Perls is awesome. 문자가 표시되고 OK 버튼이 있는 MessageBox

예제2)	C# program that uses two arguments
//
// Dialog box with text and a title. [2]
//
MessageBox.Show("Dot Net Perls is awesome.",
    "Important Message");
->	Title 칸에 Important Message 가 표시되고
	Message 칸에 Dot Net Perls is awesome. 문자가 표시되고 OK 버튼이 있는 MessageBox

예제3)	C# program that uses three arguments
//
// Dialog box with two buttons: yes and no. [3]
//
DialogResult result1 = MessageBox.Show("Is Dot Net Perls awesome?",
    "Important Question",
    MessageBoxButtons.YesNo);
->	Title 칸에 Important Question 가 표시되고
	Message 칸에 Is Dot Net Perls awesome? 문자가 표시되고 Yes, No 버튼이 있는 MessageBox

예제4)	C# program that uses four arguments
//
// Dialog box with question icon. [4]
//
DialogResult result2 = MessageBox.Show("Is Dot Net Perls awesome?",
    "Important Query",
    MessageBoxButtons.YesNoCancel,
    MessageBoxIcon.Question);					// or MessageBoxIcon.Warning or MessageBoxIcon.Exclamation
->	Title 칸에 Important Query 가 표시되고
	Message 칸에 Question표시 아이콘과 Is Dot Net Perls awesome? 문자가 표시되고 Yes, No, Cancel 버튼이 있는 MessageBox

예제5)	C# program that five arguments
//
// Dialog box with question icon and default button. [5]
//
DialogResult result3 = MessageBox.Show("Is Visual Basic awesome?",
    "The Question",
    MessageBoxButtons.YesNoCancel,
    MessageBoxIcon.Question,
    MessageBoxDefaultButton.Button2);
->	Title 칸에 The Question 가 표시되고
	Message 칸에 Question표시 아이콘과 Is Visual Basic awesome? 문자가 표시되고 Yes, No, Cancel 버튼이 있는 MessageBox(단, Default로 No 버튼이 선택됨)

예제6)	MessageBox Yes / No 처리
private void Form1_FormClosing(object sender, FormClosingEventArgs e)
{
    const string message =
        "Are you sure that you would like to close the form?";
    const string caption = "Form Closing";
    var result = MessageBox.Show(message, caption,
                                 MessageBoxButtons.YesNo,
                                 MessageBoxIcon.Question);

    // If the no button was pressed ...
    if (result == DialogResult.No)
    {
        // cancel the closure of the form.
        e.Cancel = true;
    }
}

33.	Form size 자동 조절
	Form으로 설정되어 있는 윈도우 창을 마우스로 들렸다 줄였다 할 경우
	내부에 있는 richTextBox 창도 자동으로 들렸다/줄였다 동작하려면
	->	속성 -> 레이이웃 -> Anchor -> Top, Bottom, Left, Right 등으로 변경하면 됨

34	리플렉션 및 각종 C# 명령어 Tip
리플렉션 ? 실시간으로 실행중에 객체의 정보를 알수 있게 수집, 조사가 가능하다
 
1번째 방식
GetType을 이용하는 방법
Myclass mc = new Myclass();
Type t = mc.GetType();
 
2번째 방식
Type t = Type.GetType(“MyClass”)
-> 객체를 생성할 필요없이 클래스 이름만으로도 확인 할 수 있다.
 
3번째 방법
Type t = typeof(MyClass);
Type T = typeof(mc);
-> 클래스명을 이용할 수도 있고 객체명을 이용할 수도 있다.
 
 
1번 실행결과

 
 
**** System.Activator ? CreateInstance();
 -> 실행중에 만들 수 있다.
Assembly.Load(“MyClass”);
 -> 특정 클래스를 Load가 메모리로 올린다.
Assembly a = Assembly.Load(“MyClass”);
 -> 리턴값을 다시 Assembly가 저장
Type t = a.GetType();
Activator.CreateInstance(t);
object o = Activator.CreateInstance(t);
 ->이런식으로 해서 다른 모듈(프로그램)을 실행시킬 수 있다.
MethodInfo.Invoke(); -> 객체에 있는 메서드를 호출해서 사용할 수 있게 해주는 메서드
 
 
 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Collections;
 
namespace _080912.cs
{
        
               ////////////////////////////////// 1. 리플렉션(기본정보 알아내기) //////////////////////////////////
               // using System.Reflection; -> 리플렉션을 쓰기 위해서는 이걸 선언해 줘야 한다.
               class ReflectionTest
               {
                       public static void Main()
                       {
                              Type t = typeof(System.Type);
                              Console.WriteLine("이 프로그램은 {0}타입의 정보를 출력합니다.", t);
                              Console.WriteLine();
 
                              Console.WriteLine("<기본 정보>");
                              Console.WriteLine("\t타입의 이름은? : {0}", t.FullName);
                              Console.WriteLine("\t기본 타입은? : {0}", t.BaseType);
                              Console.WriteLine("\t클래스인가? : {0}", t.IsClass);
                              Console.WriteLine("\t추상 클래스인가? : {0}", t.IsSealed);
                              Console.WriteLine();
 
                              Console.WriteLine("<상세 정보>");
                              // interface의 목록을 알고 싶다.
                       
                              Type []  tinter = t.GetInterfaces(); 
                              // 리턴을 받아야 하는데 반환받을 변수가 많아서 배열로 받아준다
                              Console.WriteLine("인터페이스 : ");
                              foreach (Type temp in tinter)
                              {
                                      Console.WriteLine("\t{0}", temp);
                                      // foreach문은 몇개를 반복돌려야 하는지 모를때 사용한다.
                              }
                              Console.WriteLine();
 
                              FieldInfo [] finfo = t.GetFields();
                              foreach (FieldInfo temp in finfo)
                              {
                                      Console.WriteLine("\t{0}", temp);
                                      // foreach문은 몇개를 반복돌려야 하는지 모를때 사용한다.
                              }
                              Console.WriteLine();
 
                              // 생성자 정보
                              // 메서드 정보
                              // 이벤트 정보
                       }
               }
        }
        
        ////////////////////////////////// 2. 리플렉션(기본정보 알아내기) //////////////////////////////////
        class ReflectionTest
        {
               public static void Main()
               {
                       Type t = typeof(System.Type);
                       Console.WriteLine("이 프로그램은 {0}타입의 정보를 출력합니다.", t);
                       Console.WriteLine();
 
                       Console.WriteLine("<기본 정보>");
                       Console.WriteLine("\t타입의 이름은? : {0}", t.FullName);
                       Console.WriteLine("\t기본 타입은? : {0}", t.BaseType);
                       Console.WriteLine("\t클래스인가? : {0}", t.IsClass);
                       Console.WriteLine("\t추상 클래스인가? : {0}", t.IsSealed);
                       Console.WriteLine();
 
                       ConstructorInfo[] cinfo = t.GetConstructors();
                       Console.WriteLine("생성자 : ");
                       PrintMember(cinfo);
 
                       EventInfo[] einfo = t.GetEvents();
                       Console.WriteLine("이벤트 : ");
                       PrintMember(einfo);
               }
 
               public static void PrintMember(Type[] tmem)
               {
                       foreach (Type temp in tmem)
                       {
                              Console.WriteLine("\t{0}", temp);
                       }
                       Console.WriteLine();
               }
 
               public static void PrintMember(MemberInfo[] minfo)
               {
                       foreach (MemberInfo temp in minfo)
                       {
                              Console.WriteLine("\t{0}", temp);
                       }
                       Console.WriteLine();
               }
        }
}
 
        ////////////////////////////////// 3. dll 모듈 //////////////////////////////////
        // dll은 홀로 실행될수 없고(기생파일) 메인이 필요 없다.
        public class HelloWorldApp
        {
               public static void Main()
               {
                       Assembly a = Assembly.Load("HelloWorld");
                       Type t = a.GetType("HelloWorld");
                       Object obj = Activator.CreateInstance(t);
 
                       MethodInfo mi = t.GetMethod("WritehelloWorld");
                       mi.Invoke(obj, null);
               }
        }
}
 
        ////////////////////////////////// 4. 컬렉션 //////////////////////////////////
        // using System.Collections; -> 컬렉션을 쓰려면 이거 선언해 줘야 한다.
        class Enumerator1
        {
               static void Main()
               {
                       int[] arr = { 10, 20, 30, 40 }; // 배열로 준비
                       // 어떤형식이든지 나열하든시 저장해서 원할때 꺼내 쓸수가 있다.
                       IEnumerator e = arr.GetEnumerator();
                       // 현재 arr이 가지고 있는 데이터들을 순서대로 나열하듯이 집합을 모아줄수가 있다.
                       // 인터페이스는 객체를 생성할수 없지만 자식의 주소를 참조할수 있다.
                       // 인터페이스를 이용해서 열거형으로 그 값을 모아놓고 그 위치를 가르키는 것이다.
 
                       while (e.MoveNext())
                       // 무브 넥스트라는걸 이용해서 데이터를 꺼내 올수 있다.
                       {
                              Console.WriteLine("아이템 : {0}", (int)e.Current);
                              // 커런트는 현재 위치부터 데이터를 꺼내 오겠다는 것이다.
                              // IEnumerator를 이용하는건 전부 이런식으로 꺼내 올수 있다.
                       }
               }
        }
}
 
        ////////////////////////////////// 5. 컬렉션(array list) //////////////////////////////////
        using System.Collections;// -> 컬렉션을 쓰려면 이거 선언해 줘야 한다.
        public class ArrayListTest
        {
               public static void Main()
               {
                       ArrayList flexible = new ArrayList();
                       // ArrayList는 기본 가용크기가 있다. 
 
                       // 데이터 넣기
                       flexible.Add("one");
                       flexible.Add("100");
                       flexible.Add("product");
                       flexible.Add(10);
                       flexible.Add(20.0);
                       flexible.Add(false);
                       flexible.Add(30);
                       flexible.Add(40);
                       flexible.Add(50);
                       flexible.Add(60);
                       // 문자를 집어넣든 숫자를 집어넣든 전혀 형식에 구애를 받지 않는다.
 
                       Console.WriteLine("count : {0}", flexible.Count);
                       // 데이터가 몇개가 들어갔는지 확인할수 있다.
                       Console.WriteLine("가용량 : {0}", flexible.Capacity); // 지금 기본크기는 16개
                       // ArrayList가 담을수 있는 최대 크기를 알려준다
                       // 기본크기보다 더 들어오면 자동으로 늘어난다.
                       
                       flexible.TrimToSize();
                       // 최대한 메모리를 알뜰하게 쓰고 싶을때
                       // 실제 갯수에 맞게 크기가 알아서 최적화가 된다
                       Console.WriteLine("count : {0}", flexible.Count);
                       Console.WriteLine("가용량 : {0}", flexible.Capacity); // 지금 기본크기는 16개
 
                       flexible.Clear();
                       Console.WriteLine("count : {0}", flexible.Count);
                       Console.WriteLine("가용량 : {0}", flexible.Capacity); // 지금 기본크기는 16개
                       // 싹다 지운다.
                       PrintList(flexible);
                       Console.WriteLine("count : {0}", flexible.Count);
                       Console.WriteLine("가용량 : {0}", flexible.Capacity); // 지금 기본크기는 16개
 
                       flexible.Capacity = 100;
                       // 이런식으로 가용량을 100개로 늘리고 시작할 수도 있다.
                       Console.WriteLine("count : {0}", flexible.Count);
                       Console.WriteLine("가용량 : {0}", flexible.Capacity); // 지금 기본크기는 16개
 
                       ArrayList noWrite = ArrayList.ReadOnly(flexible);
                       noWrite[0] = 100;
                       // 이런식으로 읽기 전용으로 만들수도 있다
               }
 
               public static void PrintList(IEnumerable myList)
               // 어떤 컬랙션을 쓸지 모르는 상황에서 특정 컬랙션만 쓰는건 융통성이 없다.
               {
                       IEnumerator e = myList.GetEnumerator();
                       
                       while (e.MoveNext())
                       {
                              Console.WriteLine("{0}", e.Current);
                       }
               }
        }
}
 
////////////////////////////////// 6. 컬렉션(array list) //////////////////////////////////
        using System.Collections;// -> 컬렉션을 쓰려면 이거 선언해 줘야 한다.
        public class ArrayListTest
        {
               public static void Main()
               {
                       ArrayList flexible = new ArrayList();
 
                       flexible.Clear();
 
                       flexible.Add("라이언 일병 구하기");
                       flexible.Add("너는 내 운명");
                       flexible.Add("말할 수 없는 비밀");
                       flexible.Add("스내치");
 
                       foreach (String item in flexible)
                       {
                              Console.WriteLine(item);
                       }
 
                       Console.WriteLine();
                       // 컬렉션은 검색기능도 다 가지고 있다.
                       Console.WriteLine("스내치 포함여부 : {0}", flexible.Contains("스내치"));
                       // contains가 찾는 값이 있으면 true고 없으면 false를 보내준다.
 
                       flexible.Insert(flexible.IndexOf("너는 내 운명"), "메트릭스");
                       // Insert를 이용해서 원하는 데이터를 삽입 할 있고, Indexof를 이용해서 위치를 지정할 수 있다.
                       // 너는 내 운명 위로 들어가게 된다
                       foreach (String item in flexible)
                       {
                              Console.WriteLine(item);
                       }
               }
 
               public static void PrintList(IEnumerable myList)
               // 어떤 컬랙션을 쓸지 모르는 상황에서 특정 컬랙션만 쓰는건 융통성이 없다.
               {
                       IEnumerator e = myList.GetEnumerator();
 
                       while (e.MoveNext())
                       {
                              Console.WriteLine("{0}", e.Current);
                       }
               }
        }
}
출처: http://pinkcula.tistory.com/entry/C-5 [I'm Black Label]


35.	C# 문자열을 변수명으로 처리
1)	예제1, 제대로 구현됨 확인 완료한 예제
	바로 아래 예제는
	Rx1 = 1;
	Rx2 = 2;
	Rx3 = 3;
	Rx4 = 4;
	Rx5 = 5;
	Rx6 = 6;
	이와 같이 변수 선언한 것과 동일한 기능을 구현 함
	
	
	Dictionary<string, int> dic = new Dictionary<string, int>();
	int iTemp = 0;

	for(int i = 1; i <=6; i++)
	{
		dic.Add("Rx" + i.ToString(), i);
	}

	for (int i = 1; i <= 6; i++)
	{
//		GetDic(dic["Rx" + i.ToString()]);
		iTemp = dic["Rx" + i.ToString()];
		Console.WriteLine(iTemp);
	}

->	결과
1
2
3
4
5
6

2)	예제2
데이터 처리를 해야하는데 데이터 명이
Data1_Num1
Data1_Num2
Data1_Num3
Data1_Num4
Data1_Num5
Data1_Num6

SortedList<string, object> Data_Nums = new SortedList<string, object>();
for( int i = 1; i <= 6; i++)
	Data_Nums.add( "Data1_Num"+ i, i );

Result( "Data1_Num"+ i );

void Result( string key )
{ 
	int datanum = int.Parser( Data_Nums[ key ] );
    ... 
}

요런식으로 돌려서는 가능합니다. 

또는 변수가 메서드 지역이 아니고 
클래스에 선언된것이라면 리플렉션을 이용 할 수 도 있는데... 

혼자 개발하시는것이 아니면 위에 소스처럼 지원되는 객체들을 이용하시는게 옳지 않을까 생각합니다. 

3)	예제3
field 나 프로퍼티라면 indexer나 리플렉션을 사용하면되고 지금은 로컬변수 말하는 거죠?
string을 로컬변수이름으로 만들려면 dictionary를 사용해보세요.
private void button3_Click_1(object sender, EventArgs e)
{
	int Rx0 = 0;
	int Rx1 = 1;
	int Rx2 = 2;

	Dictionary<string, int> dic = new Dictionary<string, int>()
	{
		{"Rx0",Rx0},
		{"Rx1",Rx1},
    	{"Rx2",Rx2}
    };

	for (int i = 0; i < 3; i++)
	{
		GetDic(dic["Rx"+i.ToString()] );
	} 
}

void GetDic(int dicvalue)
{
	Console.WriteLine(dicvalue);
}


35+1.C# 키(Key)와 값(Value)을 가진 Dictionary 사용 방법 및 예제
C#에서는 키와 값을 세트로 저장할 수 있는 연상 배열로 Dictionary가 있습니다.
값을 저장할 때는 키(Key)가 중복되지 않도록 주의해야 합니다.

[Dictionary 기본 사용 방법]
Dictionary 클래스를 사용하기 위해서는 
using System.Collections.Generic
으로 먼저 선언을 해줘야 합니다.

・선언
Dictionary 선언 방법입니다.
Dictionary<Key 타입, Value 타입> 변수명 = new Dictionary<Key 타입, Value 타입>()

또는 아래와 같은 방법으로도 선언할 수 있습니다.
var 변수명 = new Dictionary<Key 타입, Value 타입>()

・선언 및 초기화
Dictionary를 선언하면서 초기화도 같이할 수 있습니다.
var 변수명 = new Dictionary<Key 타입, Value 타입>()
{
	{Key0, Value0},
	{Key1, Value1},
	・・・・・・
};

[Add 요소 추가]
Dictionary에 요소를 추가하기 위해서는 Add메서드를 사용합니다.
Dictionary변수.Add(Key, Value);

요소 추가 예제
using System;
using System.Collections.Generic;

namespace Sample
{
	class Sample
	{
		static void Main()
		{
			var myTable = new Dictionary<string, string>();
			myTable.Add("Korea", "Seoul");
			myTable.Add("Japan", "Tokyo");
			myTable.Add("America", "Washington");

			foreach(KeyValuePair<string, string> item in myTable) {
				Console.WriteLine("[{0}:{1}]", item.Key, item.Value); 
			}

			Console.ReadKey();
		}
	}
}

결과
[Korea:Seoul]
[Japan:Tokyo]
[America:Washington]

Add를 사용하여 Dictionary에 값을 추가하고 출력까지 해보았습니다.

[Key 취득 방법]
Dictionary에서 Keys프로퍼티를 사용하여 Key만 취득을 할 수 있습니다.
Keys프로퍼티 예제
using System;
using System.Collections.Generic;

namespace Sample
{
	class Sample
	{
		static void Main()
		{
			var myTable = new Dictionary<string, string>();
			myTable.Add("Korea", "Seoul");
			myTable.Add("Japan", "Tokyo");
			myTable.Add("America", "Washington");

			foreach(string Key in myTable.Keys) {
				Console.WriteLine(Key); 
			}

			Console.ReadKey();
		}
	}
}

결과
Korea
Japan
America

[Value 취득 방법]
Dictionary에서 Values프로퍼티를 사용하여 Value만 취득을 할 수 있습니다.
Values프로퍼티 예제
using System;
using System.Collections.Generic;

namespace Sample
{
	class Sample
	{
		static void Main()
		{
			var myTable = new Dictionary<string, string>();
			myTable.Add("Korea", "Seoul");
			myTable.Add("Japan", "Tokyo");
			myTable.Add("America", "Washington");

			foreach(string Value in myTable.Values) {
				Console.WriteLine(Value); 
			}

			Console.ReadKey();
		}
	}
}

결과
Seoul
Tokyo
Washington

[Key로 Value 취득 방법]
List에서는 인덱스 번호로 값을 취득할 수 있습니다.
Dictionary에서는 Key로 값을 취득할 수 있습니다.
Key로 Value 취득 예제

using System;
using System.Collections.Generic;

namespace Sample
{
	class Sample
	{
		static void Main()
		{
			var myTable = new Dictionary<string, string>();
			myTable.Add("Korea", "Seoul");
			myTable.Add("Japan", "Tokyo");
			myTable.Add("America", "Washington");

			string str = "America";
			Console.WriteLine("[{0}:{1}]", str, myTable[str]); 

			Console.ReadKey();
		}
	}
}

결과
[America:Washington]
Dictionary[Key]로 Value를 취득하여 값이 출력된 것을 확인했습니다.

[정리]
연상 배열인 Dictionary는 키와 값을 세트로 저장할 수 있습니다.
키로 값을 취득할 수 있습니다.
Dictionary 키값은 중복될 수 없기 때문에 주의해야 합니다.

35+2.[C# 강좌 - 45] Linq 쿼리식
이 글은 C#의 Linq에 대해 소개하는 글입니다. Linq식은 Array형식으로 있는 데이터를 데이터 베이스 쿼리식처럼 코딩을 해서 가독성이나 생산성을 높이는 효과가 있는 C# 문법입니다.
Java에서는 stream()식이 있습니다만 개인적으로 C#의 Linq식이 훨씬 편합니다. 어떨 때는 이 Linq식이 너무 편해서 Java으로 개발할 일을 C#으로 개발했던 적이 있습니다.
Linq 문법은 데이터 베이스의 쿼리식으로 만들 수도 있지만 코딩식처럼 함수 호출로도 할 수 있습니다. 이 글에서는 데이터 베이스 쿼리식처럼 나타내는 방법을 소개하겠습니다.

 [소스 보기] 
using System;
using System.Collections.Generic;
using System.Linq;

class Program
{
  static void Main(string[] args)
  {
	var dic = new Dictionary<int, string>();
    dic.Add(0, "Zero");
    dic.Add(1, "First");
    dic.Add(2, "Second");
    dic.Add(3, "Third");
    dic.Add(4, "Fourth");
    dic.Add(5, "Fifth");
    dic.Add(6, "Sixth");
    dic.Add(7, "Seventh");
    dic.Add(8, "Eighth");
    dic.Add(9, "Ninth");
 
    var values = from item in dic where item.Key > 5 select item.Value;
    //결과
    //Sixth
    //Seventh
    //Eighth
    //Ninth
    foreach (var value in values)
    {
      Console.WriteLine(value);
    }
 
    Console.WriteLine("Press Any Key...");
    Console.ReadKey();
  }
}
위 소스는 dic의 값에서 key가 5초과(5가 포함되지 않는)의 값을 출력하는 예제 입니다.
from 에서 item은 쿼리식에서 사용할 변수이고 in 키워드를 통해 주입합니다. 그리고 리스트에서 하나의 item의 key가 5초과 일 경우 item.value를 list형식으로 변환하는 것입니다.

 [소스 보기] 
class Program
{
  static void Main(string[] args)
  {
    var dic = new Dictionary();
    dic.Add(0, "Zero");
    dic.Add(1, "First");
    dic.Add(2, "Second");
    dic.Add(3, "Third");
    dic.Add(4, "Fourth");
    dic.Add(5, "Fifth");
    dic.Add(6, "Sixth");
    dic.Add(7, "Seventh");
    dic.Add(8, "Eighth");
    dic.Add(9, "Ninth");
 
    var dic2 = new Dictionary();
    dic2.Add(0, "Zero");
    dic2.Add(1, "One");
    dic2.Add(2, "Two");
    dic2.Add(3, "Three");
    dic2.Add(4, "Four");
    dic2.Add(5, "Five");
    dic2.Add(6, "Six");
    dic2.Add(7, "Seven");
    dic2.Add(8, "Eight");
    dic2.Add(9, "Nine");
 
    var values = from item in dic
                 // dic2와 join해서 결과 값을 joinitem으로 한다.
                 join item2 in dic2 on item.Key equals item2.Key into joinitem
                 // joinitem의 각 아이템 값은 item3으로 한다.
                 from item3 in joinitem
                 //item의 값이 「Seventh」인 것을 빼고, 조인된 값 item3에서 value를 결과로 만든다.
                 where item.Value.Equals("Seventh") select item3.Value;
    //결과
    //Seven
    foreach (var value in values)
    {
      Console.WriteLine(value);
    }
 
    Console.WriteLine("Press Any Key...");
    Console.ReadKey();
  }
}
위 소스는 두개의 Dictionary를 Join해서 dic의 값이 Seventh인 값을 같은 key값으로 묶어서 dic2에서 key가 7인 value값을 출력하는 예제입니다.

 [소스 보기] 
class Program
{
  static void Main(string[] args)
  {
    var dic = new Dictionary();
    dic.Add(0, "Zero");
    dic.Add(1, "First");
    dic.Add(2, "Second");
    dic.Add(3, "Third");
    dic.Add(4, "Fourth");
    dic.Add(5, "Fifth");
    dic.Add(6, "Sixth");
    dic.Add(7, "Seventh");
    dic.Add(8, "Eighth");
    dic.Add(9, "Ninth");
 
    var values = from item in dic
                 where item.Key > 2
                 // from where 의 결과를 item2로 다시 만든다.
                 let item2 = item
                 // item2의 key가 5미만
                 where item2.Key < 5 select item2.Value;
    //결과
    //Third
    //Fourth
    foreach (var value in values)
    {
      Console.WriteLine(value);
    }
 
    Console.WriteLine("Press Any Key...");
    Console.ReadKey();
  }
}
위 소스는 let 구문의 예제입니다. 사실 where에 item.Key > 2 && item.Key < 5라고 해도 같은 결과가 나오는 식입니다만 예제를 만들기 위한 소스입니다.
즉 item2에서는 dic의 Key가 2초과 된 값의 dic의 item2로 만들어 지고 다시 이것을 where 조건을 통해 결과를 출력하는 방법입니다.
보통 단순 where로 계산하기 힘들거나 두 개 이상의 Linq식을 결합할 때 사용하는 키워드입니다.

 [소스 보기] 
class Program
{
  static void Main(string[] args)
  {
    var dic = new Dictionary();
    dic.Add(0, "Zero");
    dic.Add(1, "First");
    dic.Add(2, "Second");
    dic.Add(3, "Third");
    dic.Add(4, "Fourth");
    dic.Add(5, "Fifth");
    dic.Add(6, "Sixth");
    dic.Add(7, "Seventh");
    dic.Add(8, "Eighth");
    dic.Add(9, "Ninth");
 
    // 내림차순 소트
    var values = from item in dic orderby item.Key descending select item.Value;
    //Ninth
    //Eighth
    //Seventh
    //Sixth
    //Fifth
    //Fourth
    //Third
    //Second
    //First
    //Zero
    foreach (var value in values)
    {
        Console.WriteLine(value);
    }
    Console.WriteLine("Press Any Key...");
    Console.ReadKey();
  }
}
위 예제는 Key를 내림차순으로 정렬하는 예제입니다.
Linq식의 경우는 Dictionary 타입만 되는 것이 아니고 List, 배열등 집합 요소의 클래스 식은 전부 됩니다. (String도 char의 집합이기 때문에 String에도 Linq식이 붙어 있습니다.)

여기까지 Linq의 쿼리식 설명이었습니다.

궁금한 점이나 잘못된 점이 있으면 댓글 부탁드립니다.
출처: https://nowonbun.tistory.com/262 [명월 일지]


36.	C# 간단 총 정리
변수
열거형-사용자가 정의한 일련의 이산적인 겂들을 가진 변수 형식, 숫자 대신 사람이 좀더 읽기 쉬운 상수들을 효율적으로 사용하기 위한것
구조체-다른 변수 형식들을 하나로 조직화하는 복합 변수 형식
배열   -한 형식의 값들을 여러 개 담을 수 잇는 형식 (색인을 통해서 개별 값들에 접근한다.)

명시적 변환
속성-구성속성-빌드-산술연산오버플로/언더플로확인 : 이것을 True로 바꾸면 unchecked를 명시적으로 지정하지 않는한모든
표신식에서 오버플로 점검한다.
. Convert.ToBoolean(val), Convert.ToByte(val), Convert.ToChar(val), Convert.ToDecimal(val), Convert.ToDouble(val)
  Convert.ToInt32(val) - int로 변환 
  
문자열조작
"<string>.TrimStart()   :  문자열의 앞이나 뒤 중 한 쪽의 빈칸들만 제거하려 할 때
<string>.TrimEnd()"
"<string>.PadLeft()    : 문자열 앞.뒤에 추가적인 빈칸들을 채우는 명령
<string>.PadRight()"
<string>.Split() : 하나의 문자열을 구분 문자들을 기준으로 나워서 string배열로 만들어준다.(기준이 되는 구분문자는 char배열로지정)

변수의Default값
정수타입        :0
부동소수 타입:0.0
char              : null문자(\u0000)
decimal         :0.0
bool               :false

조건문
<<  IF 문의 형식  >>

if(조건식)
   문장
else
  문장
---------------------
if(조건식){
   문장
}else{
  문장
}
　
<<  switch문의 형식  >>

switch(표현식)
{
  case constant1:
      명령문
      break;
  case constant2:
      명령문
      break;
  default:
      명령문
      break;
}

반복문
<< while문의 형식>                         <<do while 문의 형식>> 

while(조건식){문장}                        do{문장}
                                                      while(조건식);
private사용하는 이유
1. 클래스 내부에서만 사용하기 위해서
2. 외부에서 들어오는 데이터라 할지라고 직접적인 할당보다는 간접적으로 할당하기 위해서

new
Family sister = new Family()의 분석
Family    : 클래스로 생성한 데이터 타입
sister     : Family 데이터타입으로 선언한 변수
new       : 메모리를 생성하는 연산자
Family() : 메모리 생성 후 초기화 ��업을 담당���는 생성자 
＝＞　클래스를　이용하여　만든　변수를　다른　변수들과　구분하기　위해Ｏｂｊｅｃｔ또는Ｉ���ｓｔａｎｃｅ라는　용어를　사용

ｒｅｆ와　ｏｕｔ키워드
ｒｅｆ　：　참조할　변수는　반드시　초기화되어　있어야　한다．
ｏｕｔ　：　참조할　변수가　반드시　초기화될　필요는　없다．

<상수>
const 키워드
. 상수를 선언하는 키워드
. Const로 선언한 변수는 반드시 초기화 되어야 한다. - 초기화되어 있지 않다면 한번 설정되면 바꿀수 없다는 상수의 법칙에 위배
. Const는 자동으로 static 이 된다.

<상수>
readonly키워드
. Static 키워드를 사용하면 static 상수가 된다. 사용하지 않으면 일반 상수가 된다.
. 반드시 초기화 할 필요는 없다.
. Static readonly일 경우 스태틱 생성자에서 초기화할 수 있다.(횟수제한-> 한번만 가능)
   - 상수의 기본 성질인 중복해서 값을 설정할 수 없다는 것이 포인트
. 일반 readonly일 경우 생성자에서 초기화 할 수 있다.
. Static readonly일 경우 클래스의 이름으로 접근가능
. 일반 readonly일 경우 객체의 이름으로 접근가능

static
static으로 선언된 필드나 메서드는 스태틱이라고 하는 특수한 메모리 영역에 단 하나의 메모리가 생성되기 때문에 클래스 전체에 
공유가능  
스태틱 특성상 객���를 생성하지 않고 클래스의 이름으로 해당 상수에 바로 접근가능하다.

열거형
(Enum/Enumeration)
. 이름을 가지는 정적 정수형 상수이다.
. 상수이므로 값이 한번 설정되면 변경할 수 없다.
. 열거형의 멘버들의 초기값은 0부터 자동으로 1씩 증가한다. 만약 중간에 임의의 값이 설정된 곳부터는 해당 값을 1씩 증가시켜 할당
  (순차적인 숫자 값을 가져올 경우 현변환 필수겠죠)
. 열거형에서 사용할 수 있는 형 =><<   byte, sbyte, short, ushort, int, unit, long, ulong  >>

네임스페이스와어셈블리
. 진입점을 포함하는 형태의 실행파일(.exe)
. 진입점을 포함하지 않는 라이브러리 형태의 파일(.dll)
. [참고]exe나 dll 은 모두 중간언어(IL) 형태로 되어 있다.

Main()메서드의 특징
. 프로그램의 시작점이다.
. Main() 메서드가 끝나면 프로그램은 종료한다.
. 반환형은 void나 int 둘 중의 하나이어야 한다.
. Main() 메서드에서 객체를 생성하거나 다른 메서드를 호출할 수 있다.
. 명령프롬프트 상의 매개변수를 읽기 위해서 string배열을 사용한다.

Static 멤버필드
. 모든 클래스에서 공유하기 위한 멤버를 선언하는 데 사용
. 변수, 메서드, 속성,연산자 및 생성자에 사용할 수 있음
. 인덱서 , 소멸자에는 사용할 수는 없음
. 클래스 내의 모든 곳에서 사용할 수 있는 공유변수

Static 멤버메서드
. Public static 메서드일 경우 객체를 생성하지 않고 클래스의 이름으로 접근가능
. 객체를 생성하지 않고도 사용할 수 있는 공유 메서드
. 스태틱 메서드를 이용하여 일반 멤버필드에 접근 불가
. 일반 멤버필드는 객체 생성 후에 존재하기 때문에 스태틱 메서드에서는 접근 불가

Main()메서드가 
static인 이유
C#에서는  Main()메서드를 실행할때 CLR 에서 실행 클래스의 객체가 생성되기 전에 접근해야 하기 때문에 스태틱으로 선언

오버로딩(Overloading)
. 하나의 클래스 내에서 동일한 이름을 가진 여러 개의 메서드
. 메서드들의 구별은 메서드의 매개변수의 개수와 매개변수의 형에 의행서 구분
. 리턴타입(Return Type)으로는 구별하지 않는다.

오버로딩규칙
. 매개변수의 개수가 달라야 한다.
. 매개변수의 타입이 달라야 한다.
. 위의 개수와 다입중 하나만 달라도 오브로딩의 조건이 성립된다.
. 메서드이 리턴타입은 오버로딩을 구분할 때 사용하지 않는다.

상속(Inheritance)
. 계층구조 형태로 클래스들을 생성시키는 방법
. 상위클래스를 기본 클래스라고 하며 하위클래스를 파생클래스라고 한다.
. 상속을 하면 상위클래스의 능력을 하위클래스에서 모두 이용할 수 있다.

Inheritance특징
. 생성자는상속되지 않고 하위클래스의 객체가 만들어질 때 상위클래스의 생성자가 자동으로 호출된다.
. 클래스는 중복상속할 수 없으며 단일 상속만 가능하다.

sealed키워드
. Sealed키워드는 클래스로부터의 상속을 막을 때 사용

Constructor의 특징
. 생성자는 리턴타입(Returm Type)이 없다.
  - ( 이유 : new 연산자가 메모리를 생성한 후 해당 메모리의 참조값을 객체변수에게 리턴해 버리기 때문에 생성자는 리턴이 없고 초기화만 담당  )
. 생성자의 이름은 클래스의 이름과 동일하다
. New 연산자가 힙(Heap)영역에 해당 클래스의 메모리를 생성한 직후 호출된다.
. 생성자는 말 그대로 객체가 생성될 때 호출되는 메서드입니다. 객체를 생성하는 순간에 함께 함께 호출될 수 있다는 장점이 있다.
   
소멸자(Destructor)
. 객체가 소멸되기 전에 호출되어 객체에 부여된 메모리의 회수를 담당
. 실제적으로 메모리의 호수 여부는 Garbage Collector가 담당한다.
. 매개변수와 접근 제한자를 가질 수 없다.

<<  4.9  protected 접근자  >>
　
디자인타임의접근문제
상속받아서 코딩하고 있는 순간, 상속을 받아서 하나의 새로운 클래스를 제작하고 있는 순간,
 하위클래스 입장에서 상위 클래스의 접근 문제를 다룬다.

상속 관계에서의 private
.  상위클래스를 상속받은 하위클래서 내에서 상위클래스의 private멤버필드에 직접 접근할 수 없다.
. 어떠한 경우라도 private이면 public메서드를 통해서만 접근 가능하다.

상속 관계에서의 protected
. 아버지의 protected 멤버는 실행타임에선 private이면서 아들에게는 완전한 public이 된다.
  -모든 면에서 private을 수행하면서 상속의 관계에서만 public의 행위를 하는 것이 바로 protected 이다.

Internal접근자
. Private과 public의 중간 형태로 한의 Assembly 내에서만 접근을 허락하는 접근자
. 같은 어셈블리(즉 같은 프로그램 내) 안에 있어야 접근 가능하다.

메서드 재정의 종류
. new 키워드를 이용한 재정의
. Virtual, override 키워드를 이용한 재정의

Upcasting(업케스팅)
. 정의 - 하위 클래스의 객체를 상위클래스의 객체로 형변환한 것
. New 키워드를 이용하여 메서드를 재정의한 후 업캐스팅 했을 때
 - 업캐스팅 되었을 때 상위 클래스는 상위클래스 내의 메서드만을 호출한다. 

virtual,override,new의 관계
. Virtual : 하위 클래스에서 재정의해서 사용할 것을 표시
. Override : 상위클래스에서 virtual로 표시된 메서드를 재정의할 때 사용
. New : 상위클래스의 메서드를 완전히 무시할 대 사용

this를사용하는 곳
. 자신을 참조하는 this를 이용하여 멤버를 이용할 수 있다.
.  디자인타임에 자기 자신을 직접 참조할 수 있는 참조변수이다.
.  디자인타임에 자기 자신을 참조할 수 있는 유일한 키워드이다. 
- 디자인타임에 하나의 이름으로 자시능ㄹ 참조하고 실행 타임에서는 각각에 적용

this.멤버
. 지금은 클래스 내부의 this이지만 언젠가 생성될 내 메롬리의 this라고 해석할 수 있다. 
  즉 , 언젠가 생성될 메모리의 참조값이 되는 것입니다. 

자신의 멤버를 가르키는 this
. 메서드의 매개변수와 클래스의 멤버필드를 구분해 주어야 할 때 사용
. This키워드를 사용하지 않아도 무방

this()
. 자신의 생성자를 호출할 때도 사용
. 자신의 생성자를 재사용하기 위새서 생성자를 호출하는 방법을 제공

base() 키워드
. 디자인타임에 아버지를 참조하는 유일한 참조변수이다.
. 무시당한 아버지클래스의 메서드를 사용하고 싶을 때 사용한다.
. 아버지 생성자에 매개변수가 존재한다면 생성자의 매개변수의 형과 개수를 맞추어 주어야한 호출이 가능
. 생성자 내에서 아버지 생성자를 호출하기 위해 사용

Boxing // UnBoxing
. 박싱(Boxing) : 값타입을 참조타입으로 변환하는 기법
. 언박싱(UnBoxing) : 참조타입을 값타입으로 변환하는 기법

Boxing의 순서
. 값타입 변수를 객체화하기 위한 메모리를 Heap영역에 생성한다. 이공간을 Box라고 한다.
. P 에 있는 값을  Heap에 생성한 Box로 복사
. 참조타입 변수 o에 Box의 참조값을 할당
예>  int p = 123;
       object o = p

UnBoxing의 순서
. 해당 객체가 지정한 값타입을 Boxing한 값인지 확인
. 박싱된 객체라면 객체의 값을 값타입 변수에 복사한다.
. Boxing한 메모리와 UnBoxing한 메모리 두 개가 존재한다.

추상클래스가 되는 방법
. 몸체가 없는( 메서드의 구현부가 없다는 뜻) 메서드를 하나라도 포함하고 있는 클래스
. 몸체없는 메서드를 포함하고 잇지 않더라도 클래스를 선언할 때 abstract 키워드를 포함하고 있는 경우
< 추상메서드는 묵시적으로 virtual메서드이다.>

Abstract Class
(추상클래스)
추상클래스는 객체가 가지는 특성들을 추상화시켜 놓고 구체적인 구현은 이 추상클래스를 상속받는 파생클래스에서 하도록 한것
. Abstract 키워드를 사용
. 몸체없는 추상메서드를 하나라도 포함하고 있으면 추상클래스가 된다.
. 추상클래스가 되면 반드시 클래서 선언부에 abstract 키워드를 명시해야 한다.
. 클래스를 선언할 때 클래스 앞에 abstract 키워드를 사용하면 추상메서드를 포함하고 있지 않아도 추상클래스가 된다.ㅋ
. 추상클래스는 객체(인스턴스)를 생성할 수 없다.
. 추상메서드는 묵시적으로 가상메서드(Virtual Method)가 된다.
. 추상메서드는 virtual키워드를 사용하지 않지만 자동으로 virtual이 된다.

Abstract Method
(추상메서드)
. 몸체가 없는, 몸뚱이가 없는 메서드
. 프로토타입(Prototype)만 가지고 있음
 virtual키워드가 디폴트로 포함되어 있음

Interface의 구성요소
/특징
Method, Property, Event, Indexer
. 인터페이스 내의 멤버는 모두 몸체가 없다.
. 인터페이스의 멤버는 디폴트로 전부 public이다.
. 내부에 필드를 가질 수 없다.
. 멤버에 어떠한 접근자, 한정자도 붙이지 않는다.

Interface의 멤버가 public인 이유
. 인터페이스를 하위클래서에서 구현하기 위해서는 최소한 하위클래서에서 접근할 수 있어야 하며 
  인터페이스로 외부에서 작업하기 위해서는 인터페이스의 멤버는 기본적으로 public이어야 한다.
- 인터페이스내의 멤버 앞에 abstract, public, protected, internal, private, virtual, override, static과 같은 키워드들 사용못함

Interface 메서드 구현 주의사항
. 인터페이스 멤버의 접근지정자는 자동으로 public이 된다 때문에 구현하는 클래스에서도 이와 일치시키기 위해 public을 명시
  클래스의 멤버는 접근지정자가 명시된지 않으면 private으로 지정된다.    Public void a(){…}
. 그러나 명시적으로(상속받은 인터페이스네 같은 이름의 메서드가 존재시) 구현한 메서드는 접근 지정자를 붙이지 않는다.

override
. 추상클래스와 인터페이스의 추상메서는 모두 가상(virtual)메서드이 성질을 가지고 있습니다. 하지만 추상클래스내의 
 추상메서드를 재정의할 때에는 override 키워드를 사용하여 메서드를 재정의하지만 인터페이스 내의 추상메서드를 재정의할
 때에는 override키워드를 사용하지 않습니다.

추상클래스와 인터페이스의 공통점
. 스스로 객체를 생성할 수 없다.
. Upcasting이 가능하다.
. 모든 추상 멤버를 구현해야 한다.
. 추상클래스와 인터페이스의 추상메서드는 virtual(가상)메서드이다.

추상클래스와 인터페이스의 차이점
. 인터페이스는 멤버의 접근지정자를 선언할 수 없다.
. 추상클래스 내의 멤버에 접근지정자를 사용해서 선언할 수 있다.
. 인터페이스는 인터페이스들 끼리의 상속과 중복구현이 가능하다.
. 추상클래스는 클래스이기 때무에 단일 상속을 원칙으로 한다.
. 인터페이스는 일반적인 멤버필드를 포함할 수 없다.
. 추상클래스는 일반적인 멤버필드나 멤버메서드를포함할 수 있다.
. 인터페이스는 멤버를 abstract키워드로 선언할 수 없다.
. 추상클래스에서 추상메서드는 abstract키워드로 명시해야 한다.
. 인터페이스의 추상메서드는 구현할 때 override를 사용하지 않지만 추상클래스에서는 override르르 사용하여 재정의 한다.

메서드 재정의에서의 업캐스팅(Upcasting)
. New 키워드를 이용한 메서드 재정의에서 나타나는 업캐스팅
  - 업캐스팅된 상위클래스의 객체는 상위 클래스 내의 메서드만을 호출한다.
  - 아들의 몸체지만 아버지의 이름이라면 아버지의 메서드만 호출할 수 있다. 
. Virtual 키워드를 이용한 메서드 재정의에서 나타나는 업캐스팅
 - 상위클래스의 이름으로 메서드를 호출했을 때 해당 메서드가 재정의되어 있을 경우에만 하위클래스의 메서드를 호출할 수 있다.
 - 아들의 몸체지만 아버지의 이름으로 아들의 메서드를 호출한다.

Delegate정의
. 메서드의 대리자
. 메서드를 보다 효율적으로 사용하기 위하여 특정 메서드 자체를 캡슐화할 수 있게 만들어 주는 방법

배열의 분류
. Value Type의 배열
. Object 배열

배열의 특징
. 같은 데이터 타입의 변수를 한꺼번에 여러 개 생성할 수 있다.
. 배열의 크기는 배역의 첨자(index)로 결정된다.
. 첨자에 해당하는 만큼의 같은 데이터타입을 가진 메모리가 생성된다.
. 배열의 메모리는 연속적으로 잡히게 된다.
. 배열은  참조값(ReferenceValue)을 잉ㅇ하여 핸들링할 수 있다.
. 배열의 이름은 연속된 변수들을 참조하기 위한 참조값이다.
. 배열의 요소는 변수이다.
. 배열은 객체다.

배열의 선언
데이터형[] 변수명 = new 데이터형[첨자];
배열의 선언 및 초기화
예> 배열의 이름이 mydream이고 int형의 배열 요소를 10개 생성한다면
. 선언과 메모리 할당을 동시에   =>    int[] mydream = new int[10];
. 선언과 메모리 할당의 분리      =>    int[] mydream ;                                                      
                                                      mydream = new int[10];
배열의 선언과 동시 초기화
● int[] mydream = new int[]{100,200,300,400,500,600,700,800,900,999};
● int[] mydream = {100,200,300,400,500,600,700,800,900,999};

값타입의 배열과 객체배열의 생성시 차이점
. 값타입(Value Type)배열                                       => 배열 생성과 동시에 메모리 확보 
. 객체(object)배열 , 참조타입(Reference type)배열  => 객체변수의 이름들만 생성할 뿐, 객체의 메모리는 생성되지 않음 .
  - 객체변수의 참조값 자체를 위한 메로리만 확보, 배열 요소의 메모리는 따로 생성해 주어야 함.
  
HashCode?
해시코드는 메모리가 생성될 때 객체에  부여되는 32bit 정수형으로 서로 다른 객체는 같은 해시코드를 부여 받을 수 없다. 
따라서, 해시코드가 없다는 것은 아직 메모리가 생성되지 않았다는 것을 의미 결국, NullreferenceException이 발생 

2 차원 배열 초기화
int[,] myarray = new int[3,2]

2 차원배열선언과 동시초기화
 
int[,] myarray = new int[,]{{1,2},{3,4},(5,6}};
int[,] myarray = {{1,2},{3,4},(5,6}};
참고> string[,]  saRObjId = {{sObjId[i].ToString()},{"ContentsList"}};
=================================================================
using System;
class ArrayDemo
{
 public static void Main()
 { 
  string[] sid = {"a","b","c","d"};    //가변적으로 변화는 값이다
  string[,] obj = new string[sid.Length,2]; 
  for (int i=0; i < sid.Length ; i++) 
  {
   obj[i,0] = sid[i];  //**
   obj[i,1] = "z";     //**
   for (int j=0; j < 2; j++)
    Console.WriteLine("Element({0},{1})={2}", i, j, obj[i,j]);
  }

 }
}

배열의 길이(Length)와 차원(Rank)의 수
. 배열의 길이는 배열이름.Length로 나타낸다.
. 배열의 차원의 수는 배열이름.Rank로 나타낸다.

System.Array클래스
. Public abstract class Array : Icloneable, Ilist, Icollection, Ienumerable
. 배열을 생성하고 지원하는 언어 구현의 기본적 클래스
. 배열은 기본적으로 Array클래스를 상속한다.

Array클래스의 
유용한 메서드
. Array.Sort(배열) - 배열을 작은 순으로 정렬
. Array.Reverse(배열)  - 배열을 큰 순으로 정렬
. Array.Clear(배열,0,5) - 0번째부터 5번째까지 6개를 0으로 초기화
. Array.IndexOf(배열,55) - 배열의 첫부터 검색하여 55가 있는 index의 위치를 반환
. Array.LastIndexOf(배열,5) - 배열의 끝에서부터 검색하여 처음으로 5가 있는 위치를 리턴

Array클래스이 메서드
. 배열은 Array클래스를 상속받았기 때문에 Array클래스의 메서드들은 대부분static 메서드이기 때문에 클래스의 
  이름을 통해서만 접근할 수 있다.
  
배열을 복사하는 방법
. Array.Copy() 메서드를 이용하는 방법  => 배열의 일부분 복사(부분 배열 복사)
. Clone() 메서드를 이용하는 방법          => 배열의 전체 복사 ( 배열의 메모리 차원의 복사)

Array.Copy()메서드
. 원본과 복사본 배열 객체가 존재하고 있어야 한다.
. 주로 배열의 부분복사를 위해 사용된다.

배열.Clone() 메서드
. 원본 배열의 메모리를 통째로 복사해 준다.
. Object형을 반환하므로 다운캐스팅(Downcasting)을 해주어야 한다.

foreach문
. Array이나 collection 내에 존재하는 각 요소들에 대해 접근할 수 있게 해주는 제어문
<<  형식 >>  foreach(데이터타입  변수명  in 배열명){ 실행문장 }
. 데이터타입 : foreach 문 내부에서 사용될 반복변수의 형
. 반복변수    : 컬렉션 요소의 값을 반복적으로 얻어내는 변수
. 컬렉션식    : foreach 문을 실행시킬 배열이나, 컬렉션 
 
foreach문 특징
. 메모리에 저장된 순서대로 요소 값이 호출됨
. 반복변수는 오직 읽기전용으로 사용
. 따라서, 반복변수를 사용한 배열요소의 데이터 값을 변경할 수는 없다.

Array 객체 만들기
. System.Array.CreateInstance()메서드
 - Array 클래스의 새 객체를 생성하는 메서드
 - 스택틱(static) 메서드
. Array 클래스 객체 입출력
 - SetValue(Object obj, int i)   => 지정된 요소를 지정된 값에 출력(첫번째 매개변수: 저장할 데이터, 두번째매개변수: 인덱스)
 - GetValue(int i)                    => 지정된 요소의 값 출력

문자열 
. 문자열은 System.String 클래스의 객체이다.
. 문자열은 문자상수의 집합니다.
.   + 연산자를 사용하여 두 문자열을 연결하여 새로운 문자열을 생성한다.
. 특수문자를 문자 그대로 받아들일 때는 @를 사용한다.

문자열 주요 메서드
. IndexOF()       - 문자열을 첫 부분부터 검색하여 입력한 문자열을 제일 먼저 만나는 위치를 int로 반환
. LastindexOf() - 문자열을 마지막 부분부터 검색하여 입력한 문자열을 제일 먼저 만나는 위치를 int로 반환
. Replace(a,b) - 문자열에서 특정 문자(a)를 원하는 문자 (b) 로 치환한 문자열을 반환한다. 
. Substring()    - 문자열에서 지정된 위치에 있는 부분 문자열을 반환합니다.

System.Text.StringBuilder
. Stringbuilder의 용량은 추가되는 데이터가 커지면 문자를 저장하는데 필요한 메모리를 자동으로 늘리기 때문에 동적으로 
   용량이 늘어난다.(기본용량 16)
. Public sealed class StringBuilder
. 문자열의 수정을 가능하게 하는 클래스

Stringbuilder클래스의 메서드 및 속성
. Append(데이터) - 지정된 문자열 표현을 StringBuilder 객체의 끝에 추가
. EnsureCapacity(int capacity)  - 인스턴스의 용량을 최소한 지정된 값이 되도록 함
. ToString()  - StringBuilder를 String으로 변환 
. Capacity 속성 - 인스턴스의 요량을 지정하거나 반환
. Length 속성 - 인스턴스의 길이를 가져오거나 설정

Collection류 클래스들의 특징
. 켈렉션류 클래스들은 ㅅ형 메모리 데이터베이스의 기능인 수정, 삭제, 검색, 삽입 등의 기능을 함
. 동적으로 메모리 확장 가능

컬렉션류 인터페이스의 특징
. 인터페이스들은 컬렉션류 클래스들의 일관성과 사용상의 편리성을 제공
. 컬렉션 인터페이스들은 많은 컬렉션 클래스들 사이에 공통된 사용자 패턴을 정의

IEnumerable 인터페이스의 메서드
public interface IEnumberable{
           IEnumerator GetEnumerator();
          }

IEnumerator속성
object Current - 컬렉션에서 현재 객체에 대한 참조(Element)를 반환하는 읽기전용 속성

IEnumerator 메서드
. Bool MoveNext();
  - 열거자를 컬렉션의 다음 요소로 커서를 이동시킨다.
  - 다음 요소가 존재하지 않는다면 false를 존재한다면 true를 리턴한다.
  - 커서를 이동시킨 뒤 Current속성을 이용하여 데이터를 추출할 수 있다.
. Void Reset();
  - Current 포인터를 컬렉션의 처음 부분 앞에 있는 정의하지 않은 값으로 다시 설정한다.
  - Reset을 호출한 후 Current를 접근하기 전에 MoveNext()를 호출해야 한다.  이유는 처음에는 Current참조가 정의되어 
     있지 않기 때문이다.

ICollection인터페이스
속성
. Int Count  -컬렉션의 객체 수를 반환한다. 즉, 켈렉션 내에 얼마나 많은 객체가 잇는지 알아낸다.
. Bool IsSynchronized -  다중 스레드된 액세스를 위해 컬렉션에 대한 액세스(Access)를 동기화한 경우 true를 반환한다.
                                       컬렉션이 동기화되는지에 따라서 쓰레드 안전성이 있는지 검사한다.
. Object SyncRoot - SyncRoot 속성은 스레드에서 컬렉션에 대한 액세스를 동기화하기 위해 사용할 수 있는 객체를 반환한다.
                             -  CLR 은 자동으로 어떤 .NET 형식 인스턴스라도 동기화 루트(SyncRoot)가 되도록 한다.
                             - SyncRoot 는 하나 이상의 코드 문장이 동시에 한 스페드에 의해서만 실행되는 것을 확실하게 하기 위해 
                               잠거거나 해제할 수 있다.,
                             -  ICllection.SyncRoot를 실행하면 항상 적절한SyncRoot객체를 반환한다.

ICollection인터페이스 메서드
.  Void CopyTo(Array array, int index)  - 지정한 배열 위치부터 컬렉션의 요소를 배열로 복사한다.

IList 인터페이스 속성
. bool   IsFixedSize {get;}  - 리스트가 고정 길이 리스트인지 체크한다.
. bool   IsReadOnly{get;}  - 리스트가 읽기전용인지 체크한다.
. object  this[int  index] {get;set;}  - 인덱스 값으로 데이터를 얻거나 추가할 수 있다.
                                                       - 인덱서(Indexer)
IList 인터페이스 메서드
. int Add(object value);              -  리스트 끝에 데이터를 추가할 수 있다.
. void Clear();                            -  리스트의 모든 데이터를 제거한다.
. bool  Contains(object value);  - 어떤 데이터가 리스트내에 존재하는지 여부를 체크한다.
. int IndexOf(object value)         - 리스트 내의 특정 데이터의 위치를 반환한다.
. void Insert(int index, object value); - 리스트 내의 특정 위치에 대이터를 삽입한다.
. void RemoveAt(int index);               - 참조 또는 인덱스에 의해 지정한 인덱스의 데이터를 제거한다.

IDictionary 인터페이스 속성
.  bool IsFixedSize{get;};  - 컬렉션의 크기가 정해져 있는지 검사한다.
.  bool IsReadOnly {get;}  - 컬렉션이 읽기전용인지 검사한다.
.  ICollection Keys {get;}    - 컬렉션 내의 모든 키를 나열한다.
.  ICollection Values {get;}  - 컬렉션 내의 모든 값을 나열한다.

IDictionary 인터페이스 메서드
. void Add(object key, object value); - 키와 값을 전달하여 데이터를 컬렉션에 추가한다.
. void Clear();                                   - 컬렉션을 비운다.
. bool Contains(object Key);             - 특정 키가 데이터와 연관되어 있는지 검사한다.
. IDictionaryEnumerator GetEnumerator();  - 키와 갓을 나열한다.  IdictionaryEnumerator 인터페이스를 반환한다.
. boid Remove(object key);                         -  삭제할 값의 키를 전달하여 데이터를 컬렉션에서 삭제한다.

IDictionaryEnumerator 인터페이스의 상속구조
. DictonaryEntry Entry{get;}   - 열거 요소내의 키와 값을 가져온다.
. Object  Key {get;}                -  열거 요소내의 키를 가져온다.
. Object Value {get;}              - 열거요소 내의 값을 가져온다.

ArrayList클래스의 프로토타입
. public class ArrayList  : IList, ICollection, IEnumerable, Icloneable

Hashtable 클래스의 프로토타입
. public class Hashtable : IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback, Icloneable
- IDictionary 인터페이스의 대표적인 예
- 객체를 삽입할때 특별한 Key와 Value을 같이 입력해야 한다.

SortedList 클래스의 프로토타입
.  Public class SortedList : IDictionary, ICollection, IEnumerable, Icloneable
 - SortedList는 키의 목록 또는 값의 목록만 반환하는 메서드를 제공
 - SortedList는 내부적으로 두 개의 배열 즉, 키에 대한 배열과 관련 값에 대한 배열을 유지하여 요소를 목록에 정장
 - SortedList는 각 요소에 대해 키, 값 또는 인덱스의 세가지 방법으로 액세스함.
 - 요소가 삽입되면, 지정된 키가 이미 존재하는지 검사 -> 중복을 허용치 않음

Queue 클래스
. public class Queue : ICollection, IEnumerable, ICloneable

Queue 클래스의 특징
. 선입선출 컬렉션 클래스
. Enqueue() 메서드는 Queue의 첫위치에 요소를 삽입
. Dequeue() 메서드는 Queue의 마지막 위치의 요소를 삭제
. Peek() 메서드는 Queue의 마지막 위치의 요소를 제거하지 않고 반환

Stack 클래스의 프로토타입
. Public class Stack : ICollection, IEnumerable, Icloneable

Stack 클래스의 특징
. 후입선출 컬렉션 클래스
. Push() 메서드는 Stack의 맨 위에 요소를 삽입
. Pop() 메서드는 Stack의 맨 위에 있는 요소를 삭제하고 데이터를 반환
. Peek() 메서드는 Stack의 맨 위에 있는 요소를 제거하지 않고 반환

BitArray 클래스의 프로토타입
. public sealed class BitArray  : ICollection, IEnumerable, Icloneable
 - BitArray b = new BitArray(8);
 - 8비트를 가지는 비트배열 생성
 -  모든 비트는 false로 설정

NameValueCollection 클래스
　
Exception
표준 예외들
. Exception  : Object형으로 모든 예외의 기본클래스
. SystemException : Exception 형으로 모든 런타임 생성 오류의 기본 클래스
. IndexOutOFRangException : SystemException 형으로 매열이 올바르지 않게 인덱싱되는 경우에만 런타임에 의해 throw된다.
           배열의 인덱스가 유효한 범위를 벗어날 때 사용   ex)  arr[arr,Length+1]
. NullReferenceException  : SystemException형으로  null 객체가 참조되는 경우에만 런타임에 의해 throw됨.  
                   ex) object o = null;   o.ToString();
. InvalidOperationExceptio  : System.Exception형으로 유효하지 않은 상태에 있을 때 메서드에 의해 throw됨
. ArgumentException : SystemException형으로 모든 인수 예외의 기본 클래스 입니다.
. ArgumentNullException : ArgumentException형으로 인수에 null을 혀용하지 않는 메서드에 의해  throw됨.
                     ex) string s = null;     "Calclulate".IndexOf(s);
. ArgumentOutRangeException : ArgumentException형으로 인수가 지정된 범위에 있는지 검사하는 메서드에 의해 throw됨
                  ex)string s = "string";  s.Chars[9]; 
. ExternalException : SystemException형으로 런타임 외부에서 발생하거나 런타임 외부의 환경을 대상으로 하는 
                            예외의 기본 클래스
. COMExceptionExternalException :  COM HRESULT 정보를 캡슐화하는 예회, COM interop 에서 사용됨
. SEHException : ExternalException형으로  Win32 구조의 예외처리 정보를 캡슐화하는 예외, 곤리되지 않는 코드 
   interrupt에서 사용

cf)	java - Exception throws , 사용자 정의 예외  

소스코드를 보면  메소드 바디 앞에 thows Exception 이라는 문구가 들어간 메소드를 보는 경우가 있다.
대략 이런 모양이다 . 

   public void test_method(String req) throws Exception{
        ...
        // do something!
    }

throws Exception 이 하는 일은 test_method가 동작하다가 해당 메소드 안에서 오류가 발생하게 되면 해당 메소드에서 발생한 오류 객체를 test_method 메소드를 호출한 곳으로 넘기는 역할을 한다. 
이때 사용하는 예약어가 throws 이고 throws 뒤에 처리하고 싶은 Exception 클래스를 적어주면 된다.
예를들어  ClassNotFoundException 예외와 같이 다른 개발자가 원하는 Exception 처리를 할 수 있다.

사용자가 직접 예외를 정의해서 사용도 가능하다.
사용법은 아래와 같다.

// 1. 사용자 정의할 클래스를 생성한다. 
// 2. Exception 클래스를 상속 받는다. 
public class TestException extends Exception{
    public TestException (){
        // 3.super() 를 이용해서 Exception 메세지를 설정한다. 
        super("내가 만든 예외");
    }
}

// 4. 작업할 클래스에서 사용한다.
public class TestClass{
    // 5. 테스트를 위해서 강제로 예외를 발생시킬 메소드를 만든다.
    static void callTestException() throws TestException{
        throw new TestException();
    }

    public static void main(String args[]){
       try{
           callTestException();
       }
       catch(TestException e){
            // err msg : "내가 만든 예외"
       }
    }

}[출처] java - Exception throws , 사용자 정의 예외|작성자 열혈남아


try~catch
. try(예외감시자)      - 예외가 발생할 가능성이 있는 코드의 영역을 지정
. catch(예외처리기) - try에서 발생한 예외들에 대해 어떤 종류의 예외를 어떻게 처리해 줄 것인가를 결정

try~catch 사용형식
 try{}
 catch(예외타입 변수명) {  }

다중 catch 문을 사용할 때의 주의사항
. 각각의 catch문은 반드시 서로 다른 종류의 예외를  처리할 것
. catch 문에서 사용될 예외 객체는 하위예외타입을 상위 예외타입보다 먼저 사용할 것

try~catch~finally문
try{     //예외를 발생시킬 가능성이 있는 코드
    }
catch(예외타입1  변수명) 
    {    // 예외1이 발생했으 때 실행되는 코드
    }
catch(예외타입2 변수명)
    {    // 예외2가 바랭했을 때 실행되는 코드
    }
finally 
    {    // 필수 실행 코드
    }

Exception 클래스에서 예외의 상태정보 속성
. StackTrace 속성       :  이 속성에는 오류 발생 위치를 알 수 있으며 스택을 추적한 정보를 포함하고 있다. 
                                     스택 추적에는 소스파일 이름과 프로그램 줄 번호가 포함됩니다.
. InnerException 속성 :  예외가 발생했을 때 하나의 예외가 발생하면 또 다른 예외로 이어지게 되는데 하나의 예외에 
                                     포함된 다른 예외정보를 포함하고 있는 속성
. Message 속성         :   예외에 포함된 메시지를 포함하고 있는 속성
. HelpLink 속성           :  예외의 원인에 대한 정보를 제공하는 도움말 파일의 URL 또는 URN이 보관 될 수 있다.

checked & unchecked 키워드
. Arithmetic Overflow  - 산술연산 중 특정 타입의 변수가 허용하는 값의 범위를 초과하는 것
. CLR 에서 오버플로에 대한 기본 설정 
  - 상수식(일반상수로만 이루어진 식) : 컴파일 시 오버플로 검사
  - 비상수식(변수를 포함되어 만들어진 식) : 오버플로를 검사하지 않음

상수식의 기본 성질
. 상수식은 checked가 기본 성질이다.
. 상수식은 컴파일러가 컴파일할 때 오버플로를 검사한다.

비상수식의 기본 성질
. 비상수식은 unchecked가 기본 성질이다.  (즉, 비상수식에서 오버프로가 발생하더라도 체크하지 않는다는 뜻)
. 컴파일 시 비상수식의 오버플로는 점검될 수 없다.
. 실행시(런타임)에 오버플로가 발생할 수 있다.
. 실행시 오버플로의 에러 감지를 위해서 checked키워드를 이용한다.

Stream의 정의
. 자료의 입출력을 도와주는 추상적인 개념의 중간 매개체

데이터 흐름의 방향성 분류
. 입력스트림( Stream, TextReader,BinaryReader)    
. 출력스트림(Stream, TextWriter, BinaryWriter)

데이터 처리하는 단위기준
. Byte Stream  과  Character Stream 으로 구분

입력스트림의 사용
. 목표지점에 대이터 스트림 생성
. 알맞은 데이터 스트림으로 변환
. 데이터 입력(Read 계열 메서드)
. 데이터 스트림 닫기(Close() 메서드)

출력스트림의 사용
. 목표지점에 데이터 스트림 생성
. 알맞은 데이터 스트림으로 변환
. 데이터 출력 또는 저장 (Write 계열 메서드)
. 데이터 스트림 닫기 (Close() 메서드 )

Byte Stream의 종류
. Stream              : 스트림 계층 구조의 최상위 추상 기본 클래스
. BufferedStream : 바이트스트림에 버퍼 기능의 추가
. FileStream         : 파일 I/O 에 사용
. MemoryStream : 메모리에 사용

Character Stream의 종류
. TextReader, TextWriter : 문자스트림 계층 구조의 최상위 추상클래스
. StreamReader              : 입력 바이트스트림을 문자스트림으로 변환
. StreamWriter                : 출력 바이트스트림을 문자스트림으로 변환
. StringReader                : 문자열을 핸들하기 위한 입력 문자스트림
. StringWriter                  : 문자열을 핸들하기 위한 출력 문자 스트림

파일, 디렉터리 관련 클래스들
. FileSystemInfo               -  파일시스템 객체를 나타내는 기본 클래스
. Directory, DirectoryInfo  - 디렉터리를 나타내는 기본 클래스
. File, FileInfo                   - 파일을 나타내는 기본 클래스
. Path                              - 경로를 조작하기 위한 클래스

File 클래스
. Public sealed class File
. FileStream의 객체 생성
. 파일 관련 메서드 제공 
. 멤버메서드들이 public static으로 선언

File 클래스의 주요메서드
. AppendText()               :  UTF-8로 인코딩된 텍스트를 추가하는 STreamWriter를 만든다.
. Copy()                         :  새파일에 기존 파일을 복사
. Create()                       : 경로에 파일을 만든다.
. CreateText()                : UTF-8로 인코딩된 텍스트를 쓰기 위해 새 파일을 만들거나 연다.
. Delete()                       :  파일을 삭제합니다.  지정된 파일이 없어도 예외가 throw되지 않는다.
. Exists()                       : 파일이 있는지 여부를 확인한다.
. GetAttributes()             : 정규화된 경로에 있는 파일의 FileAttributes를 가져옴.
. GetCreationTime()      : 파일 또는 디렉터리를 마지막으로 액세스한 날짜와 시간을 반환
. GetLastAccessTime() : 파일 또는 디렉터리를 마지막으로 액세스한 날짜와 시간을 반환
. GetLastWriteTime()     : 파일 또는 디렉터리를 마지막으로 쓴 날짜와 시간을 반환
. Move()                        : 파일을 새 위치로 이동하고 파일의 이름을 새로 정할 수 있다.
. Open()                       : 지정된 경로에서 FileStream을 엽니다.
. OpenRead()              : 읽기용으로 팡ㄹ을 엽니다.
. OpenText()                : UTF-8 로 인코딩된 텍스트 파일을 읽기용으로 Open
. OpenWrite()               : 쓰기용으로 기존 파일을 엽니다.
. SetAttributes()            : 파일의 지정된 FileAttributes를 가져온다.
. SetCreationTime()      : 파일이 만들어진 날짜와 시간을 설정
. SetLastAccessTime() : 파일을 마지막으로 액세스한 날짜와 시간을 설정
. SetLastWriteTime()      : 파일에 마지막으로쓴 날짜와 시간을 설정

Directory 클래스 
. 디렉터리의 생성, 이동, 삭제의 기능을 이용할 수 있다.
. public sealed class Directory
. 디렉터리 생성 및 삭제
. 하위디렉터리 생성 및 삭제
. 디렉터리 관련 메서드 제공
. 멤버메서드는 모두 public static 으로 선언되어 있다. 

Path 클래스
. public sealed class Path
. 파일이나 디렉터리의 경로의 확장 및 변경, 수정하는 클래스
. 멤버메서드, 멤버필드 모두 public static으로 선언되어 있다.

Stream 클래스
. public  abstract class Stream : MarshlbyRefObject, IDisposable 
. 바이트스트림 클래스들의 추상 기본 클래스
. 기본적이 입출력에 관련된 메서드를 포함하고 있다.
. 바이트 스트림 클래스들이란  Stream 계열의 BufferedStream, FileStream, MemoryStream, NetworkStream, CryptoStream등
  - 추상클래스이므로 스트림을 직접 생성하지는 못하고 , Stream 클래스를 구현하여 각각의 장치에 맞는 스트림을 만들어 사용

스트림을 얻기 위한 Console의 정적 메서드
. public static Stream OpenStandardOutput()
  - 표준 출력스트림을 가져옵니다.
.  public static Stream OpenStandardOutput(int)
  -  표준 출력스트림을 가져와서 지정한 버퍼 크기로 설정

Stream클래스의 속성(Property)
. CanRead : 파생클래스에서 재정의될 때 현재 스트림이 읽기를 지원하는지 여부 확인
. CanSeek : 파생클래스에서 재정의 될 때 현재 스트림이 검색을 지원하는지 여부 확인 
. CanWrite: 파생 클래스에서 재정의 될 때 현재 스트림이 쓰기를 지원하는지 여부 확인
. Length: 파생클래스에서 재정의된 경우 스트림 바아트의 길이 반환
. Position: 파생클래스에서 재정의되면 현재 스트림 내의 위치를 가져오거나 설정

FileStream 클래스
. public class FileStream : Stream
. 파일에서 스트림을 생성할 때 사용
. 바이트 형식의 파일을 읽고 쓸 때 사용
. Stream 클래스의 모든 기능 사용 가능

FileStream의 변환
. 바이트가 아니라 문자 방식으로스트림을 사용하기 위해서는 FileStream 클래스를 StreamReader 클래서와
  StreamWriter 클래스로 변환하여 사용합니다.  스트림의 변환 절차를 거치면 자동적으로 바이트스트림을 문자스트림으로
  핸들할 수 있게 해줍니다.  StreamReader클래스와 StreamWriter 클래스는 바이트스트림을 문자스트림으로 변환하고자 할 때
  주로 사용합니다.

File 클래스를 이용하여 스트림을 생성하는 예
FileStream을 이용하여 직접 FileStream을 생성할 수 있지만 
예 >   FileStream fs = new FileStream(path, FileMode.Create);
File클래스의 OpenRead()메서드를 이용하여 FileStream 객체를 생성할 수도 있습니다.
예 >  FileStream fs = File.Openread("C:\C#Example\03\HelloWorld\test.txt");

FileMode 상수
. Append          : 해당 파일이 있을 경우 파일을 열고, 파일의 끝까지 검색하거나 새 파일을 만듦
. Create            : 운영체제에서 새 파일을 만듦. 해당 파일이 있으면 덮어씀.
. CreateNew     : 운영체제에서 새 파일을 만듦. 파일이 존재하면 Exception 발생
. Open              : 운영체제에서 기존 파일을 열도록 지정 파일이 없으면 Exception 발생
. OpenOrCreate: 파일이 있으면 열고, 없으면 새 파일을 만듦
. Truncate         : 기존 파일을 열고, 파일 크기가 0 바이트가 도도록 만듦.

SeekOrigin 상수
. Begin     : 스트림의 맨 앞을 지정합니다.
. Curerent : 스트림 내의 현재 위치를 지정합니다.
. End        : 스트림의 맨 끝을 지정합니다.

Fush()
Flsh() 메서드는 스트림에 기록한 모든 데이터들을 목표지점으로 밀어내는 역할

Peek()
Peek()메서드는 읽을 데이터가 있으면 그 값을 반환하지만, 없으면 -1을 반환하는 메서드 

BufferedStream 클래스
. public sealed class BufferedStream : Stream
. BufferedStream은 내부적으로 버퍼 기능을 제공해 준다.
. 디폴트 버퍼 사이즈는 4096 Bytem
. 내부에 버퍼를 사용하기 때문에 처리하는 속도가 훨씬 빠름

MemoryStream 클래스
 . public sealed class MemoryStream : Stream
. 메모리에서 스트림 생성
. 부호없는(unsigned)바이트 배역 (byte[])로 저장된 데이터를 캡슐화

TextReader & TextWriter 클래스
. public abstract class TextReader : MarshalbyRefObject, Idisposable
. public abstract class TextWriter : MarshalbyRefObject, Idisposable
. 문자스트림(Character Stream)의 최상위 클래스

StringReader & StringWriter 클래스
. public class sStringReader : TextReader
. public class StringWriter     : TextWriter
. StringReader 클래스는 string형 데이터를 매개변수로 직접 스트림 생성
. StringWriter 클래스는 스트림에 문자를 기록한다.

StreamReader & StreamWriter 클래스 
. public class StreamReader : TextReader
. public class StreamWriter : TextWriter
. 바이트스트림  - >  문자스트림
. TextReader 와 TextWriter를 상속받는 문자스트림
. 바이트 스트림을 문자스트림으로 변환할 때 사용

BinaryReader & BinaryWriter 클래스
. public class BinaryReader :IDisposable
. public class BinaryWriter : Idsposable
. 타입에 따라 이진 데이터를 읽거나 쓸 경우 사용하는 클래스 

Object 클래스
.  .NET Framework 최상위 클래스
. 모든 클래스는 Object클래스를 상속

Object 클래스의 멤버메서드
. public virtual bool Equals(object obj)
 - 지정한 객체가 현재 객체과 같은지 비교
 - 디폴트는 참조비교, 파생되어 다양한 비교를 함
. public static bool Equals(object obj1, object obj2)
 - 지정한 두 객체가 같은 객체인지 비교하는 스태틱 메서드
 - 매개변수로 들어오는 객체의 Equals()에 따라서 비교가 결정
. public static bool ReferenceEquals(object obj1, object obj2)
 - obj1 과 obj2 같은 참조값을 가지는지 비교
. public virtual int GetHashCode()
 - 객체의 HashCode 값 반환
 - 기본 참조코드 반환, 파생되어 다양한 형식의 유일키 반환
. public Type GetType()
 - 런타입시 객체의 형 반환
. public virtual string ToString()
 - 재정의하지 않았을 때 디폴트로 객체의 타입을 출력한다.
 - 객체의 정보출력을 목적으로 함, 재정의되어 객체의 다양한 정보를 반환 
. protected ~ Object()
 - 메모리 해제시 가ㅣ지콜렉터에 의해 자동호출
. protected object MemberwiseClone()
 - 객체의 메로리 단순 복사

해시코드(HashCode)란?
. CLR이 부여하여 객체를 식별하는 고유한 ID
. GetHashCode()에 의하여 반환
.  사용자가 GetHashCode()를 재정의하여 사용할 수 있음

GetType() 메서드
. System.Type의 객체를 반환하는 메서드
  ※ Type 클래스 : 프로그램이 실행될 때 클래스는 CRL에 로딩되어질 것입니다. CLR에 로딩된 클래스는 클래스 내의 모든 
                            정보를 담고 있습니다.  예를 들어 , 생성자가 몇 개인지, 멤버필드가  어떠한 것인 있는지, 누구로부터 상속을 
                           받았는지 등에 관한 클래스 자체의 모든 정보를 담고 있습니다. 가령, 여러분이 문자열을 핸들하고자 한다면 
                           string 클래스를 사용합니다.  이와 마찬가지로 클래스의 모든 정보를 핸들하고자 한다면 Type클래스를 
                           이용하는 것입니다.
Type 클래스의 메서드가 제공하는 클래스 정보
. 클래스 타입에 관관 정보 : 클래스 상속, 인터페이스 구현 등의 정보
. 클래스 멤버에 관한 정보 : 메서드 , 속성, 이벤트, 객체의 정보

Reflection이란
실행시에 객체를 통해 클래스의 정보를 분석해내는 프로그램 기법

일반적인 클래스의 사용
. 클래스 디자인
. 클래스를 이용해서 객체변수 선언
. 선언된 객체에 메모리 할당
. 객체변수를 통해서 메서드 호출

리플렉션(Reflection) 기법의 사용
. 메모리를 보유하고 있는 객체가 존재할 경우
. 객체의 형(Type) 정보를 알아낸다. (즉, 해당 객체의 Type 클래스 생성)
. 생성된 Type과 해당 객체의 메모리를 이용하여 멤버들을 호출할 수 있다.

클래스의 형정보(Type Information)가 존재하는 곳
. 파일 어셈블리(Assembly) 내에 형정보가 들어 있다.
. 어셈블리에 존재하는 클래스가 로딩되었다면 CLR의 모모리 내에도 형정보가 존재한다.
. 해당 객체가 CLR 내에 존재한다는 것은 해당 클래스의 타입(형)정보가 로딩되었다는 것을 의미한다.

Type 클래스 
. Type 클래스는 클래스의 모든 정보를 관리하는 클래스
. 특정 객체의 타입(Type)만 알고 있다면, 이 Type을 이용하여 모든 작업을 할 수 있다.

Type을 얻을 수 있는 방법
. 객체.Type()
. Type.GetType("클래스 명")
. Typeof(클래스명)

동적바인딩과 정적바인딩
typeof 키워드는 클래스 자체를 인수로 받아서 컴파일 시에 그 클래스를 검사사하기 때문에 해당하는 클래스가 없다면 예외를 발생
그리고, 실행시(Run-Time) 에는 이미 확인된 타입을 그대로(정적으로) 사용하는 것입니다. 하지만, Type.GetType() 메서드는 
프로그램 실행시, 해당 구문을 실행할 때 문자열로 지정된 타입을 동적으로 찾아서 그 형을 반환하므로, 컴파일 타임과는 상관이
없게 되는 것이입니다.

Type 클래스를 분석하는 방법
. 생성자를 알아낼 때 : public ConstructorInfo[] GetConstructors() 사용
. 메서드를 알아낼 때 : public MethodInfo[] GetMethods() 사용
. 변수를 알아낼 때   : public FieldInfo[] GetFields() 사용  

대리자(Delegate)
. 메서드의 대리자
. 메서드를 보다 효율적으로 사용하기 위하여 특정 메서드 자체를 캐슐화할 수 있게 만들어 주는 방법

대리자(Delegate) 구현단계
. 1단계 : Delegate할 메서드를 정한다.
. 2단계 : 메서드에 맞는 Delegate 선언하기 
              - 메서드의 리턴타입과 매개변수를 정확하게 일치(반환형, 매개변수 개수, 매개변수 타입)
. 3단계 : 임의의 객체 만들기
. 4단계 : Delegate 생성과 호출 

Delegate의 선언
. 사용하려는 Delegate의 형을 생성하는 부분
   public delegate void TopDelegator(string str);
. 메서드의 선언 (시그너쳐)
  public void NormalMethod(string str)
  public static void StaticMethod(string str)

Delegate의 생성
. 생성된 Delegate 타입으로 부터 Delegate 객체를 생성하는 부분
  - Delegate객체를 만들 대의 매개변수는 메서드의 이름이다.
  - 예) TopDelegator dele = new TopDelegator(t.NormalMethod);

Delegate를 사용하여 메서드 호출하는 부분
. 생성된 Delegate 객체를 사용하여 메서드를 호출하는 부분
  td1("jabook")
  td2("소설같은 C#")

Delegate의 해석
. 메서드의 포인터를 편리하게 사용하는 방법을 제공한다.
. Safe Type Method Pointer
. Method의 Pointer를 C#에서는 Delegate라는 형식을 빌어 사용할 수 있게 해준다.
. 메서드를 Delegate라는 것에서 관리하게 하고 메서드의 반환형과 매개변수 등의 안전성을 보장 받는다.

Thread에 사용되는 Delegate의 구현
. ThreadTest tt = new ThreadTest(); //임의의 ��체
. Thread t = new Thread(new ThreadStart(tt.메서드));
. thread.Start();

ThreadStart
. 스레드를 만들기 위해서는 스레드로 사용할 메서드를 반드시 ThreadStart 델리케이트로 만들어야 합니다. 
  ThreadStart 델리케이트는 라이브러리 내부에 선언되어 있으며 여러분은  스레드를 만들고자 할 때 ThreadStart를 
  사용하기만 하면 됩니다.

하나의 Delegate에 다른 Delegate를 추가, 삭제하는 방법
. 추가하려는 메서드를 담고 있는 객체를 += 연산자를 사용하여 등록
. 추가한 메서드를 제거할 때에는 -= 연산자를 사용하여 제거
. 멀티 Delegate를 사용할 때 메서드는 반드시 void를 반환해야 함

이벤트란?
. 이벤트(Event) 그 자체
. 이벤트를 발생시키는 이벤트 발생기
. 이벤트를 받는 이벤트 처리기 (Event Handler)

일반적인 이벤트 순서
1단계 : GUI 이벤트를 테스트 하기 위한 윈도우 폼 만들기
2단계 : 폼에 등록된 이벤트 찾가(Click)
3단계 : Click 이벤트 처리기(Event Handler) 만들기  
           EventHandler의 형태 => private void ClickReceive(object sender, EventArgs e){  }
                                                object sender : 메시자가 어디서 발생하는지 발생된 곳의 참조값을 의미
                                                EventArgs e    :  이벤트의 데이터를 담고 있는 매개변수
4단계 : Form의 Click 이벤트에 이벤트  처리기 등록하기
5단계 : Click 이벤트 발생, 이벤트, 이벤트 처리

Event의 처리 순서
1. User가 폼을 클릭한다.(Click 이벤트 발생)
2. 폼의 Click 이벤트에 연결된 이벤트 처리기를 찾는다 (등록된 EventHandler검색)
3. 이벤트 처리기를 호출한다. (EventHandler 호출, 매개변수로 ㅎ출자와 이멘트의 정보를 주고 Eventhandler를 호출한다.
4. EventHandler에 포함된 메서드를 호출하여 작업을 처리한다. 

전처리 지시어의 종류
. #define, #undef ; 조건부 컴파일 기호를 정의하거나 정의를 해제할  때 사용
. #if, #elif, #else, #endif : 소스 코드의 특정 부분을 조건적으로 건너 뛸 때 사용
. #line : 오류나 경고에 대해 생성되는 줄 번호를 제어할 때 사용
. #error, #warning : 오류나 경고를 발생시킬 대 사용
. #region, #endregion: 소스 코드의 특정 부분을 명시적으로 표시할 때 사용

스레드( Therad)의 특징
. 프로그램내의 일련의 작업단위
. 스레드 단위로 CPU의 제어권을 확보할 수 있다.
. 스레드를 프로그래머가 직접 제어할 수 있다.

Process와 Thread
Process는 실행중인 하나의 프로그램을 의미하고, 
Thread는 프로세서내에서 작업의 단위로서 여거 개 존재할 수 있다.

Process  - Thread   t1   - TLS(Thread Local Storage)
                                      - Call Stack
                ---------------------------------------
               - Thread   t2   - TLS(Thread Local Storage)
                                      - Call Stack

※ Call Stack : Thread 내에서 사용하는 메서드 호출 순서와 메서드 내부에서 사용하는 메모리를 저장하는 역할 담당
                      ( 스레드에서 사용하는 메모리 자체)
※ TLS : 스레드 자신의 정보를 저장하는 역할

Thread 상태
Unstarted(생성 직후의 상태) - Runnable(실행 가능한 상태) - Suspended(대기상태) - Stopped( 실행을 끝내고 죽은 상태)

Thread 클래스에 정의된 메서드
Thread.Start() - 해당 스레드의 실행
Thread.Abort()- 해당 스레드의 종료
Thread.Join() - 해당 스레드의 실행 종료시까지 대기
Thread.Suspend() - 해당 스레드를 대기 상태로 변경
Thread.Resume() -  해당 스레드를 실행 상태로 변경
Thread.Sleep() -  해당 스레드를 특정 시간동안 대기 상태로 변경

스레드를 대기상태로 보내는 방법
. Sleep() 
  - 지정한 시간(Millisecond) 동안 스레드를 대기상태로 만듦
  - 지정된 시간이 지나면 자동으로 Runnable 상태가 된다.
. Suspend()
 - 스레드를 대기상태로 보낸다.
 - 다시 실행 상태가 되기 위해서는 Resume() 메서드를 호출해야 한다.
 -  Resume()을 호출하지 않으면 스레드는 Runnable 상태로 되돌아 올 수 없다.

스레드의 종료
. 자동 종료 - 해당 메서드의 종료
. 강제 종료 - Abort() 메서드를 이용하여 ThreadAbortException을 발생하여 종료
. ThreadAbortException 
                - 일반적으로는 처리할 수 없는 예외 해당
                - 단, 스레드가 WaitSleepJoin 상태라면 이 예외를 처라할 수 있음

동기화(Synchronization)
. 스레드가 자원을 공유할 때 한번에 하나의 스레드만 사용
. 하나의 스레드가 공유자원을 사용할 때 공유자원에 lock을 걸어준다.

동기화(Synchronization) 위한 방법들
. Lock 키워드의 사용
. Threading 네임스페이스의 Monitor 클래스의 사용
. Threading 네임스페이스의 Mutex 클래스의 사용

Marshaling ?
예> 객체를 메모리로 통째로 저장한 후 다른 컴퓨터로 전송했는데 이것을 복원해서 사용하려 합니다. 
  컴퓨터간에 사요하은 데이터타입의 메모리가 다르거나 데이터를 저장하는 형태가 다르다면 어떻게 될까요?
  이것을 방지하기 위해서는 적절한 정보를 첨부해서 객체를 전송하거나 다른 방법을 강구해야만 합니다.  이러한 형식을 맞추기
  위해서 해주는 작업을 마샬링 이라고 합니다. 
[출처] C# 간단정리|작성자 이원호씨
출처: http://leeexe.tistory.com/entry/C-간단-정리 [내 놀이터]






cf)	 기타 C# 명령
1.	iOp = tb.Text.IndexOf("+");
	만약 tb.Text String 상에 "+"문자가 있으면 해당하는 위치를 return값으로 제공
	ex)	tb.Text = 111+1 인 경우 return값으로 3 출력






[60-1]	자바기본문법(java)
1]	자바명령어
	System.out.print("\n"+s);				// 출력가능 문자열 출력
	System.out.println("\n"+s);				// 출력가능 문자열 출력 후 줄 구분 문자열 출력(\n)
	System.out.write(("\n"+s);				// byte형을 출력

2]	자바기본설명
	가)	기본 컴파일 방법
		javac test.java	->	test.class
		test.class를 test.exe(c언어) 처럼 다른 프로그램 도움 없이 그대로 실행 시킬 수 없고
	나) test.class 파일을 java.exe(Java Virtual Machine; JVM) 프로그램 도움을 받아서 실행 시켜야 함
		java.exe 처럼 JVM이 있기 때문에 test.class 파일을 JVM 종류만 달리 하면 Linux OS에서 실행 시킬 수도 있고
		Windows OS에서 실행 시킬 수도 있으며 Web browser에서도 실행 시킬 수 있다
		ex)	java test	// .class 확장자를 붙이면 안된다.
						// 여러개의 .class 파일이 있을 때는 public class 파일 이름을 사용
	다)	java.exe vs javaw.exe
		java.exe로 실행된 어플리케이션은 java prompt를 유지하며, 콘솔창을 닫을 경우 프로그램 종료됨
		javaw.exe 는 콘솔과 문관하게 자바 어플리케이션을 구동시키며 javaw.exe로 실행된 어플리케이션은 콘솔창과 무관하게 동작함
	
3]	자바 기본 문법
1-1.파일 이름과(ex, Test.java) public class 이름은(ex, public class Test) 서로 같아야 한다.
	아래 파일의 이름은 반드시 HelloWorldApp.Java이어야 한다. 물론 대소문자까지도 같아야 한다. 그렇지 않으면 error이다.
	파일이름은 class의 이름과 정확히 일치해야 한다('class가 뭐지?' 라고 질문이 생겨도 그냥 넘어가자. 4 line에 class 선언이 있다.)
4. public class HelloWorldApp { 
5.      public static void main (String args[]) { 
6.              System.out.println("Hello World!"); 
7.      } 
8. }

1.	class 유형
public class Account
{
	private long restMoney = 34123415;

	public void saveMoney(long amount)			// -> class 안에 변수 뿐만 아니라 method(함수)도 가능
	{			
		restMoney = restMoney + amount;
	}
}

2.	Object 만들기(instance 만들기)
	상기 1번 class에 대한 object 생성
	Account x = new Accout();
	x.restMoney = 123;							// restMoney = 34123415 -> 123으로 변경
	cf)	instance(인스턴스/객체)
			instance는 상단 코드에서 new 연산자를 사용해서 실행가능한 object로 생성된 x를 뜻함(메모리에 올라감)
		method(메서드)
			서브함수 혹은 서브 루틴 정도로 해석
			C에서는 함수라 하지만 C++에서는 메서드라하며 객체에서 멤버함수를 의미하는 말이 메서드임
			하지만 넓은 의미로 그냥 함수라는 즉 어떠한 루틴을 처리하기 위한 명령들의 묶음을 메서드라고 하기 함

3.	배열(Array)
1)	1차원 Array
	ex1)	int [] arr = new int[5];
			int arr[] = new int[5];
			arr[0] = arr[3];
			
			int[] arr;
			arr = new int[5];

	ex2)	char s [];
			char s[];							// cf, char s[5] -> 에러
			char [] s;
			Point p[];
			Point [] p;

	ex3)	double aTemp[] = {1.0, 1.2, 2.3, 3.5};
			int iTemp2[] = {1, 2, 3};
			
	ex4)	string[] stArray = new string[5];

2)	다차원 Array
	가)	코드
		int[][] arr;
		arr = new int[3][];
		arr[0] = new int[3];
		arr[1] = new int[3];
		arr[2] = new int[3];
	나)	설명
		arr		arr[0]		arr[0][0] arr[0][1] arr[0][2]
				arr[1]		arr[1][0] arr[1][1] arr[1][2]
				arr[2]		arr[2][0] arr[2][1] arr[2][2]
3)	클래스 배열
	/*	Method array는 어쩔 수 없이 이렇게 constructor(생성자)를 사용해서 정의 해 줘야 함
	 *	cf) TYPE_BAND Tline = new TYPE_BAND(); -> 이와 같이 생성자 사용 없이 정의 불가	 */
	TYPE_GRAPH_DATA [] m_CardiacData;

	CImageDataProcess()
	{
		m_CardiacData = new TYPE_GRAPH_DATA[CDefine.IMAGE_NUM_MAX];
		
//		m_CardiacData[0] = new TYPE_GRAPH_DATA();
//		m_CardiacData[1] = new TYPE_GRAPH_DATA();
//		m_CardiacData[2] = new TYPE_GRAPH_DATA();
//		.........................................		
		for(int i = 0; i < CDefine.IMAGE_NUM_MAX; i++)
		{
			m_CardiacData[i] = new TYPE_GRAPH_DATA();
		}
	}
4)	동적 배열
자바의 배열은 정적입니다. 미리 크기가 정해져 있기에, 나중에 요소를 추가할 수 없습니다. 
만약 추가한다면 Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 이런 에러가 나게 됩니다.

텍스트 파일 등을 다룰 때는, 펄(Perl)의 배열처럼, 실시간으로 늘어나는 배열이 편리합니다.
펄의 배열은 크기 제한이 없어서, 실행시에 아무 값이나 넣어도 고무줄처럼 쭉쭉 늘어나게 됩니다. 그리고 문자열과 숫자를 한꺼번에 넣을 수도 있습니다.

그래서 자바의 ArrayList 를 사용해서, 펄 스타일의 배열을 구현해 보았습니다. 적어도 제가 보기로는 펄의 배열과 똑같이 잘 작동했습니다.

oPerlishArray 라는 배열에 add() 메소드로 요소들을 마음대로 추가하면, oPerlishArray 배열의 크기가 자동으로 늘어나게 됩니다. 
인덱스 번호로 지정하지 않고, 그냥 뒤쪽에 요소들이 추가됩니다.

펄에서 흔히 그렇게 하듯, 텍스트 파일을 통째로 배열에 넣어서 처리할 때 편리할 것입니다.

그런데 이런 동적 배열은 속도가 떨어지고 메모리 관리도 비효율적이기에, 꼭 필요한 경우에만 사용해야 합니다. 
물론 텍스트 파일 처리 등에서는 퍼포먼스가 떨어지더라도 차이를 체감할 수는 없을 것입니다.

ArrayList 예제: 배열 요소 추가, 배열 크기 조절 Array Resize

파일명: Foo.java
import java.util.*;

public class Foo {
  public static void main(String args[]) {

    List<Object> oPerlishArray = new ArrayList<Object>();

    // 배열 요소 몇 개 채우기, 문자열 숫자 가리지 않고
    oPerlishArray.add(123);
    oPerlishArray.add("하하하");

    // 이제는 배열 요소 (숫자) 한꺼번에 채우기
    for (int x = 10; x <= 100; x++) oPerlishArray.add(x);


    // 배열 출력
    for (int i = 0; i < oPerlishArray.size(); i++)
      System.out.format("[%d] = %s%n", i, oPerlishArray.get(i));

  }
}

배열에 정수만을 넣기 위해서는
List<Integer> oPerlishArray = new ArrayList<Integer>();
이렇게 <Integer> 로 변경합니다.

문자열만 넣으려면 다음과 같이 합니다.
List<String> oPerlishArray = new ArrayList<String>();

펄(Perl)처럼 모든 타입을 가리지 않고 넣으려면 다음과 같이 합니다.
List<Object> oPerlishArray = new ArrayList<Object>();

4.	static
	가)	static 사용하는 이유 instance(object) 만들지 않고 곧바로 사용하기 위해
	나)	static 으로 선언하면 모든 instance 들에서 공유된다.(공통적으로 같은 값을 사용하게 됨)
		C언어의 전역변수 처럼 사용 가능
ex)
class Card
{
	String kind;				// 인스턴스 변수 - 카드의 무늬
	int number;					// 인스턴스 변수 - 카드의 숫자
	static int width = 100;		// 클래스 변수(static 변수) - 카드의 폭(공통적으로 같은 값을 사용)
	static int height = 250;	// 클래스 변수(static 변수) - 카드의 높이(공통적으로 같은 값을 사용)
}

class CardTest
{
	public static void main(String args[])
	{
		// 클래스변수(static 변수)는 객체생성없이 "클래스이름.클래스변수"로 직접 사용 가능하다.
		System.out.println("Card.width =" + Card.width);
		System.out.println("Card.height =" + Card.height);

		Card c1 = new Card();
		c1.kind = "Heart";
		c1.number = 7;
		
		Card c2 = new Card();
		c2.kind = "Spade";
		c2.number = 4;
		
		System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")");
		System.out.println("c2은 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")");
		
		System.out.println("이제 c1의 width와 height를 각각 50, 80으로 변경 합니다.");
		
		c1.width = 50;
		c1.height = 80;
		
		System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")");
		System.out.println("c2은 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")");
	}
}

->	실행결과
Card.width =100
Card.height =250
c1은 Heart, 7이며, 크기는 (100, 250)
c2은 Spade, 4이며, 크기는 (100, 250)
이제 c1의 width와 height�� 각각 50, 80으로 변경 합니다.
c1은 Heart, 7이며, 크기는 (50, 80)
c2은 Spade, 4이며, 크기는 (50, 80)
		
	다)	주의점 : static method 안에 instance ���수를 넣으면 안 됨
		public class Count
		{
			int var1 = 0; // instance 변수
			static int var2 = 1;

			static int getCount()
			{ // static method 선언
                return var1; // 달라진 곳
            }

            public static void main(String [] args)
            {
                System.out.println(Count.getCount()); // 요길 보세요. -> 에러 발생
            }
        }
    라)	예제(변수)
		public class Count
		{
			int var1;				// instance 변수
			static int var2;		// static 변수 선언

			public static void main(String [] args)
			{
//				var1 = 7;			// 띠옹~ -> 에러 발생
    			var2 = 8;			// Count.var2 = 8; 이라고 해도 됨
			}
		}
	마)	예제(method)
		public class Count
		{
			int var1 = 0;			// instance 변수
			static int var2 = 1;	// static 변수선언
					
			static int getCount() { // static method 선언
				return var2;
			}
					
			public static void main(String [] args){
				System.out.println(Count.getCount()); // 요길 보세요.
			}
		}
	바)	전역변수/지역변수
public class PryT {
    public static int [] xPosition = new int [5];	//전역변수
    public static int sirl = 0;						//전역변수

    public PryT(){
       int aLvs = 5;     //지역변수
       ........
    }
}
라는 코드가 있다면 
메소드 ��부에 선언한  aLvs는 지역변수(Local Variable)가 된다.
저 메소드가 사용되었을 때만 메모리에 있고 메소드이 끝나면 메모리에서 사라진다.
그러나 위 코드에서 전역변수라고 한 정수형 배열 변수인 xPosition와 정수형 변수인 sirl 은 프로그램이 끝나야 없어진다.
	사)	static class
		outter class 내부에 inner class가 선언되어 있는 경우
		보통, outer class의 instance가 먼저 생성된 후, inner class의 instance가 생성되어야 하지만
		inner class 가 static으로 선언되어 있으면 outer class의 instance를 먼저 생성하지 않고
		inner class 의 instance를 먼저 생성시켜서 사용할 수 있다
		
		예제)
		package com.inner;
		
		public class Outer
		{
			static int scount = 80;
			
			static class Inner
			{
				public void go()
				{
					System.out.println("value: " + scount);
				}
			}
			
			public static void main(String[] args)
			{
				Inner i = new Inner();
				i.go();
				System.out.println(i.getClass().getName());
			}
		}
		
		->	결과
		value: 80
		com.inner.Outer$Inner
	아)	static 변수는 지역변수로 존재할수 없습니다
		public class Person
		{		
			public int run()
			{
				static int i=0;     <===== 여기서 에러가 나는데....
				i++;
				return i;
			}
			public static void main(String[] args)
			{
				Person one = new Person ();
				one.run();
				int i = one.run();
				System.out.println(i);
			}
		}
		
		왜 i가 에러가 나죠???
		Illegal modifier for parameter i; only final is permitted

		->	답변
		static 변수는 지역변수로 존재할수 없습니다
		
		"인스턴스에 종속적이지 않는다" 라는 특성때문이지요		
		run 메소드의 지역변수로 존재한다는것은, run메소드가 호출되어야만 메모리에 할당된다는 뜻이고		
		결국 run메소드가 포함된 클래스의 인스턴스에 종속적이라는 뜻이지요
				
		이런 이유말고도 static 변수는 메소드 영역에 할당되고, 지역변수는 스택영역에 할당되기 때문에 이치에 맞지않습니다

5.	final
	1)	사용이유 : 보완 때문에 사용
		final 사용하면
		-	class의 경우는 절대로 상속될 수 없다(ex, final class TestFinal { .. } )
		-	method의 경우는 overriding이 불가능(ex, final public void func() { .. } )
		-	변수의 경우는 변경이 불가능한 상수가 된다.(ex, final public int MAX_ARRAY_SIZE = 25; )

6.	String
	1)	String 도 object이기 때문에 reference 변수를 만들고 new 키워드를 사용해야 한다.
		ex)	String str = new String("안녕");
	2)	하지만 String 만 유일하게 new 키워드를 사용하지 않고 사용 가능하다
		ex)	String str = "안녕";

7.	접근제어자(public, private...)
	●public : 어느 class에서나 참조 가능.
	●protected : 같은 package 내의 class에서만 참조 가능, 자식 class가 다른 package에 있을 경우, 그 자식class도 참조가능.
	●default(기본) : 같은 package 내의 class에서만 참조 가능.	->	cf) default를 앞에 붙이라는 뜻이 아니고 아무것도 붙이지 않으면 본 경우와 같이 동작 한다는 뜻임
	●private : 같은 class 내에서만 참조 가능
	ex)	public int var;
		long var2;

8.	은닉(Encapsulation)
1:	public class Encapsulation {
2:		private String creaditCardNo; // private member
3:
4:		public void setCreaditCardNo(String str) {
5:			if (hasAuthority() == true) // 권한이 있는가?
6:				creaditCardNo = str;
7:			else
8:				System.out.println("No Authority !!!");
9:		}
10:
11:		public String getCreaditCardNo() {
12:			if (hasAuthority() == true) // 권한이 있는가?
13:				return creaditCardNo;
14:			else {
15:				System.out.println("No Authority !!!");
16:				return "-1";
17:			}
18: 	}
19:	}
	위의 예제는 encapsulation(은닉)이 무엇인지 간단하게 보여주는 예제이다. 물론 이 예제가 encapsulation의 모든 면을 보여주는 것은 아니다.
	단지 이해를 돕고자 보인 예제일 뿐이다.
	5 line에서 소개된 hasAuthority()란 method는 사용자의 권한여부를 check한 후 신용카드 정보를 보여줄 건지 말 건지를 결정하는 method이다
	(여기서는 자세한 코드는 소개되고 있지 않다). 결국 권한이 있는 사람만이 4, 11 line의 두 method를 호출해서 신용카드의 정보를 보거나 수정할 수 있다는 예제이다. 

9.	상속
1:	class Employee {
2:		String name;
3:		Date hireDate;
4:		Date dateOfBirth;
5:	}
6:	class JavanuriManager extends Employee{
7:		String department;
8:		Employee subordinamtes [];
9:	}
	JavanuriManager class를 보면 상당히 간단해진 것을 볼 수 있다. line 6을 보자.
	extends 키워드는 반드시 기억하자. 상속받을 때 사용하는 키워드이다.
	이렇게 JavanuriManager class가 Employee class를 상속받으면 Employee class가 가지고 있는 모든 것
	(물론 1가지 제외되는 것이 있기는 한데, 이것은 나중에 설명할 것이다)을 JavanuriManager class는 가지게 된다. 
	말 그대로 부모의 것을 그대로 상속받게 되는 것이다.
	이 때 잠깐 용어를 정리하자면 JavanuriManager class를 자식(child 혹은 sub) class라고 부른다(받는 입장이니까).
	그리고 Employee class를 부모(parent 혹은 super) class라고 부른다. 이 용어는 꼭 기억해야 한다

class Employee
{
	void x()
	{
		System.out.println("나는 부모");
	}

	void z()
	{
		System.out.println("나는 z");
	}
}

class Manager extends Employee
{
	void x()
	{
		System.out.println("나는 자식");
	}

	void y()
	{
		super.x();			// 3 line의 부모의 x() 호출
		x();				// override 한 16 line의 x() 호출
	}
}

public class ServerTest
{
	public static void main(String [] args)
	{
		Manager m = new Manager();

		m.x();
		m.y();
		m.z();
	}
}

->	결과
	나는 자식
	나는 부모
	나는 자식
	나는 z

10.	다른 클래스(class) 메서드 사용
	Class A
	{
		B bbb = new B(); // B class와 관계를 갖는다. (has a relation)
		bbb.x(); // 이제 B class의 x()를 호출할 수 있다.
	}
	class B
	{
		x() { ... }
	}

10+1)java - 싱글톤(Singleton), getInstance() 메소드-> 본 getInstance를 통해서도 (다른 클래스를 선언하고) 다른 클래스 메서드를 사용할 수 있다.
	new를 가지고 다른 클래스에 접근하는 방식과 유사하지만
	new는 (각각 다른곳에서) 생성할때 마다 다른메모리(주소)로 생성되지만
	getInstance는 (각각 다른곳에서) 생성해도 동일한메모리(주소)를 가리킴	->	고정된 메모리영역을 사용하여 메모리 낭비를 줄이고
																				공통된 객체를 사용할 때 매번 객체를 새로 생성하지 않는 방식

자바 프로그램이 동작할 때 최초 한번만 메모리를 할당하고 할당된 메모리에서만 사용하는 방식을 말한다.
즉, 고정된 메모리영역을 사용하여 메모리 낭비를 줄이고 공통된 객체를 사용할 때 매번 객체를 새로 생성하지 않는 방식을 말한다.
자바에서 객체를 새로 생성할때 new 연산자를 통하여 매번 메모리에 새로 할당을 하는데, 싱글톤 패턴은 기본 생성자 자체를
private으로 생성하여 new 연산자를 통해 생성하지 못하도록 제약을 둔다.
그럼 생성자를 통해 객체를 생성을 못하는데 어떻게 객체를 생성하고 가져올까?
이때 자바의 setter, getter의 느낌인 getIntance() 메소드를 통하여 객체를 반환시킨다.
예제를 보겠다.

SingleTon.java
public class SingleTon {
	//전역 객체변수로 사용하기 위해 static 객체변수로 생성
	static SingleTon instance;
	
	//생성자를 priavte로 만들어 접근을 막는다
	private SingleTon(){}
	
	//getInstance 메소드를 통해 한번만 생성된 객체를 가져온다.
	public static SingleTon getInstance(){
		if(instance == null){ //최초 한번만 new 연산자를 통하여 메모리에 할당한다.
			instance = new SingleTon();
		}		
		return instance;
	}
	
	public x() { ... }
}

SingleTonMain.java
public class SingleTonMain {

	public static void main(String[] args) {
		SingleTon st = SingleTon.getInstance();
		st.x();
		System.out.println(st);
	}
}

예제와 같이 SingleTon class에서 생성자를 private로 생성하여 new 연산자로 생성을 방지하고, 객체 변수인 instance를 통하여
최초 null인 경우에만 new SingleTon(); 으로 메모리에 한번 할당시킨다.
main문을 확인해보면 일반적으로 객체를 사용하던 SingleTon st = new SingleTon();  new 연산자 방식이 아닌
getInstance() 메소드를 통해 할당하고 있는것을 볼 수 있다.

이렇게 적어놓은 개념이 이해가 안될 수 있을 것 같다.
그럼 일반적인 new 연산자를 통한 객체 선언과 getInstance() 메소드를 통한 싱글톤 패턴의 차이를 보겠다.

NormalClass.java
public class NormalClass {
	public NormalClass(){		
	}
}

SingleTonMain.java
public class SingleTonMain {
	public static void main(String[] args) {
		//싱글톤 getInstance() 메소드를 통한 객체 사용
		SingleTon st1 = SingleTon.getInstance();
		SingleTon st2 = SingleTon.getInstance();
		SingleTon st3 = SingleTon.getInstance();
		
		System.out.println(st1);
		System.out.println(st2);
		System.out.println(st3);
		
		//일반적인 new 연산자를 통한 객체 사용
		NormalClass nc1 = new NormalClass();
		NormalClass nc2 = new NormalClass();
		NormalClass nc3 = new NormalClass();
		
		System.out.println(nc1);
		System.out.println(nc2);
		System.out.println(nc3);
	}
}

com.java.instance.SingleTon@7852e922
com.java.instance.SingleTon@7852e922
com.java.instance.SingleTon@7852e922
com.java.instance.NormalClass@4e25154f
com.java.instance.NormalClass@70dea4e
com.java.instance.NormalClass@5c647e05
싱글톤과 new연산자를 통한 주소값의 차이

기존에 생성해놓은 SingleTon 객체를 3번 선언한것과 새로 만든 NormalClass 객체를 3번 생성한것을 비교한 소스이다.
sysout을 통해 주소값을 확인해보면 확연한 차이를 알 수 있다.
싱글톤 방식은 3번이나 생성한 것 같아보이지만 getInstance() 메소드에 의해 한번만 할당된 객체의 주소값을 참조하는걸 알 수 있다.
반면 new연산자는 객체를 생성할때 마다 메모리에 새로 만들기 때문에 3개 모두 다른 메모리값으로 처리된 걸 볼 수 있다.
[출처] java - 싱글톤(Singleton), getInstance() 메소드|작성자 Sin

11.	인수전달
1)	Pass by value(값에 의한 전달)
	class PassByValue
	{
		//increment 함수를 만들것
		void increment(int j)
		{
			j++;
			System.out.println("value of j in the increment = " + j);
		}

		public static void main(String args[])
		{
			PassByValue pbv = new PassByValue();
			int j = 5;
			System.out.println("value of j before the call = " + j);

			//increment 함수를 호출  
			pbv.increment(j);
	
			System.out.println("value of j after the call = " + j);
		}
	}
	실행 결과
	value of j before the call = 5
	value of j in the increment = 6
	value of j after the call = 5
2)	Pass by reference(참조에 의한 전달)
	class PassByReference
	{
		void addTen(int arg[])
		{
			for(int i = 0; i <  arg.length; i ++ )
			{
				arg[i] += 10;   
			}
		}

		public static void main(String[] args)
		{
			int arr[] = { 4, 8, 2, 3, 5, 1, 2};

			PassByReference test = new PassByReference();
			System.out.print("Values of the array: [ ");
			for(int i = 0 ; i < arr.length; i ++){
				System.out.print(arr[i] + " ");
			}
			System.out.println("]");

			test.addTen(arr);							//arr은 배열이니까 주소가 넘어간다.
			System.out.print("New Values of the array: [ ");
			for(int i = 0 ; i < arr.length; i++){
				System.out.print(arr[i] + " ");
			}
			System.out.println("]");
		}
	}
	실행 결과
	Values of the array: [ 4 8 2 3 5 1 2 ]
	New Values of the array: [ 14 18 12 13 15 11 12 ]
3)	Pass by reference(참조에 의한 전달), ArrayList
void f(ArrayList list) {}

다음과 같이 호출하면, 

ArrayList mylist = new ArrayList();
f(mylist);

여기에서도 mylist 에의 참조의 복사본을 건네받습니다. 
메소드 내부에서 참조의 값을 변경하는 경우는, 파라미터 변수만, 즉 list 의 값이 변경됩니다. 
이것은, list 가 mylist 의 pass-by-value 복사본으로 있기 때문입니다. 예를 들어, 다음과 같이 썼다고 하면, 

void f(ArrayList list) {
list = null;
}

단순하게 list 의 값이 null로 변경될뿐입니다. 
호출측 mylist 의 값에는 아무런 영향도 없습니다. mylist 의 값은, f 가 호출 되기 전과 같습니다. 

그러나, 메소드내에서는 넘겨받은 객체의 내용 또는 상태를 변경할 수가 있습니다. 
예를 들어, 다음과 같이 쓸 수가 있습니다. 

void f(ArrayList list) {
list.add(new Integer(37));
}

이 코드는, 실제의 ArrayList 객체의 내용을 변경합니다. 
그 결과, 이 객체의 참조를 가진 프로그램의 모든 부분에서, 객체가 변경됩니다. 
덧붙여 여기서 변경하고 있는 것은 객체의 내용이며, 넘겨받은 참조의 값이 아닙니다. 
4)	Pass by reference(참조에 의한 전달), List<Integer>
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Employee
{
	static int iTemp = 0;
	
	void x()
	{
		System.out.println("나는 부모");
	}

	void z()
	{
		System.out.println("나는 z");
		
		iTemp++;
		System.out.println("iTemp = " + iTemp);
	}
}

class Manager extends Employee
{
	int iTemp2 = 0;

	void x()
	{
		System.out.println("나는 자식");
		
		iTemp2++;
		System.out.println("iTemp2 = " + iTemp2);
	}

	void y()
	{
		super.x();			// 3 line의 부모의 x() 호출
		x();				// override 한 16 line의 x() 호출
	}
}

class Log
{
	void logStuff(String s1, String s2)
	{
		// TODO Auto-generated method stub

		String buf = null;
		int s1_len = s1.length();
		int s2_len = s2.length();
//		System.arraycopy(s1, 0, buf, 0, s1_len);
//		System.arraycopy(s2, 0, buf, s1_len, s2_len);
		buf = s1 + s2;
		System.out.println("buf = " + buf);
	}
}

class PassByValue
{
	//increment 함수를 만들것
	void increment(int j)
	{
		j++;
		System.out.println("value of j in the increment = " + j);
	}
}

class PassByReference
{
	void addTen(int arg[])
	{
		for(int i = 0; i <  arg.length; i ++ )
		{
			arg[i] += 10;   
		}
	}
	
	void ArrayListChange(List<Integer> iArrayTemp)
	{
		for(int i = 0; i < iArrayTemp.size(); i++)
		{
			iArrayTemp.set(i, iArrayTemp.get(i) + 10);
		}
		
		iArrayTemp.add(999);
	}
}

class Card
{
	String kind;				// 인스턴스 변수 - 카드의 무늬
	int number;					// 인스턴스 변수 - 카드의 숫자
	static int width = 100;		// 클래스 변수(static 변수) - 카드의 폭(공통적으로 같은 값을 사용)
	static int height = 250;	// 클래스 변수(static 변수) - 카드의 높이(공통적으로 같은 값을 사용)
}

public class MainRoutine
{
	public static void main(String [] args)
	{
		int i;

		Manager m = new Manager();

//		m.x();
//		m.y();
//		m.z();
		m.x();
		m.z();
		m.x();
		m.z();

		char[] src = { 'd', 'e', 'c', 'a', 'f', 'f', 'e','i', 'n', 'a', 't', 'e', 'd' };
		char[] dst = new char[7];
		System.arraycopy(src, 2, dst, 0, 7);		// caffein 이 dst로 복사
		System.out.println(new String(dst));		// caffein 출력
		System.out.println(dst);					// caffein 출력

		String strTemp = "";
		strTemp = "hello test";
		System.out.println(strTemp);
		
		
		
		int[] iArray = new int[10];
		int[] iArray2 = new int[10];
	
		for(i = 0; i < 10; i++)
			iArray[i] = i;
		
		iArray2 = Arrays.copyOf(iArray, iArray.length);
		for(i = 0; i < 10; i++)
		{
			System.out.println("iArray["+i+"] = "+iArray[i]);		// iAraay[?]	= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  출력
			System.out.println("iArray2["+i+"] = "+iArray2[i]);		// iAraay2[?]	= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  출력
		}
		
		Arrays.fill(iArray2, 0);
		System.arraycopy(iArray, 2, iArray2, 0, 7);
		for(i = 0; i < 10; i++)
		{
			System.out.println("iArray["+i+"] = "+iArray[i]);		// iAraay[?]	= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  출력
			System.out.println("iArray2["+i+"] = "+iArray2[i]);		// iAraay2[?]	= 2, 3, 4, 5, 6, 7, 8, 0, 0, 0  출력
		}
		
		
		
		Log cLog = new Log();	
		cLog.logStuff("hoho", "hihi");


		
		
		
		PassByValue pbv = new PassByValue();
		int j = 5;
		System.out.println("value of j before the call = " + j);

		//increment 함수를 호출  
		pbv.increment(j);

		System.out.println("value of j after the call = " + j);


		
		
		int arr[] = { 4, 8, 2, 3, 5, 1, 2};

		PassByReference test = new PassByReference();
		System.out.print("Values of the array: [ ");
		for(i = 0 ; i < arr.length; i ++){
			System.out.print(arr[i] + " ");
		}
		System.out.println("]");					// Values of the array: [ 4 8 2 3 5 1 2 ] 출력

		test.addTen(arr);							//arr은 배열이니까 주소가 넘어간다.
		System.out.print("New Values of the array: [ ");
		for(i = 0 ; i < arr.length; i++){
			System.out.print(arr[i] + " ");
		}
		System.out.println("]");					// New Values of the array: [ 14 18 12 13 15 11 12 ] 출력

	

		
		List<Integer> pImageData = new ArrayList<Integer>();
		pImageData.clear();
		pImageData.add(1);
		pImageData.add(2);
		pImageData.add(3);
		pImageData.add(4);
		pImageData.set(2, 7);
		System.out.print("Before values of the pImageData: [ ");
		for(i = 0 ; i < pImageData.size(); i ++){
			System.out.print(pImageData.get(i) + " ");
		}
		System.out.println("]");					// Before values of the pImageData: [ 1 2 7 4 ] 출력
		
		test.ArrayListChange(pImageData);
		System.out.print("After values of the pImageData: [ ");
		for(i = 0 ; i < pImageData.size(); i ++){
			System.out.print(pImageData.get(i) + " ");
		}
		System.out.println("]");					// After values of the pImageData: [ 11 12 17 14 999 ] 출력	
		
		
		
	
		CImageDataProcess cImageDataProcess = new CImageDataProcess();

		System.out.println("cImageDataProcess.m_CardiacData[0].Tline.Peak = " + cImageDataProcess.m_CardiacData[0].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[1].Tline.Peak = " + cImageDataProcess.m_CardiacData[1].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[2].Tline.Peak = " + cImageDataProcess.m_CardiacData[2].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[0].Cline.mABS = " + cImageDataProcess.m_CardiacData[0].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[1].Cline.mABS = " + cImageDataProcess.m_CardiacData[1].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[2].Cline.mABS = " + cImageDataProcess.m_CardiacData[2].Cline.mABS);

		cImageDataProcess.m_CardiacData[0].Tline.Peak = 777;
		cImageDataProcess.m_CardiacData[1].Cline.mABS = 1.2345;
		System.out.println("cImageDataProcess.m_CardiacData[0].Tline.Peak = " + cImageDataProcess.m_CardiacData[0].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[1].Tline.Peak = " + cImageDataProcess.m_CardiacData[1].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[2].Tline.Peak = " + cImageDataProcess.m_CardiacData[2].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[0].Cline.mABS = " + cImageDataProcess.m_CardiacData[0].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[1].Cline.mABS = " + cImageDataProcess.m_CardiacData[1].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[2].Cline.mABS = " + cImageDataProcess.m_CardiacData[2].Cline.mABS);
		
		for(i = 0; i < CDefine.ANALYSIS_IMAGE_WIDTH; i++)
			cImageDataProcess.m_CardiacData[0].densitometer.densitoData[i] = (short)i;
		cImageDataProcess.m_testBoundaryStart = 0;
		cImageDataProcess.m_testBoundaryEnd = 479;
		cImageDataProcess.Image_ProcessDensitoData();
		System.out.println("cImageDataProcess.m_CardiacData[0].Tline.Peak = " + cImageDataProcess.m_CardiacData[0].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[1].Tline.Peak = " + cImageDataProcess.m_CardiacData[1].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[2].Tline.Peak = " + cImageDataProcess.m_CardiacData[2].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[0].Tline.PeakDistance = " + cImageDataProcess.m_CardiacData[0].Tline.PeakDistance);
		System.out.println("cImageDataProcess.m_CardiacData[1].Tline.PeakDistance = " + cImageDataProcess.m_CardiacData[1].Tline.PeakDistance);
		System.out.println("cImageDataProcess.m_CardiacData[2].Tline.PeakDistance = " + cImageDataProcess.m_CardiacData[2].Tline.PeakDistance);

		
		
		
		Engine e;
		
		// 판매상으로 부터 engine을 산다.
		e = (new EngineVendor()).getEngine();
		
		// 구매한 engine의 최고속도를 알아본다.
		System.out.println(e.getMaxSpeed());

		
		
		
		
		// File name 변경 테스트
		if (args.length != 0) {
			System.out.println("USAGE : java FileEx9 DIRECTORY");
			System.exit(0);
		}
		
		//File dir = new File(args[0]);
		File dir = new File("C:\\Temp\\logs");
		if(!dir.exists() || !dir.isDirectory()){
			System.out.println("유효하지 않은 디렉토리입니다.");
			System.exit(0);
		}
		
		File[] files = dir.listFiles();
		for(i = 0; i < files.length; i++){
			String fileName = files[i].getName();
			//파일명
			System.out.println("파일이름 :" + fileName);
			String newFileName = "0000" + fileName;
			newFileName = newFileName.substring(newFileName.length() - 7);
			System.out.println("변경된 파일 이름 : " + newFileName );
			files[i].renameTo(new File(dir, newFileName));
		}

	}
}

/*public class MainRoutine
{
	public static void main(String [] args)
	{
		// 클래스변수(static 변수)는 객체생성없이 "클래스이름.클래스변수"로 직접 사용 가능하다.
		System.out.println("Card.width =" + Card.width);
		System.out.println("Card.height =" + Card.height);

		Card c1 = new Card();
		c1.kind = "Heart";
		c1.number = 7;
		
		Card c2 = new Card();
		c2.kind = "Spade";
		c2.number = 4;
		
		System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")");
		System.out.println("c2은 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")");
		
		System.out.println("이제 c1의 width와 height를 각각 50, 80으로 변경 합니다.");
		
		c1.width = 50;
		c1.height = 80;
		
		System.out.println("c1은 " + c1.kind + ", " + c1.number + "이며, 크기는 (" + c1.width + ", " + c1.height + ")");
		System.out.println("c2은 " + c2.kind + ", " + c2.number + "이며, 크기는 (" + c2.width + ", " + c2.height + ")");	
	}
}*/

11+1.간단한 클래스간의 값 주고 받기

public class FirstClass
{
	private int a, b, c;

	public FirstClass(int a, int b, int c)
	{
		this.a = a;
		this.b = b;
		this.c = c;
	}
	
	public int getcalc()
	{
		return a+b+c;
	}
}

public class SecondClass
{
	private int myheart;
	private FirstClass fc;
	private int c;

	public SecondClass()
	{
		fc = new FirstClass(1, 2, 3);
		System.out.println(fc.getcalc());
	}
	
	public static main(String[] args)
	{
		SecondClass sc = new SecondClass();
	}
}

->	결과값
	6

12.	C언어 -> 자바
1)	memcpy
	가)	byte[] src = {1, 2, 3, 4};
		byte[] dst = Arrays.copyOf(src, src.length);
		System.out.println(Arrays.toString(dst));
	나)	int[] iArray = new int[10];
		int[] iArray2 = new int[10];
	
		for(i = 0; i < 10; i++)
			iArray[i] = i;
		
		iArray2 = Arrays.copyOf(iArray, iArray.length);
		for(i = 0; i < 10; i++)
		{
			System.out.println("iArray["+i+"] = "+iArray[i]);		// iAraay[?]	= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  출력
			System.out.println("iArray2["+i+"] = "+iArray2[i]);		// iAraay2[?]	= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  출력
		}
		
		Arrays.fill(iArray2, 0);
		System.arraycopy(iArray, 2, iArray2, 0, 7);
		for(i = 0; i < 10; i++)
		{
			System.out.println("iArray["+i+"] = "+iArray[i]);		// iAraay[?]	= 0, 1, 2, 3, 4, 5, 6, 7, 8, 9  출력
			System.out.println("iArray2["+i+"] = "+iArray2[i]);		// iAraay2[?]	= 2, 3, 4, 5, 6, 7, 8, 0, 0, 0  출력
		}
	다)	char[] src = { 'd', 'e', 'c', 'a', 'f', 'f', 'e','i', 'n', 'a', 't', 'e', 'd' };
		char[] dst = new char[7];
		System.arraycopy(src, 2, dst, 0, 7);		// caffein 이 dst로 복사
		System.out.println(new String(dst));		// caffein 출력
		System.out.println(dst);					// caffein 출력

2)	strlen
	x.length;

3)	strcpy
	가)	String s1, s2;
		s1 = new String("hello");
		s2 = s1; // This only copies s1 to s2.
	나)	String s1 = "";
		s1 = "hello test";

4)	memset
	int[] arr = new int[5];			// arr = { 0, 0, 0, 0, 0 }
	Arrays.fill(arr, 1);			// arr = { 1, 1, 1, 1, 1 }
	Arrays.fill(arr, 1, 2, 2);		// arr = { 1, 2, 2, 1, 1 }

5)	atoi	(문자열을 숫자로 변경)
	// 첫 번째 인자가 '100' 인 경우 각각의 int 형 변수에 '100'이 저장된다.
	int data1 = atoi(args[1]);					// C/C++
	int data2 = Integer.parseInt(args[0]);		// Java
	int data3 = int.Parse(args[0]);				// C#
	
	자바 형변환
	// String -> int
	int i = Integer.parseInt(String);
	
	// int -> String
	String str = String.valueOf(int);

	// String 16진수 -> 정수 변환
	int inum1 = 0, inum2 = 0;
	stTemp1 = "FF";
	stTemp2 = "2A";		// 0x2A로 대입하면 에러 발생 함
	inum1 = Integer.parseInt(stTemp1, 16);
	inum2 = Integer.parseInt(stTemp2, 16);

	public class Foo {
  		public static void main(String[] args) {

    	String h = "FF";
    	int n = Integer.parseInt(h, 16);

    	n++; // 이제 숫자가 되었으니 ++ 로, 더하기 1을 할 수 있음
    	System.out.println(n);
    	// 출력 결과: 256
    	// 255+1=256

    	String h2 = "0xFF";

    	// 접두사 0x 제거 하기
    	h2 = h2.replaceFirst("^0x", "");
    	System.out.println(h2); // FF

    	int n2 = Integer.parseInt(h2, 16);

    	n2++;
    	System.out.println(n2);
    	// 출력 결과: 256
		}
	}

5+1)반올림
String.format() 을 이용하는 방법
 
float f = 0.55555f
String str = String.format("%.2f", f);
System.out.println("str = " + str);

str = 0.56

6)	class를 구조체 처럼 사용(다중 구조체)
ex)
class TYPE_BAND  
{
	int Peak = 1;
	int PeakDistance = 2;
	double mABS = 3.4;				// 4. 센서 코드식이 적용된 값에 외부온도에따른측정값보정 코드식을 적용한 최종 측정값(Quick test만 외부온도에따른측정값보정 코드식을 적용하고 Patient test는 적용하지 않음)
	double mABSraw = 5.6;			// 1. 코드식 적용이 안된 digit값
	double mABSraw2 = 7.8;			// 2. digit값에 미터기 코드식을 적용한 값
	double mABSraw3 = 9.0;			// 3. 미터기 코드식이 적용된 값에 센서 코드식을 적용한 측정값
	int ABSArea = 11;
	int ReflArea = 12;
}

class TYPE_GRAPH_DATA
{
	TYPE_BAND Tline = new TYPE_BAND();
	TYPE_BAND Cline = new TYPE_BAND();
	double mAbsTCRatio = 13.14;
	double AreaTCRatio = 15.16;
}

class CImageDataProcess
{
	/*	Method array는 어쩔 수 없이 이렇게 constructor(생성자)를 사용해서 정의 해 줘야 함
	 *	cf) TYPE_BAND Tline = new TYPE_BAND(); -> 이와 같이 생성자 사용 없이 정의 불가	 */
	TYPE_GRAPH_DATA [] m_CardiacData;

	CImageDataProcess()
	{
		m_CardiacData = new TYPE_GRAPH_DATA[3];
		
		m_CardiacData[0] = new TYPE_GRAPH_DATA();
		m_CardiacData[1] = new TYPE_GRAPH_DATA();
		m_CardiacData[2] = new TYPE_GRAPH_DATA();
	}
}

public class ServerTest
{
	public static void main(String [] args)
	{
		CImageDataProcess cImageDataProcess = new CImageDataProcess();

		System.out.println("cImageDataProcess.m_CardiacData[0].Tline.Peak = " + cImageDataProcess.m_CardiacData[0].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[1].Tline.Peak = " + cImageDataProcess.m_CardiacData[1].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[2].Tline.Peak = " + cImageDataProcess.m_CardiacData[2].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[0].Cline.mABS = " + cImageDataProcess.m_CardiacData[0].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[1].Cline.mABS = " + cImageDataProcess.m_CardiacData[1].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[2].Cline.mABS = " + cImageDataProcess.m_CardiacData[2].Cline.mABS);
		cImageDataProcess.m_CardiacData[0].Tline.Peak = 777;
		cImageDataProcess.m_CardiacData[1].Cline.mABS = 1.2345;
		System.out.println("cImageDataProcess.m_CardiacData[0].Tline.Peak = " + cImageDataProcess.m_CardiacData[0].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[1].Tline.Peak = " + cImageDataProcess.m_CardiacData[1].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[2].Tline.Peak = " + cImageDataProcess.m_CardiacData[2].Tline.Peak);
		System.out.println("cImageDataProcess.m_CardiacData[0].Cline.mABS = " + cImageDataProcess.m_CardiacData[0].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[1].Cline.mABS = " + cImageDataProcess.m_CardiacData[1].Cline.mABS);
		System.out.println("cImageDataProcess.m_CardiacData[2].Cline.mABS = " + cImageDataProcess.m_CardiacData[2].Cline.mABS);
	}
}
->	처리결과
cImageDataProcess.m_CardiacData[0].Tline.Peak = 1
cImageDataProcess.m_CardiacData[1].Tline.Peak = 1
cImageDataProcess.m_CardiacData[2].Tline.Peak = 1
cImageDataProcess.m_CardiacData[0].Cline.mABS = 3.4
cImageDataProcess.m_CardiacData[1].Cline.mABS = 3.4
cImageDataProcess.m_CardiacData[2].Cline.mABS = 3.4
cImageDataProcess.m_CardiacData[0].Tline.Peak = 777
cImageDataProcess.m_CardiacData[1].Tline.Peak = 1
cImageDataProcess.m_CardiacData[2].Tline.Peak = 1
cImageDataProcess.m_CardiacData[0].Cline.mABS = 3.4
cImageDataProcess.m_CardiacData[1].Cline.mABS = 1.2345
cImageDataProcess.m_CardiacData[2].Cline.mABS = 3.4

7)	클래스 밖에서 member method 정의
	->	자바에서는 아래와 같은 기능이 없는 것 같다.
		무조건 member method를(아무리 코드가 길지라도) class 내부에서 정의해야 하는 것 같음
class Test
{
function Func();
}

function Test::Func()
{
}

8)	Java는 C언어와 다르게 semi-boolean의 개념이 없다(semi-boolean이란 0은 false, 0이 아니면 true인 개념)
	즉, if의 조건에 반드시 boolean 개념(true 혹은 false)이 와야 한다.
	int count = 1;
//	if(count) {			// -> error !
//	if(count > 0) {		// -> ok
	if(true) {			// -> ok
	}
	else {
	}

9)	C언의 전처리문 사용(#if 0 #elif 0 #endif)
	->	결론적으로 JAVA에서는 C언의 전처리문을 사용할 수 없다
		대신 하기와 같이 전처리문을 흉내 낼 수는 있다
		참고로, 자바에서 if(false) { ... } 명령 안의 코드는 Dead code로 컴파일 시 바이트코드에 포함되지 않는다.

->	예제)
if(false) {
	switch (keyCode)
	{
		case KeyEvent.KEYCODE_J:
			x -= 30;
			break;
		case KeyEvent.KEYCODE_K:
			x += 30;
			break;
	}
} else {
	switch (keyCode)
	{
		case KeyEvent.KEYCODE_DPAD_LEFT:
			x -= 30;
			break;
		case KeyEvent.KEYCODE_DPAD_RIGHT:
			x += 30;
			break;
	}
}

10)	자바에는 #define 문이 없다
	가)	사용불가 :	#define ORIGINAL_IMAGE_WIDTH 640						->	C언어 표현
	나)	대체:		public static final int ORIGINAL_IMAGE_WIDTH = 640;		->	자바 대체 사용(전역)
		대체:		final int ORIGINAL_IMAGE_WIDTH = 640;					->	자바 대체 사용(지역, 함수 내부)


13.	Data type
a. Logical :     참(true) 과 거짓(false)값만 가질 수 있으며, C 언어에는 없는 type 이다.
        ㄱ. boolean
b. Textual :    2 byte 크기이다. 한글 처리 가능. 일반적인 문자를 담을 수 있다.
        ㄱ. char
c. Integral :    정수를 표현하는데 사용됨. ()안은 표현 범위를 나타냄.
        ㄱ. byte : 1 byte (-2^7 ~ 2^7 -1)
        ㄴ. short : 2 byte (-2^15 ~ 2^15 -1)
        ㄷ. int : 4 byte (-2^31 ~ 2^31 - 1)		// 정수형 상수는 int가 기본형 임
        ㄹ. long : 8 byte (-2^63 ~ 2^63-1)		// 정수형 상수는 int가 기본형이기 때문에 Long 데이터에 상수를 입력 할 때에는 Long = 2147483648L 뒤에 L을 붙여서 적어주면 상수도 Long 데이터형으로 바뀌고 오류가 나지 않습니다. 
d. Floating : 실수를 표현하는데 사용됨.
        ㄱ. float: 4 byte						// 실수형 상수는 Double이 기본형이기 때문에 float을 쓰려면 F를 붙입니다. ex) Float a= 6.332F; 
        ㄴ. double : 8 byte						// 실수형 상수는 double이 기본형 임
예제
public static void main(String [] args)
{
	boolean b= false;
	char c = 'a';
	byte b1 = 1;
	short s = 1;
	int i = 1;
	double a = 12.3d;
	float f = 12.3f;
}


13+1.자바는 unsigned 가 없다 따라서 하기와 같이 처리해줘야 함
1)	int iValue = 0xff000000;
	long LValue1 = (long)iValue;
	long LValue2 = iValue & 0xffffffffL;
	long LValue3 = 0xff000000;
	long LValue4 = 0xff000000L;

	System.out.println("int iValue = " + iValue);
	System.out.println("(long)iValue = " + (long)iValue);
	System.out.println("long LValue1 = " + LValue1);
	System.out.println("long LValue2 = " + LValue2);
	System.out.println("long LValue3 = " + LValue3);
	System.out.println("long LValue4 = " + LValue4);

->	int iValue = -16777216
	(long)iValue = -16777216
	long LValue1 = -16777216
	long LValue2 = 4278190080
	long LValue3 = -16777216
	long LValue4 = 4278190080


2)	byte bValue = -1;
	byte bValue2 = -127;
	byte bValue3 = -128;
	int iValue2 = bValue & 0xff;
	int iValue3 = bValue2 & 0xff;
	int iValue4 = bValue3 & 0xff;

	System.out.println("byte bValue = " + bValue);
	System.out.println("int iValue2 = " + iValue2);
	System.out.println("int iValue3 = " + iValue3);
	System.out.println("int iValue4 = " + iValue4);

->	byte bValue = -1
	int iValue2 = 255
	int iValue3 = 129
	int iValue4 = 128


14.	코딩시 주의사항
	Java coding을 할 때, identifier에 관련된 convention이 있다. 다음을 보자.
1.	class : 반드시 대문자로 시작. 나머진 소문자. 다음 단어는 첫 자만 대문자.
	class MyClass
	class UniversalDirectory
2.	Interface : interface도 class의 일종이다.   따라서 class와 같은 convention을 따른다.
	interface JavanuriUser
3.	Method : 시작은 소문자, 다음단어는 첫 자만 대문자.
	printUser()
	changePassword()
4.	Variable : Method와 같다.
	myMoney
	exchangeUser
5.	Constants (상수) : 모두 대문자. 다음단어 사이에 underscore(_)를 준다.
	HEAD_COUNT
	MAX_PAGE

15.	Inner class
	Inner Class는 이해하기 만만치 않은 것 중의 하나다. 
	Inner class라는 것은 그 이름 그대로, class 안에서 선언된 class를 말한다. 다음의 예를 보자.

1	public class TestInner {
2		public int x = 7;
3		TestInner() { // Constructor
4			IamInner i = new IamInner();
5			i.print();
6		}
7		public int func1() {
8			x = x * x;
9			return x;
10		}
11		class IamInner { // Inner Class
12			public void print() {
13				System.out.println(x + "의 제곱은 " + func1() + "이다.");
14			}
15		}
16		public static void main(String [] args) {
17			TestInner ti = new TestInner();
18		}
19	}
	위의 예제에서 11 ~ 15 line이 inner class이다. TestInner라는 class안에 정의되어 있다(TestInner class를 흔히 outter class라고 부른다).
	이 예제의 시작점은 16 line이다. TestInner class의 instance가 생성되면 자동으로 constructor(line 3)가 호출된다.
	그러면 constructor는 4 line에서 inner class의 instance를 생성한다. 그리고 5 line에서, 생성된 inner class의print()를 호출한다.
	여기서 자세히 볼 사항은 inner class의 내부이다. 특히 13 line을 자세히 보면 outter class의 x 변수나 func() method를 자유롭게 호출하고 있다.
	다시 말해서 inner class는 outter class의 모든 member를 자유로이 호출할 수 있다. 
	이렇게 outter class의 모든 member를 자유로이 사용할 수 있다는 장점이 inner class를 사용하는 가장 큰 이유이다.
 	또한 기억할 것은, outter class의 instance가 먼저 생성된 후, inner class의 instance가 생성되어야 한다는 것이다.

16.	==	or	equals() method
	1)	==	, primitive data type 간의 비교
		public class TestEquality {		
			public static void main(String [] args) {		
				int a = 7;		
				int b = 7;

				if (a == b)
					System.out.println("same");
				else
					System.out.println("different");
			}
		}
		->	결과 : same 출력
	2)	equals() method
		public class TestEquality {
			public static void main(String [] args) {
				String a = new String("test");
				String b = new String("test");
		
				if (a.equals(b))
					System.out.println("same");
				else
					System.out.println("different");
			}
		}
		->	결과 : same 출력

17.	interface
1)	interface 사용 목적
	가)	단일상속의 한계를 극복할 수 있다
		interface는 class Child implements Test1, Test2 처럼 여러개의 interface를 상속 받을 수 있다.
	나)	interface를 사용하면 재사용성과 호환성이 매우 높은 프로그램을 만들 수 있다.
		이유)	interface로 정의해도 implements로 상속 받은 class에서(자식 class) 재정의(overriding) 해줘야 하기는 하지만
				interface 에서 규격화된 method 이름 등을 미리 선언해 놓았기 때문에
				본 interface를 가져다 쓰는 자식 class에서는 동일한 method 이름을 불러들여서 사용할 수 있음
				->	inteface를 한마디로 설명한다면 interface는 큰 틀에서 규칙을 만들어 주는 것이다.(쌍방간의 약속)
					(세부적인 사항을 묘사해 주는 것이 아닌)
				->	본 의미가 중요한 것은 interface 상의 어떤 기능을 upgrade한다고 해도 자식 class에서는 프로그램적으로
					아무 변화 없이 사용할 수 있다는 뜻이다.
				->	만약, interface를 사용하지 않고 extends를 사용한다면
					a)	부모 class에서 어떤 기능을 upgrade할 때 마다
						자식 class에서 부모 class에서 혹시 어떤 method가 추가되지 않았는지 method 명, method 형식이 변경되지는 않았는지 확인해야 하고
					b)	extends 상속의 단점인 한개의 부모 class만 상속 받을 수 있기 때문에
						여러개 이미 많이 정의된 기능을 한번에 상속 받아서 사용할 수 없다.
						cf)	interface는 여러개의 interface를 자식 클래스에 상속 시킬 수 있다.
	다)	예제
		사실 interface라는 것은 그 단어가 의미하듯이 '쌍방간의 약속'이라고 할 수 있다. 
		이 예제처럼 엔진을 사서 조립하는 쪽과 그러한 엔진을 만드는 쪽에서 서로 일종의 약속(specification 혹은 표준)을 정하는 것처럼 말이다.
		이런 약속이 명확하다면 engine을 만드는 회사가 여럿이라 할 지라도, 
		이 약속만 지켜서 만든다면 회사에 상관없이 모든 엔진은 호환성을 가지게 되는 것이다
		(이것은 마치 전구처럼 만든 회사에 상관없이 가져다 꼽기만 하면 불이 들어오는 것과 같은 이치다).
		1)	엔진(Engine.java)					->	interface 정의
		2)	Ferrari엔진(FerrariEngine.java)		->	1)번 interface에서 정의된 규칙에 맞춰서 Ferrari 엔진을 만드는 서브 공장
			Matiz엔진(MatizEngine.java)			->	1)번 interface에서 정의된 규칙에 맞춰서 Matize 엔진을 만드는 서브 공장
		3)	Engine판매상(EngineVendor.java)		->	2)번 엔진 만드는 서브 공장에서 만들어진 엔진을 자동차 공장에 판다.
		4)	자동차공장(CarFactory.java)			->	3)번 Engine판매상으로 부터 엔진을 사서 자동차 생산

		1.	먼저, 엔진을 어떻게 만들 것인지 약속을 하자(여기서는 엔진이 낼 수 있는 최대 속도를 알아내는 약속만 정의한다). 
interface Engine {
	public String getMaxSpeed();
}
			간단하다. 이제 약속이 생긴 것이다. 그럼 이 약속만 준수해서 엔진을 만들면 된다.

		2.	엔진을 만드는 업체에서 위의 약속에 근거해서 엔진을 만든다.
class FerrariEngine implements Engine {
	public String getMaxSpeed() {
		return "250 Km";
	}
}
			다른 회사에서 엔진을 하나 더 만들었다.
class MatizEngine implements Engine {
	public String getMaxSpeed() {
		return "100 Km";
	}
}
		3.	자, 이제 엔진을 사용하는 입장에서 살펴보자. 여기서는 이해를 돕기 위해서 엔진 사용자를 둘로 나누었다.
			하나는 엔진 판매상이고, 하나는 엔진을 조립하는 공장이다. 먼저 판매상부터 보자. 
public class EngineVendor {
	/*	e라는 reference 변수를 선언할 때 FerrariEngine가 아니라 Engine이라고 interface의 이름을 줬다.
		이렇게 사용해도 되는 것은 polymorphism의 개념에서 "부모의 reference 변수는 자식의 object를 reference할 수 있기 때문임"	*/
	Engine e;									// 약속된 interface의 reference

	EngineVendor () {
		// Ferrari 엔진을 사서 판다.
		// 이 부분을 Matiz 엔진으로 고치면 그 엔진을 팔게된다.		
		e = new FerrariEngine();
	}

	Engine getEngine() {						// 여기서 Engine은 선언용이 아닌 return 용 임
		return e;
	}
}
			이 판매상은 현재는 ferrari 엔진을 팔고 있다.

		4.	최종적인 자동차 공장을 보자.
public class CarFactory {
	public static void main(String [] args) {
		Engine e;								// interface의 reference

		// 판매상으로 부터 engine을 산다.
        e = (new EngineVendor()).getEngine();	// new EngineVendor().getEngine(); 이라고 해도 됨

        // 구매한 engine의 최고속도를 알아본다.
        System.out.println(e.getMaxSpeed());
	}
}
		각각의 class를 만들어 실행해 보면 잘 수행될 것이다.
		만약 엔진을 교체한다면 어느 class만 수정하면 될까? 바로 EngineVendor.Java만 수정하면
		다른 source는 고칠 필요가 없는 것이다. 다른 엔진을 만드는 회사가 생겨도 수정할 부분이 거의 없다.
		이렇게 interface를 이용하면 각 source의 재사용성(reusability)이나 호환성(compatibility)을 높일 수 있다.
		예를들어 JDBC(Java Database Connectivity)의 경우 우리가 사용하던 DB의 종류가 바뀌었을 경우, DB Driver만 바뀌어주면
		전체 프로그램 source를 고칠 필요가 없다. 이것이 바로 Java의 interface의 장점 중의 하나인 것이다(물론 ANSI SQL만을 사용했을 경우).
		하여간, 기존의 프로그래밍 언어가 거의 할 수 없었던 일을 Java가 해낸 것이다(물론 대부분의 OOP에서 가능한 이야기이지만...).
		그래서 Java가 대단한 언어라고 말하는 것이다.

17+1자바(JAVA) 인터페이스와 추상클래스의 설명과 예제

추상메서드
정의 : 내용이 없는 메서드, 구현(정의)는 하지 않고 선언만 한 메서드
목적 : 메서드의 내용이 너무 일반적인 내용이라 부모 클래스에서 구체화하여 정의할 필요가 없을 경우,
	 추상메서드로 선언만하고 상속받은 자식 클래스에서 재정의하도록 할 때 사용

추상클래스(abstract class)
정의 : - 한 개 이상의 추상메서드를 가지는 클래스
   - 일반적인 클래스는 세부적이고, 구체적 ex) 고양이과, 개과
   - 반면 추상클래스는 일반클래스에 비해 구체적이지 않고 추상적 ex) 고양이, 사자, 강아지
목적 : 추상메서드는 선언만되고 구현이 되지 않은 불완전한 메서드이므로 객체로 생성되어서는 안됩니다. 
   이런 클래스(추상메서드가 포함된 클래스)는 추상클래스로 선언하여 객체 생성을 금지시킵니다.

추상클래스는 반드시 하나 이상의 추상메서드를 가지며, 객체를 생성할 수 없습니다.
하지만 슈퍼클래스로 사용할 수는 있으며 추상메서드를 사용하기 위해서는 반드지 해당 메서드를 재정의 해야만 합니다.
추상클래스 또는 추상메서드를 선언하기 위해서는 이름 앞에 abstract를 추가하면 됩니다.

추상클래스 형식
abstract class 클래스명{
    추성메서드();
}

추상메서드 형식
abstract 접근제한자 반환타입 메서드명(매개변수){
     내용,,,
}

추상클래스와 추상메서드 예제
public class AbstractTest {
    public static void main(String[] args) {
        FirstCat fc = new FirstCat();
        SecondCat sc = new SecondCat();
        
        fc.call();
        sc.call();
    }
}//AbstractTest
 
abstract class Cat{ // 추상 메서드를 포함하므로 추상클래스로 선언
    abstract void call(); // 추상 메서드 선언(구현x)
    void call2(){
        System.out.println("일반 메서드");
    }
}
 
//Cat 추상클래스를 상속한 클래스들
class FirstCat extends Cat{
    void call(){ //추상메서드는 서브클래스에서 반드시 재정의 되어야 함
        System.out.println("첫번째 야옹이");
    }
}
 
class SecondCat extends Cat{
    void call(){
        System.out.println("두번째 야옹이");
    }
}

실행 결과 화면
첫번째 야용이
두번째 야용이

**
추상메서드를 재정의 하지 않을 경우 컴파일러는 에러를 발생시킵니다. 그러므로 추상메서드는 반드시 재정의 되어야합니다.
**
추상클래스는 해당 클래스를 통해 만들어낸 객체가 전혀 객체의 모습을 띄지 못할때, 해당클래스가 객체를 생성할 수 없도록 사용됩니다.

추상 : 무엇인가 덜 구체화된 것
객체 : 상태와 행동을 가진 것
클래스 : 객체를 만들기 위한 틀
초기화 : 클래스를 이용하여 객체 생성

인터페이스
 - 추상클래스와 비슷한 기능을 하지만 극단적인 경우이다.
 - 추상메서드와 상수로만 이루어져 있다.(=로직을 작성할 수 없음)
 - 다중 상속이 가능하다.
추가 설명

인터페이스 형식
interface 인터페이스명 [extends 상속받을 인터페이스명,,,,]{
    public abstract void 추상메서드명1();
    // public abstract 생략 가능
    void 추상메서드명2();
}

클래스가 인터페이스를 참조하게 될 경우 형식
class 클래스명 extends 상속받을클래스명 implements 인터페이스명{
    내용
}

인터페이스 구현 예제
interface catWorld{
    public void call();
}

public class InterfaceTest implements catWorld{
    
    public void call() { //오버라이드
        System.out.println("야옹야옹!");
    }
    
    public static void main(String[] args) {
        InterfaceTest it = new InterfaceTest();
        
        it.call();
    }
 
}

실행 결과 화면
야옹야옹

**
클래스에 인터페이스 상속 시 인터페이스 내에 정의된 모든 추상메서드를 구현(오버라이드) 해야만 정상적인 컴파일이 가능합니다.

인터페이스와 추상클래스의 공통점
 - 추상클래스와 인터페이스는 선언만 있고 구현 내용이 없다.
 - 그래서 자기 자신이 new를 통해 객체를 생성할 수 없으며, 상속받은 자식만이 객체를 생성할 수 있다.
 - 상속받은 자식이 구현을 반드시 하도록 해야할 때 사용한다.
 - JAVA에서는 type이 지정되있기 때문에 선언된 type과 자식의 type이 같아야만 한다.

인터페이스와 추상클래스의 차이점
인터페이스(Interface)									추상클래스(Abstract Class) 
구현 객체의 같은 동작을 보장하기 위함					추상클래스를 상속받아 기능을 이용하고, 확장시키기 위함 
다중 상속 가능											다중 상속 불가능 
추상메서드만 가능(abstract생략가능)						일반메서드+추상메서드 가능
-	자바 7 이전까지 인터페이스의 메소드는 
	추상 메소드로만 선언할 수 있었는데, 
	자바 8부터 디폴트 메소드�� 정적 메소드도 선언이 
	가능해졌다.
상수+추상메서드 형태									일반변수(가능)+일반메서드(가능)+추상메서드 형태 
생성자와 일반변수를 가질 수 없음						생성자와 일반변수 모두 가질 수 있음 
implments												extends 
메서드 선언만 가능										메서드의 부분적인 구현이 가능 

출처: https://private.tistory.com/20 [공부해서 남 주자]


18.	Unreachable code 에러
	예제1)과 같은 경우 C언어에서는 Warning 정도로 경고만 띠우지만 JAVA에서는 Unreachabel code Error를 띠워서 전체 실행조차 못하도록 한다.
	이에 예제2)와 같이 변경하면 JAVA에서도 Dead code 경고만 띠우게 되어서 전체 실행할 수 있도록 변경 됨

	예제1)
	int main(void)
	{
		return 1;

		return 0;			->	Unreachabel code Error 발생
	}
	예제2)
	int main(void)
	{
		if(true)
			return 1;

		return 0;			->	Dead code Warning 발생		
	}

18.	Java Garbage Collection
	
	Java는 프로그램 코드에서 메모리를 명시적으로 지정하여 해제하지 않는다. 가끔 명시적으로 해제하려고 해당 객체를 null로 지정하거나 System.gc() 메서드를 호출하는 개발자가 있다. 
	null로 지정하는 것은 큰 문제가 안 되지만, System.gc() 메서드를 호출하는 것은 시스템의 성능에 매우 큰 영향을 끼치므로 System.gc() 메서드는 절대로 사용하면 안 된다
	(다행히도 NHN에서 System.gc() 메서드를 호출하는 개발자를 보진 못했다).
	
	Java에서는 개발자가 프로그램 코드로 메모리를 명시적으로 해제하지 않기 때문에 가비지 컬렉터(Garbage Collector)가 더 이상 필요 없는 (쓰레기) 객체를 찾아 지우는 작업을 한다. 
	이 가비지 컬렉터는 두 가지 가설 하에 만들어졌다(사실 가설이라기보다는 가정 또는 전제 조건이라 표현하는 것이 맞다).
	
	?대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.
	?오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.
	이러한 가설을 'weak generational hypothesis'라 한다. 이 가설의 장점을 최대한 살리기 위해서 HotSpot VM에서는 크게 2개로 물리적 공간을 나누었다. 둘로 나눈 공간이 Young 영역과 Old 영역이다.
	
	?Young 영역(Yong Generation 영역): 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 
	이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
	?Old 영역(Old Generation 영역): 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 
	이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.

	Ex)	CDatabase cDatabase = new CDatabase(getContext());
		cDatabase.insertResult(iSum);
						
		cDatabase = null;
//		System.gc();					// 절대로 사용하면 안된다고 함(시스템 성능 저하)

	Summary
	- GC ( Garbage Collection ) 은 매우 heavy 한 작업이고, "우리가 기대하는 데로" 작동하지 않기 때문에 알아둘 필요가 있다.
	- GC는 C나 C++의 pointer, malloc, free 의 역할을 모두 담당해주는 녀석으로, new 를 통해 heap 메모리에 생성된 객체가
	 사용되지 않을 때 ( Strong reference 가 없을 때 ) 그 객체를 free 해준다.
	- GC에 대해 이해하기 위해서는 객체의 생성 주기를 알아야 한다.
	- 객체의 생성 주기 안에는 순환참조, Invisible, 재생, finalize 등의 매우 rare 하지만 반드시 고려하고 알아야 할 사항들이 있다.
	- GC는 만병통치약이 아니며 OutOfMemoryError 나 Performance degradation으로 이어질 수 있다.
	- 강제로 GC 를 부르는 행위는 암묵적으로 금지되어 있다.
	- GC를 이해하고 Memory 관리를 잘 하는 것은 Good Programmer 로서 반드시 갖춰야 할 덕목이다.


19.	Java에서의 소멸자
자바에서는 C++에서와 같이 소멸자를 만들 수는 없습니다. 다만 객체가 GC에 의해 메모리에서 해제 될 때 finalize() 메소드를 호출하도록 되어 있으므로 
객체가 메모리에서 해제 되기 직전에 무언가 “유언”이 필요하다면 이 부분에 어떤 작업 내용을 기술하면 됩니다.
(이건 닷넷의 경우도 거의 유사하니 이 부분은 C#의 “객체와 메모리” 강좌를 참고 하시기 바랍니다.)

아래의 예제를 참고 하세요~
public class Destructor {
        public void finalize() {
                System.out.println("객체의 마지막 유언... ");
        }
        
        public static void main(String[] args) {
                Destructor d = new Destructor();
                d = null;     //객체에 대한 참조를 끊어 가비지컬렉터에 의해 제거 대상이 되게 합니다.
                System.gc();  //가비지컬렉터를 호출 합니다.
        }
}

finalize는 반드시 호출된다는 보장이 없기 때문에 필수적인 로직을 넣으면 안 됩니다. 파일 스트림이나 디비 커넥션 등을 열었을 때는 명시적으로 닫아주는 것이 좋습니다. finalize()를 이용하면 안 됩니다.
그럼 finalize()는 모하는데 쓰느냐? 혹시나 하는 로직을 넣으면 됩니다. 디비를 열고 사용자가 혹시 안 닫았으면 닫는 로직정도죠.
if(!connection.isClosed()){
    connection.close();
}
위의 예제 정도가 적당하겠습니다.

finalize 메소드의 오버라이딩을 자제해야 하는 이유.
모든 자바 클래스의 최상위 부모클래스인 java.lang.Object 클래스에는 finalize() 메소드가 존재하며, Java API 에는 이 메소드는 '가비지 컬렉터가 레퍼런스를 잃은 클래스의 인스턴스를 가비지 컬렉션할 때 호출된다' 
라고 기술하고 있습니다. 
이 메소드는 객체인스턴스가 가비지 콜렉션에 의해 소멸되는 시점에 특정한 동작을 수행해야 할때도 요긴하게 사용할 수 있는 메소드입니다만 일반적인 경우 불필요하게 이 finalize() 메소드를 오버라이딩하는 것은 자제해야합니다.
이유는 'finalize 메소드에 의한 Collection 지연과 OOME(Out of Memory Exception)발생 가능성'때문입니다.
특정 Class에 finalize 메소드가 정의되어 있는 경우, 이 Class Type의 Object는 Garbage Collection 발생시 즉각적으로 Collection 되지 않습니다. 대신 Finalization Queue에 들어간 후 Finalizer에 의해 정리가 되는데요. 
Finalizer는 Object의 finalize 메소드를 실행한 후 메모리 정리 작업을 수행하게됩니다. 
만일 finalize 메소드를 수행하는데 오랜 시간이 걸린다면 그 만큼 객체가 오랫동안 메모리를 점유하게 되고 이로 인해 OOME가 발생할 확률이 높아집니다. 
이런 이유로 finalize 메소드는 되도록 사용하지 말아야 합니다.

하지만 finalize 메소드는 거의 사용되지 않음. Why? garbage collector가 실행시점이 불분명하기 때문에(garbage collector에 의해 finalize()가 호출됨) 
finalize() 메소드를 실행하더라도 그 때 finalize() 메소드가 실행된다는 보장이 없음(실행 시간 불확실). 
실제로 프로그램 수행 중 한번도 garbage collector가 수행되지 않을 수 있음.


[60]	Android(안드로이드)
1.	안드로이드 교육
	1)	안드로이드 교육 1일
<Android Application 개발환경 구축>
JDK 최신버전
Android SDK
eclipse 설치
Android용 eclipse plugin 설치

에뮬레이터 동작중 : adb shell(프로세스 관리)

emulator -avd my_avd 
         -show-kernel(리눅스 커널 메세지 show) 
         -ramdisk ramdisk.img(image path) 
         -system system.img(system path)
         -init-data userdata.img(initdata path)
-kernel ???(원하는 커널 이미지로 실행할수 있음)
 
QEmu : x86->x86,powerpc,mips(system emulator)
Android emulator는 QEmu 기반으로 만들어짐.

예제 프로그램 실행후
adb shell 실행시켜 /data/app 위치에 보면 실행된 예제프로그램이 있음.(apk)

프로그램 삭제
home/settings/Application/manager application/에서 삭제한다.

<전통적인 임베디드 리눅스 시스템 vs 안드로이드 시스템>
응용프로그램

(middle ware)그래픽시스템(QT, GTK+, ...) + 멀티미디어 + DB
C 라이브러리(glibc, uclibc, NewLib, ...)

커널+디바이스드라이버
부트로더
하드웨어

<Android 지원 Architecture>
ARMv5TE 이상
x86

<Virtual Machine>
Sun JVM, Microsoft CLR : Stack Machine
Android Dalvik VM : Register Machine

apk 파일 뒤에 zip 파일로 변환하면 내용을 볼수 있다.

<Android System Boot Flow>
Power on -> CPU reset 
         -> 부트로더(하드웨어 초기화(최소), 리눅스 커널&램디스크 메모리에 로드)
         -> 리눅스 커널(하드웨어 초기화, 시스템 초기화, 내부 자료구조 초기화, ...)
-> init(c로 만들어짐) 프로그램을 실행(ramdisk에 존재)($ pstree로 확인)
   (안드로이드는 최상위 디렉토리 '/' 는 램디스크에 존재함)
         (여기까지 전통적인 리눅스 부팅)
-> init(custom version) 프로그램을 실행
-> 설정 파일(/init.rc, /init.하드웨어명.rc)을 읽어들여서 처리한다.
   (내가 원하는 프로그램(c로작성된)을 백그라운드로 돌리고싶을때 위의 파일에서 실행시키면 됨)

<init.rc>
C:\punbear>adb pull /init.rc(init.rc 파일을 현재 디렉토리로 꺼냄)
init.rc의 내용은 리눅스 명령이 아님(ex.mount, chown, chmod, ...)

내용중 "## Daemon processes to be run by init." 아래 있는 순서대로 Daemon이 실행됨.
adb shell에서 ps 로 확인해보면 init의 PPID가 init으로 된 녀석을 찾아보면 Daemon이
실행된 순서되로 되어 있음.

Daemon이 critical로 되어있는 서비스는 동작중 멈추게되면 init(최상위서비스)에서 자동으로 재실행해준다.
(ex. ps에서 나온 process 중 /system/bin/servicemanager(critical) 를 kill 하게되면 실제로 
     emulator가 멈췄다가 재실행된다. 그후 ps로 확인하면 다시 살아있음.)

linux android source :  android-repo-dir/system/core/init/readme.txt 
위의 파일에 init.rc 파일 속성에 대한 설명이 있다.

<Android source>
*.mk 파일 (Makefile)

bootchart (최적화 툴) Android.mk 파일에서 bootchart부분 활성화 시켜서 컴파일하여
실행시키면 bootchart 폴더안에 파일이 생성됨. 이파일들을 tgz 압축하여 리눅스에서
bootchart 프로그램설치후 확인가능함.(sudo apt-get install bootchart)

	2)	안드로이드 교육 2일
1. system, data, sdcard(응용프로그램 개발이면 위의 3개 폴더에서 주로 작업함)

unique linux user ID(security)

Android component
(Activity, Service, Broadcast Receiver, Content provider)

Activity = Single Thread

Broadcast Receiver
1. System이 발생
2. Application이 발생(Send,Receiver 둘다 작성)

event 발생시 NotificationManager(폰 맨위의 타이틀바)에 표현가능.
 
Toast : 간단히 메세지 출력하기

BroadcastReceiver subclass(이벤트 발생시 한줄 출력하는 코드)
public void onReceive(Context context, Intent intent) {
	Toast.makeText(context, "SMS received!", Toast.LENGTH_SHORT).show();
}

Eclipse ShortKey
Ctrl+Shift+f : 코드 정리
Ctrl+m : 화면 최대화(code)
Ctrl+Shift+o : import 자동 해결
F2 : 파일이름변경

shift+F2(특정클래스이름에서) : 도움말 열림.

실행시 제대로 동작이 안될시 : permission 관련 문제일 경우가 많음.

ContentProvider데이터는 ContentResolver class로 접근 가능하다.

android:id="@+id/Button01  "+" 는 id를 추가한다라는 의미임.
(만약에 +가 없다면 기존의 존재하는 id값을 사용함)

Intent의 종류
- Explicit intent(대상 명확함) : 하나의 응용 프로그램 내부에서 
				자신의 Activity/Service/Receiver를 구동할때 사용.
- Implicit intent(대상 명확하지않음) :

디버그 메세지 출력 Log.d("test", "OnCreate called");
DDMS에서 LogCat 텝에서 확인가능함(filter를 사용하면 원하는 디버깅 메세지 쉽게 확인가능)

Home : Activity 종료되지않음.
Back : Activity 종료됨.

색상설정
code : 0xAARRGGBB
layout : #AARRGGBB

dip(dp) : density-independent pixel
          (Pixel이 다른 기기에서도 동일한 padding 값을 유지함)

	3)	안드로이드 교육 3일
Toast 사용자 임의 수정 가능함.(아래 파일 참조)
file:///C:/android/android-sdk-windows/docs/guide/topics/ui/notifiers/toasts.html
Toast 바로 표시하기!(??) 어떻게 할까요??

에뮬레이터에서 F6 : 트랙볼

다국어 관련 파일들 존재
C:\android\android-sdk-windows\platforms\android-7\data\res
mcc : Mobile Climate Control  ???
mnc : Media Nusantara Citra   ???
위의 둘다 지원함.
res 에 values/Language 추가(이때 기존의 values/strings.xml 파일과 이름이 동일해야함
로케일 변경하면 자동적으로 다국어 변환됨.

- anonymouse inner class(안드로이드에서 빈번하게 사용됨)
builder.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
@Override
public void onClick(DialogInterface dialog, int which) {				
}
});

<Thread>
Looper : 메시지 루프를 구동함
Handler : 메시지 큐에 메시지를 넣음. 메시지 큐에서 메시지를 꺼냄
Bundle class : key-value형태로 데이터를 관리하는 클래스
ex)
Message msg = thread.mHandler.obtainMessage(); (미리 만들어논 메시지가 
있다면사용되지 않는 object 리턴[최적화])
Bundle b = new Bundle();
b.putInt("total", total);
msg.setData(b);     // msg.getData().getInt("total");(가져오기)
thread.mHandler.sendMessage(msg);

Handler는 생성되는 위치에따라서 Parent의 thread와 결합하여 동작되게 된다.
(메시지큐 동일하게 사용함)

<Menu>
1. Option menu(Web browser의 옵션)
- Icon menu
- Expanded menu

  Menu버튼을 click했을때(Activity.onCreateOptionsMenu()) 자동호출
  메뉴가 최초에 open 될때 호출됨.
  source-override Implement methods... 에서 코드 ��동추가 가능함.

  menu추가 방법
  code : Menu.add() 
ex)       
menu.add(groupId, itemId, order, title)
menu.add(0, Menu.FIRST+1, 0, "Menu1");
menu.add(0, Menu.FIRST+2, 0, "Menu2");
(Menu.FIRST 는 Menu class에서 권장하는 초기 itemId 상수임.)
 
- Menu.add()는 MenuItem객체를 리턴하므로 MenuItem의 객체를 바로 수정가능하다.
ex)
 menu.add(0, MENU1, 0,"Menu1").setIcon(R.drawable.icon); (아이콘추가)
 menu.add(0, MENU1, 0, Menu1").setIcon(android.R.drawable.ic_btn_speak_now));
(android에 내장된 icon 객체를 바로사용할수 있음)
            
C:\android\android-sdk-windows\platforms\android-7\data\res\
drawable-mdpi 위치에서 확인가능함.

menu 수가 6개 이상일때는 화면을 많이 가려 불편할수 있으므로 5개까지 표시한후
More 버튼이 마지막에 표시되며, 나머지 6번째 이상부터 표시된다. 이때 아이콘은 표시되지 않는다.

MenuItem을 click했을때(Activity.onOptionsItemSelected()) 호출됨.

ex)
public boolean onOptionsItemSelected(MenuItem item) {
	switch(item.getItemId())
	{
	case MENU1:
Toast.makeText(this, "MENU1 Selected", Toast.LENGTH_SHORT).show();
		return true;
	case MENU2:
		...

  menu항목을 상황에 따라 바꾸고 싶을때.(Toggle button(ex.power on/off))
  메뉴가 열릴때마자 Activity.onPrepareOptionsMenu()자동으로 호출됨.

  ex)
public boolean onPrepareOptionsMenu(Menu menu) {
MenuItem item = menu.findItem(MENU2);
if (mPowerState)
{
	item.setTitle("Power On");
}
else
{
	item.setTitle("Power Off");	
}

* onOptionsItemSelected()에서 선택했을때 바로 text를 바꿀수도 있지만.
  일반적으로는 선택후 다음에 메뉴가 보여질때(onPrepareOptionsMenu()) 에서
  text를 변경함.

 - XML -
menu.xml 파일을 생성한후 코드에서 아래와 같이 추가한다.
public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.options_menu, menu);
		return super.onCreateOptionsMenu(menu);
	}

XML 에서 resource 참조 방법(Layout)

ex) for XML
android resource : @android:drawable/ic_dialog_email 
   (android.R.drawable 에있는 기본 아이콘중하나)
user resource : @string/menu2 

2. Context menu(mouse long click)
- long clicked시 Activity.onCreateContextMenu()가 호출된다.
  (누르는 위치에따라 동작이 다르며, Avtivity.registerForContextMenu()를 해주어야 동작이됨.)
   각 component들은 id값을 가지고 있어야한다.
   ContextMenu에서 setIcon은 적용되지 않는다.
   
3. Submenu
- 다른 메뉴들과 같이 사용된다. 하위계층.
  Parent의 callback function onOptionsItemSelected()/ onContextItemSelected()에서 
  같이 처리됨. Parent의 menuID와 중복되면 안된다.

ex)
SubMenu subMenu = menu.addSubMenu("MENU3");
subMenu.add(0, SUBMENU1, 0, "SUB Menu1");
subMenu.add(0, SUBMENU2, 0, "SUB Menu2");
subMenu.add(0, SUBMENU3, 0, "SUB Menu3");

?<Dialog>

- AlertDialog (Ok,Cancel 같이 항목들중 한가지 선택가능하도록)
AlertDialog는 back 버튼 동작되지 않는다.
(AlertDialog.Builder.setCancelable(true) 하면 가능함)
ex)
protected Dialog onCreateDialog(int id) {
		switch(id)
		{
		case DIALOG1:
		{
			AlertDialog.Builder builder = new AlertDialog.Builder(this);
			builder.setMessage("Are you sure you want to exit?");
			builder.setCancelable(false);
			builder.setPositiveButton("Yes",
					new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int id) {
	  				DialogTest.this.finish();
					}
					});
			builder.setNegativeButton("No",
					new DialogInterface.OnClickListener() {
						public void onClick(DialogInterface dialog,int id) {
							dialog.cancel();
						}
					});
			AlertDialog alert = builder.create();
			return alert;
		}
    case DIALOG2:
    {
 	    final CharSequence[] items = { "Red", "Green", "Blue" };
            AlertDialog.Builder builder = new AlertDialog.Builder(this);
	    builder.setTitle("Pick a color");
	    builder.setItems(items, new DialogInterface.OnClickListener() {
	      public void onClick(DialogInterface dialog, int item) {
Toast.makeText(getApplicationContext(), items[item],
			Toast.LENGTH_SHORT).show();
	    	}
	    });
	    AlertDialog alert = builder.create();
	    return alert;
     }
     case DIALOG3:
    {
             final CharSequence[] items = { "Red", "Green", "Blue" };
	     AlertDialog.Builder builder = new AlertDialog.Builder(this);
	     builder.setTitle("Pick a color");
	     builder.setSingleChoiceItems(items, -1,
	     new DialogInterface.OnClickListener() {
		public void onClick(DialogInterface dialog, int item) {
Toast.makeText(getApplicationContext(), items[item],              Toast.LENGTH_SHORT).show();
				}
		});
		AlertDialog alert = builder.create();
		return alert
    }

 setPositiveButton : 긍정의미의 버튼
 setNeutralButton : 중립의미의 버튼
 setNegativeButton : 부정의미의 버튼
 (위의 3버튼들을 사용자 임의로 설정할수 있다.)

- ProgressDialog(진행사항표시)
setProgressStyle(ProgressDialog.STYLE_HORIZONTAL) 일반적인 퍼센트 표시
setProgressStyle(ProgressDialog.STYLE_SPINNER) 끝나는 시점을 예측하기 힘들때 사용됨.

- DatePickerDialog(날짜)
- TimePickerDialog(시간)
file:///C:/android/android-sdk-windows/docs/resources/tutorials/views/index.html 참조

- CustomDialog(user create)

Activity.showDialog(int) 로 Dialog가 보여진다.
showDialog() 호출시 최초 Dialog가 생성될때 
Activity.onCreateDialog(int) 가 자동으로 호출된다.
onCreateDialog()에서 생성된 Dialog 객체를 return 해준다.

Activity.onPrepareDialog(int, Dialog) Dialog가 display 되기전에 호출된다.

Dialog 종료하기 
1. Dialog.dismiss(), Activity.dismissDialog(int) (화면에 보여지지만 않음)
2. Activity.removeDialog(int) 완전히 삭제 소멸

<Handling UI Events>
- Event listener : 일반적인 button clicked 같은 이벤트 listener
- Event handler : 클래스를 확장하여 기능을 변경함.
                        (트랙볼같은경우는 handler에서 처리해야 자세한 정보를얻을수있다.)

ll.setFocusable(true) : focus상태에서만 key를 입력을 받는다.
ll.setFocusableInTouchMode(true);   : 터치모드에서도 key 입력을 받는다.

onKey()에서 return true는 onKey()에서 처리가 완료되었으므로 더이상
parent()로 이벤트 전달하지 않는다.

onTouch()에서 return true/false 차이점.
최초의 터치 이벤트를 처리안했다고 하면(return false) 그 이후에 마우스 이동시
이벤트가 발생이안된다.즉 Android에서는 처음 Touch 이벤트 처리가 안되면, 
그다음은 의미가 없다고 생각함. return false 를 하면 후속 이벤트 발생안됨.

	4)	안드로이드 교육 4일
- Focus
View.dispatchKeyEvent() : focus를 붙잡아서 처리할수 있다.

UI 이벤트 발생
-> Activity(dispatch~로 시작되는 method 호출)
-> View(호출)
-> Activity(on~로 시작되는 method 호출)

Android에서는 기본적으로 Focus 처리를 합리적으로 처리되게끔
되어 있으나, Focus 처리를 바꾸고 싶다면, 아래 XML속성으로 쉽게
변경할수 있다.
(nextFocusLeft, nextFocusRight, nextFocusUp, nextFocusDown)
ex)
<LinearLayout android:orientation="vertical" ... >
<Button android:id="@+id/top" android:nextFocusUp="@+id/bottom" ... />
<Button android:id="@+id/bottom" android:nextFocusDown="@+id/top" ... />
</LinearLayout>

View.requestFocus() ( = setFocus() ) 강제 포커스

<Intent>
대상이 명확할때는 intent filter가 필요없다(Explicit intent)
대상이 명확하지 않을때는 intent filter가 필요함(Implicit intent)

<Notification>
- Toast
- Status bar notification(맨위에 Title bar)
주로 Service(화면에 보이지 않는)에서 사용됨.

1. Get a reference to the NotificationManager.
String ns = Context.NOTIFICATION_SERVICE;
NotificationManager mNotificationManager =(NotificationManager)getSystemService(ns);

2.  Instantiate the Notification.
int icon = R.drawable.notification_icon;      // icon
CharSequence tickerText = "Hello";           // text
long when = System.currentTimeMillis();   // msg 발생 시간
Notification notification = new Notification(icon, tickerText, when);
notification.flags |= notification.FLAG_AUTO_CANCEL; <= 확인하면 위에
아이콘이 자동으로 사라짐!!!!

3. Define the Notification's expanded message and Intent.(이벤츠를 펼칠때)
Context context = getApplicationContext();
CharSequence contentTitle = "My notification";
CharSequence contentText = "Hello World!";
Intent notificationIntent = new Intent(this, MyClass.class);
PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
notification.setLatestEventInfo(context, contentTitle, contentText, contentIntent);

4 Pass the Notification to the NotificationManager.
private static final int HELLO_ID = 1;
mNotificationManager.notify(HELLO_ID, notification);

- Dialog notification

<AdapterView>

배열을 resource로 만들기.
contact의 데이터를 접근하려면 permission이 필요하다.
AndroidManifest.xml에서 uses-permission(android.permission.READ_CONTACTS)
을 추가한다.

Adapter는 데이터만이 아닌 +@(항목에 사용될 View)도 설정이 가능하다.
- ArrayAdapter : 배열 객체
ex)
Spinner s1 = (Spinner)findViewById(R.id.spinner1);
ArrayAdapter<?> adapter = ArrayAdapter.createFromResource(
this, R.array.colors, android.R.layout.simple_spinner_item);
adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
s1.setAdapter(adapter);
final String[] arr = getResources().getStringArray(R.array.colors); 
s1.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
@Override
public void onItemSelected(AdapterView<?> parent, View view,
		int position, long id) {
	Toast.makeText(SpinnerTest.this, arr[position] + " 선택됨",
			Toast.LENGTH_SHORT).show();
}
@Override
public void onNothingSelected(AdapterView<?> parent) {
}
});
 
resource data를 code level에서 접근하기
final String[] arr = getResources().getStringArray(R.array.colors);  

- SimpleCursorAdapter : database 데이터(Content Provider)
ex)
String[] PROJECTION = new String[] { People._ID, People.NAME };
Spinner s2 = (Spinner) findViewById(R.id.Spinner02);
Cursor cur = managedQuery(People.CONTENT_URI, PROJECTION, null, null, null);
SimpleCursorAdapter adapter2 = new SimpleCursorAdapter(this,
			android.R.layout.simple_spinner_item, cur,
			new String[] { People.NAME }, new int[] { android.R.id.text1 });
adapter2.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
		s2.setAdapter(adapter2);


Contect Provider에 접근할때 URI로써 접근한다.
Avtivity.managedQuery() 통해서 가져옴.(Cursor 리턴)
항목선택에대한 처리는 AdapterView에서 처리한다.

<Data Storage>
각 응용프로그램의 데이터는 공유되지 않는다.
(단. Content provider를 통해서 접근 가능하다.)

- Preferences

 어플리케이션 데이터를 간단하게 저장(XML로저장된 파일)
DDMS-File Exporer-data-data-package 이름-shared_prefs 에 파일 존재함.

ex)
@Override protected void onPause() {
		super.onPause();
		// SharedPreferences setting =getPreferences(MODE_PRIVATE);
		SharedPreferences setting = getSharedPreferences("mysetting", MODE_PRIVATE);
		Editor editor = setting.edit();
		editor.putString("mytext", edit.getText().toString());
		editor.commit();
	}


@Override protected void onResume() {
		super.onResume();
		// SharedPreferences setting =getPreferences(MODE_PRIVATE);
		SharedPreferences setting = getSharedPreferences("mysetting", MODE_PRIVATE);
		edit.setText(setting.getString("mytext", ""));
	}

getPreferences() : 같은 응용프로그램내에서 다른 Activiry 접근 불가능.
getSharedPreferences() : 내응용프로그램내의 다른 Avtivity 들 간의 데이터 접근.

MODE_PRIVATE : 나혼자 사용하겠음. (-rw-rw---) 소유자:그룹:기타
MODE_WORLD_READABLE : 공유할수는 있지만 파일의 위치를 알아야하므로 비추

edit() 과 commit() 사이에 저장한다.

settings값들을 저장하기에 적합하다.

- Files
ex)
FileOutputStream out = null;
FileInputStream in = null;

try {
	if (v == btnWrite) {
		try {
			out = openFileOutput("mydata.txt", MODE_PRIVATE);
			out.write(text.getText().toString().getBytes());
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
	else if (v == btnRead) {
		try {
			in = openFileInput("mydata.txt");
			text.setText("");
			final int length = 256;
			byte[] buf = new byte[length];
			int n;
			String str;
			while ((n = in.read(buf, 0, length)) != -1) {
				str = new String(buf, 0, n);
				text.append(str);
			}
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
}
finally {
	try {
		if (out != null)
			out.close();
		if (in != null)
			in.close();
	}
	catch (IOException e) {
		e.printStackTrace();
	}
}

openFileOutput() openFileInput() , 이름에는 Path sperator는 추가될수 없다.
(즉 "/sdcard/mytext.txt" 로 파일을 열수 없다.) 
아래와 같이 FileOutputStream constructor로서 path를 포함하여 파일을 열수 있다.
ex)
out = new FileOutputStream("/sdcard/mydata.txt");
in = new FileInputStream("/sdcard/mydata.txt");
(Java에서는 permission 개념이 없으므로 위의 Java class로 파일을 오픈하면,
 권한이 rw로 되어 있다.)

- Databases
SQLite3 명령어 : 따로 공부 필요함.
.schema : 테이블의 상태를 알수 있음.
.databases : 모든 테이블 보여줌
...

데이터베이스를 사용하고 싶다면.
1. SQLiteOpenHelper을 subclass 해서 몇가지 Method를 재정의한다.
ex)
private static class MyDatabaseHelper extends SQLiteOpenHelper {
	@Override
	public void onCreate(SQLiteDatabase db) {
		// TODO Auto-generated method stub
		//DB 생성시
	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
		// TODO Auto-generated method stub
		//DB 업데이트시 수정 작업을 도와줌
	}
	// 초기생성자의 매개변수는 사용자 임의로 변경가능하다.
	public MyDatabaseHelper(Context context, String name,
			CursorFactory factory, int version) {
		super(context, name, factory, version);
		// TODO Auto-generated constructor stub
	}
}

SQLiteDatabase mDb = mDbHelper.getWritableDatabase(); // 실제 데이터베이스 생성

데이터 추가
ex)
ContentValues initialValues = new ContentValues();
initialValues.put(KEY_TITLE, title);
initialValues.put(KEY_BODY, body);
mDb.insert(DATABASE_TABLE, null, initialValues);

데이터 삭제
ex)
mDb.delete(DATABASE_TABLE, KEY_ROWID + "=" + rowId, null) > 0;  
 
데이터 가져오기
ex)
mDb.query(DATABASE_TABLE, new String[] 
{KEY_ROWID, KEY_TITLE, KEY_BODY}, null, null, null, null, null);

데이터 업데이트
ex)
ContentValues args = new ContentValues();
args.put(KEY_TITLE, title);
args.put(KEY_BODY, body);
mDb.update(DATABASE_TABLE, args, KEY_ROWID + "=" + rowId, null) > 0;

Notepad Tutorial 참조.

- Content Providers

데이터 공유 할수 있는 공식적인(표준적) 방법이다.

두가지 방법
1. 기존의 Content provider를 추가한다.
2. 새로운 Content provider를 생성한다.

Content provider는 단순한 테이블로 구성되어 있다.(공식적으로 id는 _ID로 되어 있다.)
Cursor를 통해서 record를 이동하여 참조할수 있다.

Database의 접근은 URI를 통해서 접근한다.(문자열. "content://"로 시작됨.)
(즉 DB정보를 몰라도 하나의 주소형태로 접근가능하다)

Android에서 기본적으로 제공하는 URI
android.provider.Contacts.Phones.CONTENT_URI
android.provider.Contacts.Photos.CONTENT_URI
android.provider.CallLog.Calls.CONTENT_URI
...

질의 방법에는 두가지가 있는데,ContentResolver.query(), Activity.managedQuery() 
Activity는 Cursor(resource)를 life cycle에 의해서 리소스 할당 해제가 자동으로 
관리되므로 Activity.managedQuery()를 주로 사용한다.
Activity.startManagingCursor(Cursor c);

실제 마지막 데이터에 접근하려면 id값이 추가로 필요한다.
ContentUris.withAppendedId(), Uri.withAppendedPath() 통해서 추가하여 URI로
사용된다.
public static Uri withAppendedId(Uri contentUri, long id)
public static Uri withAppendedPath(Uri baseUri, String pathSegment)

ex)
Uri myPerson = ContentUris.withAppendedId(People.CONTENT_URI, 23);
// id가 23인 people에 접근하는 URI
Cursor cur = managedQuery(myPerson, null, null, null, null);
// cur는 단 특정 id(23)을 지정하였으므로 하나의 내용만 가지고 있다.

ex) content 접근 예제(주의 permission 필요함 android.permission.READ_CONTACTS)
String[] projection = new String[] { People._ID, People.NAME, People.NUMBER };
// Get the base URI for the People table in the Contacts content
// provider.
Uri contacts = People.CONTENT_URI;
// Make the query.(오름차순)
Cursor managedCursor = managedQuery(contacts, projection, null,
						null, People.NAME + " ASC");
getColumnData(managedCursor);

...

private void getColumnData(Cursor cur){
	if (cur.moveToFirst()) {  // cursor의 맨앞으로
		String name;
		String phoneNumber;
		int nameColumn = cur.getColumnIndex(People.NAME);
		int phoneColumn = cur.getColumnIndex(People.NUMBER);
		do {
			// Get the field values
			name = cur.getString(nameColumn);
			phoneNumber = cur.getString(phoneColumn);
			// Do something with the values.
			Log.d("test", "name="+name+", phone="+phoneNumber);
...
		} while (cur.moveToNext());
	}
}

Cursor는 가져온 데이터를 출력용으로 사용하고,
Data수정은 ContentResolver() 통해서 수정가능하다.

ex) data 수정
ContentValues values = new ContentValues(); // DB에 추가할때 사용됨.
// Add Abraham Lincoln to contacts and make him a favorite.
values.put(People.NAME, "Punbear");
// 1 = the new contact is added to favorites
// 0 = the new contact is not added to favorites
values.put(People.STARRED, 1);  // 즐겨찾기 추가
Uri uri = getContentResolver().insert(People.CONTENT_URI, values);
// 리턴되는 uri는 추가된 데이터의 URI

ex) data 추가(위의 코드와 연결됨)
Uri phoneUri = null;
Uri emailUri = null;
phoneUri = Uri.withAppendedPath(uri, People.Phones.CONTENT_DIRECTORY);
values.clear();
values.put(People.Phones.TYPE, People.Phones.TYPE_MOBILE);
values.put(People.Phones.NUMBER, "01047150000");
getContentResolver().insert(phoneUri, values);
// Now add an email address in the same way.
emailUri = Uri.withAppendedPath(uri, People.ContactMethods.CONTENT_DIRECTORY);
values.clear();
// ContactMethods.KIND is used to distinguish different kinds of
// contact methods, such as email, IM, etc.
values.put(People.ContactMethods.KIND, Contacts.KIND_EMAIL);
values.put(People.ContactMethods.DATA, "punbear@gmail.com");
values.put(People.ContactMethods.TYPE, People.ContactMethods.TYPE_HOME);
getContentResolver().insert(emailUri, values);

Provider 종류 아래 URL 참조
file:///C:/android/android-sdk-windows/docs/reference/android/provider/package-summary.html

Contacts : 연락처(1.6 버전 이하)
ContactsContract : 연락처(2.0 버전 이상)
MediaStore : 미디어관련
...

1.6까지는 web과 1개만 sync 되었었는데 2.0(API Level 5) 로 와서는 3개까지 지원됨.
실제로 전화기 관련 app 개발시 ContactsContract 를 통해서 작업해야함. Contact 는 참고!!

- NDK란??
NDK : Java에서 C code를 결합하는거 ?
NDK를 사용하는 주요이유는 기존에 사용하는 c코드 및 리눅스 레벨에서 사용되는 코드를
그대로 사용하기 위해서, OpenGL, Android 게임 프로그래밍등등..
JNI(C code Interfaces)
1. Java에서 C code를 사용할 수 있는 구성 요소로 사용
2. JAVA에서는 Device단을 직접적으로 제어하지 못하기 때문에 본 NDK를
   중간 단계로 사용해서 제어 함


- Binder
- Service 
- AIDL(Android Interface Definition Language) (Java 문법 아님) 기법. 아래 URL 참조
   file:///C:/android/android-sdk-windows/docs/guide/developing/tools/aidl.html 

Font는 res가 아닌 assets 폴더 안에다가 넣는다(자동화 되지 않음)
ex) Fontset
Typeface typeface = Typeface.createFromAsset(getContext(), getAssets(), "gulim.ttf");
setTypeface(typeface);

- 이클립스 단축키
F4 : class Hierarchy를 볼수 있음.

	1)	Android Vitual Device Manager 설정
		가)	Device Definitions
			a)	New Device -> Resolution : 800 x 480, RAM : 512
		나)	Android Vitual Devices
			a)	Device : 800x480, Target : Android 2.3.3 - API Level 10
			b)	Memory Options : RAM : 450, VM Heap : 32
			c)	Internal Storage : 50, SD Card : 10
			d)	Emulation Options : [v]Use Host GPU
			e)	Start -> [v]Wipe user data

	2)	안드로이드 개발환경 구축에 대해 질문 합니다~앨리스
http://www.androidpub.com/1804422010.03.08 10:22:57 18773기타 질문안녕하세요.
안드로이드를 이제 막 시작하려고 하는데요..
어디부터 해야하는지 막막합니다.
우선 제가 여기저기 사이트에서 본 것들을 바탕으로 제가 알고 있는것이 맞는지..
중요한 것을 빠뜨린것은 없는지.. 또 몇가지 궁금한 사항들에 대해 여쭤보고 싶습니다.
질문이 넘 많아 죄송합니다. ㅠㅠ

1. OS: 리눅스만을 사용해야 한다.
2. 어플리케이션 개발환경: JAVA JDK + Eclipse + Android SDK
3. NDK: 자바가 아닌 c, c++로 개발할 수 있도록 해준다. 
     => 이런경우, OS만 리눅스 환경에서 만들고, 어플단은 윈도우 환경에서 NDK를 이용, cygwin에서 컴파일 하면 되는것인가요?
           호환성에 좀 문제가 될 수 있다고 들었는데, 실제로 이렇게 개발해서 출시된 제품들이 있는지 궁금합니다.
4. 필요한 요소들은...
    자바로 했을때:  리눅스, Java jdk, eclipse, android sdk 만 있으면 개발 요소는 모두 갖춘것인가요?
    C, C++로 했을때: 리눅스, ndk, cygwin 만 있으면 개발 요소는 모두 갖춘것인가요?
5. 위의 개발요소들 중에 라이센스 해야하는.. 비용을 지불해야하는 것들은 어떤것이고, 가격은 어느정도 인지요?
6. 어플리케이션 개발을 위한 훌륭한 책 2~3권 추천 좀 해주세요. (자바 초보자 입니다.)

	3)	.apk 관련
		가)	linux /data/app folder에 저장됨
		나)	apk파일 자체는 user 앱일 경우 /data/app  시스템앱일경우 /system/app 에 존재하며
			dex파일은 /data/dalvik-cahce 에 존재한다는것을 확인했습니다.
			또한 각종 앱 데이터파일들, DB나 .so파일들은 /data/data/<appname>에 존재하더라고요
		다) 해당 앱 종료
			eclipse(ADT) -> Window -> Open Perspective -> DDMS
			에서 해당 앱 STOP 시킴
##		라)	.apk Target board에 intall 하는 방법
			1)	*.apk file download
			2)	윈도우 cmd창에서
				adb intall *.apk 실행		->	*.apk 파일이 target board에 intall 됨				
##		마)	.apk 수동실행방법(터미널 창에서 실행)
			am(Activity Manager)를 사용해서 실행시키면 된다.
			ex)
			1)	/# cd /data/app
			2)	data/app # am start -a android.intent.action.MAIN -n ch.serverbox.android.usbcontroller2/.UsbControllerActivity
				cf)	ch.serverbox.android.usbcontroller2	->	package
					UsbControllerActivity				->	activity class
			
			
	4)	안드로이드 액티비티 스택 확인하기
		->	어떤 액티비티가 살아 있는지 확인용이며, Cygwin Terminal 에서 하기 명령 실행
가)	방법1
adb shell dumpsys activity
->	매우 긴 영문들이 뒤섞여 보인다. 
	처음에는 매우 난감했지만, Activity를 이래저래 띄우면서 테스트 한 결과에 의하면,
	"Activity Stack"과 "Running Activities" 부분을 보면 된다.

	"Activity Stack"에는 스택 순서대로 Hist #2, Hist #1, Hist #0 순으로 표기되어 있다.
	즉, 단말기의 [이전]버튼을 누르면 ActivityA가 닫히고, 한 번 더 누르면 MainActivity가 닫힌다.

	작업하는 중간중간에 다시 실행시켜보면, 정확히 화면에 보이는 Activity가 "Activity Stack" 로그의 최상위에 보여지게 된다.

	Hist #0는 보통 안드로이드 런처(홈) Activity이다.
		
나)	방법2
좀더 간략하게 보기
adb shell dumpsys activity activities

다)	방법3
아래 명령어로 치면 기타 정보 다 빼고 간략하게 볼수 있다.
Run #0  이런식으로 숫자가 붙어있다.
adb shell dumpsys activity activities | grep -i run

라)	참고
그외 기타 정보 dumpsys 로 알아 보기
커맨드 창에 아래와 같이 입력하면 자세한 정보를 알수 있다.
adb shell dumpsys

dumpsys는 안드로이드 폰의 어플리케이션 및 현재 기기의 상태에 대한 자세한 정보를 제공한다.
(소스코드 위치: ./frameworks/base/cmds/dumpsys/dumpsys.cpp)
http://developer.android.com/tools/help/adb.html

adb shell dumpsys meminfo: 메모리 사용 정보를 표시
adb shell dumpsys cpuinfo: CPU 프로세서 사용 정보를 표시
adb shell dumpsys account: 모든 계정에 대한 정보를 표시
adb shell dumpsys activity: Activity에 대한 정보를 표시
adb shell dumpsys window: 키보드와 윈도우, 그리고 그들의 z order에 대한 정보를 표시
adb shell dumpsys wifi: 접속 가능한 액세스 포인트와 현재의 연결 상태를 표시
adb shell dumpsys power: 전원 관리와 관련된 정보(wakelock, screen off time 등)를 표시

	4+1)다른 액티비티로 이동한 이후 기존에 있던 액티비티는 종료하는 방법
액티비티를 띄운 후 2초 후에 다음 액티비티로 이동시키는 .java 소스이다.

import android.app.Activity;
import android.content.Intent; //Intent 사용에 필요
import android.os.Bundle; 
import android.os.Handler; //핸들러 사용에 필요
import android.view.Menu;

public class MainActivity extends Activity
{
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
	 
		Handler timer = new Handler();	//Handler 생성
	 
		timer.postDelayed(new Runnable()
		{ 								//2초후 쓰레드를 생성하는 postDelayed 메소드
			public void run()
			{
				//intent 생성
				Intent intent = new Intent(MainActivity.this, NFC_WAIT.class); 
				startActivity(intent); //다음 액티비티 이동
				finish(); // 이 액티비티를 종료
			}
		}, 2000); //2000은 2초를 의미한다.
	}
 
	@Override
	public boolean onCreateOptionsMenu(Menu menu)
	{
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.main, menu);
		return true
	}
}

	4+2)기본 Class 소스를 보고 싶을 때
		가)	Class File Editor - Source not found 에러 발생
		나)	Change Attached Source... 버튼 누름
		다)	External File... 버튼 누름 -> C:\Program Files\Java\jdk1.8.0\src.zip 선택
		cf)	하지만 이렇게 해도 src.zip 파일에 포함된 java/lang/String.java 등의 class만 볼 수 있다
		cf)	src.zip 파일에 포함되지 않은 Edit.java 등은 볼 수 없음	

	5)	Android 명령어(안드로이드/자바/Java)
		1-1)자바 공부하기 위한 중요 사이트
			가)	자바문법
				http://www.javanuri.com/edu/jp01/index.html
			나)	Java API  ->  자바 API 찾기 -> 하기 사이트 -> 오른쪽상단 -> Index -> 해당 method의 머리글자 선택 -> Ctrl+F -> 해당 method 찾기
				ex) println 같은 경우는 java.io가 package이고 PrintStream이 class이며 println이 method인 것임
				http://docs.oracle.com/javase/6/docs/api/
			다)	자바 예제 소스 제공(다른 곳 헤매지 말고 이곳에서 자바 예제 소스를 찾자) -> Java tutorial
				http://www.java2s.com/Tutorial/Java/CatalogJava.htm
			라)	안드로이드 예제 import
				File->New-> Other -> Android Sample Project -> version 선택 -> API Demo

		1)	setContentView
			가)	XML 문서의 리소스 ID를 전달받아 이 정보대로 객체를 생성하여 액티비티 내부에 채운다.
			나)	xml문서의 레이아웃은 뷰를 담는 컨테이너 역할을 하는 부분으로 그 내부에 실제 화면에 나타날 View 객체들의 목록과 구조,
				속성들이 정의되어있다. 이러한 xml문서를 실제 안드로이드 프로그램이 실행될 때 메모리에 올리는 과정은 ADT에 포함된 aapt(Android Asset Packaging Tool)에 의해 수행된다.
				바로 이러한 수행을 하도록 코드상에 존재하는  메소드가 setContentView() 인 것이다. 이러한 동작을 Inflation(전개)이라고 한다. 

		2)	팁 #1 - 외부 java class 에서 main activity 의 콘트롤 findViewById를 사용
			http://www.androidpub.com/4282032010.06.09 22:25:26 65373강좌처음 팁을 쓰게 되네요.
			안녕하세요, 안떠니 라고 합니다.
			류종택 님의 동영상 강좌와 김상형 님의 책을 참고하고.
			나머지는 구글링과 여기 질답 게시판을 참고하면서 앱을 만들고 있습니다.

			그중에 제일 먼저 부딪히게 된 것이, 바로 클래스를 디자인하고 클래스를 선언까지는 했는데요. 
			클래스에서 main 에 있는 콘트롤을 접근하기 위해 findViewById 쓰는데 문제가 발생한 것입니다.
			코드 하나 하나는 다른 분이 댓글로 달아주시면 감사하겠습니다.
			
			자 메인 코드는 다음과 같습니다. main.xml 에 txtSound 라는 EditText 콘트롤이 있다고 가정합니다.
			package SoundExam.Android;
			import android.app.Activity; 
			import android.os.Bundle; 
			import android.view.View; 
			import android.widget.Button;
			
			public class SoundExamActivity extends Activity
			{ 
				/** Called when the activity is first created. */
				@Override
				public void onCreate(Bundle savedInstanceState)
				{ 
					super.onCreate(savedInstanceState); 
					setContentView(R.layout.main);
					SoundExam.InitExam(this); 
				}  
			}

			그리고 여기서 참조하는 SoundExam 클래스는 다음과 같습니다.
			package SoundExam.Android;
			public class SoundExam
			{ 
				static Context mMain;
			
				public static void InitExam(Context main)
				{ 
					mMain = main;
				}
			
				public static void NextSound()
				{
					((EditText) ((Activity) mMain).findViewById(R.id.txtSound)).setText("Downloaded!"); 
				} 
			}
			
			코드만 보면 대충 아실껍니다
		
		2+1)R.java error
			resource file 이름은 반드시 영어 소문자, 숫자, 언더바, 점(.), 이렇게 네가지만을  사용해서 이름을 정해야 함(대문자 사용 불가)
			그렇지 않으면 하기와 같은 에러 발생 함
			res\layout\Main.xml: Invalid file name: must contain only [a-z0-9_.]

		3)	현재 Activity 나  Context를 넘기고 받는 방법
			가)	Activity 는
				Activity act;
    			act = 현재클래스명.this;
			나)	Context 는
				Context mContext;
				mContext =  getApplicationContext();
			cf)	Activity와 Context 는 비슷해 보이면서도 다릅니다. 저도 아직 두 가지 명확하게 설명을 할 
				수준은 못되지만, 명확한 개념을 알고싶으시면 조금만 수고를 하셔서 검색을 하시면
				다른 훌륭하신분들의 글이 많이 올라와 있습니다. 

				먼저 Activity 는 안드로이드 어플리케이션의 가장 기본적인 블록으로 전체적으로 한 화면 이라고
				보시면 됩니다. 한 화면의 View와 UI 를 뿌리고 관리하며 터치 등 사용자의 입력을 감지합니다.

				한 화면이기 때문에 다음 화면으로 넘어가면 거기서 새로운 액티비티가 생성되고 관리하게 됩니다. 
				반면 Context는 핵심 부품같은 존재로 여러 액티비티의 리소스를 접근하거나 공유할 수 있게 
				해줍니다. 설명이 많이 부족하네요 이거 -_-.. 

				현재 Activity와 Context를 얻어서 사용해야 할 때가 있습니다. 다이얼로그나 팝업등을 띄울 때인데요
				팝업을 예로들면 어느 앱에 로그인을 하려는데 그 로그인창이 팝업창으로 되어 있다면 컴퓨터는
				멍청해서 알아서 메인화면 위로 로그인창을 띄우지 못하고 코드상으로 꼭 메인화면 위에서 띄워라 라고 써줘야 합니다. 

				View.getContext()
				-	자신의 Context가 아닌 다른 Context를 access 하려 할때 사용함. 
					ContextWrapper 는 getBasecontext()를 경유해서 Context를 참조할 수 있다. 
				-	현재 실행되고 있는 View의 Context를 return하는데 보통은 현재 활성화 된 Activity의 Context가 사용된다.
				
				Activity는 Context interface를 상속받아 구현된다.
				즉, Activity는 Context 중 하나이다.
				Context는 특정 컴포넌트와 안드로이드 시스템과의 통로라고 할 수 있다.
				
				이러한 Context를 얻어오는 메서드는 크게 3가지가 존재한다.
				
				첫 번째로 View.getContext() 형태이다.
				현재 활성화되어 있는 View의 Context를 얻을 때 사용된다.
				해당 클래스 내에서 this로도 참조가 가능하다.
				
				두 번째로 ContextWrapper.getBaseContext() 형태이다.
				다른Activity의 Context에 접근할 때 사용된다.
				
				세 번째로 Activity.getApplicationContext() 형태이다.
				Application 자체 즉, 서비스의 Context를 얻을 수 있다.
				
				getApplicationContext()보다 getBaseContext()를 빈번히 사용하는 이유는 
				메모리 유지 때문이다.
				
				getApplicationContext는 Global Application Context로써 앱이 종료 후에도 
				한동안 메모리상에 남아있기 때문이다.
				
				반면에 getBaseContext는 앱이 종료됨과 동시에 메모리에서 unload된다.
				
				안녕하세요 UnlimitedJava입니다.
				Context가 뭔지 이해하기가 어려웠습니다(다른 분들도 이거 개념잡는걸 어려워 하는거 같아보였습니다...아닌가...).
				Context의 개념에 대해서 질문이 있길래 답변하다가 나름대로 정리되서 여기에 적어봅니다.
				잘못 알고 있는 것이나 부족한 부분, 첨가할 것 있으면 코멘트해 주시면 함께 배울수 있을 거 같습니다.
				다음은 저의 Context에 대한 이해입니다.
				- - - - - - - - - - - - - - - - - - - - - - - - - - 
				하나의 application이 실행되기 위해서는 그 밑바탕에 깔려져야 하는 많은 정보들과 환경들(environment)이 필요합니다. 
				
				그 정보들과 환경들을 안드로이드 시스템이 제공해 줍니다.
				application 실행을 위해 밑바탕에 깔려져 있는 정보들과 환경들을 Context라 합니다.
				따라서 이 Context를 통해서 안드로이드 시스템이 제공해주는 많은 유용한 정보들을 
				꺼낼수가 있습니다(getSystemService()로).
				
				근데 Context를 필요로하는 곳에 Activity 객체인 this를 념길수 있는 이유는  
				Activity가  Context를 상속 받았기 때문에 Activity는 Context의 모든 정보를 가지고 있는 것이지요. 
				그래서 Context를 필요로 하는 곳에서 Activity의 객체를 넘길수 있는 겁니다.
				
				Context를 얻을수 있는 몇 가지 방법
				-. Activity 객체를 통해서
				-. View의 객체가 있으면 View의 getContext()를 통해서
				-. Context 클래스의 getApplicationContext()를 통해서
				
				여기까지가 Context에 대한 저의 이해였습니다.
				
				
				안드로이드 Context란? 기능과 사용 방법
				http://kaludin.egloos.com/2646070
				출처 : http://androidnote.co.kr/8
				이번에는 안드로이드의 Context란 무엇인지 알아 보고 Conext를 얻는 방법과 그 사용 범위에 대해 개괄적으로 알아보도록 하겠습니다.
				Context
				Application Context는 안드로이드 어플리케이션의 핵심 기능을 위한 중심부 역할을 합니다.
				Context는 여러 Activity 인스턴스들 간에 리소스를 공유하거나 설정등에 접근하기 위해 사용됩니다.
				현재의 프로세서에서 Application Context는 getApplicationContext() 메서드를 사용하여 얻을 수 있습니다.
				Context context = getApplicationContext();			->	본 방식은 public class Test extends Application 처럼 Application 을 부모class로 받아 오는 경우에만 가능
				Activity 클래스는 Context 클래스를 상속 확장하였으므로, Context를 얻기 위해 Activity의 this를 직접 받아올 수도 있습니다.
				하지만 무분별한 Activity 참조는 메모리릭이 발생할 확률을 높이므로 가급적 getApplicationContext() 메서드를 통해 얻는것이 좋습니다.
				이에 대한 자세한 설명은 이곳을 참조하세요.
				
				Context의 사용
				일단 Context를 얻게 되면 다음과 같은 다양한 어플리케이션 기능과 서비스를 이용할 수 있습니다.
				
				어플리케이션 리소스 얻기
				Context의 getResources() 메서드를 이용하여 어플리케이션의 리소스를 얻을 수 있습니다.
				
				다음은 어플리케이션의 String 리소스를 얻어오는 예제 입니다.
				String greeting = getResources().getString(R.string.hello);  
				
				Application Preferences 이용하기
				Context의 getSharedPreferences 메서드를 이용하면 SharedPreferences 클래스를 사용할 수 있습니다.
				SharedPreferences 클래스는 어플리케이션의 환결설정과 같은 간단한 데이터들을 저장할 수 잇습니다.
				아래는 SharedPreferences를 이용하여 사용자 이름과 성별을 저장하는 간단한 예제 입니다.
				
				SharedPreferences settings = getSharedPreferences(“User”, MODE_PRIVATE);   
				SharedPreferences.Editor prefEditor = settings.edit();   
				prefEditor.putString(“UserName”, “Spunky”);   
				prefEditor.putString(“SEX”, "Man");   
				prefEditor.commit();  
				
				preference 세팅을 얻으려면 아래와 같이 해줄 수 있습니다.
				SharedPreferences settings = getSharedPreferences(“User”, MODE_PRIVATE);   
				String userName = settings.getString(“UserName”, “androidnote (Default)”);   
				
				Contexts를 이용하여 다른 어플리케이션의 기능을 접근하기
				이밖에도 Application Context는 아래와 같은 다양한 기능들을 제공하여 줍니다.
				
				Activity 실행
				System-level 서비스 프로바이더 요청 ( ex : location service )
				Application의 파일, 폴더, 데이터베이스 다루기
				Application permission 검사

#####	3+1)[안드로이드] 다른 액티비티의 함수 호출
			cf)	MainActivity main = new MainActivity(); 
				main.restoreActionBar();
				//액티비티는 new 하지 않고 안드로이드 자체에서 Instance생성하여 씁니다.
				//위코드에서 new MainActivity 한다면 onCreate / onResume 도 타지않고 초기화 되지 않겠죠.
				//new MainActivity를 하게되면 새로운 MainActivity를 생성하기 때문에 null 에러가 발생합니다.
			
			호출하고 싶은 함수가 있는 액티비티에 Context 퍼블릭 스태틱 변수를 만들어 주고
			OnCreate에서 this를 먹여준다.
			
			public class MainTabActivity extends TabActivity
			{
				public static Context mContext;
				
				/** Called when the activity is first created. */
				@Override
				public void onCreate(Bundle savedInstanceState)
				{
					super.onCreate(savedInstanceState);
					setContentView(R.layout.tab);
					
					// setup tab widget
					setupTabs();
					mContext = this;
				}
				..................................................
			
			그리고 호출하고 싶은 곳에서 아래와 같이 함수를 호출하면 된다.
			ex)	1.	MainTabActivity class에서 preview = new Preview(this, savedInstanceState);를 사용해서 preview를 Object 선언해서 사용하고 있고
				2.	Preview class에서 MainTabActivity class안의 isFinising method를 사용하고 싶다면 하기와 같이 실행하면 됨
					cf)Preview class안에서 MainTabActivity class를 다시 new로 선언해서 사용하는 것이 아님
			if(((MainTabActivity)MainTabActivity.mContext).isFinishing() == false)		// MainTabActivity 가 finish 상태가 아니라면 하기 명령 실행
			{
				((MainTabActivity)MainTabActivity.mContext).displayAlert();
			}
		3+2)안드로이드 Database 추가
			SQLiteOpenHelper 사용법
			앞서 설명한 SQLite 예제(http://v.daum.net/link/48293915)를 이용하면 쉽게 DB관련 작업을 수행할 수 있다. 
			다만 해당 예제에서는 DB관련한 코드들이 Activity 코드에 포함되어야 한다는 단점이 있다. 
			별도의 DB관리 코드를 만들어서 재사용하고 싶을 때에는 본, SQLiteOpenHelper를 이용하면된다.

<CDatabase.java>
package net.krh.selexon2;

import java.util.ArrayList;
import java.util.Calendar;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDatabase.CursorFactory;
import android.database.sqlite.SQLiteOpenHelper;
import android.widget.Toast;

//DB를 총괄관리
public class CDatabase
{
	// DB관련 상수 선언
	private static final String dbName = "SelexOn.db";
	private static final String tableName = "contact";
	public static final int dbVersion = 1;

	// DB관련 객체 선언     
	private OpenHelper opener; // DB opener     
	private SQLiteDatabase db; // DB controller      

	// 부가적인 객체들    
	private Context context;

	// 생성자     
	public CDatabase(Context context)
	{
		this.context = context;
		this.opener = new OpenHelper(context, dbName, null, dbVersion);
		db = opener.getWritableDatabase();
	}

	// Opener of DB and Table     
	private class OpenHelper extends SQLiteOpenHelper
	{
		public OpenHelper(Context context, String name, CursorFactory factory, int version)
		{
			super(context, name, null, version);
			// TODO Auto-generated constructor stub         
		}

		// 생성된 DB가 없을 경우에 한번만 호출됨        
		@Override
		public void onCreate(SQLiteDatabase arg0)
		{
			// String dropSql = "drop table if exists " + tableName;            
			// db.execSQL(dropSql);               

			String createSql = "CREATE TABLE " + tableName + " ( _id INTEGER PRIMARY KEY AUTOINCREMENT, " + "date TEXT, " + "result TEXT)";
			arg0.execSQL(createSql);
			Toast.makeText(context, "DB is opened", 0).show();
		}

		@Override
		public void onUpgrade(SQLiteDatabase arg0, int arg1, int arg2)
		{
			// TODO Auto-generated method stub
			arg0.execSQL("DROP TABLE IF EXISTS " + tableName);
			onCreate(arg0);
		}
	}

	// 측정결과 추가
	public void insertResult(int iResult)
	{
		String result = String.valueOf(iResult);

		Calendar cal = Calendar.getInstance();
		String date = String.format("%d, %02d, %02d %02d:%02d", cal.get(Calendar.YEAR), cal.get(Calendar.MONTH) + 1, cal.get(Calendar.DATE), cal.get(Calendar.HOUR), cal.get(Calendar.MINUTE));

		db.execSQL("INSERT INTO " + tableName + " VALUES (null, '" + date + "', '" + result + "');");
	}

	// 측정결과 검색
	public Cursor select()
	{
		Cursor c = db.rawQuery("SELECT * FROM " + tableName, null);
		return c;
	}

	/*	// 데이터 추가
	public void insertData(APinfo info)
	{
		String sql = "insert into " + tableName + " values(NULL, '" + info.getSSID() + "', " + info.getCapabilities() + ", '" + info.getPasswd() + "');";
		db.execSQL(sql);
	}

	// 데이터 갱신     
	public void updateData(APinfo info, int index)
	{
		String sql = "update " + tableName + " set SSID = '" + info.getSSID() + "', capabilities = " + info.getCapabilities() + ", passwd = '" + info.getPasswd() + "' where id = " + index + ";";
		db.execSQL(sql);
	}

	// 데이터 삭제     
	public void removeData(int index)
	{
		String sql = "delete from " + tableName + " where id = " + index + ";";
		db.execSQL(sql);
	}

	// 데이터 검색    
	public APinfo selectData(int index)
	{
		String sql = "select * from " + tableName + " where id = " + index + ";";
		Cursor result = db.rawQuery(sql, null);

		// result(Cursor 객체)가 비어 있으면 false 리턴         
		if (result.moveToFirst())
		{
			APinfo info = new APinfo(result.getInt(0), result.getString(1), result.getInt(2), result.getString(3));
			result.close();
			return info;
		}
		result.close();
		return null;
	}

	// 데이터 전체 검색     
	public ArrayList<apinfo> selectAll()
	{
		String sql = "select * from " + tableName + ";";
		Cursor results = db.rawQuery(sql, null);

		results.moveToFirst();
		ArrayList<apinfo> infos = new ArrayList<apinfo>();

		while (!results.isAfterLast())
		{
			APinfo info = new APinfo(results.getInt(0), results.getString(1), results.getInt(2), results.getString(3));
			infos.add(info);
			results.moveToNext();
		}
		results.close();
		return infos;
	}*/
}

<Activity 파일>
CDatabase manager = new CDatabase(this);
manager.updateData(newInfo, index);
manager.insertData(newInfo);

엑티비티에서 CDatabase를 통해 SQLite를 이용하는 위의 코드내용과 같다.
CDatabase 객체를 생성하는 순간 DB가 오픈된다. 만약 해당 DB나 Table이 존재하지 않는다면 OpenHelper()와 onCreate() 메소드들에 의해 자동 생성된다.
DB가 오픈되면 생성한 CDatabase 인스턴스를 이용하여 데이터의 추가/갱신/삭제/검색등이 가능해 진다.

		3+3)안드로이드 database 조회(sqlite3)		
1.ADB Shell 띄우기 : C:\>adb shell
2.Database 연결하기 : # sqlite3 /data/data/패키지경로 (예:com.androidbook.aaaa)/databases/디비이름 (예:abc.db)
3.빠져나오기 : sqlite>프롬프트에서 .quit 또는 .exit 또는 Ctrl+Z(sqlite 명령이 아예 듣지 않는 경우 비상 탈출)
4.사용가능한 DB나열 : sqlite>프롬프트에서 .databases
5.사용가능한 테이블 나열 : sqlite>프롬프트에서 .tables
6.특정테이블 인덱스 나열 : sqlite>프롬프트에서 .indices 테이블이름
7.테이블의 스키마보기 : sqlite>프롬프트에서 .schema 테이블이름
8.DB의 스키마보기 : sqlite>프롬프트에서 .schema (전체 DB)
9.덤프
sqlite>.output /data/local/tmp/xxxx.sql ->덤프내용을 담을 파일을지정
sqlite>.dump 테이블명 ->덤프 대상 테이블 지정
sqlite>.output stdout ->다시 화면출력으로 변경
결론
BEGIN TRANSTION
CREATE TABLE ......이런내용이 /data/local/tmp/xxxx.sql 에 저장됨
10.SQL 스크립트 실행 : sqlite>.read /data/local/tmp/xxx.sql
11.자료들여오기
sqlite>.separator ,
sqlite>.Import /data/local/tmp/읽어들일파일명.csv    테이블명
12.프롬프트에서 SQL명령실행
sqlite>.mode column
sqlite>.header on
sqlite>SELECT a,b,c FROM......	(ex, select * from contact;)
결과 : A      B         C
------------------------------------
           1       2         3
13.열 너비 sqlite>.width 5 50 30 (1열은 5자리, 2열인 50자리, 3열은 30자리)
14.도움말 : sqlite>.help

		4)	super, this
가)	super라고 하는 키워드가 있다. 이것은 this와 상반되는 것이다. this는 자신의 object를 가리키거나 혹은 자신의 constructor를 호출할 때 사용된다.
그러나 super는 부모의 object 혹은 부모의 constructor를 호출할 때 사용된다(사용방법은 this와 같다).
이미 여러번 말했지만, 부모를 상속받으면 부모의 constructor는 상속되지 않는다. 그러나 문제는 자식이 object화될 때 부모의 constructor가 반드시 수행되어야 한다는 점이다(와 어렵다). 

나)	super는 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다. 멤버변수와 지역변수의 이름이 같을 때 this를 사용해서 구별했듯이
상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때는 super를 사용해서 구별할 수 있다. 
조상클래스로부터 상속받은 멤버도 자손클래스 자신의 멤버이므로 super대신 this를 사용할 수 있다. 그래도 조상클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 super를 사용하는 것이 좋다. 
조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 this는 근본적으로 같다. 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다. 
static메서드(클래스메서드)는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super역시 static메서드에서는 사용할 수 없고 인스턴스메서드에서만 사용할 수 있다. 

cf)	super(context);	상위 부모 class의 생성자를 호출					

[예제7-5] SuperTest.java 
class SuperTest { 
      public static void main(String args[]) { 
            Child c = new Child(); 
            c.method(); 
      } 
} 

class Parent { 
      int x=10; 
} 

class Child extends Parent { 
      void method() { 
            System.out.println("x=" + x); 
            System.out.println("this.x=" + this.x); 
            System.out.println("super.x="+ super.x); 
      } 
} 
 
[실행결과] 
x=10 
this.x=10 
super.x=10 
->	이 경우 x, this.x, super.x 모두 같은 변수를 의미하므로 모두 같은 값이 출력되었다. 

[��제7-6] SuperTest2.java 
class SuperTest2 { 
      public static void main(String args[]) { 
            Child c = new Child(); 
            c.method(); 
      } 
} 

class Parent { 
      int x=10; 
} 

class Child extends Parent { 
      int x=20; 
      void method() { 
            System.out.println("x=" + x); 
            System.out.println("this.x=" + this.x); 
            System.out.println("super.x="+ super.x); 
      } 
} 
 
[실행결과] 
x=20 
this.x=20 
super.x=10 
 
		5)	무명클래스
가)	책, 안드로이드 프로그래밍 page 168
	무명 클래스는 클래스 몸체는 정의되지만 이름이 없는 클래스이다.
	무명 클래스는 클래스를 정의하면서 동시에 객체를 생성하게 된다.
	무명 클래스는 이름이 없기 때문에 한 번만 사용이 가능하다. 
	무명 클래스는 코드의 양을 줄일 수 있는 장점도 있지만 반면에 표기법이 상당히 난해하다.
	
	new 부모클래스 또는 인터페이스() { 클래스 몸체 };
	
	무명 클래스는 부모 클래스에서 상속을 받아서 작성하거나 인터페이스를 구현하여서 작성할 수 있다.
	new 키워드 다음에 부모 클래스 이름이나 인터페이스 이름을 적어주면 된다. 부모 클래스 이름을 적으면
	그 부모 클래스에서 상속을 받는다는 의미이고, 인터페이스 이름인 경우에는 그 인터페이스를 구현하는 클래스라는
	의미이다. 이름이 있는 클래스와 무명 클래스를 비교하여 보자. OnClickListener 인터페이스를 구현한다고 가정하자.
	
	A)	이름이 있는 클래스의 경우
		a)	구조
			class ClickListener implements OnClickListener
			{
				.............
			}
			
			ClickListener obj = new ClickListener();
			
			Function(obj);
		b)	실제예제
			package kr.co.company.buttonevent1;

			import android.app.Activity;
			import android.os.Bundle;
			import android.view.View;
			import android.view.View.OnClickListener;
			import android.widget.Button;
			import android.widget.Toast;
			public class MainActivity extends Activity {
			
				class MyListenerClass implements OnClickListener {
					public void onClick(View v) {
						Toast.makeText(getApplicationContext(), "버튼이   눌려졌습니다", Toast.LENGTH_SHORT).show();
					}
				}
			
				@Override
				public void onCreate(Bundle savedInstanceState) {
					super.onCreate(savedInstanceState);
			
					setContentView(R.layout.activity_main);
					Button button = (Button) findViewById(R.id.button);
			
					MyListenerClass buttonListener = new MyListenerClass();
					button.setOnClickListener(buttonListener);
				}
			}
		
	B)	무명 클래스의 경우
		a)	구조
			Function(new OnClickListener()										// new OnClickListener()은 필요 없다면 기입하지 않아도 됨
			{
				.............
			});
		b)	실제예제
			package kr.co.company.buttonevent1;

			import android.app.Activity;
			import android.os.Bundle;
			import android.view.View;
			import android.view.View.OnClickListener;
			import android.widget.Button;
			import android.widget.Toast;
			public class MainActivity extends Activity {
				@Override
				public void onCreate(Bundle savedInstanceState) {
					super.onCreate(savedInstanceState);
			
					setContentView(R.layout.activity_main);
					Button button = (Button) findViewById(R.id.button);
			
					button.setOnClickListener(new OnClickListener() {			// OnClickListener 등의 interface나 부모 클래스가 존재하지 않으면 본, new OnClickListener() 등은 기입하지 않아도 되는 것 같다
						public void onClick(View v) {
							Toast.makeText(getApplicationContext(), "버튼이 눌려졌습니다", Toast.LENGTH_SHORT).show();
						}
					});
				}
			}


나)		무명 클래스는 객체를 생성하고자 하는 코드 부분에서 직접 객체 생성 루틴과 함께 정의된 클래스를
		의미하며, 클래스의 이름이 없기 때문에 무명 클래스라 부른다.
		무명 클래스는 한번만 사용이 가능하기 때문에, 필요한 객체에 대하여 간단히 정의하여 사용하고자 할 때 이용한다.
		
		아래 예제는 무명 클래스를 사용하여 필요한 클래스를 따로 정의하지 않고, methodA 메서드의
		매개변수로 직접 객체를 생성하여 사용한 예이다. 특히 무명 클래스는 상위 클래스의 메서드를
		재정의해서 사용하고자 할 때 클래스를 따로 정의하지 않고, 직접 객체 생성과 동시에 메서드를
		재정의해서 사용한다.
		무명 클래스는 이벤트 처리를 위한 구문에서 주로 많이 사용한다.
		즉, 이런 부분들은 자바 GUI 환경이나 안드로이드 코딩 방식에서 많이 볼 수 있는 부분이다.
		
		예제)
		Point.java
		------------------------------------------------------
		package rss;
		
		public class Point
		{
			public void print()
			{
				System.out.println("This is Point Class");
			}
		}
		
		Fraction.java
		------------------------------------------------------
		package rss;
		public class Fraction
		{
			public static void methodA(Point p)
			{
				p.print();
			}
			
			public static void main(String[] args)
			{
				methodA(new Point()
				{
					public void print()
					{
						System.out.println("This is Example.");
					}
				});
			}
		}
		
		-> 실행하면 "This is Example." 이 출력 됨
		
다)		자바 익명중첩클래스(무명클래스)
		자바에서는 4대 중첩 클래스라는 것이 있습니다. 그중에서도 익명중첩 크래스에 대해서 알아보려고 합니다.
		보통 이 녀석을 사용하는 부분은 이벤트 처리 할 때나, 쓰레드를 사용할 때 많이 사용 합니다.
		먼저 기본적인 개념을 알아 보겠습니다.
		
package 익명중첩클래스;

class test
{
	public void a(){
		System.out.println("a");
	}
	
	public void b(){
		System.out.println("b");
	}
	
	public void c(){
		System.out.println("c");
	}
}

public class exam01
{
	public static void main(String[] args)
	{
		test cl = new test()
		{
			public void b()
			{
				System.out.println("오버라이딩 b");
			}
		};
		
		cl.a();
		cl.b();
		cl.c();
	}
}

-> 결과는
a
오버라이딩 b
c

보시면, test 라는 클래스에 대해서 객체를 발생 시킵니다. 그런데, 이중에서 b라는 메소드 부분을 변경 시키고자 할 때
원래는 새로운 클래스를 만들어서 해당 부분을 오버라이딩 해주어야 합니다.
하지만, 위에 예제 처럼 익명클래스 또는 무명클래스를 통해서, 손쉽게 오버라이딩이 가능 합니다.

만드는 방법은 간단 합니다. 일반적으로 객체를 생성 하듯이 만듭니다.
test cl = new test();
-> 상기 () 와 ; 사이에 커서를 두고 {} 넣어 줍니다.
이후 {} 사이에 오버라이딩 하고자 하는 메소드를 넣어주면 됩니다.
이러한 개념을 통해서, 이벤트 핸들러라든지, 스레드를 쉽게 작성 할 수 있습니다.
		
		
		6)	배열 채우기
 
        fill(Type[] a, Type val) 
        : 배열의 모든 요소를 지정된 val 값으로 채웁니다
 
        fill(Type[] a, int fromIndex, int toIndex, Type val)
        : 배열의 fromindex 부터 toIndex 까지 지정된 val 값으로 채웁니다
 
        fill() 메서드는 C++ 의 memset() 함수와 동일하게 배열의 요소를 지정한 값으로 채워 넣는 기능을
        합니다. fill() 메서드를 이용하여 다음과 같이 코드를 작성하면 int 형 배열 arr 의 요소들은 주석과
        같이 값이 변경됩니다.
 
            int[] arr = new int[5];			// arr = { 0, 0, 0, 0, 0 }
            Arrays.fill(arr, 1);			// arr = { 1, 1, 1, 1, 1 }
            Arrays.fill(arr, 1, 2, 2);		// arr = { 1, 2, 2, 1, 1 }	->	arr배열의 arr[1]에서 arr[2]까지 2로 채운다는 뜻
            Arrays.fill(arr, 0);			// arr = { 0, 0, 0, 0, 0 }
            Arrays.fill(arr, 1, 2, 7);		// arr = { 0, 7, 7, 0, 0 }	->	arr배열의 arr[1]에서 arr[2]까지 7로 채운다는 뜻

		cf)	double aTemp[] = {1.0, 1.2, 2.3, 3.5};
			int iTemp2[] = {1, 2, 3};


		7)	import, extends/implements
import 는 위에서 가져다가 쓰겠다는 말입니다.
우리가 만약 현재 프로그램에서 만들어져있는 팩키지의 일부를 사용하겠다고 했을경우
import 문을 써서 팩키지 경로를 적습니다.

예를 들어 API에 있는 Array 를 사용할려고 할때는 import java.util.Array
라고 해야 합니다. 
그리고 나서  Array arr  =  new Array(); 라고 했을때 컴파일러는 Array 가 무엇인지 알수 있을겁니다.

implements   ,  와  extends 는 비슷하지만 많은 차이가 있습니다.
implements 는 선생님이라고 보시면 되고.. extends 는 아버지라고 보시면 됩닌다.
선생님은 친한 관계이긴 하지만 선생님의 물건이나 재산이 제자의 것이 되진 않습니다.
하지만 아버지의 물건이나 재산은 결국 자식에게 돌아올수 있습니다.
다시 설명드리면  선생님(implements)은 고기잡는 법을 알려주시는 조언자 라고 보면 되고.. 아버지(extends) 는 고기를 잡아다 주시는 것이라고 이해하면 됩니다.
아버지(extends)는 1명만 존재할수 있으면 선생님(implements) 는 여려명이 존재할수 있겠죠.

어떠한 프로그램을 만들때 하나의 프로그램안에 모든 코드를 만들어서 사용하진 
않습니다. 이미 만들어져 있거나 구현되어 있는 것은 상속을 해서 사용하거나 implements 해서 구현을 합니다.
그게 현명한 방법이겠죠?
수공~

		8)	액티비티 생성주기(life cycle)
			onCreate() -> onStart() -> onResume()/onPause() -> onStop() ->onDestroy()
			
			cf) 액티비티 중지 명령
			일반적으로 액티비티가 불려진 후 버튼 입력을 통해서 finish()를 수행하면,
			onPause() -> onStop -> onDestroy() 가 순서대로 호출되지만,
			그냥 화면 전환하자 마자 onCreate() 등 에서 finish()를 날리면  onDestroy()만 바로 불리더군요.
			cf)	프로세스 죽이기
				가)	moveTaskToBack(boolean nonRoot)
					인자로 boolean을 받고 결과값을 boolean형으로 반환합니다. 이 메서드는 현재의 액티비티가 속해있는 테스크를 백그라운드로 즉시 이동시킵니다.
					정상적으로 이동이 되었다면 true가 반환이 되고 이동에 실패할경우 false가 반환됩니다.
					하나의 인자를 받는데 true를 입력할 경우 어떠한 경우라도 상관없이 백그라운드로 이동을 시킵니다.
					하지만 false일 경우 현재의 액티비티가 루트(root)일 경우에만 백그라운드로 이동시 킵니다. "액티비티가 root 다" 라는 것은 가장 첫번째(바닥)의 엑티비티(Activity)임을 뜻합니다.
				나)	finish()
					(정확하게 조사해보고 알려드리는 것이 아니고 직접 사용해본 결과를 말씀드립니다.)
					finish()를 호출했을 때 현재 액티비티(Activity)만 종료하는것 같습니다. 즉, 위에서 말씀드린 root 액티비티에서 finish()를 호출 할 경우 더이상 표시할 액티비티가 없으므로
					어플리케이션을 종료하고 어플을 실행하기 전 화면으로 전환되는것 같습니다.
				다)	android.os.Process.killProcess(android.os.Process.myPid())
					제가 조사해본 바로는 이 메소드로 어플종료를 유도했을 시 어플이 완전히 죽지 않는다는 겁니다.
					물론 실행되고 있는 어플이 액티비티가 한 개 라면 정상적으로 종료됩니다. 하지만 액티비티가 두 개 이상이고 root 액티비티가 아닌 다른 액티비티에서 해당 메소드를 호출
					하여 종료하면 프로세스 자체는 죽지 않습니다. (어떻게 보면 finish()와 비슷하기도 합니다..)
				   (다른 서적에 명확한 정의가 있겠지만 저는 실험을 통해 알게된 사실을 말씀드립니다)


1.package zeroday.activity_test;
2. 
3.import android.app.Activity;
4.import android.os.Bundle;
5.import android.widget.Toast;
6. 
7.public class MainActivity extends Activity {
8.   
9.    // 액티비티가 처음 실행될때 호출
10.    @Override
11.    protected void onCreate(Bundle savedInstanceState) {
12.        super.onCreate(savedInstanceState);
13.        Toast.makeText(this,
14.                        "onCreate()",
15.                        Toast.LENGTH_SHORT).show();
16.    }
17.   
18.    // 액티비티가 처음 실행될때는 호출되지 않고
19.    // 정지(onStop)되었다가 다시 시작될때 호출
20.    @Override
21.    protected void onRestart() {
22.        super.onRestart();
23.        Toast.makeText(this,
24.                "onRestart()",
25.                Toast.LENGTH_SHORT).show();
26.    }
27.   
28.    // 액티비티가 화면에 나타나기 전에 호출
29.    // onCreate다음(처음 시작시)이나 onRestart다음(재시작) 호출
30.    @Override
31.    protected void onStart() {
32.        super.onStart();
33.        Toast.makeText(this,
34.                "onStart()",
35.                Toast.LENGTH_SHORT).show();
36.    }
37.   
38.    // 액티비티가 포그라운드 상태가 되기 직전에 호출
39.    @Override
40.    protected void onResume() {
41.        super.onResume();
42.        Toast.makeText(this,
43.                "onResume()",
44.                Toast.LENGTH_SHORT).show();
45.    }
46.   
47.    // onStop() 호출되기전에 호
48.    @Override
49.    protected void onPause() {
50.        super.onPause();
51.        Toast.makeText(this,
52.                "onPause()",
53.                Toast.LENGTH_SHORT).show();
54.    }
55.   
56.    // 액티비티가 백그라운드 상태(보여지지 않을때) 호출(홈버턴, 다른 app실행, ...)
57.    @Override
58.    protected void onStop() {
59.        super.onStop();
60.        Toast.makeText(this,
61.                "onStop()",
62.                Toast.LENGTH_SHORT).show();
63.    }
64.   
65.    // 액티비티가 종료(finish())될때 호출
66.    // 액티비티가 종료되어도 프로세스는 남아있게 된다.
67.    @Override
68.    protected void onDestroy() {
69.        super.onDestroy();
70.        Toast.makeText(this,
71.                "onDestory()",
72.                Toast.LENGTH_SHORT).show();
73.    }
74.}
[출처] [62] Activity - 생명주기 (JAVA 개발자) |작성자 zeroDay
		
		9)	try-catch-finally

			int num1, num2, num3 = 0;

			System.out.println("두 수를 입력하시오");
			Scanner scan = new Scanner(System.in);
			num1 = scan.nextInt();
			num2 = scan.nextInt();

			try
			{
				// 예외가 발생할 가능성이 있는 실행문
				num3 = num1/num2;
			}
			catch(ArithmeticException e)	// catch (Exception e)
			{
				// 예외 처리문
				System.out.println("0으로 나눌 수 없습니다.");
			}
			finally
			{
				// 예외 발생 여부와 상관없이 무조건 실행되는 문장(생략 가능)
				System.out.println("결과는" + num3 + "입니다.");
			}		

		10)	소켓이 살아있는지 죽었는지 확인하는 메소드 

Server는 socket의 끊어지 상태 확인이 어려운 경우가 많으며 
socket보다 방화벽의 connection timeout이 짧은 경우 종종 발생합니다.

서버는 소켓이 끊어진지 여부를 모르기 때문에 아래의 절차를 거쳐 socket close후 처리를 합니다.

if(socket.isConnected() == true && socket.getKeepAlive() == false)
{
	socket.setKeepAlive(true);
	if(socket.getKeepAlive() == false)
	{ // Socket 연결이 끊어 졌는지 확인
		socket.close();
		releaseSocket(socket, endpoint);
		socketsPool.clear(socketKey);
		socket = (Socket) socketsPool.borrowObject(socketKey);
	}
}

Socket 클래스
TCP 통신에서 포트를 사용하여 특정 대상 컴퓨터에 접속할 수 있도록 도와주는 클래스

java.lang.Object
  ��� java.net.Socket

1. Constructs(생성자)
Socket()
   -. 소켓의 디폴트 생성자

Socket(InetAddress addr, int port)
   -. 특정 주소의 포트에 접속을 시도

Socket(InetAddress addr, int port, InetAddress localaddr, int localport)
   -. 특정 주소의 포트에 접속을 시도하면서 현 컴퓨터의 주소와 포트를 명시

Socket(String addr, int port)
   -. 특정 주소의 포트에 접속을 시도

Socket(String addr, int port, InetAddress localaddr, int localport)
   -. 특정 주소의 포트에 접속을 시도하면서 현 컴퓨터의 주소와 포트를 명시

2. Method(메서드)
void close()
   -. 접속 종료

InetAddress getInetAddress() 
   -. 접속된 곳의 InetAddresss 얻기

InputStream getInputStream()
   -. InputStream() 객체 얻기

boolean getKeepAlive()
   -. 연결이 유지되고 있는지 얻기

InetAddress getLocalAddress() 
   -. 현 컴퓨터의 InetAddress 얻기

int getLocalPort()
   -. 현 컴퓨터의 포트 얻기

OutputStream getOutputStream()
   -. OutputStream 객체 얻기

int getPort()
   -. 접속된 곳의 포트 얻기

int getReceiveBufferSize()
   -. 데이터를 받을 수 있는 버퍼 크기

int getSendBufferSize() 
   -. 데이터를 보낼 수 있는 버퍼 크기

int getSoTimeout()
   -. 접속 시도 시간 얻기

boolean isBound()
   -. 소켓이 바인딩 되었는지 확인

boolean isClosed() 
   -. 소켓이 닫혔는지 확인

boolean isConnected()
   -. 소켓이 연결되어 있는지 확인

boolean isInputShutdown()
   -. InputStream이 종료되었는지 확인

boolean isOutputShutdown()
   -. OutputStream이 종료되었는지 확인

void setKeepAlive(boolean b)
   -. 연결을 유지할 것인지 설정

void setReceiveBufferSize(int a)
   -. 데이터 받는 버퍼 크기 설정

void setSendBufferSize(int a)
   -. 데이터 보내는 버퍼 크기 설정

void setSoTimeout(int a)
   -. 접속 시도 시간 설정

void shutdownInput()
   -. InputStream 닫기

void shutdownOutput()
   -. OutputStream 닫기

String toString()
   -. toString()값 얻기
		
		11)	키보드 Password 입력 창 추가
			하기 명령을 xml 파일에 추가 시키면 자동으로 password를 입력시키기 위한 키보드 입력창이 추가됨
			<EditText
        		android:id="@+id/editText2"
		        android:layout_width="match_parent"
		        android:layout_height="wrap_content"
        		android:ems="10"
		        android:inputType="textPassword" />
		        
		12)	안드로이드 타이머 사용
			cf)	타이머 사용 방법은 아래와 같이 3가지(가, 나, 다) 방법이 있지만 3가지 방법 모두
				1msec 처럼 짧은 시간을 정확하게 타이머 구동 시켜주지는 못한다.
			cf)	타이머 인터럽트란?
				타이머 인터럽트는 사용자가 정해준 시간마다 등록한 특정 작업을 할 수있게 해주는 기능 입니다.
				(정해준 시간마다 인터럽트가 발생하여 등록한 함수를 호출해 줍니다.)
				윈도우 프로그래밍을 해보신분은 API의 타이머를 생각하시면 편하실 겁니다.
				정해준 시간마다 등록한 함수를 수행 하지만 여기서 중요한 점은 리눅스가 리얼타임 OS가 아니기 때문에
				이시간을 100% 보장 해주지는 않습니다.(오차가 발생 한다는 것입니다.)
			
			가)	Timer, TimerTask를 사용한 방법
				a)	무명클래스 이용
				TimerTask myTask = new TimerTask() {
				    public void run() {
				    	/*	이 곳에 반복할 작업을 넣으면 됩니다.	*/
			        	Log.d("myTask", "run()");	
			    	}
				};
				Timer timer = new Timer();
				//timer.schedule(myTask, 5000);  // 5초후 실행하고 종료
				timer.schedule(myTask, 5000, 3000); // 5초후 첫실행, 3초마다 계속실행

				/*	타이머를 종료하려면 하기 명령 중 1가지 실행	*/
				timer.cancel();
				myTask.cancel();
				
				b)	유명클래스 이용
				public class MainRoutine
				{
					public static void main(String [] args)
					{
						Timer timer = new Timer();
						CTimer_Func cTimer_Func = new CTimer_Func();
						timer.schedule(cTimer_Func, 1000, 1000);
					}
				}
				
				class CTimer_Func extends TimerTask
				{
					int nTimer = 0;

					public void run()
					{
						Log.v("THREAD", "time=" + nTimer++ + "sec");
					}
				}

			나)	CountDownTimer를 이용한 방법
				new CountDownTimer( 100, 100 ){
					@Override
					public void onFinish() {
						imgLamp.setImageResource(R.drawable.lamp);
					}

					@Override
					public void onTick(long millisUntilFinished) {
						// TODO Auto-generated method stub
					}
				}.start();

			다)	handler를 이용한 방법
				http://www.androidpub.com/4374
				Handler mHandler = new Handler();
				mHandler.postDelayed(new Runnable() {
				   //Do Something
				}, 3000);

		13)	색상표현(ARGB)
			RGB 는 ARGB 의 Alpha 값이 무조건 255 (불투명) 입니다. 정리하면 '모든 RGB 는 투명하지 않다'가 되겠네요.
			ex)	Color Black (검정) - RGB 0, 0, 0 - ARGB 255, 0, 0, 0 - Hex Color #000000 (또는 #FF000000)
				Color White (하양) - RGB 255, 255, 255 - ARGB 255, 255, 255, 255 - Hex Color #FFFFFF (또는 #FFFFFFFF)
			ex)	//	tmpBmpRange.setPixel(x, y, 0x00ff0000);				// 투명도가 최대가 되기 때문에 빨간색 Pixel로 변하지 않음 
				tmpBmpRange.setPixel(x, y, 0xffff0000);					// 투명도가 0이기 때문에 빨간색 Pixel로 변함

		14)	Loader Callbacks
			cf)	CursorAdapter를 이용하여 Contacts(연락처, 주소록)를 읽어와서 ListView에 표시하는 방법을 설명한다.
				예제들을 찾다보면 managedQuery와 startManagingCursor method를 사용하여 Contacts를 ListView에 보여주는 방법이 있다.
				그런데 이 방법은 대부분 cursor를 직접 다루며 UIThread에서 동작을 하게 하는데 이렇게 cursor를 이동하면서 data 를 얻는 방법은 
				UIThread에 부하를 주게 되어 application이 간혹 응답이 느려지는 등의 현상이 나타날 수 있다.
				이로 인해 구글은 더 이상 startManagingCursor와 managedQuery를 지원하지 않는다.
				->	안드로이드는 이러한 data loading시의 thread 문제를 해결하기 위하여 Loader를 만들어서 비동기적인 data loading이 가능하도록 하였다.
			
			LoaderManager 가 시작할 때 , 끝날 때 우리가 원하는 일을 시킬 수 있다. 이 일을 하는 것이 LoaderCallbacks 이다. 
			이 LoaderCallbacks 는 LoaderManager.initLoader() 에서 register 하게 된다.

			LoaderManager.LoaderCallbacks<?> 을 implement 하면
				onCreateLoader() 
				onLoadFinished() 
				onLoaderReset() 
			를 override 하게 된다. 여기서는 이 함수가 호출되는 시점을 알아보자.
			
			1.	onCreateLoader() : getLoaderManager().initLoader()(support library 에서는 
				getSupportLoaderManager().initLoader) 를 호출하면 바로 onCreateLoader() 가 호출된다. 
			2.	onLoadFinished() : onStart() 이후, AsyncTask 가 동작을 시작한다. 이 AsyncTask 동작이 끝나면, 
				onLoadFinished() 가 호출된다. 이 곳에는 data 가 load 되고 난 후의 UI update 내용을 적으면 된다. 
			3.	onLoadReset() : android.app.LoaderManager,restartLoader()에서 새로운 loader 를 가져오고 
				쓰이지 않는 loader 를 destroy() 하는데 이 때 destroy() 에서 onLoadReset() 이 호출된다. 

			예제1)
			public class MyFragment extends Fragment implements LoaderCallbacks<Cursor>
			{
				final static int LOADER_ID = 1;
				private SimpleCursorAdapter adapter;

				@Override
				protected void onCreate(Bundle savedInstanceState)
				{ 
					super.onCreate(savedInstanceState);
					setContentView(R.layout.listviewfortest);        

					adapter = new SimpleCursorAdapter(
									getApplicationContext(),
									R.layout.cursoradapterviewlist_entry,	// 여기서는 ListView가 포함된 Layout xml외에 별도로 xml을 만들어서 data에 대한 layout을 정해 주었다.
									null,  									// 예전 방법과는 달리 cursor instance가 미리 만들어지지 않으므로 처음에는 null을 준다.
									new Sring[] { ContactsContract.Contacts.DISPLAY_NAME }, 
									new int[] { R.id.entry_displayname },	// layout xml 내의 id
			        				0);        	
					
					ListView listview = (ListView)findViewById(R.id.ListView1);
		    		listview.setAdapter(adapter);       		      		

       				getLoaderManager().initLoader(LOADER_ID, null, this);    		
				}
				....
				@Override
				public Loader<Cursor> onCreateLoader(int id, Bundle args)	
				{
					CursorLoader loader = new CursorLoader(
												this,
												ContactsContract.Contacts.CONTENT_URI,
												null, 
												null,
												null,
												null);
					return loader;
				}
	
				@Override
				public void onLoadFinished(Loader<Cursor> arg0, Cursor arg1) 
				{
					arg1.moveToFirst();
					adapter.swapCursor(arg1);	
				}
				
				@Override
				public void onLoaderReset(Loader<Cursor> loader) 
				{
					adapter.swapCursor(null);
				}
				...
			}   

			Adapter는 많이 사용되는 SimpleCursorAdapter를 사용하였고 Create시에 생성 후 ListView에 Set하였다.
			manifest file에는 꼭 permission READ_CONTACTS를 준다.

			예제2)
onCreateLoader 예제
public Loader<Cursor> onCreateLoader( int id, Bundle args){
	Uri baseUri;
	if( mCurFilter != null){
		baseUri = Uri.withAppendedPath( Contacts.CONTENT_FILTER_URI, 
			Uri.encode( mCurFilter));
	} else {
		baseUri = Contacts.CONTENT_URI;
	}

	String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
					+ Contacts.HAS_PHONE_NUMBER + "=1) AND ("
					+ Contacts.DISPLAY_NAME + " != '' ))";

	return new CursorLoader(
			getActivity(),
			baseUri,	// 가져올 컨텐트의 uri
			CONTACTS_SUMMARY_PROJECTION,  // 가져올 컬럼의 정보, null 일 경우 모든 컬럼을 리턴한다.
			select, // 가져올 데이터를 필터링 하는 정보 SQL 의 WHERE 절과 유사하다., 모든 데이터를 가져올 경우 null 을 설정한다.
			null, // selectionArgs 
			Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC" // 정렬 순서 sortOrder
			);
}

onLoadFilnished 예제
- 로딩이 끝난후 adapter 에 Cursor를 설정하는 예제
SimpleCursorAdapter mAdapter;
public void onLoadFinished( Loader<Cursor> loader, Cursor data){
	mAdapter.swapCursor( data);
}

onLoaderReset 예제
- Loader 가 리셋 되었을 때 호출된다. 그러므로 기존 데이터를 해제해야 한다.
SimpleCursorAdapter mAdapter;
public void onLoaderReset( Loader<Cursor> loader){
	mAdapter.swapCursor( null);
}

LoaderManager.LoaderCallbacks 를 구현한 Fragment 예제입니다.
public static class CursorLoaderListFragment extends ListFragment
        implements OnQueryTextListener, LoaderManager.LoaderCallbacks<Cursor> {

    // This is the Adapter being used to display the list's data.
    SimpleCursorAdapter mAdapter;

    // If non-null, this is the current filter the user has provided.
    String mCurFilter;

    @Override public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        // Give some text to display if there is no data.  In a real
        // application this would come from a resource.
        setEmptyText("No phone numbers");

        // We have a menu item to show in action bar.
        setHasOptionsMenu(true);

        // Create an empty adapter we will use to display the loaded data.
        mAdapter = new SimpleCursorAdapter(getActivity(),
                android.R.layout.simple_list_item_2, null,
                new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS },
                new int[] { android.R.id.text1, android.R.id.text2 }, 0);
        setListAdapter(mAdapter);

        // LoaderManger 를 초기화합니다. ID 가 존재하는 경우는 존재하는 Loader 를 재사용합니다.
		// Fragment 는 onActivityCreated 메소드내에서 초기화를 진행합니다.
        getLoaderManager().initLoader(0, null, this);
    }

    @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        // Place an action bar item for searching.
        MenuItem item = menu.add("Search");
        item.setIcon(android.R.drawable.ic_menu_search);
        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
        SearchView sv = new SearchView(getActivity());
        sv.setOnQueryTextListener(this);
        item.setActionView(sv);
    }

    public boolean onQueryTextChange(String newText) {
	// ActionBar 에서 검색시 검색어가 변경되었을 경우에 기존 로더를 재사용하기 위해 Loader의 데이터를 초기화해 줍니다.
        mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
        getLoaderManager().restartLoader(0, null, this);
        return true;
    }

    @Override public boolean onQueryTextSubmit(String query) {
        // Don't care about this.
        return true;
    }

    @Override public void onListItemClick(ListView l, View v, int position, long id) {
        // Insert desired behavior here.
        Log.i("FragmentComplexList", "Item clicked: " + id);
    }

    // CursorLoader 에서 가져올 컬럼 정의
    static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] {
        Contacts._ID,
        Contacts.DISPLAY_NAME,
        Contacts.CONTACT_STATUS,
        Contacts.CONTACT_PRESENCE,
        Contacts.PHOTO_ID,
        Contacts.LOOKUP_KEY,
    };

    // Loader 를 생성하는 콜백 메소드. Loader 를 생성해서 넘겨주면 LoaderManager 에서 알아서 실행하게 됩니다.
    @Override public Loader<Cursor> onCreateLoader(int id, Bundle args) {
        // This is called when a new Loader needs to be created.  This
        // sample only has one Loader, so we don't care about the ID.
        // First, pick the base URI to use depending on whether we are
        // currently filtering.

        Uri baseUri;

        if (mCurFilter != null) {
            baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
                    Uri.encode(mCurFilter));
        } else {
            baseUri = Contacts.CONTENT_URI;
        }

        // Now create and return a CursorLoader that will take care of
        // creating a Cursor for the data being displayed.
        String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
                + Contacts.HAS_PHONE_NUMBER + "=1) AND ("
                + Contacts.DISPLAY_NAME + " != '' ))";

        // CursorLoader 를 생성해서 넘겨줍니다.
        return new CursorLoader(getActivity(), baseUri, 
                CONTACTS_SUMMARY_PROJECTION, select, null,
                Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC");
    }

    // Loader 작업이 끝난후 결과 데이터를 처리하는 콜백 메소드
    @Override public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        // Swap the new cursor in.  (The framework will take care of closing the
        // old cursor once we return.)
        mAdapter.swapCursor(data);
    }

    // Loader 가 리셋되었을때 기존 데이터를 해제하는 콜백 메소드
    @Override public void onLoaderReset(Loader<Cursor> loader) {
        // This is called when the last Cursor provided to onLoadFinished()
        // above is about to be closed.  We need to make sure we are no
        // longer using it.
        mAdapter.swapCursor(null);
    }
}

			예제3)
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.LoaderManager;
import android.support.v4.content.CursorLoader;
import android.support.v4.content.Loader;
import android.text.Html;
import android.widget.TextView;

public class SimpleCursorLoader extends FragmentActivity implements
LoaderManager.LoaderCallbacks<Cursor> {

  public static final String TAG = SimpleCursorLoader.class.getSimpleName();
  private static final int LOADER_ID = 0x01;
  private TextView textView;

  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.simple_cursor_loader);
    textView = (TextView) findViewById(R.id.text_view);
    getSupportLoaderManager().initLoader(LOADER_ID, null, this);

  }

  public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {

    return new CursorLoader(this,
      Uri.parse("content://com.github.browep.cursorloader.data")
      , new String[]{"col1"}, null, null, null);
    }

    public void onLoadFinished(Loader<Cursor> cursorLoader, Cursor cursor) {
      cursor.moveToFirst();
      String text = (String) textView.getText();
      while (!cursor.isAfterLast()) {
        text += "<br />" + cursor.getString(1);
        cursor.moveToNext();
      }
      textView.setText(Html.fromHtml(text) );

    }

    public void onLoaderReset(Loader<Cursor> cursorLoader) {

    }
  }

			예제4)	Loader를 이용하여 SQLite Database에 접근하기 
				CursorLoader는 content provider에 의해 return되는 Cursor들 만을 위한 것이지만 SQlite를 직접 사용할 경우에
				다른 Loader를 구현해야 한다.
				
				Mark Murphy가 작성한 library는 Loader framework를 제공하며 SQLiteCursorLoader를 포함하고 있다.
			
				예)
				public Loader<Cursor> onCreateLoader(int id, Bundle args)	{
					String rawQuery = "SELECT ...";
					String[] queryParams = // 
					SQLiteCursorLoader loader = 
						new SQLiteCursorLaoder(
							getActivity().getApplicationContext(),
							yourSqliteOpenHelper,
							rawQuery,
							queryParams);
					return loader;
				}

		15)	List<String> 사용 하기
			List<String> list = new ArrayList<String>();
		    
		    list.clear();
		    
		    list.add("1");
		    list.add("2");
		    list.add("3");
		    list.add("4");
		
		    System.out.println("List : " + list);

			->	결과 : 
			List : [1, 2, 3, 4]

		16)	ArrayList 처리 방법
			ArrayList와 Vector는 RandomAccess inteface를 구현하고 있다.
			List의 크기만큼 반복문을 도는 방법에는 크게 두 가지 방법이 많이 쓰이고 있죠.
			
			1. java.util.List의 size()로 크기를 구해서 그 갯수만큼 반복문을 돌아서 get(int index)로 List안에 있는 객체를 가지고 온다.
			2. iterator() 로 java.util.Iterator 객체를 얻은 후 이 객체의 hasNext()가 true인 동안 반복문을 돌아서 next()로 List안의 객체를 가지고 온다.
 
			반복문 내에서 list의 크기가 변하는 경우가 아니라면 for문의 초기화 때 한번으로 충분합니다.
			for(int i = 0, n = list.size(); i < n; i++)
			{
				//일하기
			}
 			n을 for문 앞에서 선언하는 방법도 있지만, for block 밖에서 n이 필요한 경우가 아니라면 n이 for의 초기화 부분에 선언되고 할당되는 것이 좋습니다. 변수의 유효범위가 최소화되기 때문이죠.
 			
			반복문에서는 while보다는 for를 쓰는 것이 변수의 범위관리에 유리합니다.
			보통 iterator와 while이 아래와 같이 많이 쓰이고 있습니다.
			Iterator i = c.iterator();
			while (i.hasNext())
			{
				doSomething(i.next());
			}
 			이 것을 for문으로 쓴다면 다음과 같습니다.
 			for (Iterator i = c.iterator() ; i.hasNext(); )
 			{
 				doSomething(i.next());
 			}
			작은 차이지만 Iterator i는 for block을 벗어나는 순간  잊어버려도 되는 것이니 block 밖에서 개발자의 머리는 조금이나마 가벼워 질 수 있습니다. 
			이것은 캡슐화의 원칙인 class의 맴버 중 밖에서 볼 필요 없는 것들은 private으로 선언해야 하는 이유와 일맥상통합니다




	6)	ADT(Android Developer Tools)
		1.	ADT 실행 시 하기 오류 문제 해결 방법
			1)	오류사항 : The project was not built since its build path is incomplete. Cannot find the class file for java.lang.Object. Fix the build path then try building this project	AbsoluteLayoutTest		Unknown	Java Problem
			->	해결방법
			a)	ADT -> Window -> Android SDK Manager -> Tools
				Android SDK Build-tools 에서 Rev.19을 install 시킴
				cf)	Rev.19은 Android 4.4.2(API 19)에 해당하며
					따라서, 해당 프로젝트 -> 우측클릭 -> Properties -> Android -> Android 4.4.2를 선택해야 함
			2)	오류사항 :	The JAR file C:\StudyJava\Java\jre8\lib\rt.jar has no source attachment.
						You can attach the source by clicking Attach Source below:
			->	해결방법
			Attach Source...버튼 > External File...버튼 > jdk폴더를 찾고 jdk폴더 안에 src.zip을 선택한다.
			오류가 해결되었다
			cf)	src.zip은 java 파일이 있고, rt.jar는 class파일이 존재
		2.	개발의 필수요소, DDMS를 사용해보자!
			어플리케이션 개발을 하다 보면 단말기 혹은 에뮬레이터의 상태에 대해 조금 더 자세히 보고 싶은 경우도 있고
			(LogCat 로그 확인 등..), 프로세스를 확인하거나 내부에 저장된 데이터를 살펴보는 등 조금 더 "깊숙한 곳"의 무엇인가를 보거나
			수정해야 하는 경우가 많습니다. 
			안드로이드 SDK에는 이러한 작업을 위해 DDMS(Dalvik Debug Monitoring Service)를 제공합니다. 
			DDMS를 통해 에뮬레이터/단말기 내의 로그나 실행중인 프로세스 확인이나 화면 캡쳐 등의 작업을 할 수 있습니다. 
			DDMS를 "내 손 같이" 다룰 수 있게 된다면, 어플리케이션 개발 과정에 엄청난 도움이 되니 DDMS에서 자주 사용하는 기능은 
			꼭 알아두고 있어야 합니다.
			
			DDMS에는 여러가지 기능들이 있지만, 자주 사용하는 기능은 아래 다섯 가지 정도입니다.
				프로세스 관리  
				에뮬레이터 조작 (Emulator Control) 
				로그 관리 (LogCat) 
				파일 관리 (File Explorer) 
				화면 캡쳐 

	7)	Thread를 사용하려면 AsyncTask 클래스를 사용하자
		가)	AsyncTask
			AsyncTask는 Thread 기능도 하면서 복잡하지 않게 Thread 정의 method 안에서 UI를 변경시키는 것을 가능하게 해준다.
			cf)	Thread.sleep(1000); 명령을 써서 Thread 실행 간격을 지정한 경우
				정확하게 1sec 간격으로 실행되지는 않는다.
				다른 명령이 실행되면 그 만큼 지연되어서 실행된다.
			
public class AsyncTest extends Activity {
	private ProgressBar mProgress;
	private int mProgressStatus = 0;

	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		mProgress = (ProgressBar) findViewById(R.id.progress_bar);
		Button button = (Button) findViewById(R.id.button);
		button.setOnClickListener(new Button.OnClickListener() {
			public void onClick(View v) {
				new CounterTask().execute(0);
			}
		});
	}

	class CounterTask extends AsyncTask<Integer, Integer, Integer> {
		protected void onPreExecute() {
		}

		protected Integer doInBackground(Integer... value) {
			while (mProgressStatus < 100) {
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
				}
				mProgressStatus++;
				publishProgress(mProgressStatus);
			}
			return mProgressStatus;
		}

		protected void onProgressUpdate(Integer... value) {
			mProgress.setProgress(mProgressStatus);
		}

		protected void onPostExecute(Integer result) {
			mProgress.setProgress(mProgressStatus);
		}
	}
}

		나)	Thread 와 Runnable 차이점
		Thread를 구현하는 방법
		1.	Thread 클래스를 상속받는 방법
		2.	Runnable 인터페이스를 구현하는 방법
		이 두 방법의 큰 차이는 상속에 있다.
		Thread클래스를 상속받게 되면 다른 클래스를 상속받을 수 없게 되기 때문에, 보통 Runnable 인터페이스를 구현 받는 경우가 대부분 이다.
		cf)	interface 의 경우는 여러개의 interface를 상속 받을 수 있다.
		
		// -------- [Thread 클래스 상속] --------------------------------------
		class StoneThread extends Thread
		{
			// Thread Class 의 run() 오버라이딩
			public void run()
			{
				// Business Logic
			}
		}
		// 실행
		StoneThread stoneThread = new StoneThread();
		stoneThread.start();

		
		// -------- [Runnable 인터페이스 구현] --------------------------------------
		class StoneRunnable implements Runnable
		{
			// Runnable Interface의 추상메소드 run()을 구현
			public void run()
			{
				// Business Logic
			}
		}
		// 실행
		StoneRunnable stoneRunnable = new StoneRunnable();
		Thread thread = new Thread(stoneRunnable);
		thread.start();
		
		다)	Synchronized (자바 동기화)
			하나의 객체에 여러개의 스레드가 접근해서 처리하고자 할 때
			static으로 선언한 객체에 여러 스레드가 동시에 사용 할 때 Synchronized를 사용해서 동시에 처리되지 않도록 해줌
			http://blog.naver.com/meelong0/140094191195
			
			1. Java에서 동기화란? - "날 방해하지 말아줘~ 내가 됐다고 할 때까지 그냥 내버려둬!"
			  - 네이버 국어 사전에서는 다음과 같이 동기화에 대해서 언급을 하고 있습니다.
			  - "작업들 사이의 수행 시기를 맞추는 것. 사건이 동시에 일어나거나, 일정한 간격을 두고 일어나도록
				시간의 간격을 조정하는 것을 이른다."
			  - 즉, 프로그램에 가져와서 이야기를 한다면... 이게 참 한 줄로 딱 짤라서 말하기 힘든데,
				"어떤 작업의 독립적이고 완전한 실행권을 보장하기 위한 방법"인 데 그냥 위에 갈색 표현이 맘에 듭니다.
			  - 단, 방해하지 말라고 했다고 그냥 다른 사람은 무작정 됐다고 할 때까지 기다리는 문제가 발생할 수 있으니깐
				좀 더 폭넓은 관점에서 들여다 봤을 때에는 이 방법이 완전하다. 안전하다. 최고다. 이렇게는 단정 지을 수 없겠네요. 

			2. 어떻게 쓸까? - 함수, 블록, 변수에서 사용
			  - synchronized 키워드는 다양한 곳에 붙어서 사용되어질 수 있습니다. 
			 1) 함수 : 해당 함수가 실행되고 있는 동안에 동기화를 보장한다.
			  - ex) public synchronized void importMoney(int money) { ... }
			  - 예를 들어 은행에서 돈을 입금할 때는 이체나 인출이나 또 다른 입금에 대해서 독립적인 실행이 보장되어야 한다.
			    따라서, 입금과 관련된 동작은 동기화를 보장하여야 한다.
			 2) 블록 : 해당 블록내에서는 동기화를 보장한다.
			  - ex) public void importMoney(int money) {
				      synchronized (this)    {
	        		  ...
	           		  }
              		  ...
			        }
			  - 예를 들어 은행에서 돈을 입금할 때 필요한 구간에만 딱 걸어두면 된다.
			    동기화 구문이 커질수록 다른 작업은 그에 따라 작업 수행 속도가 저하될 수 있다.
			    여기서 사용된 this 객체는 자기 자신 즉, 현재 이 함수를 수행하고 있는 객체에 대해서 동기화를 시킨다는 의미다.
			    여러 사람이 여러 계좌의 각각의 구좌에 대해서 독립적으로 동기화 되어야 하므로 이 함수가 발생되는 동안에는
			    해당 구좌에 대해서만 동기화를 확실히 수행하는 것이다.

			 3) 변수 : 해당 블록내에서 해당 변수에 대하여 동기화를 보장한다.
			  - ex) public void importMoney(int money) {
		              synchronized (money)    {
	                  ...
				      }
		              ...
			        }
			  - 구간 내에서 변수에 대해서 동기화를 수행한다. 물론 위에서처럼 객체 변수로 통한 접근도 가능하지만,
			    이 방법을 사용하면 블록 내에서 해당 변수에 한하여 동기화를 보장하도록 한다.
			3. 조심해야 할 부분 - 적재적소에 사용
			  - 잘못된 방법으로 동기화를 할 경우, 원래 의도와는 다르게 동작하는 경우가 발생할 수 있다.
			    2-2에서도 언급하였듯이 각각의 객체별로 해줄때와 단순히 하나의 메소드를 통째로 하는 방법,
			    그리고 변수 하나를 이용하여 동기화 하는 방법은 그 쓰임새가 분명 조금씩 다를 수 있다.
			    따라서 이런 실수를 범하지 않기 위해서 소스를 구현하기 이전에 어떻게 구현할지에 대해서
			    먼저 잘 따져보는 것이 중요하다.
			  - cf) 잘 못 사용하면 Dead lock이 걸릴 수 있기 때문에 꼭 필요한 경우에만 제대로 알고 쓰자		

	8)	자바 오버라이딩 + 오버로딩 차이점(JAVA overriding, overloading  차이점 알아보자)

오버라이딩 
overriding   over + ride =  먼가 위에서 (라이딩 한다)달린다.

md vocabulary 33000 에서 이런식으로 해석한거 같다 (?) 기억이 가물가물 즉슨  네이버 사전을 보면 최우선시 되는 이란다.
개풀 먼소리냐 나도 모르겟고  부모클래스에서 상속 받아 다시 쓰는 거다 약간 해석해보면 부모클래스에서 달린다 ? 다시쓴다? 맞는 소리인거 같기도하다

ex) 부모클래스와 자식클래스에서 이름을 다시 정의(?)해주는것, 상속을 받아 다시 재정의 하는 것

오버라이딩은 
public class Car {
printInfo(){
System.out.println("차입니다.";
}
}

public class SportCar extends Car {
@override
printInfo(){
System.out.println("스포츠카입니다.";
}
}

main(){
SportCar sportCar = new SportCar(); 
sportCar.printinfo();
}

-> 결과
스포츠카입니다.


오버로딩 
overloading  over + road = 먼가위에서   짐을 적재하다 (?) ㅋㅋ 스타크래프트 오버로드 만 생각난다 
딱그거다 오버로드에 저글링 태워 삼센치 드랍을 생각해라 

ex ) 같은 클래스안에 같은 메소드를 두개이상 만드는것, 
     메소드이름은 같고 매개변수나 매개변수타입이 다름  

class Sub
{
	String id;
	int pw;
	
	public void getInfo(int pw)
	{
		this.pw = pw;
		System.out.println("비번 = " + pw);
	}
	
	public void getInfo(int pw, String id)
	{
		this.pw = pw;
		this.id = id;
		System.out.println("비번 = " + pw + " / " + "아이디 = " + id);
	}
}

public class par
{
	public static void main(String[] args)
	{
		Sub sub = new Sub();
		sub.getInfo(1234);
		sub.getInfo(12345, "ggari");
	}
}

-> 결과
비번 = 1234
비번 = 12345 / 아이디 = ggari


	9)	다른 클래스에 있는 메소드 등을 호출하는 방법
		예를 들어 A class, B class가 있다고 가정하자. 이 두 class가 서로 관계를 맺으려면, 
		즉 다른 class의 method를 호출할 수 있다든지, 또는 memeber 변수의 값을 읽으려고 한다든지 등등, 이 같은 작업을 하려면 두 class는 relation을 가져야 한다
		(즉 has a relation이어야 한다). relation을 맺는 방법은 간단하다. A class에서 B class를 접근하려면 A class안에 B class의 reference만 있으면 된다. 다음의 예를 보자.

Class A
{
	B bbb = new B();	// B class와 관계를 갖는다. (has a relation)
    bbb.x(); 			// 이제 B class의 x()를 호출할 수 있다.
}

class B
{
    x(){ ... }
}
아주 간단하다. 위의 두 class는 이제 relation(관계)이 있는 것이다. 참고하기 바란다.

	10)	안드로이드 USB 통신
		안드로이드 USB 통신은 쉽지 않다
		이유는, PC(Windows)와 안드로이드 보드를 연결하면 안드로이드 보드상의 Internal storage(/mnt/shell/emulated/0)은
		USB-Memory처럼 PC(Windows) 탐색기에서 Internal storage로 표시되며
		Eclipse는 ADB를(USB연결) 통해서 안드로이드 보드를 직접 제어하기 때문 임

		cf)	USB Host Mode
			Android Device가 USB Host Mode일 경우 USB Host로써의 역할을 수행합니다.
			비유를 하자면 Android Phone이 PC와 같은 역할을 하게 되며 연결되는 USB 장치 예로 USB Mass Storage, Keyboard, Mouse 등을 사용할 수 있게됩니다. .
		cf)	USB Accessory Mode
			Android Device가 USB Accessory Mode일 경우 단순 USB Device로써의 역할(Host 기능 없음)로 동작하기 때문에 외부 연결된 USB Device가 USB Host로써의 역할을 수행합니다.
			위 모드일 경우에는 Open Hardware Project인 Arduino와 같은 H/W들과 연동하여 사용되는 경우가 많습니다.

		1-2)adb over USB on Windows Machine를 이용하자
			중요)TI-Android-JB-4_1_2-DevKit-4_0_0 UserGuide - Texas Instruments Wiki.mht 참고

		1-1)UsbController application 등 USB HOST 통신은
			Client 디바이스와의 연결을 EHCI USB PORT가 아닌 OTG PORT에 연결시켜야 한다.
			->	관련 문서등을 다 조사해 보니 HOST Board OTG PORT에 연결시키라고 나와 있음

		1)	adb 명령의 forward 기능을 사용하면 될 것 같다.
			adb를 이용하여 USB를 통하여 TCP 연결하기
			안드로이드 장비에 TCP 소켓 기반 서버 들이 구동되어 있다는 가정하에 Putty나 WinSCP 같은
			프로그램으로 연결하는 방법을 기술한다.
			adb 명령에는 다음과 같이 로컬 포트와 안드로이드 장비의 특정 포트간에 포워딩을 해주는 방법이 있다.
			이 명령행을 이용하면 설정한 로컬 포트에 해당 툴로 연결을 하면 USB 인터페이스를 통하여 안드로이
			장비로 포워드 되어 안드로이드 장비에 Ethernet 케이블이나 WiFi로 연결한 것과 동일하게 사용할 수 있다.

			cf)	ADB에는 forward라는 옵션이 있다. 이는 ?Android의 풀소스 중에 adb.c를 보면 다음과 같은 소스가 있다. 
				이는 ADB가 PC의 Application과 소켓통신을 할 수 있도록 port-forwarding을 지원한다는 말이다. 
				즉, Linux Agent 없이 PC<->APK간의 통신이 가능하다는 것인데... 명령어 처리는 다음과 같이 심플하게 처리 가능하다. 
				adb.exe forward tcp:19999 tcp:19999 
				위와 같이 처리한 후, PC에서는 127.0.0.1 주소에 19999 포트로 연결하면 
				일반 소켓통신하듯, 단말기와 통신이 가능하다. 
				좀더 빨리 알았으면 Linux Agent를 사용하는 귀찮은 방법을 안해도 되었을 터인데 무척 아쉽다.
				Using these line of code on client side before creating the connection (make sure you are making your android device Server and Application on PC ll be client)
				you can send any data on android device through USb using different streams Classes
				
			명령 형식 : adb forward <local> <remote>
			<local> <remote> 형식 :
				-	tcp:<portnum>
				-	local:<UNIX domain socket name>
				-	dev:<character device name>
				-	jdwp:<pid>
			
			예)	로컬 시스템의 21번 포트를 안드로이드 장비의 21번 포트로 포어딩 한다.
				adb forward tcp:21 tcp:21
				
			예)	포트 대신 도메인 소켓 이름을 사용할 수도 있다.
				adb forward tcp:6100 local:logd
				
			putty나 WinSCP의 연결 정보에 IP는 127.0.0.1로 하고 해당 서버의 로컬 포트를 설정하여 연결을 수행한다.
			
		2)	안드로이드 요요 - 오픈 엑세서리 개발보드( IOIO for Android )
			
		3)	[안드로이드] USB-accessory와 USB-host에 둘의 차이점을 정확히 모르겠습니다.   
			글쓴이 : triplej 날짜 : 2013-04-12 (금) 11:41 조회 : 1002    
			글주소 : http://www.androidside.com/B49/113319   
			
			반갑습니다 질문이 두가지가 있어서 이렇게 글을 올렸습니다. 
			첫번째는 
			http://developer.android.com/guide/topics/connectivity/usb/host.html USB-host
			http://developer.android.com/guide/topics/connectivity/usb/accessory.html USB-accessary
			이 둘중에서 어떤 것을 선택해야 핸드폰과 다른 장치가 serial 통신을 할 수 있는지에 대해서 알아보려고 하는데 
			명쾌한 해답이 없네요... 
			 
			두번째는
			제가 알아본 바로는 핸드폰에 다른 창치를 연결할 수 있는 포트가 USB-slave라고 하던데 
			위에 에 있는 링크중 하나인 USB-host에  있는 자료가 
			USB-host라는 것이 핸드폰에서 OTG 케이블 연결했을 때 OTG 케이블 쪽의 USB-host를 사용할 때 쓰는 것인지  
			아니면 핸드폰 개발을 위해서 사용하는 USB-host를 말하는 것인지를 모르겠습니다. 

	11)	AVD(Android Virtual Devices) 사용 방법
		1-1)AVD 실행시키면 어느 정도 LOADING 되다가 아예 빠져나오는 문제 해결 방법
			Windows -> Android Virtual Device(AVD) Manager
			-> Android Virtual Devices -> Android~선택 -> Edit -> [ ]Use Host GPU 항목 선택 해제
		1)	포트번호(TCP/IP)
			AVD 창의 상단 AVD이름(Ex, 5554:Android_2.3.3, 5556:Android_2.3.3_2) 앞 부분이
			포트번호를 가리키며
			cmd -> telnet localhost 5554 와 같이 해당 포트 번호로 telnet으로 접속할 수 있음
		2)	IP
			AVD에서는 10.0.2.2 가 localhost (Windows OS에서의 127.0.0.1) 임
			cf)	2개의 AVD를 사용할 경우 IP는
				첫번째가	10.0.2.2 이고
				두번째가 	10.0.2.15 임
			cf)	확실하게 어떤 IP로 할당되어 있는지 알고 싶으면 하기와 같이 adb 명령으로 들어가서 확인
				가)	adb -s emulator-5554 shell
				나)	ifconfig eth0
					eth0: ip 10.0.2.15 mask ~
		3)	Android TCP UDP 통신 (Emulator 간)taehwan | 2010/11/30 22:10 | Dev | 2 
--------------------------------------------------------------------------------
아래 emulator을 이용한 TCP와 UDP 소스코드
  http://thdev.net/3
English
   http://blog.thdev.net/2010/11/android-tcp-udp-emulator.html

목적 Object
Emulator 3개를 이용하여 TCP와 UDP의 통신을 한다.
Emulator에 접속하여 소문자를 대문자로 변환하는 소스코드를 짠다.
----------------------------------------------------------------------------------
emulator간 TCP와 UDP 통신을 하기 위해서는 Telnet을 이용하여 포트를 추가해주어야 합니다.
Ex)	telnet localhost 5554
	redir add tcp:5000:6000

포트 추가하기 전에 몇 가지 설명 드리겠습니다.
먼저 emulator의 포트번호는 각 emulator가 구동되면서 발생하는 emulator 번호입니다.
아래는 제가 사용한 emulator 입니다.
5554, 5556, 5558 이렇게 3가지입니다.

3가지의 5554, 5556, 5558 번은 emulator의 번호이면서 접근 할 수 있는 포트 번호입니다.
이 emulator의 포트번호를 이용하여 포트번호를 열어줘야 합니다.
열어주는 방법은 아래와 같습니다.
 
명령어 : redir add tcp:7000:7000				cf) 지우는 명령어 : redir list -> redir del tcp:7000
tcp:외부에서 접근 포트:emulator 포트
여기서 TCP 외부, 내부 포트는 7000로 설정하였습니다. 
 
명령어 : redir add udp:8000:8000
udp:외부에서 접근 포트:emulator 포트
여기서 UDP 외부, 내부 포트는 8000으로 설정하였습니다. 

윈도우 사용자일 경우
emulator와 emulator 간은 외부 접근 포트를 위의 방법대로 열어줘야 접근이 가능합니다.
자바 코드에서 emulator로의 접근도 위의 방법을 사용해야 할 수 있습니다.
----------------------------------------------------------------------------------

- 소스 코드상에서 처리
IP주소는 아래내용을 참고 하세요
10.0.2.1 Router/gateway address 
10.0.2.2 Special alias to your host loopback interface
		(i.e., 127.0.0.1 on your development machine) 
10.0.2.3 First DNS server 
10.0.2.4 / 10.0.2.5 / 10.0.2.6 Optional second, third and fourth DNS server (if any) 
10.0.2.15 The emulated device's own network/ethernet interface 
127.0.0.1 The emulated device's own loopback interface 

서버가 구동되는 2개의 emulator는 IP주소가 10.0.2.2 번으로 접근할수 있습니다.
클라이언트에서 접근을 위해서는 10.0.2.2번으로 설정하시고 TCP와 UDP 포트번호를 지정하시면 됩니다. 
다시 정리하자면 10.0.2.2번으로 접속하는 클라이언트를 만들어주시면 되고, 포트번호는 telnet을 이용하여 add해주시면 됩니다.

	12)	안드로이드 TCP/IP 통신
		가)	안드로이드 TCP/IP server는 전송 문자열 뒤에 "\n" 문자가 올 때 까지 문자열을 기다린다.
			OS Windows 계열에서 프로그램 코딩 시 하기 사항을 주의해서 코딩해야 함
	UpdateData(TRUE);
	char chBuf[100] = {0};
	memset(&chBuf, 0, sizeof(chBuf));

	strncpy(chBuf, m_sMsg, 100);

	strcat(chBuf, "\n");					// 안드로이드 TCP/IP server는 전송 문자열 뒤에 "\n" 문자가 올 때 까지 문자열을 기다린다.
											// 따라서, 문자열 뒤에 "\n"이 없으면 무한대로 문자열 기다림

	m_Client.Send(chBuf,strlen(chBuf));
		나)	/*	실제 TCP/IP Server/Client 통신 성공 사용 환경
			 *	1.	ClientTest
			 *		1)	AVD(Android Virtual Device)에서 Client application 구동시키며
			 *		2)	이때 프로그램 구성은 socket = new Socket("10.1.75.95", 6666);
			 *			이고 10.1.75.95은 Server ip 주소로(Windows 7 PC 고유주소) ipconfig으로 확인할 수 있음
			 *			또한 6666은 통신 Port번호 임
			 *	2.	ServerTest
			 *		1)	Server는 Windows7 PC환경에서
			 *			Eclipse -> Run As ->  Java Application 으로 실행시키면 되며
			 *		2)	프로그램 구성은 serverSocket = new ServerSocket(6666);
			 *			이고 6666은 통신 Port번호 임
		다)	안드로이드 보드에서 TCP/IP 설정
			busybox ifconfig eth0 192.168.1.103 명령을 수행해도 부팅하고 나면 다시 원래 대로 변경되서
			어쩔 수 없이
			/data/gpio_driver.sh 명령에 하기 사항을 추가 시켜서 부팅과 동시에 항상 실행(설정)하도록 함
			busybox ifconfig eth0 192.168.1.103

			cf)	설정1
				설정 대상 : eth0
				IP Address	:	10.2.12.12
				netmask		:	255.0.0.0
				Broadcast	:	10.2.255.255
				Network ID	:	10.2.0.0
				->	busybox ifconfig eth0 10.2.12.12 netmask 255.0.0.0 broadcast 10.2.255.255 up
			cf)	설정2
				설정 대상 : eth0
				IP Address	:	10.1.74.103
				netmask		:	255.255.254.0
				Broadcast	:	10.1.75.255
				->	busybox ifconfig eth0 10.1.74.103 netmask 255.255.254.0 broadcast 10.1.75.255 up
			cf)	설정2+1
				설정 대상 : eth0
				IP Address	:	10.1.75.250
				netmask		:	255.255.255.0
				Broadcast	:	10.1.75.255
				->	busybox ifconfig eth0 10.1.75.250 netmask 255.255.255.0 broadcast 10.1.75.255 up
			cf)	설정3
				설정 대상 : eth0
				IP Address	:	10.0.2.16
				netmask		:	255.255.255.0
				Broadcast	:	10.0.2.255
				->	busybox ifconfig eth0 10.0.2.16 netmask 255.255.255.0 broadcast 10.0.2.255 up

		라)	PC(Windows7) <-> 안드로이드보드(i.MX6) 간의 TCP/IP 통신 성공 사용 환경(스위치(허브) 없이 Direct 연결 방법)
			1)	크로스 랜 케이블을 만든다
			2)	안드로이드 보드 -> Ethernet 아이콘 선택 -> Configure Ethernet -> Static IP -> IP address -> 192.168.1.103 cf) DNS address 비워 둠
			3)	안드로이드 보드 -> Terminal window -> 상기 다) 안드로이드 보드에서 TCP/IP 설정 을 수행
			4)	PC(Windows7) -> 네크워크설정 -> 해당네크워크어댑터 -> Internet Protocol Version 4 (TCP/IPv4) 속성
				-> 다음 IP 주소 사용 -> IP 주소 : 192.168.1.104 -> 서브넷 마스크 -> 255.255.255.0 -> 나머지 설정 비워 둠
			5)	만들어 놓은 크로스 랜 케이블로 서로 연결 함
			6)	안드로이드 보드 -> Terminal window -> ping 192.168.1.104 명령 실행 시 아래와 같은 문구가 나오면 정상적으로 서로 TCP/IP 연결 된 것임
				PING 192.168.1.104 (192.168.1.104) 56(84) bytes of data.
				64 bytes from 192.168.1.104: icmp_seq=1 ttl=128 time=7.31 ms
				............................................................	
			7)	PC(Windows7)의 전체 포트를 하기 방법을 사용해서 열어 놓음
				제어판 -> Windows 방화벽 설정 또는 해제 -> "Windows 방화벽 사용 안 함" 모두 선택
			8)	PC(Windows7) -> Eclipse -> ServerTest2를 Windows7 환경에서 실행시켜(Java Application) Server가 실행 되도록 함
			9)	PC(Windows7) -> Eclipse -> ClientTest(AliveCheck)를 실행시켜(Android Application) 안드로이드 보드에서 Client가 실행 되도록 함
			10)	PC(Windows7) -> Eclipse -> Console 창에서 하기 문구가 실행되면 제대로 TCP/IP 통신이 연결된 것임
				클라이언트 연결, ServerThread_count = 1
				클라이언트로부터 받은 문자열: nAliveCheck = 1

		라+1)	PC(Windows7) <-> 안드로이드보드(i.MX6) 간의 TCP/IP 통신 성공 사용 환경(스위치(허브) 사용의 경우)
			1-1)NFS로 구현 중이라면 booti mmc2 setting으로 변경
			1)	일반 랜 케이블 사용
			2)	안드로이드 보드 -> Ethernet 아이콘 선택 -> Configure Ethernet -> Static IP -> IP address -> 10.1.75.250 cf) DNS address 비워 둠
			3)	안드로이드 보드 -> Terminal window -> 상기 다) 안드로이드 보드에서 TCP/IP 설정 -> cf)설정2+1 과 같이 설정/수행
			4)	PC(Windows7) -> 네크워크설정 -> 해당네크워크어댑터 -> Internet Protocol Version 4 (TCP/IPv4) 속성
				-> 다음 IP 주소 사용 -> IP 주소 : 10.1.75.95 -> 서브넷 마스크 : 255.255.255.0 -> 기본게이트웨이 : 10.1.75.254
				-> 다음 DNS 서버 주소 사용 -> 기본 설정 DNS 서버 : 10.1.61.231 -> 보조 DNS 서버 : 10.1.61.232
			5)	일반 랜 케이블로 서로 연결 함
			6)	안드로이드 보드 -> Terminal window -> ping 10.1.75.95 명령 실행 시 아래와 같은 문구가 나오면 정상적으로 서로 TCP/IP 연결 된 것임
				PING 10.1.75.95 (10.1.75.95) 56(84) bytes of data.
				64 bytes from 10.1.75.95: icmp_seq=1 ttl=128 time=3.26 ms
				............................................................
			6+1)PC -> cmd.exe -> ping 10.1.75.250 명령 실행 시 정상적으로 통신 가능한지 체크

		라+2)	PC(Windows7) <-> 안드로이드보드(i.MX6) 간의 TCP/IP 통신 성공 사용 환경(스위치(허브) 사용의 경우)
			1-1)NFS로 구현 중이라면 booti mmc2 setting으로 변경
			1)	일반 랜 케이블 사용
			2)	안드로이드 보드 -> Ethernet 아이콘 선택 -> Configure Ethernet -> Static IP -> IP address -> 10.1.74.103 cf) DNS address 비워 둠
			3)	안드로이드 보드 -> Terminal window -> 상기 다) 안드로이드 보드에서 TCP/IP 설정 -> cf)설정2 와 같이 설정/수행
			4)	PC(Windows7) -> 네크워크설정 -> 해당네크워크어댑터 -> Internet Protocol Version 4 (TCP/IPv4) 속성
				-> 다음 IP 주소 사용 -> IP 주소 : 10.1.75.95 -> 서브넷 마스크 : 255.255.254.0 -> 기본게이트웨이 : 10.1.75.254
				-> 다음 DNS 서버 주소 사용 -> 기본 설정 DNS 서버 : 10.1.61.231 -> 보조 DNS 서버 : 10.1.61.232
			5)	일반 랜 케이블로 서로 연결 함
			6)	안드로이드 보드 -> Terminal window -> ping 10.1.75.95 명령 실행 시 아래와 같은 문구가 나오면 정상적으로 서로 TCP/IP 연결 된 것임
				PING 10.1.75.95 (10.1.75.95) 56(84) bytes of data.
				64 bytes from 10.1.75.95: icmp_seq=1 ttl=128 time=3.26 ms
				............................................................	
			6+1)PC -> cmd.exe -> ping 10.1.74.103 명령 실행 시 정상적으로 통신 가능한지 체크



			7)	PC(Windows7)의 전체 포트를 하기 방법을 사용해서 열어 놓음
				제어판 -> Windows 방화벽 설정 또는 해제 -> "Windows 방화벽 사용 안 함" 모두 선택
			8)	PC(Windows7) -> Eclipse -> ServerTest2를 Windows7 환경에서 실행시켜(Java Application) Server가 실행 되도록 함
			9)	PC(Windows7) -> Eclipse -> ClientTest(AliveCheck)를 실행시켜(Android Application) 안드로이드 보드에서 Client가 실행 되도록 함
			10)	PC(Windows7) -> Eclipse -> Console 창에서 하기 문구가 실행되면 제대로 TCP/IP 통신이 연결된 것임
				클라이언트 연결, ServerThread_count = 1
				클라이언트로부터 받은 문자열: nAliveCheck = 1

		마)	VirtualBox(Ubuntu) <-> 안드로��드보드(i.MX6) 간의 TCP/IP 통신 성공 사용 환경(스위치(허브) 사용의 경우)
			1)	일반 랜 케이블 사용
			2)	안드로이드 보드 -> Ethernet 아이콘 선택 -> Configure Ethernet -> Static IP -> IP address -> 10.0.2.16 cf) DNS address 비워 둠
			3)	안드로이드 보드 -> Terminal window -> 상기 다) 안드로이드 보드에서 TCP/IP 설정 -> cf)설정3 와 같이 설정/수행
			4)	VirtualBox(Ubuntu) -> 설정 -> 네크워크 -> 브리지어댑터로 변경
			5)	VirtualBox(Ubuntu) 내부창 -> terminal -> ifconfig
				->	eth0      Link encap:Ethernet  HWaddr 08:00:27:00:f0:26  
					inet addr:10.0.2.15  Bcast:10.0.2.255  Mask:255.255.255.0
			6)	일반 랜 케이블로 서로 연결 함
			7)	안드로이드 보드 -> Terminal window -> ping 10.0.2.15 명령 실행 시 아래와 같은 문구가 나오면 정상적으로 서로 TCP/IP 연결 된 것임
				PING 10.0.2.15 (10.0.2.15) 56(84) bytes of data.
				64 bytes from 10.0.2.15: icmp_seq=1 ttl=64 time=4.28 ms
				............................................................
			7+1)VirtualBox(Ubuntu) 내부창 -> terminal -> ping 10.0.2.16 명령 실행 시 정상적으로 통신 가능한지 체크



	13)	안드로이드 GUI 사용
		가)	전체화면 사용하기 (Status bar, Title bar 숨기기)회색
			http://www.androidpub.com/47102009.02.13 16:24:36 733131 / 0 5앱개발안드로이드에서 전체화면을 사용하기 위해서는 상태바(Status Bar)와 타이틀바(Title Bar)를 숨겨야 합니다. 
			숨기는 방법은 여러가지가 존재하는데 그 중 몇가지 방법을 정리하도록 하겠습니다.
			1. 미리 정의된 Theme 사용하기
				1.<activity android:name=".MyActivity"
				2.          android:theme="@android:style/Theme.NoTitleBar.Fullscreen"  >
				AndroidManifest.xml 에서 Activity의 Theme를 위와 같이 설정해주면 Status Bar와 Title Bar가 모두 없는 상태가 됩니다. 

				1.<activity android:name=".MyActivity"
				2.          android:theme="@android:style/Theme.NoTitleBar"  >
				이렇게만 한다면 TitleBar만 없는 상태가 됩니다

	14)	NDK 로그 출력(printf 처럼 사용, 하지만 터미널 창으로는 출력 불가)
		NDK 내부에서 __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__) 명령을 사용해서 LogCat 창에
		관련 로그 사항 출력하기
		1)	Android.mk에 다음 추가
			LOCAL_LDLIBS := -llog
		2)	로그 사항 출력하고자 할 *.c 파일에 하기 사항 추가
			#include <android/log.h>

			#define  LOG_TAG    "your-log-tag"
			#define  LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
			#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
			#define  printf(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)		
			........................................................
			LOGD("Hello world");
			LOGE("Number = %d", any_int);
		cf)	Android.mk를 include $(BUILD_EXECUTABLE) 속성으로 build 시켜서(ndk-build)
			평가 보드 -> RS232 터미널 창에서 NDK 실행 파일을 곧바로 실행 시키면(./mango64LED_simple_app)
			printf 문의 내용이 RS232 터미널 창에 표시 되지만
			
			Android.mk를 include $(BUILD_SHARED_LIBRARY) 속성으로 build 시켜서(ndk-build)
			*.apk 형식으로 실행시키면 printf 문의 내용이 RS232 터미널 창에 표시되지 않음
			이 경우는 상기 LogCat으로만 내부 사항을 출력시킬 수 밖에 없음
		cf)	ndk-build clean 	-> clean 명령
			ndk-build			-> build 명령
	15)	jni
		0)	Android res에 포함된 파일 JNI에서 접근하기

				안드로이드에서는 이미지나 사운드 등의 파일을 res에 넣어두고,				
				불러다가 사용할 수 있다.				
				하지만, 이는 JAVA에서 사용할 수 있다는 것이고,				
				만약 JNI를 통해 C에서 이 파일을 접근하려면 어려움이 있다.				
				먼저 배포가 apk로 되어 다이렉트로 접근이 불가능하여 				
				apk를 unzip(?)해야 접근할 수 있다는 것이다.				
				assets에 파일을 두어 AssetManager를 통해 접근도 가능하겠지만,(이 방법 밖에 없는 것 같고, 이 방법이 가장 사용하기 쉽고 간단함)
				res에 넣은 파일을 사용하려면 파일을 다른곳으로 복사해준 뒤 그곳으로 접근하여 사용해야 한다.				
				sdcard에 넣는 방법도 있으나, 배포 및 삭제시에 깔끔하게 되길 바라기 때문에 이렇게 하는 것이다.					
				그러기 위해선 어플리케이션이 실행될 때, 파일이 해당 경로에 존재하는지 체크하고,				
				없다면 복사를 해주는 작업인 것이다.				
				onCreate안에서 수행되게 해 보았다.


				// Resource Check -->
				String strbellPath = 
				"/data/data/kr.ac.eslab.aldehyde7.ResourceTest/files/bell.snd";
				try {
					CopyIfNotExist(R.raw.bell, strbellPath);
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}   
				// <-- Resource Check

				파일 존재여부 체크
				public void CopyIfNotExist(int resID, String target) throws IOException
				{
					File targetFile = new File(target);
					if (!targetFile.exists()) 
					{   
						CopyFromPackage(resID,targetFile.getName()); 
					}
				}

				파일 복사 
				public void CopyFromPackage(int resID, String target) throws IOException
				{
					FileOutputStream lOutputStream = openFileOutput(target, Context.MODE_PRIVATE); 
					InputStream lInputStream = getResources().openRawResource(resID);
					int readByte;
					byte[] buff = new byte[8048];

					while (( readByte = lInputStream.read(buff))!=-1) 
					{
						lOutputStream.write(buff,0, readByte);
					}
				    
					lOutputStream.flush();
					lOutputStream.close();
 					lInputStream.close();
				} 

				이렇게 하면 /data/data/패키지/files 아래에 파일이 복사된 것을 확인할 수 있다. 
				이 경로를 가지고 파일을 열거나 사용하면 될 것이다 ^^ 

		cf)	
				2020-01-28 17:30:38.791 21396-21396/app.nemoin D/[nemo_analyzer]: Java_app_nemoin_camera_ConnectJNI_SetResourceCount = 1
				2020-01-28 17:30:38.791 21396-21396/app.nemoin D/NEMONEMO: tttttttttt initOcrApi
				2020-01-28 17:30:38.793 21396-21396/app.nemoin D/NEMONEMO: tttttttttt makeFolder
				2020-01-28 17:30:38.793 21396-21396/app.nemoin D/NEMONEMO: file ============== NanumSquare.traineddata
				2020-01-28 17:30:38.793 21396-21396/app.nemoin D/NEMONEMO: tttttttttt makeFolder
				2020-01-28 17:30:38.793 21396-21396/app.nemoin D/NEMONEMO: file ============== OCRA.traineddata
				2020-01-28 17:30:38.793 21396-21396/app.nemoin D/NEMONEMO: tttttttttt makeFolder
				2020-01-28 17:30:38.793 21396-21396/app.nemoin D/NEMONEMO: file ============== lib_005.so
				2020-01-28 17:30:39.039 21396-21396/app.nemoin I/Tesseract(native): Initialized Tesseract API with language=OCRA
				2020-01-28 17:30:39.039 21396-21396/app.nemoin D/NEMONEMO: tttttttttt makeFolder
				2020-01-28 17:30:39.049 21396-21396/app.nemoin D/NEMONEMO: onResume
				2020-01-28 17:30:39.053 21396-21396/app.nemoin V/SoundPool: load: fd=58, offset=3449412, length=44721, priority=1
				2020-01-28 17:30:39.053 21396-21396/app.nemoin V/SoundPool: create sampleID=1, fd=62, offset=44721 length=3449412
				2020-01-28 17:30:39.054 21396-21451/app.nemoin V/SoundPool: Start decode
				2020-01-28 17:30:39.054 21396-21451/app.nemoin V/SoundPool: fd 62, offset 3449412, size 44721


		1)	JNI 에서 JAVA로 배열 DATA 전송
			JNI programming - (5) 배열 다루기 2엄철웅http://forum.falinux.com/zbxe/index.php?document_srl=5712142012.07.15 21:34:08 (*.88.147.16) 39020JNI 를 통해 배열을 다루는 방법 중, 지난 강좌에 못 다룬 부분들에 대한 내용을 추가해 보겠습니다

			JNI 에서는 c/c++ 레벨에서 java 배열을 생성하고, 값을  set 하는 함수를 제공하고 있습니다.

			===== (5) 배열 다루기 2 =================================================================
			
			1. 예제
			MainStart.java
			
			public class MainStart
			{
			        public static void main(String[] args) {
			                int[] iArray;
			
			                iArray = JniFunctions.makeIntArray(10);
			                JniFunctions.setIntArray(iArray, 123);
			
			                System.out.println("Array len = " + iArray.length);
			                for(int i=0; i<iArray.length; i++) {
			                        System.out.println("Array [" + i + "] = " + iArray[i]);
			                }
			        }
			}
			
			
			JniFunctions.java
			
			public class JniFunctions {
			        static {
			                System.loadLibrary("mylib");
			        }
			
			        public static native int[] makeIntArray(int len);
			        public static native int setIntArray(int[] arr, int value);
			
			}
			 
			c/c++ 레벨에서 배열을 생성해서 반환하는 함수 : makeIntArray()
			c/c++ 레벨에서 배열에 값을 설정하는 함수 : setIntArray()
			
			
			JniFunctions.cpp
			
			#include <jni.h>
			#include <stdio.h>
			#include <stdlib.h>
			
			#ifdef __cplusplus
			extern "C" {
			#endif
			
			JNIEXPORT jintArray JNICALL Java_JniFunctions_makeIntArray
			  (JNIEnv *env, jclass cls, jint arr_len)
			{
			        jintArray ji_array = NULL;
			        ji_array = env->NewIntArray(arr_len);
			
			        if(ji_array != NULL) {
			                printf("In JNI >> new int array : %d\n", arr_len);
			                return ji_array;
			        }
			        else {
			                printf("In JNI >> fail make new int array\n");
			                return NULL;
			        }
			}
			
			JNIEXPORT jint JNICALL Java_JniFunctions_setIntArray
			  (JNIEnv *env, jclass cls, jintArray ji_array, jint value)
			{
			        int len, i;
			        jint *int_buf;
			
			        len = env->GetArrayLength(ji_array);
			        int_buf = (jint *)malloc(sizeof(jint) * len);
			        if(int_buf == NULL) {
			                printf("In JNI >> fail allocate memory\n");
			                return 0;
			        }
			
			        for(i=0; i<len; i++)
			                int_buf[i] = value;
			        env->SetIntArrayRegion(ji_array, 0, len, (const jint *)int_buf);
			
			        free(int_buf);
			
			        return len;
			}
			
			#ifdef __cplusplus
			}
			#endif
			 
			
			실행 및 결과
			
			$ javac JniFunctions.java
			$ javac MainStart.java
			$ g++ -shared -o libmylib.so JniFunctions.cpp -I/usr/lib/jvm/java-6-openjdk/include/ -I/usr/lib/jvm/java-6-openjdk/include/linux/
			$ export LD_LIBRARY_PATH=./
			$ java MainStart 
			In JNI >> new int array : 10
			Array len = 10
			Array [0] = 123
			Array [1] = 123
			Array [2] = 123
			Array [3] = 123
			Array [4] = 123
			Array [5] = 123
			Array [6] = 123
			Array [7] = 123
			Array [8] = 123
			Array [9] = 123
			
			2. 메모리 관리.
			NewIntArray() 와 SetIntArrayRegion() 을 사용하면서 메모리 관리에 대한 의문이 들 수 밖에 없다.
			java 의 가비지 콜렉터에게 맡기면 되는 것인지, c/c++ 레벨에서 free / release 를 해주어야 하는 것인지 정확히 구분하기 어렵다.
			NewIntArray() 의 경우는 생성된 배열을 return 시켜 java 레벨로 올려주므로 별도의 release 는 필요없을 것으로 생각된다.
			그러나 SetIntArrayRegion() 에서 argument 로 들어가는 jint * 는 c/c++ 에서만 사용하므로,
			malloc 을 했다면 반드시 free 를 해주어야 할 것이다.
			
			* JNI 가 정확한 자료나 책이 많지 않기때문에, 경험상 android source 에서 reference 를 구하는 것이 가장 좋다.

		2)	jni -> gpio 제어 예제(i.MX 보드상에서 구현)
			1)	하기 파일을 만든 다음 리눅스 상에서 make 를 실행시켜서 컴파일 시킴
				가)	Makefile
					#EXTRA_CFLAGS += -Who-declaration-fater-statement

					MODULES = gpio_driver
					
					#KERNEL_SOURCE = /home/beagleboard/linuxkernel/RobertCnelson-stable-kernel-6ce0908/KERNEL
					#KERNEL_SOURCE = /root/rowboat-android/kernel
					KERNEL_SOURCE = /root/myandroid/kernel_imx
					
					ARCH = arm
					
					#CURDIR = /home/beagleboard/gpiodrv
					CURDIR = $(shell pwd)
					
					#CROSS_COMPILE = arm-linux-gnueabi-
					CROSS_COMPILE = /usr/local/arm-2009q3/bin/arm-none-linux-gnueabi-
					CFLAGS =
					default: all
					
					obj-m += $(MODULES:%=%.o)
					
					BUILD = $(MODULES:%=%.ko)
					
					all: $(BUILD)
					
					clean:
						rm -f $(BUILD) *.o *.ko *.mod.c *.mod.o *~ .*.cmd Module.symvers
						rm -rf .tmp_versions
					
					$(MODULES:%=%.ko):	*c
						$(MAKE) CROSS_COMPILE=$(CROSS_COMPILE) ARCH=$(ARCH) -C $(KERNEL_SOURCE) SUBDIRS=$(CURDIR) M=$(CURDIR) modules
				나)	gpio_driver.c
					#include <linux/module.h>
					#include <linux/gpio.h>
					#include <linux/timer.h>
					#include <linux/delay.h>
					#include <linux/fs.h>
					#include <asm/uaccess.h>
					#include <linux/ctype.h>
					#include <linux/device.h>
					
					MODULE_LICENSE("Dual BSD/GPL");
					
					#define GPIODRIVER_NAME             "gpio_driver"
					
					static struct class *gpiodrive_class;
					
					#define FIRST_GPIO_PIN 3
					#define LAST_GPIO_PIN 24
					#define GPIO_TOTAL_COUNT (LAST_GPIO_PIN - FIRST_GPIO_PIN + 1)
					
					int pin[GPIO_TOTAL_COUNT];
					
					// mapping of gpio pin numbers with expansion pin numbers in beagleboard
					int pin_gpio[] = 
					{  
					139, /* PIN 3 */
					144, /* PIN 4 */
					138, /* PIN 5 */
					146, /* PIN 6 */
					137, /* PIN 7 */
					143, /* PIN 8 */
					136, /* PIN 9 */
					145, /* PIN 10 */
					135, /* PIN 11 */
					158, /* PIN 12 */
					134, /* PIN 13 */
					162, /* PIN 14 */
					133, /* PIN 15 */
					161, /* PIN 16 */
					132, /* PIN 17 */
					159, /* PIN 18 */
					131, /* PIN 19 */
					156, /* PIN 20 */
					130, /* PIN 21 */
					157, /* PIN 22 */
					183, /* PIN 23 */
					168  /* PIN 24 */
					};
					
					int gpiodrive_open(struct inode *inode, struct file *filp);
					int gpiodrive_release(struct inode *inode, struct file *filp);
					ssize_t gpiodrive_read(struct file *filp, char *buf, size_t count, loff_t *f_pos);
					ssize_t gpiodrive_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos);
					
					struct file_operations gpiodrive_funcs = {
					read: gpiodrive_read,
					write: gpiodrive_write,
					open: gpiodrive_open,
					release: gpiodrive_release
					};
					
					int gpioDrvMajor = 0; // Major number of driver - will be dynamically given from kernel
					int id=0; // minor number
					int gpioDrvOpen = 0; // is it opened?
					
					#define LED1_GPIO 2				// #define SABRESD_CHARGE_NOW	IMX_GPIO_NR(1, 2) -> IMX_GPIO_NR(1, 2) = (((1) - 1) * 32 + (2)) = 2
					//#define LED1_GPIO 64				// #define SABRESD_GPS_EN	IMX_GPIO_NR(3, 0) -> IMX_GPIO_NR(3, 0) = (((3) - 1) * 32 + (0)) = 64
					//#define LED2_GPIO 2
					
					// initialize driver
					static int gpiodrive_init(void) {
					    printk("<1>Initialize\n");
					    //need registration of this module.
					    gpioDrvMajor = register_chrdev(gpioDrvMajor, GPIODRIVER_NAME, &gpiodrive_funcs); // register character device driver
					    if (gpioDrvMajor < 0) // if failed, error
					    {
					        printk("<1>Init ERROR: %i\n", gpioDrvMajor);
					        return gpioDrvMajor;
					    }
					    printk("<1>major number=%i\n", gpioDrvMajor);
					
					    gpiodrive_class = class_create(THIS_MODULE, GPIODRIVER_NAME); // create driver class
					    device_create(gpiodrive_class, NULL, MKDEV(gpioDrvMajor, id), NULL, GPIODRIVER_NAME "%d", id); //device creation
					
					gpioDrvOpen = 1; // now the driver is opened
					
					    return 0;
					}
					
					int gpiodrive_open(struct inode *inode, struct file *filp) {
					    printk("<1>Open\n");
					gpio_request(LED1_GPIO,"gpioDrv");
					//gpio_request(LED2_GPIO,"gpioDrv");
					
					gpio_direction_output(LED1_GPIO,0);						// gpio_direction_output(LED1_GPIO,0);에서 0의 뜻은 입력을 뜻하는 것이 아닌 출력포트로 선정하고 초기값을 0으로 한다는 뜻임
					//gpio_direction_output(LED2_GPIO,0);
					
					
					    return 0;
					}
					
					ssize_t gpiodrive_read(struct file *filp, char *buf, size_t count, loff_t *f_pos) {
					char buffer[2] = {0};
					
					    printk("<1>Read\n");
					buffer[0]=gpio_get_value(LED1_GPIO);
					//buffer[1]=gpio_get_value(LED2_GPIO);
					copy_to_user(buf, buffer, 2);
					    return 0;
					}
					
					ssize_t gpiodrive_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos) {
					char buffer[2] = {0};
					printk("<1>Write\n");
					copy_from_user(buffer, buf, 2);
					// add
					printk("buffer[0]=%d\n", buffer[0]);
					//printk("buffer[1]=%d\n", buffer[1]);
					// add
					gpio_set_value(LED1_GPIO, buffer[0]);
					//gpio_set_value(LED2_GPIO, buffer[1]);
					
					return 0;
					}
					
					int gpiodrive_release(struct inode *inode, struct file *filp) {
					printk("<1>Release\n");
					gpio_free(LED1_GPIO);
					//gpio_free(LED2_GPIO);
					return 0;
					}
					
					static void gpiodrive_exit(void) {
					gpioDrvOpen = 0;
					
					unregister_chrdev(gpioDrvMajor, GPIODRIVER_NAME); // unregister character device
					device_destroy(gpiodrive_class, MKDEV(gpioDrvMajor, id)); // destory the device
					printk("<1>Exit\n");
					}
					
					module_init(gpiodrive_init);
					module_exit(gpiodrive_exit);
				다)	/root/.bashrc 구성은 아래와 같음
					# add
					# /rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin:$PATH
					#export PATH=/opt/arm-2014.05/bin:$PATH
					export PATH=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin:$PATH
					export PATH=/usr/local/arm-2009q3/bin:$PATH
					alias cdwin='cd /media/sf_C_DRIVE/"Program Files"/Default.corp/IP/TI/BeagleBoard-xM/program'
					# add

			2)	리눅스 ~/myandroid/out/target/product/sabresd_6dq/root/init.rc 내부에 shell script를 추가시킴(추천 방법으로, shell script(*.sh) 파일 내부의 명령만 간단히 수정하면 수정 사항이 곧바로 적용 됨)
				가)	gpio_driver.sh를 하기와 같이 작성해서 Target board /data folder에 복사 시킴
					#!/system/bin/sh
					# test

					insmod /data/gpio_driver.ko
					chmod 777 /dev/gpio_driver0
				가+1)상기 1)번 make 명령을 실행시켜서 생성된 gpio_driver.ko 파일을 Target board /data folder에 복사 시킴
				나)	~/myandroid/out/targer/product/sabresd_6dq/root 안에 있는 init.rc 파일을 수정한 다음
					중요)	init.rc 파일 맨 아래에 아래와 같이 추가하면 shell 명령이 실행되고 그 안에 있는 insmod 와 chmod 명령도 정상적으로 수행 됨
							
					# add, 아래 명령 확실히 실행됨 확인
					#		shell script로 처리하면 구성된 명령 수정 시 shell 명령만 수정하면 되기 때문에 간단히 구성 명령을 수정할 수 있음
					#		만약, init.rc 상에서 직접 명령을 추가한 경우라면 구성 명령 수정시
					#		boot.img를 다시 build하고 SD Memory에 writing 하는 작업을 거쳐야 하기 때문에 구성 명령 수정이 상당히 오려 걸림
					service gpio_driver /system/bin/sh /data/gpio_driver.sh
						class main
						console
						user root
						group root
						oneshot
					# add

				다)	"cf)	전체 소스에서 일부분만 다시 빌드(X:\root\myandroid\kernel_imx 내부의 kernel image Rebuild)"을 참고 해서 boot image를 rebuild 시킨 다음
				라)	i.MX6 SD-Memory를 reader에 연결시켜서 Ubuntu OS에 연결시킨 후
				마)	"-> [71]	i.MX6(i.MX 6 Series SABRE for Smart Devices) -> 3)	SD Memory/eMMC 로 부팅 하기 -> 가) Android 부팅" 명령을 참고해서 Writing 하면 됨

			3)	Eclipse java source(/Pjt_008_mango64LedApp4_iMX6) 상에서 jni 폴더를 만들고 하기 소스를 복사 시킴
				가)	Android.mk
					LOCAL_PATH:= $(call my-dir)
					include $(CLEAR_VARS)
					LOCAL_MODULE    := 	mango64LED_lib
					LOCAL_SRC_FILES := 	mango64LED_lib.c
					# add
					LOCAL_LDLIBS := -llog
					# add
					include $(BUILD_SHARED_LIBRARY)
				나)	mango64LED_lib.c
					#include <jni.h>
					#include <stdio.h>
					#include <sys/types.h>
					#include <sys/stat.h>
					#include <sys/ioctl.h>
					#include <fcntl.h>
					#include <unistd.h>
					// add
					#include <android/log.h>
					#include <string.h>
					#include "mango64LED_lib.h"
					
					#define  LOG_TAG    "NDK_LED"
					#define  LOGV(...)  __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
					#define  LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
					#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
					#define  printf(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
					// add
					
					//#define MANGO64_LED_DEVICE_NAME   "/dev/mango64_led_device"
					// fix
					//#define MANGO64_LED_DEVICE_NAME   "/sys/class/leds/chg_now_led/brightness"
					#define MANGO64_LED_DEVICE_NAME   "/dev/gpio_driver0"
					// fix
					
					static int g_mango64_led_dev = -1;
					
					jint Java_com_crz_mango64LED_JniFunctions_Mango64LedOpen(JNIEnv * env, jobject thiz)
					{
						// temp
						printf("OK, hohoho printf\n");
						// temp
					
						// add
					//	system("/data/busybox/bin/su");
						system("insmod /data/gpio_driver.ko");
						system("chmod 777 /dev/gpio_driver0");
					//	system("insmod /data/gpio_driver.ko");
					//	system("chmod 777 /dev/gpio_driver0");
					
					//	system("cp /data/gpio_driver.ko /data/test.ko");				// 진짜로 실행됨 확인
					//	system("mkdir /data/testdirectory");								// 진짜로 실행됨 학인
					
					//	system("./data/gpio_driver.sh");
						// add
						LOGV("[NDK_LIB] mango64 LED device open start\n");
					    g_mango64_led_dev = open(MANGO64_LED_DEVICE_NAME, O_RDWR|O_NDELAY);
					    if(g_mango64_led_dev < 0)
					    {
					    	LOGV("[NDK_LIB] mango64 LED open error, dev:%d\n", g_mango64_led_dev);
					        return -1;
					    }
					    LOGV("[NDK_LIB] mango64 LED open success, dev:%d\n", g_mango64_led_dev);
					    return 0;
					}
					
					jint Java_com_crz_mango64LED_JniFunctions_Mango64LedClose(JNIEnv * env, jobject thiz)
					{
						LOGV("[NDK_LIB] device file close start\n");
					    close(g_mango64_led_dev);
					    g_mango64_led_dev = -1;
					    LOGV("[NDK_LIB] device file close end\n");
					    return 0;
					}
					
					jint Java_com_crz_mango64LED_JniFunctions_Mango64LedControl(JNIEnv * env, jobject thiz, jint ledNum, jint ledOnOff)
					{
						LOGV("[NDK_LIB] mango64 LED %d OnOff %d\n", ledNum, ledOnOff);
					    if(g_mango64_led_dev < 0)
					    {
					    	LOGV("[NDK_LIB] mango64 LED dev error, dev:%d\n", g_mango64_led_dev);
					        return -1;
					    }
					//	return (jint)(ioctl(g_mango64_led_dev, ledNum, ledOnOff));
						// fix
						#if 0
						static char buff[100] = {0};
						int nCount = 2;
						
						buff[ledNum-1] = ledOnOff;
						write(g_mango64_led_dev, (void*)buff, nCount);
						
						return 0;
						#elif 0
						/*	echo 1 > /sys/class/leds/chg_now_led/brightness		으로 제어 하는 경우	*/
						static char buff[2] = {0};
						int nCount = 1;
					
					//	buff[0] = ledOnOff;
						if(ledOnOff > 0)
							buff[0] = '1';
						else
							buff[0] = '0';
						write(g_mango64_led_dev, (void*)buff, nCount);
					
						return 0;
						#else
						/*	echo -e '\1''\1' > /dev/gpio_driver0	으로 제어 하는 경우	*/
						static char buff[2] = {0};
						int nCount = 1;
					
					//	buff[0] = ledOnOff;
						if(ledOnOff > 0)
							buff[0] = 1;
						else
							buff[0] = 0;
						write(g_mango64_led_dev, (void*)buff, nCount);
					
						return 0;
						#endif
						// fix
					}
					
					// add
					jstring Java_com_crz_mango64LED_JniFunctions_JniTest(JNIEnv * env, jobject thiz, int iNum1, int iNum2)
					{
						char buff[10] = {10,11,12,13,14,15,16,17,18,19};
						char buff2[10] = {0};
						char buff3[128] = {0};
						char *pBuff = buff;
					
						int i = 0;
					
						for(i = 0; i<10; i++)
						{
					//		buff2[i] = *(pBuff++);				// 이 경우도 buff2에 buff와 똑같은 10 ~ 19의 값이 들어 감, cf) ++ 명령이 마지막에 실행 됨
							buff2[i] = *pBuff++;				// buff2에 buff와 똑같은 10 ~ 19의 값이 들어 감
					
							printf("buff2[%d]=%d\n", i, buff2[i]);
						}
					
						sprintf(buff3, "iNum1 = %d, iNum2 = %d", iNum1, iNum2);
					//	return (*env)->NewStringUTF(env, "Hello ndk. 1234567890");
						return (*env)->NewStringUTF(env, buff3);
					}
					
					#if 1
					void Java_com_crz_mango64LED_JniFunctions_JniTest2(JNIEnv *env, jclass class3, jobject obj)
					{
						jclass class2;
						class2 = (*env)->GetObjectClass(env, obj);
					
						jfieldID fid;
						TestStruct stTest = {0};
					
						int i = 0;
					
						fid = (*env)->GetFieldID(env, class2, "nA", "I");
						stTest.nA = (*env)->GetIntField(env, obj, fid);
					
						fid = (*env)->GetFieldID(env, class2, "nB", "I");
						stTest.nB = (*env)->GetIntField(env, obj, fid);
					
						fid = (*env)->GetFieldID(env, class2, "nC", "I");
						stTest.nC = (*env)->GetIntField(env, obj, fid);
					
						printf("stTest.nA=%d\n", stTest.nA);
						printf("stTest.nB=%d\n", stTest.nB);
						printf("stTest.nC=%d\n", stTest.nC);
					
						stTest.nC = 1234;
					
						fid = (*env)->GetFieldID(env, class2, "nC", "I");
						(*env)->SetIntField(env, obj, fid, stTest.nC);
					}
					#endif
					// add
				다)	mango64LED_lib.h
					typedef struct
					{
						int nA;
						int nB;
						int nC;
					} TestStruct;
			4)	윈도우 ~/cygwin/Cygwin.bat 실행
				cf)	Cygwin.bat
					@echo off

					chdir bin
					
					bash --login -i 
				가)	cd / -> cd cygdrive/ -> cd c -> cd "~/workspace/Pjt_008_mango64LedApp4_iMX6"
				나)	ndk-build 실행
			5)	Eclipse java source(/Pjt_008_mango64LedApp4_iMX6/src/com/crz/mango64LED)
				가)	mango64LedApp.java
					package com.crz.mango64LED;

					import java.io.IOException;
					
					import android.app.Activity;
					import android.os.Bundle;
					import android.view.View;
					import android.widget.Button;
					
					public class mango64LedApp extends Activity {
						private int clickState_led1 = 0;
						private int clickState_led2 = 0;
					
						// add
						// JniFunctions cJni = new JniFunctions();
						JniFunctions cJni = new JniFunctions();
						CTestObj cTestObj = new CTestObj();
					
						// add
					
						/** Called when the activity is first created. */
						@Override
						public void onCreate(Bundle savedInstanceState) {
							super.onCreate(savedInstanceState);
							setContentView(R.layout.main);
					
							final Button bt1 = (Button) findViewById(R.id.Button01);
							bt1.setOnClickListener(new View.OnClickListener() {
								public void onClick(View v) {
									clickState_led1 ^= 0x1;
									if (0 == clickState_led1) {
										cJni.Mango64LedControl(1, 0);
										bt1.setText(R.string.led1Off);
									} else {
										cJni.Mango64LedControl(1, 1);
										bt1.setText(R.string.led1On);
									}
								}
							});
					
							final Button bt2 = (Button) findViewById(R.id.Button02);
							bt2.setOnClickListener(new View.OnClickListener() {
								public void onClick(View v) {
									clickState_led2 ^= 0x1;
									if (0 == clickState_led2) {
										cJni.Mango64LedControl(2, 0);
										bt2.setText(R.string.led2Off);
									} else {
										cJni.Mango64LedControl(2, 1);
										bt2.setText(R.string.led2On);
									}
								}
							});
					
							cJni.Mango64LedOpen();
							// temp
							cJni.Mango64LedControl(1, 1);
							cJni.Mango64LedControl(2, 1);
					
							cJni.Mango64LedControl(1, 0);
							cJni.Mango64LedControl(2, 0);
					
							String test = cJni.JniTest(77, 78);
							System.out.printf("Return of cJni.JniTest = %s\r\n", test);
					
							/*
							 * int iArray[];
							 * 
							 * JniTest2(iArray, 123);
							 * 
							 * System.out.println("Array len = " + iArray.length); for(int i = 0;
							 * i<iArray.length; i++) { System.out.println("Array [" + i + "] = " +
							 * iArray[i]); }
							 */
							cTestObj.nA = 77;
							cTestObj.nB = 777;
							cTestObj.nC = 77777;
					
							cJni.JniTest2(cTestObj);
					
							System.out.println("cTestObj.nA = " + cTestObj.nA);
							System.out.println("cTestObj.nB = " + cTestObj.nB);
							System.out.println("cTestObj.nC = " + cTestObj.nC);
							// temp
					
							// temp
							/*
							 * 하기와 같이 별 방법을 다 사용해도 Runtime.getRuntime().exec -> chmod 명령이 아예 동작하지 않기
							 * 때문에(cp 명령 등 도 동작하지 않음) Android -> image_folder -> rootfs.tar.bz2 ->
							 * ueventd.rc 파일을 수정하는 방법으로 하기 /dev/i2c-2 의 속성을 변경 시킴
							 */
							/*
							 * try { Runtime.getRuntime().exec("chmod 777 /dev/i2c-2");
							 * Runtime.getRuntime().exec(new String[]{"su", "-c",
							 * "chmod 777 /dev/i2c-2"}); } catch (IOException e) {
							 * System.out.println(e.getMessage()); }
							 */
					
							// cJni.I2COpen();
							// cJni.I2CControl(0, 0);
							// temp
						}
					
						@Override
						protected void onDestroy() {
							cJni.Mango64LedClose();
							// add
							// cJni.I2CClose();
							// add
							super.onDestroy();
						}
					}
				나)	JniFuctions.java
					package com.crz.mango64LED;

					import android.app.Activity;
					import android.os.Bundle;
					import android.view.View;
					import android.widget.Button;
					
					public class JniFunctions extends Activity {
						public native int Mango64LedOpen();
						public native int Mango64LedClose();
						public native int Mango64LedControl(int ledNum, int ledOnOff);
						// add
						public native int I2COpen();
						public native int I2CClose();
						public native int I2CControl(int ledNum, int ledOnOff);
						public native String JniTest(int ledNum, int ledOnOff);
						public native void JniTest2(CTestObj cTestObj);
						// add
						
						public native int unimplementedMango64LedOpen();
						public native int unimplementedMango64LedClose();
						public native int unimplementedMango64LedControl(int ledNum, int ledOnOff);
						// add
						public native int unimplementedI2COpen();
						public native int unimplementedI2CClose();
						public native int unimplementedI2CControl(int ledNum, int ledOnOff);
						public native String unimplementedJniTest(int ledNum, int ledOnOff);
						public native void unimplementedJniTest2(CTestObj cTestObj);
						// add
					
					    static {
					    	System.out.println("Load of mango64LED_lib");
					        System.loadLibrary("mango64LED_lib");
					    }	
					}
			6)	Eclipse -> Build 후 -> Target board로 전송 시킨 후(*.apk) 실행시키면 됨
					
	16)	Eclipse	eclipse 이클립스
		1)	#include <jni.h> 등의 해당 파일이 있는지 확인하려면
			#include <jni.h> 부분에 Ctrl 키를 누른 다음 마우스를 클릭하면 해당 파일로 이동
		2)	Eclipse 편집기 창 여러개 띄우기
			찾아보니 단순히 위에 탭을 끌어다가 편집기 영역의 가장자리 여백 부분 근처까지 가면 마우스 커서가 상하좌우 삼각형(▲▼◀▶)모양으로 바뀌는데,
			이 때 마우스를 떼면 그 위치에 편집기 창이 새로 생성된다. 알고나니 별거 아니었음.
		3)	액티비티 스택
			액티비티를 차곡차곡 쌓아 두었다가 가장 상위에 있던 액티비티가 없어지면 이전의 액티비티를
			다시 실행하도록 도와줌.
			동일한 액티비티를 여러번 실행한다면 동일한 액티비티가 여러개 스택에 들어가 있고 동시에
			데이터를 여러번 접근하거나 리소스를 여러번 사용하는 문제가 발생할 수 있다.
		4)	[Eclipse] 이클립스 프로젝트 복사해서 사용하기  Tools  2013/07/09 12:16
			1.	방법1
				해당 프로젝트 선택 -> Edit - copy -> Edit - paste -> Project name : 다른 이름으로 변경 -> OK
				이렇게만 해도 다른 이름으로 변경된 프로젝트의 소스를 수정하면 변경된 내용이 적용 됨
				단, Target board에서는 기존 원본 프로젝트와 동일한 프로젝트 명으로 처리되며
				기존 프로젝트의 소스가 변경된 것으로 처리되는 방식 임 

			2.	방법2(정말 본 방법2 설명하는 대로 실행하면 정확하게 프로젝트가 다른 프로젝트 이름으로 복사 됨)
			http://withcoding.com/12
			1)	복사 할 프로젝트를 선택합니다. 그리고 Ctrl + C를 누른 후 바로  Ctrl + V
			2)	AndroidManifest.xml 파일 수정하기
				AndroidManifest.xml 파일의 package="*.*.*"의 내용 만 변경
			3)	패키지(Package) 이름 변경하기
				가)	'프로젝트명 - src - 패키지명'에서 오른쪽 마우스 클릭을 하면 위와 같은 팝업메뉴가 나타나는데
					여기서 Refactor - Rename을 선택합니다.
				나)	Rename Package 대화상자가 나타나면 New name 부분을 원하는 패키지 이름으로 변경합니다. 
					다양한 옵션이 있는데 이것들은 그냥 디폴트로 두고 바로 OK 버튼을 누릅니다.
					([v]Update references만 선택하고 나머지는 모두 선택하지 않음)
				다)	Package 'com.example.helloworld2' already exists in the project in folder 'gen' 오류가 뜨는데
					그냥 무시하고 Continue 를 선택
			4)	만약에 이렇게까지 했는데 소스코드에서 오류가 나면 '프로젝트명 - src - 패키지명'을 클릭한 후
				Ctrl + Shift + o 단축키를 누르세요. 그러면 자동으로 import문을 조절하게 되고 소스코드에 있던 오류도 사라지게 됩니다.
			5)	strings.xml 파일에서 앱 이름 변경하기
				가)	앱의 이름을 그냥 동일하게 사용하고 싶다면 이 작업은 그냥 생략해도 되지만 보통의 경우는 앱 이름을 수정하게 됩니다.
					안드로이드 프로그래밍에서는 보통 문자열을 res - values - strings.xml 파일에서 관리합니다. 
					이 파일 클릭하면 위와 같은 화면이 나오는데 여기서도 매니페스트 파일처럼 소스에서 직접 수정하기 위해 string.xml 탭을 클릭합니다.
				나)	정말 간단하게 name 속성이 app_name이라고 되어있는 곳의 값을 수정하기만 하면 됩니다. 

			3.	방법3
			http://blog.naver.com/webwizard83/60195583184 
			이클립스는 .project 파일 안에 <name> 속성으로 프로젝트를 구분합니다.
			그래서 <name>이 동일한 프로젝트는 동시에 로딩할 수 없습니다.
			따라서 프로젝트 폴더 복사후, <name>의 내용을 다른 것으로 변경해 주면 됩니다.
			그리고 프로젝트 로드하여 AndroidManifest.xml 파일의 package="*.*.*"의 내용도 변경해 줍니다.
			1)	프로젝트 -> 다른 이름의 폴더로 복사
			2)	.project -> <name> 의 내용 변경된 폴더 이름으로 변경(Navigator로 열어야 지만 .project 파일 보임)
			3)	AndroidManifest.xml 파일의 package="*.*.*"의 내용 변경된 폴더 이름으로 변경
			4)	Package Explorer 상에서 -> src -> 해당 package 이름 -> 오른쪽마우스 -> Refactor -> Rename 실행해서 -> 변경된 폴더 이름으로 변경
			
			cf)	package 이름을 변경하거나 class 이름을 변경하거나, method 이름을 변경하거나
				Refactor -> Rename을 실행해서 변경하면 프로젝트 내부에 있는 해당 이름을 전부(?) 변경 시켜 줌
		5)	Eclipse 개발툴_소스파일 붙여 넣을 경우 변경사항이 적용되도록 하는 방법
			소스등을 다른곳에서 복사해서 붙여 넣는 경우 별별 방법을 다 해도 변경된 사항이 적용되지 않는 에러가 발생함
			이런 경우에는 복사한 파일을 약간 수정해주거나(띄어쓰기 등을 추가)
			파일을 붙여넣기로 붙여 넣지 말고 File -> import 기능으로 넣어 주면 파일 변경 사항이 제대로 적용됨.
		6)	eclipse 프로그램 toolbar에 "undo/redo" 버튼 추가 방법
			http://www.foglyn.com/misc/undoredo_1.0.0.jar 파일을
			C:\Program Files\Android\adt-bundle-windows-x86\eclipse\dropins 폴더에 복사 시킨 후
			eclipse 프로그램 OFF -> ON 시킴
		7)	선택한 단어를 특정 색상으로 강조 하기(문서 중에서 선택한 단어에 해당하면 모두 특정 색상으로 강조 됨)
			가)	단어를 선택하고 -> 툴바에서 형광팬 같이 생긴 아이콘을 클릭하면 됨(Alt+Shift+O, Toggle Mark Occurrences)
			나)	색상 변경은 Preference -> General -> Editors -> Text Editors -> Annotations -> Occurrences -> Color 색상 변경
		8)	Eclipse, Search
			Search -> File Search
			-	Containing text		:	찾고자 하는 단어 입력
			-	File name patterns	:	*
			-	[]Consider derived resources
			-	Scope				:	Selected resources(현 선택된 파일에서만) or Enclosing projects(현 선택된 파일이 속한 프로젝트 모두에서만)
			cf)	[]Whole word 옵션이 존재하지 않으며 대처 방법은 아래와 같이 찾으면 sub 문구만 있는 파일만 찾아 줌
				가)	Containing text : \bsub\b
				나)	[v]Regular expression
		9)	Eclipse 실행 시키면 "Android SDK Content Loader: (0%)" 상태가 계속 유지되기만 하고 더 이상 진행되지 않는 에러 해결 방법
//			1-4.방법1-4
//				Eclipse -> Window -> Preferences -> General -> Startup and Shutdown -> [v]Refresh workspace on startup
			1-3.방법1-3
				C:\Program Files\Program\Java\workspace\.metadata\.plugins\org.eclipse.e4.workbench\workbench.xml 파일 삭제
			1-2.방법1-2
				cd C:\Program Files\Program\Java\workspace\.metadata\.plugins\org.eclipse.core.resources\.projects
				rm -rf *
			1-1.방법1-1
				여기에 고생한 흔적이..
				http://codedragon.tistory.com/428

				다 해보았는데 안되길래...
				C:\Users\KKim\.android 폴더에서 
				avd 폴더만 남기고 몽땅 old로 이동(혹시 몰라 백업한것임) 즉 나머지 모두 삭제후
				이클립스 재실행하면 
				ddms.cfg
				debug.keystore
				두개의 파일이 재생성되면 이클립스 정상동작댐...
			
			1.	방법1
				1)	상기 에러 메시지가 나오기 전 & ~error message 가 나온 바로 직후
					Eclipse 상에서 아무 프로젝트나 선택한 다음
					오른 쪽마우스버튼 -> Properties -> Android 를 선택하면 본 에러를 방지할 수 있는 것 같다.
			
			2.	방법2
				eclipse.exe-바로 가기 속성
				대상 : "C:\Program Files\Android\adt-bundle-windows-x86\eclipse\eclipse.exe" -clean -refresh
			
			3.	방법3
				C:\Program Files\Android\adt-bundle-windows-x86\eclipse\eclipse.exe -clean
			
			4.	방법3
			1.Make sure that eclipse is not active. If it is active kill eclipse from the processes tab of the task manager 
			2.Open %USERPROFILE%/ (You can locate this folder from desktop)
			3.Go to .android folder (This may be a hidden folder)
			4.Delete the folder "cache" which is located inside .android folder
			5.Delete the file ddms.cfg which is located inside .android folder
			6.Start eclipse
		9+1)Eclipse 실행 속도 빠르게 하고
			각각의 프로젝트 res -> Layout -> *.xml 수정 시 overhead gc heap memory 에러를 방지하려면 하기와 같이 수정하면 됨
			C:\Program Files\Android\adt-bundle-windows-x86\eclipse\eclipse.ini
			............................................................	
			-vmargs
			-Dosgi.requiredJavaVersion=1.8
			-XX:MaxPermSize=256m
			-Xverify:none
			-XX:+UseParallelGC
			-XX:-UseConcMarkSweepGC
			-Xms256m
			-Xmx1024m
			cf)	eclipse.ini 설명
			-Xverify:none					// 클래스 검사 생략. 이클립스 실행 시간이 줄어든다.
			-XX:+UseParallelGC				// Parallel Collector를 사용. 병렬 가비지 컬렉션.
			-XX:-UseConcMarkSweepGC			// 병행 mark-sweepGC 기능을 수행하여 GUI 응답 속도 처리			
			-XX:PermSize=32M				// 이클립스 클래스 로딩 기본 메모리
			-XX:MaxPermSize=128M			// 이클립스 클래스 로딩 최대 메모리
			-XX:NewSize=32M					// JVM에서 새로운 객체가 생성 될때 로딩되는 최소 영역
			-XX:MaxNewSize=32M				// JVM에서 새로운 객체가 생성 될때 로딩되는 최대 영역
			-Xms256m						// 이클립스 실행시 잡는 최소 메모리
			-Xmx256m						// 이클립스 실행시 잡는 최대 메모리
			* Xms와 Xmx를 똑같이 잡아 주는 이유는 이클립스가 메모리를 유동적으로 관리하는데 이걸 정적으로 고정시켜 주기 위해서이다.
			유동적으로 관리하게 놔두면 자바는 메모리가 부족할때 확보하려고 메모리 할당을 하게 되고 메모리의 여유가 있으면 남는 메모리를 
			조금씩 시스템으로 돌려버린다. 이러한 작업때문에 이클립스 속도가 더 느려지기에 아예 처음부터 최소값과 최대값을 고정시켜 버리면 
			불필요한 작업을 하지 않게 된다. 물론 메모리 값은 컴퓨터 사양에 따라 수정해주시면 된다. 			
			cf)	Android Studio 의 경우는
			~\Android\Android Studio\bin\studio64.exe.vmoptions
			
		9+2)Eclipse -> Run As 실행 시
			[에러] INSTALL_FAILED_UID_CHANGED 에러 해결 방법
			나는 루팅을 했기에, 루트탐색기를 이용하여 data/data 내부에 있는 해당 앱의 데이터를 직접 지웠다.
		10)	Eclipse 기본 폰트
			Consolas, 글꼴스타일(보통), 크기(10)
		11)	Eclipse Marketplace 설치(Eclipse 프로그램 상에서 간단하게 다양한 plug-in 프로그램 설치 시 필요한 프로그램)
			Help -> Install New Software -> Work with -> juno(내가 설치한 Eclipse 버전) -> juno - http://download.eclipse.org/releases/juno
			-> General Purpose Tools -> Marketplace Client -> Yes -> 설치 -> Help -> Eclipse Marketplace 가 삽입되어 있음
		12)	Eclipse Color Theme(여러가지 색상의 editor 편집창 선택 가능)
			가)	Help -> Eclipse Marketplace -> Search -> Find -> color theme -> Eclipse Color Theme 선택 & 설치
			나)	Window -> Preferences -> General -> Appearance -> Color Theme -> 선택
		13)	수작업으로 변경한 글꼴/색상 등의 설정 저장 방법
			File -> Export -> Preferences -> Next -> [v]Export all -> Browse -> 저장폴더선택 -> Finish
		14)	자동 정렬 기능(소스 정리)
			Tab, 띄어쓰기 등을 자동으로 맞춰주는 기능
			소스를 Drag로 선택한 후 Format(Ctrl + Shift + F) 를 누르면 자동 정렬 기능 구현
			cf) 소스 선택하지 않고 실행하면 소스 전체 정리
		15)	제목  안드로이드 앱개발, 이클립스(eclipse) 팁&트릭(tips and tricks), 단축키 http://sitehis.com/db_talk_352 
작성자  박선민   작성일  2014-11-09  조회  4002 
안드로이드 앱개발용 공짜지만 강력한 개바툴 eclipse 이클립스의 팁&트릭을 정리하여 봅니다.

공식 도움말
JAVA Deveolpment Tips & Tricks
http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.jdt.doc.user/tips/jdt_tips.html 
Eclips Tips and Tricks
http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.user/tips/platform_tips.html 

안드로이드 개발 환경 주요 환경 설정 변경 // 14/11/09
Proferences 
General > Apperance > Color and Fonts 
Basic > Text Font : 11pt 
Java > Code Style > Formatter > Active profile New... 생성 "Epclipse [buit-in] edit" 
Indentation
가운데 체크 Align field in columns 
Control Statments
가운데 체크 Keep simple 'if' on one line 
Line Wrapping
Maximum line width : 120 
Comments
Never Join lines  [체크]
Miximun Line width for comments : 120
  
주요 단축키(소스코드)
Ctrl+Space : Edit - Content Assist 
타이핑쳐야 되는데 혹은 문제발생시에 해결해주는 가장 중요한 키워드 
Alt+Shit+S : Source관련 팝업메뉴 
Ctrl+Shift+O : 자동 import 
Ctrl+Shift+F : 자동 format (소스 정리) 
Ctrl+/  : 한줄 주석(//..) 자동넣기/자동해제 
Ctrl+Shift+/ : 불럭주속(/* .. */) 자동 넣기 
Ctrl+Shift+\ : 불럭주속(/* .. */) 자동 해제 
Ctrl+I : 들여쓰기 잘못된 것 자동 수정 
Ctrl+Shift+F : 소스 정리  
Source 메뉴에 orverride 자동 생성등 추가 기능 있으니 아래 블로그 링크 참고하여 활용하세요 
참고 블로그

eclipse Source, Refactor 팝업메뉴 설명
http://blog.naver.com/skytear7?Redirect=Log&logNo=30073470100 
Refactor 기능관련
http://darkkaiser.cafe24.com/blog/106 
Debug 관련
http://wiki.dev.daewoobrenic.co.kr/mediawiki/index.php/Eclipse_debugging_guide 
 
- Eclipse 자주 쓰는 단축키 -
출처 : http://cafe.naver.com/androi.cafe?iframe_url=/ArticleRead.nhn%3Farticleid=28&

실행
Ctrl + F11 : 바로 전에 실행했던 클래스 실행 

소스 네비게이션
Ctrl + 마우스커서(혹은 F3) : 클래스나 메소드 혹은 멤버를 상세하게 검색하고자 할때 
Alt + Left, Alt + Right : 이후, 이전 
Ctrl + O : 해당 소스의 메소드 리스트를 확인하려 할때 
F4 : 클래스명을 선택하고 누르면 해당 클래스의 Hierarchy 를 볼 수 있다. 

문자열 찾기
Ctrl + K : 찾고자 하는 문자열을 블럭으로 설정한 후 키를 누른다. 
Ctrl + Shift + K : 역으로 찾고자 하는 문자열을 찾아감. 
Ctrl + J : 입력하면서 찾을 수 있음. 
Ctrl + Shift + J : 입력하면서 거꾸로 찾아갈 수 있음. 
Ctrl + F : 기본적으로 찾기 

소스 편집
Ctrl + Space : 입력 보조장치(Content Assistance) 강제 호출 => 입력하는 도중엔 언제라도 강제 호출 가능하다. 
F2 : 컴파일 에러의 빨간줄에 커서를 갖져다가 이 키를 누르면 에러의 원인에 대한 힌트를 제공한다. 
Ctrl + L : 원하는 소스 라인으로 이동 
로컬 히스토리 기능을 이용하면 이전에 편집했던 내용으로 변환이 가능하다. 
Ctrl + Shift + Space : 메소드의 가로안에 커서를 놓고 이 키를 누르면 파라미터 타입 힌트를 볼 수 있다. 
Ctrl + D : 한줄 삭제 
Ctrl + W : 파일 닫기 
Ctrl + I : 들여쓰기 자동 수정 
Ctrl + Shift + / : 블록 주석(/* */) 
Ctrl + Shift + \ : 블록 주석 제거 
Ctrl + / : 여러줄이 한꺼번에 주석처리됨. 주석 해제하려면 반대로 하면 된다. 
Alt + Up(Down) : 위(아래)줄과 바꾸기 
Alt + Shift + 방향키 : 블록 선택하기 
Ctrl + Shift + Space : 메소드의 파라메터 목록 보기 
Ctrl + Shift + O : 자동으로 import 하기 
Ctrl + Shift + F4 : 열린 파일 모두 닫기 
Ctrl + M : 전체화면 토글 
Ctrl + Alt + Up(Down) : 한줄(블럭) 복사 
Ctrl + , or . : 다음 annotation(에러, 워닝, 북마크 가능)으로 점프 
Ctrl + 1 : 퀵 픽스 
F3 : 선언된 변수로 이동, 메소드 정의부로 이동 
Ctrl + T : 하이어라키 ?b업 창 띄우기(인터페이스 구현 클래스간 이동시 편리) 
Ctrl + O : 메소드나 필드 이동하기 
Ctrl + F6 : 창간 전환, UltraEdit 나 Editplus 의 Ctrl + Tab 과 같은 기능 

템플릿 사용
sysout 입력한 후 Ctrl + Space 하면 System.out.println(); 으로 바뀐다. 
try 입력한 후 Ctrl + Space 하면 try-catch 문이 완성된다. 
for 입력한 후 Ctrl + Space 하면 여러가지 for 문을 완성할 수 있다. 
템플릿을 수정하거나 추가하려면 환경설정/자바/편집기/템플릿 에서 할 수 있다. 

메소드 쉽게 생성하기
클래스의 멤버를 일단 먼저 생성한다. 
override 메소드를 구현하려면, 소스->메소드대체/구현 에서 해당 메소드를 체크한다. 
기타 클래스의 멤버가 클래스의 오브젝트라면, 소스->위임메소드 생성에서 메소드를 선택한다. 

organize import
자바파일을 여러개 선택한 후 소스->가져오기 체계화 해주면 모두 적용된다. 

소스 코드 형식 및 공통 주석 설정
환경설정 -> 자바 -> 코드 스타일 -> 코드 포멧터 -> 가져오기 -> 프로파일.xml 을 불러다가 쓰면 된다. 
또한 다수의 자바파일에 프로파일을 적용하려면 패키지 탐색기에서 패키지를 선택한 후 소스 -> 형식화를 선택하면 된다. 
환경설정 -> 자바 -> 코드 스타일 -> 코드 템플리트 -> 가져오기 -> 템플리트.xml 을 불러다가 쓰면 된다. 

에디터 변환
에디터가 여러 파일을 열어서 작업중일때 Ctrl + F6 키를 누르면 여러파일명이 나오고 F6키를 계속 누르면 아래로 
Ctrl + Shift + F6 키를 누르면 위로 커서가 움직인다. 
Ctrl + F7 : 뷰간 전환 
Ctrl + F8 : 퍼스펙티브간 전환 
F12 : 에디터로 포커스 위치 

이클립스 자주쓰는 단축키
Ctrl + / : 주석 처리 - 한 라인/블록에 대해 주석 처리 (추가 및 제거) 
Ctrl + L : 특정 라인으로 이동 
Ctrl + F6 : Editor 창간의 이동 
Ctrl + F7 : View 이동 메뉴 
Ctrl + F8 : Prespectives 이동 메뉴 
Ctrl + D : 한라인 삭제 - 커서가 위치한 라인 전체를 삭제 한다. 
Ctrl + J : Incremental find 이클립스 하단 상태 표시줄에 Incremental find 라고 표시되어 한 글자자씩 누를 때 마다 코드내의 일치하는 문자열로 이동 , 다시 Ctrl + J 를 누르면 그 문자열과 일치 하는 부분을 위/아래 방향키로 탐색이 가능하다. 
Ctrl + N : 새로운 파일 / 프로젝트 생성 
Ctrl + 1 (빠른교정) - 문 맥에 맞게 소스 교정을 도와 준다. 변수를 선언하지 않고 썼을경우 빨간색 에러 표시되는데 이 단축키를 적용하면 변수에 맞는 선언이 추가 되도록 메뉴가 나타난다. 
Ctrl + 0 : 클래스 구조를 트리로 보기 
Ctrl + Space : Cotent Assist - 소스 구문에서 사용 가능한 메소드, 멤버들의 리스트 메뉴를 보여준다. 
Ctrl + PageUp , Ctrl + PageDown : Edit 창 좌우 이동 - Edit 창이 여러개 띄워져 있을경우 Edit 창간의 이동 한다. 
Ctrl + Shift + Down : 클래스 내에서 다음 멤버로 이동 
Ctrl + Shift + M : 해당 객체의 Import 문을 자동 생성 - import 추가 할 객체에 커서를 위치 시키고 단축키를 누르면 자동적으로 import 문이 생성 
Ctrl + Shift + O : import 문을 자동 생성 - 전체 소스 구문에서 import 안된 클래스의 import 문을 생성해 준다. 
Ctrl + Shift + G : 해당 메서드 / 필드를 쓰이는 곳을 표시 - View 영역에 Search 탭에 해당 메서드 / 필드를 사용하는 클래스를 표시 해준다. 
Alt + Shift + R : Refactoring (이름변경) - Refactoing 으로 전체 소스에서 이름변경에 의한 참조 정보를 변경해 준다. 
F3 : 선언 위치로 이동 
F11 : 디버깅 시작 
F8 : 디버깅 계속 
F6 : 디버깅 한줄씩 실행(step over) 
F5 : 디버깅 한줄씩 실행 함수 내부로 들어감 (step into) 
F12 : Editor 창으로 이동 (Debugging 등 자동적으로 포커스가 이동 됐을경우 편리) 
Alt + Up , Alt + Down : 줄 바꿈 - 해당 라인을 위 / 아래로 이동 시킨다. 
Alt + Shift + S : Source Menu - 소스메뉴 (Import 추가 , Comment 추가 , 각종 Generator 메뉴) 가 나타난다. 
Alt + Shift + Up : 블록설정 - 소스 코드를 블록 단위로 설정해 준다. 
Alt + Shift + Down : 블록해제 - 소스 코드를 블록 단위로 해제한다. 
Alt + Shift + J : 주석 생성 - 해당 메서드/클래스에 대한 주석을 템플릿을 생성해 준다. 
sysout + (Ctrl + Space) : System.out.println() 문장 삽입 - 코드 템플릿을 이용해서 소스 구문을 추가 
(Windows -> Preferences -> JAVA -> Editor -> Templates 에서 자주 쓰는 소스 구문을 추가시키면 <템플릿 이름> + (Ctrl + Space) 로 소스 문장을 완성 시킬 수 있다.) 
Alt + Shift + Z : Surround With 메뉴 - try / catch 문이나 for , do , while 등을 해당 블록에 감싸주는 메뉴가 나타난다. 
Ctrl + Shift + F : 코드 포맷팅 - 코드 내용을 문법 템플릿에 맞게 포맷팅(들여쓰기) 해준다. 
Ctrl + Alt + Down : 한줄 복사후 아래에 복사 넣기 - Copy&Paste 대체하는 단축키. 커서가 위치한 라인을 복사해 밑줄에 생성해 준다. 
Ctrl + Shift +X : 대문자로 변환 
Ctrl + Shift + Y : 소문자로 변환 
Ctrl + Shift + L : 모든 단축키의 내용을 표시해준다. 
Ctrl + Shift + B : 현재 커서 라인에 Break point 설정 
Ctrl + Shift + T : 클래스 찾기 
 
이클립스 가니메데 활용법 단축키 모음
http://blog.naver.com/kyong94s/65753580

단축키 리스트 메뉴 (Show Key Assist): Ctrl + Shift + L 
빠른 Preferences 찾기 메뉴: Ctrl + 3 
편집 (Edit) 
빠른 교정: Ctrl + 1 
코드 자동완성 도움 (Content Assist): Ctrl + Space 
네비게이션 (Navigate) 
현재 클래스 상속관계 보기 (Open Type Hierarchy): F4 
간단한 클래스 상속관계 보기 (Quick Hierarchy): Ctrl + T 
현재 클래스 메서드, 맴버변수 보기 (Quick Outline): Ctrl + O 
리소스 찾기 (Open Resource): Ctrl + Shift + R 
찾기 다이얼로그 열기 (Open Search Dialog): Ctrl + H 
선언 위치로 이동 (Open Declaration): F3 
특정 줄번호로 가기 (Go to Line): Ctrl + L 
Java Editor에서 다음 member로 이동 (Go to Next Member): Ctrl + Shift + Down 
이전 작업 화면 : Alt + Left 
다음 작업 화면 : Alt+ Right 
리팩토링 (Refactor) 
리펙토링 메뉴 바로가기 (Refactor Quick Menu): Alt + Shift + T 
변수명, 클래스명 등 이름 변경 (Rename): Alt + Shift + R 
클래스, 인터페이스 등 이동 (Move - Refactoring): Alt + Shift + V 
소스 (Source) 
선택 영역 주석처리 (Add Block Comment): Ctrl + Shift + / 
주석처리된 영역 주석해제 (Remove Block Comment): Ctrl + Shift + \
  
한줄에 대한 주석 처리 (Toggle Comment): Ctrl +/ 
Javadoc타입의 주석처리 (Add Javadoc Comment): Alt + Shift + J 
XML 편집 시 주석처리 및 해제: Ctrl + Shift +C 
탬플릿에 따른 코드 포맷팅 (Format): Ctrl + Shift + F 
들여쓰기 (Indent Line): Ctrl + I 
불필요 import 제거 및 import문 자동 생성 (Organize Imports): Ctrl + Shift + O 
빠른 소스메뉴 (Source Quick Menu): Alt + Shift + S 
텍스트 편집 (Test Editing) 
줄 삭제 (Delete Line): Ctrl + D 
줄 복사 (Duplicate Lines): Ctrl + Alt + Up or Down 
현재 줄에 새로 추가 (Insert Line Above Current Line): Ctrl + Shift + Enter 
다음 문자로 이동 (Next Word): Ctrl + Right 
이전 문자로 이동 (Previous Word): Ctrl + Left 
다음 줄에 새로 추가 (Insert Line Below Current Line): Shift + Enter 
줄 위치 위로 바꿈 (Move Lines Up): Alt + Up 
줄 위치 아래로 바꿈 (Move Lines Down): Alt +Down 
현재 위치에서 라인 끝까지 삭제 (Delete to End of Line): Ctrl + Shift + Delete 
한글자씩 찿기 (Incremental Find): Ctrl + J 
이 클립스 창의 하단 상태 표시줄 부분에 Incremental Find라고 표시되며, 한글자씩을 누를 때마다 그곳에 입력된 글자가 보이고 코드내의 일치하는 문자열로 이동하게 된다. 입력을 끝내고 다시 Ctrl + J를 누르면 그 문자열과 일치하는 곳으로 커서가 이동하게 된다. 
System.out.println() 문장 삽입: 'sysout' + (Ctrl + Space) 
Surround With 메뉴: Alt + Shift + Z 
코드를 블록으로 선택한 다음 이 단축키를 적용하면 다음과 같은 퀵 메뉴가 나타나며 선택한 문장으로 블록으로 선택했던 문장들을 감싼다. 
대문자로 (To Upper Case): Ctrl + Shift + X 
소문자료 (To Lower Case): Ctrl + Shift + Y 
윈도우 (Window) 
새로운 파일 및 프로젝트 생성: Ctrl + N 
선택된 뷰 최대화 (Maximize Active View or Editor): Ctrl + M 
열려있는 에디터간 이동 (Switch to Editor): Ctrl + Shift + E 
좌/우 창 이동: Ctrl + Page Up / Ctrl + Page Down 
Properties 열기 (Properties): Alt + Enter 
실행 (Run) 
마지막 Run 구성 실행 (Run): Ctrl + F11 
빠른 Run 실행 메뉴 열기: Alt + Shift + X 
빠른 Debug 실행 메뉴 열기: Alt + Shift + D 
디버깅 (Debug) 
브레이크 포인터 설정/해제 (Toggle Breakpoint): Ctrl + Shift + B 
디버깅 시작 (Debug): F11 
디버깅 계속 (Resume): F8 
한줄씩 실행 (Step Over): F6 
한줄씩 실행하되 함수일 경우 그 함수 내부로 들어감 (Step Into): F5 
함수 외부로 벗어남 (Step Return): F7 
현재 라인까지 실행 (Run to Line): Ctrl + R 
		16)	자바를 사용하면 다음과 같은 것들을 만들 수 있다.
			자바 어플리케이션 (Java Application) : 자바 언어로 작성된 일반 응용 프로그램
			자바 애플릿(Java Applet) : 웹 브라우저 안에서 실행되는 프로그램
			자바 서블릿(Java Servlet) : 웹 서버에서 동작하는 모듈
			자바 서버 페이지(JSP, Java Server Page) : HTML문서 상에 자바 코드를 넣어 서버 측에서 실행
			자바 빈즈(Java Beans) : 자바로 작성된 컴포넌트, 컴포넌트를 조립하여 어플리케이션을 작성 가능
			안드로이드 어플리케이션(Android Application) : 스마트폰의 안드로이드 운영체제는 리눅스 기반이지만 나머지 안드로이드 SDK는 자바로 이루어져 있다.


	16+1)Android Studio
1-2.file was loaded in the wrong encoding 'utf-8' 에러 대처 방법(한글깨짐)
	1)	프로그램윈도우창오른쪽하단 -> x-windows-949 선택 -> Reload	=> 깨진 한글이 정상적으로 보임
	2)	프로그램윈도우창오른쪽하단 -> UTF-8 선택 -> Convert			=> 프로그램 기본 언어인 UTF-8로 변경
	3)	Build -> Rebuild Project -> 'utf-8' 에러가 일어나지 않도록 해당 파일 모두 상단 1),2) 방법으로 수정
	
1-1.찾기명령 사용 방법
	1)	Find in Path -> In Project, 아무설정도 체크하지 않고 찾으면 되며(ex, []Match case,....)
	2)	찾다 보면 "100+ matches" 등의 문구가 보이며 더 이상 찾아 주지 않는 문제 발생하며
		해결 방법은
		Android studio -> Help -> Find Action -> Registry 문구 입력 -> ide.usages.page.size 크기를 기존 100 -> 99999 로 늘리면 됨

1.	Gradle project sync failed, Error:Unable to start the daemon process. 에러 발생시 대처 방법
Error:Unable to start the daemon process
This problem might be caused by incorrect configuration of the daemon.
For example, an unrecognized jvm option is used.
Please refer to the user guide chapter on the daemon at https://docs.gradle.org/4.1/userguide/gradle_daemon.html
Please read the following process output to find out more:
-----------------------

FAILURE: Build failed with an exception.

* What went wrong:
Unable to create daemon log file

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

* Get more help at https://help.gradle.org

	->	2017년 11월 08일 해결 됨
		이차장이 Cyberdigm에 전화하니 자바 프로그램은 클라우디움 환경에서 정상동작하지 않는 다는 답변을 받았고
		이에, 클라우디움 프로그램 수정을 요청 -> Cyberdigm에서 클라우디움 프로그램 수정을 해줘서 현, 클라우디움 환경에서도 정상적으로 안드로이드(자바) 프로그램이 동작하고 있음
		cf)	Cyberdigm에서 자바 정상 동작을 위해 변경한 사항 들
			C:\Cyberdigm\DestinyDrive\Profile\DefaultExceptionPath.dat 파일에 아래 사항 추가
			1 | 6 5 5 6 3 | C : \ U s e r s \ u s e r \ 
			1 | 6 5 5 6 4 | C : \ U s e r s \ u s e r \ 

	->	2017년 11월 07일 결론
		본 에러는 AVG바이러스프로그램이나 방화벽 해제를 하지 않아서 발생하는 것이 아닌
		클라우디움이 본 Android Studio 프로그램 실행을 방해해서 발생하는 것임(ex, 엑세스 오류)
		->	이유)	AVG바이러스프로그램을 OFF시키고 방화벽을 모두 해제해도 본 에러는 계속 발생함
					이때 클라우디움은 켜져 있는 상태임
			이유)	AVG바이러스프로그램과 방화벽은 모두 정상적으로 ON 시키고
					클라우디움만 OFF시키면(Windows설정 -> 업데이트및복구 -> 복구 -> 고급시작옵션 -> 명령창으로 실행 -> C:\Cyberdigm 이름을 C:\Cyberdigm_ 으로
					변경시킨다음 재 실행하면 클라우디움이 실행되지 못함)
					정상적으로 Android Studio가 동작함 확인 완료

		->	cf)	클라우디움 동작 flow
			DestinyECMAgent.exe 프로그램을 로그인해서 실행시켜면 인터넷으로 부터 DefaultExceptionPath 사항 등을 다시 읽어 들여서
			C:\Cyberdigm\DestinyDrive\Profile에 있는 *.dat (DefaultExceptionPath.dat) 파일을 수정 함

			cf)	안드로이드 정상적으로 동작하지 않을 때 클라우디움 로그 파일 -> C:\Cyberdigm\DestinyDrive\Log\PSERVICE\*.log
#?# 3 #4736# 09:42:13.864 #?# Create Target Application: 4352, 65551, java.exe
#?# 3 #4736# 09:42:13.873 #?# Create Process: 4352, java.exe
#?# 3 #4736# 09:42:13.878 #?# Create child process Target Application: 4352, 1576, 65551, conhost.exe
#?# 3 #4736# 09:42:13.885 #?# Create Process: 1576, conhost.exe
#?# 3 #4736# 09:42:14.353 #?# File System Access Deny ==> PID : 4352, PNAME : java.exe, Path : C:\Users\user\.gradle\daemon\4.1\daemon-4352.out.log
#?# 3 #4736# 09:42:14.370 #?# [Process Notification] Terminated Process : 4352 
#?# 3 #4736# 09:42:14.373 #?# [Process Notification] Terminated Process : 1576 
#?# 3 #4736# 09:42:30.291 #?# Create Process: 5900, control.exe
#?# 3 #4736# 09:42:30.316 #?# dllhost ProcessId : C:\WINDOWS\SysWOW64\DllHost.exe /Processid:{06622D85-6856-4460-8DE1-A81921B41C4B}, 8812
#?# 3 #4736# 09:42:30.432 #?# [Process Notification] Terminated Process : 5900 
#?# 3 #4736# 09:42:30.754 #?# Create Process: 12872, WmiPrvSE.exe
#?# 3 #4736# 09:42:30.885 #?# Create Process: 9624, sppsvc.exe
#?# 3 #4736# 09:42:32.408 #?# Create Process: 12088, CompatTelRunner.exe
#?# 3 #4736# 09:42:32.425 #?# Create Process: 3244, conhost.exe
#?# 3 #4736# 09:42:32.801 #?# Create Process: 6064, SystemPropertiesAdvanced.exe
#?# 3 #4736# 09:42:32.802 #?# [Process Notification] Terminated Process : 6064 
#?# 3 #4736# 09:42:32.816 #?# Create Process: 4348, consent.exe
#?# 3 #4736# 09:42:32.901 #?# dllhost ProcessId : C:\WINDOWS\system32\DllHost.exe /Processid:{E10F6C3A-F1AE-4ADC-AA9D-2FE65525666E}, 16016
#?# 3 #4736# 09:42:32.979 #?# [Process Notification] Terminated Process : 4348 
#?# 3 #4736# 09:42:32.994 #?# dllhost ProcessId : C:\WINDOWS\system32\DllHost.exe /Processid:{E10F6C3A-F1AE-4ADC-AA9D-2FE65525666E}, 6808
#?# 3 #4736# 09:42:33.074 #?# Create Process: 13880, SystemPropertiesAdvanced.exe

			cf)	안드로이드 정상적으로 동작하지 않을 때 regedit 파일 내용
Default_20171107
컴퓨터\HKEY_CURRENT_USER\Software\AppDataLow\Software\DestinyECM\DestinyECMAgent
ExtentionsForAlertByUnregisteredCompressionApplication
zip,zipx,tar,alz,ace,arc,arj,cab,gz,jar,iha,izh,rar,lzh,exe,iso,tgz,7z
ScanExceptionFolders
%PROGRAM_FILES%|%APPDATA%|%LOCAL_APPDATA%|%TEMP%|%INTERNET_CACHE%|%WINDOWS%|C?\Cyberdigm|C?\HNC|C?\ProgramData|C?\SWSetup|C?\SolidWorks Data|C?\SOLIDWORKS Data|C?\Autodesk|C?\SMYSoft|C?\UCWARE|C?\hp
UnableExecuteFileExtensions
exe|pif|application|gadget|msi|msp|com|dll|ocx|sys|scr|hta|cpl|msc|jar|bat|cmd|vbs|vb|vbe|js|jse|ws|wsf|wsc|wsh|ps1|ps1xml|ps2|ps2xml|psc1|psc2|msh|msh1|msh2|mshxml|msh2xml|reg|inf|lnk|scf

컴퓨터\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\CPService
ImagePath
C:\Cyberdigm\DestinyDrive\PantaService.exe

2.  Configuration 'compile' is obsolete and has been replaced with 'implementation' and 'api' 에러 해결
    Gradle Scripts -> build.gradle -> dependencies 명령에 기입되어 있는 "compile" 문구를 "implementation"으로 변경

3.  SDK 버전 설정
compileSdkVersion
Gradle에 어떤 안드로이드 SDK 버전으로 앱을 컴파일 할 것인지 알려줍니다 . 즉, 지원할 수 있는 가장 높은 API 버전을 의미합니다.
해당 SDK 버전에 포함된 API를 사용할 수 있다는 것을 의미합니다.
컴파일시에만 적용되므로 런타임동안에는 영향을 ���치지 않습니다.
항상 최신 버전의 SDK로 지정하는 것이 좋습니다.
import문으로참조되는 클래스나 메소드를 찾을 때 어떤 버전의 SDK에서 찾을 것인가를 결정해줍니다.

minSdkVersion
minSdkVersion보다 낮은 API 버전 앱은 설치할 수 없습니다.
minSdkVersion보다 높은 API를 사용하면 lint에서 경고를 띄워 알려줍니다.
Support Library나 Google Play Service는 자체 minSdkVersion을 가지므로 이 중 가장 높은 버전으로 맞춰야 합니다.

targetSdkVersion 
minSdkVersion 이상에서 지원하는 어떤 기능을 사용하고자 위함입니다.
실제 컴파일에는 관여하지 않음. 빌드시 버전을 낮추어도 원하는 클래스의 메소드를 컴파일 할 수 있습니다.
지정한 버전까지 앱을 테스트 했음을 의미합니다. 기기가 Nougat(API 24)더라도 target이 Marshmellow(API 23)이라면 Marshmellow 단말기까지는 정상동작 됨을 의미하며 Nougat기기는 정상적으로 돌아갈지 확신할 수 없습니다. 상위호환되는 API로 개발을 했다면 아마 잘 돌아갈 것 입니다. 
즉 targetSdkVersion이 달라야 앱의 행동 로직이 달라지므로, 안드로이드가 상위호환성을 제공할 수 있습니다.
Marshmellow(API 23)에서 도입된 런타임 퍼미션(runtime permission model)은 targetSdkVersion 을 API 23으로 지정해야 적용됩니다.

compileSdkVersion을 25로하고 targetSdkVersion을 21로하면 Marshmellow 이상 단말기에서 런타임 퍼미션이 Marshmellow 이전처럼 강제 허용되어 있습니다. 허용을 해제하려고하면 이전 버전으로 빌드된 앱이라고 메시지가 출력됩니다.
targetSdkVersion이 22이라면 22이후 버전에서 지원되는 기능이 제외된 앱이 만들어지므로 런타임 퍼미션을 사용 못하는 것입니다.

세 종류의 SDK 버전의 관계
minSdkVersion <= targetSdkVersion <= compileSdkVersion

안정적인 앱을 원한다면
minSdkVersion <= targetSdkVersion == compileSdkVersion

출처: http://duzi077.tistory.com/141 [개발하는 두더지]



	17)	안드로이드 카메라 파라미터 적용하기
현재 2.0 이상에서 추가 된 카메라 이펙트 파라미터 입니다. 
http://developer.android.com/sdk/api_diff/5/changes/android.hardware.Camera.Parameters.html 참고하세요!
이 것을 적용 해 볼까요?
======================================================================
//EFFECT
 public static final String EFFECT_AQUA="aqua";
 public static final String EFFECT_BLACKBOARD ="blackboard";
 public static final String EFFECT_MONO = "mono";
 public static final String EFFECT_NEGATIVE = "negative";
 public static final String EFFECT_NONE = "none";
 public static final String EFFECT_POSTERIZE ="posterize";
 public static final String EFFECT_SEPIA = "sepia";
 public static final String EFFECT_SOLARIZE = "solarize";
  public static final String EFFECT_WHITEBOARD = "whiteboard";
 
 //FLASH_MODE
 public static final String FLASH_MODE_AUTO = "auto";
 public static final String FLASH_MODE_OFF = "off";
 public static final String FLASH_MODE_ON = "on";
 public static final String FLASH_MODE_RED_EYE = "red-eye";
 public static final String FLASH_MODE_TORCH = "torch";
 
 //FOCUS_MODE
 public static final String FOCUS_MODE_AUTO = "auto";
 public static final String FOCUS_MODE_FIXED = "fixed";
 public static final String FOCUS_MODE_INFINITY = "infinity";
 public static final String FOCUS_MODE_MACRO = "macro";
 
 //SCENE_MODE
 public static final String SCENE_MODE_ACTION = "action";
 public static final String SCENE_MODE_AUTO = "auto";
 public static final String SCENE_MODE_BEACH = "beach";
 public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
 public static final String SCENE_MODE_FIREWORKS = "fireworks";
 public static final String SCENE_MODE_LANDSCAPE = "landscape";
 public static final String SCENE_MODE_NIGHT = "night";
 public static final String SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";
 public static final String SCENE_MODE_PARTY = "party";
 public static final String SCENE_MODE_PORTRAIT = "portrait";
 public static final String SCENE_MODE_SNOW = "snow";
 public static final String SCENE_MODE_SPORTS = "sports";
 public static final String SCENE_MODE_STEADYPHOTO = "steadyphoto";
 public static final String SCENE_MODE_SUNSET = "sunset";
 public static final String SCENE_MODE_THEATRE ="theatre";

 //WHITE_BALANCE
 public static final String WHITE_BALANCE_AUTO = "auto";
 public static final String WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
 public static final String WHITE_BALANCE_DAYLIGHT = "daylight";
 public static final String WHITE_BALANCE_FLUORESCENT = "fluorescent";
 public static final String WHITE_BALANCE_INCANDESCENT = "incandescent";
 public static final String WHITE_BALANCE_SHADE = "shade";
 public static final String WHITE_BALANCE_TWILIGHT = "twilight";
 public static final String WHITE_BALANCE_WARM_FLUORESCENT="warm-fluorescent";
 =================================================================================================
 /////////////////////////////////////////////////////////////////////////////////////////////////
   
위에 파라미터를 참고하여 만듭니다. 

 android.hardware.Camera.Parameters parameters =mCamera.getParameters();
 parameters.setWhiteBalance(WHITE_BALANCE_AUTO);
mCamera.setParameters(parameters);
========================================================================================
이런 식으로 적용. 파라미터를 초기화 해주고 
parameters를 적은 후 .을 누르면 적용할 수 있는 파라미터들이 자동으로 보여집니다. 
적용해야 하니 set을 적어보면 사용할 파라미터가 화이트 발란스나 컬러 이펙트등이 보여지는데
원하는 것을 설정하고 엔터 치면 그안에 또 해당하는 속성이 자동으로 뜨는데 골라 쓰시면 됩니다. 
적용한후 set파라미터 해주면 땡!!!

쉽죠잉?

	18)	StrictMode
개발자는 애플리케이션을 작성할 때 다음 두가지를 항상 고려해야 한다.
-느린 네트워크 ( 개발자가 연결하고자 하는 서버는 심지어 반응하지 않을 수도 있다고 가정한다 )
- 느린 파일 시스템 엑세스
결론적으로 느린 오퍼레이션은 응답성에 영향을 주기 때문에 네트워크나 파일 시스템 접근을 애플리케이션의 메인 쓰레드에서 처리하지 않도록 해야한다.
-> 메인 thread가 아닌 별도의 thread를 만들어서 네트워크나 파일 시스템 접근 등을 실행시켜줘야 한다.
-> android.os.NetworkOnMainThreadException 에러가 발생하지 않도록 하려면
   네트워크 Socket 관련 명령을 메인스레드상에서 실행하지 않고 별도의 Thread로 구성해서 실행시키면 에러가 발생하지 않음 
   cf) StricMode 명령을 실행시켜서 에러가 발생하지 않도록 하는 것은 미봉책에 불과 함
개발자의 개발 환경에서는 네트워크 문제나 파일 시스템 성능 문제가 나타나지 않을 수도 있지만, 문제가 나타날 수도 있다.
안드로이드느는 이와 같은 결함을 찾아낼 수 있는 유틸리티를 제공한다.
StrictMode는 잘못된 동작을 검출하는 툴이다. 아래처럼 일반적으로 애플리케이션이 시작할 때 즉, onCreate() 메소드가 호출될 때 StrictMode를 활성화한다.
public class MyApplicationStrictModeExam extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()            
        .detectCustomSlowCalls()          // API Level 11                                    
        .detectDiskReads()                   // API Level 9                                
        .detectDiskWrites()                   // API Level 9
        .detectNetwork()                      // API Level 9
        .penaltyLog()                           // API Level 9
        .penaltyFlashScreen()                // API Level 11
        .build());
    } 
}
StrictMode는 안드로이드 2.3부터 도입되었고, 안드로이드 3.0에 이르러 몇 가지 특성이 추가되었다. 
따라서 개발자는 배포할 안드로이드 버전을 확정하고 적절한  StrictMode를 사용해야 한다.
안드로이드 3.0에서 도입된 주목할 만한 메소드는  detectCutsomSlowCals()와 detectSlowCall()이다.
두 메소드는 애플리케이션 안에서 느리거나 느려질 가능성이 있는 큰 코드를 검출하는 데 사용한다. 
( 사용 방법은 http://developer.android.com/reference/android/os/StrictMode.html 참조)
네트워크 액세스를 일시적으로 허용하는 메소드는 없다.
얼마나 빠르게 네트워크에 액세스할지 알 수 있는 적당한 방법이 없기 때문이다.
따라서 일시적 액세스라도 이러한 액세스를 허용할 이유가 없다. 디스크도 네트워크와 마찬가지로 얼마나 빠르게 디스크를 액세스하는지 알 방법도 없다.
# 개발단계에서만 StrictMode를 활성화하고 애플리케이션을 배포할 때는 반드시 비활성화한다.
만약 개발자가 detectAll() 메소드를 사용하는 정책을 만들었다면, 앞으로 출시될 버전들의 안드로이드에서는 더 많은 오류 동작을 검출할 것아다.
따라서 배포 시 strictMode를 비활성화하는 것이 더욱 중요하다.

	19)	안드로이드 Color image 처리(이미지 평균화 처리)
		// add, Image Sum
		if(true)
		{
			switch(Image_Sum_count)
			{
				case 0:
					bitmap_backup_1 = bitmap.copy(Bitmap.Config.ARGB_8888, true);
					CUtil.saveBitmapFile(bitmap_backup_1, "/sdcard/image1.jpg");
					break;
				case 1:
					bitmap_backup_2 = bitmap.copy(Bitmap.Config.ARGB_8888, true);
					CUtil.saveBitmapFile(bitmap_backup_2, "/sdcard/image2.jpg");
					break;
				case 2:
					bitmap_backup_3 = bitmap.copy(Bitmap.Config.ARGB_8888, true);	
					CUtil.saveBitmapFile(bitmap_backup_3, "/sdcard/image3.jpg");
					break;
			}

			if(Image_Sum_count == 2)
			{
				int width2 = bitmap.getWidth();
				int height2 = bitmap.getHeight();

/*				int value_1 = 0, value_2 = 0, value_3 = 0; 
				long value_T_A = 0;
				int ivalue_T_A = 0;

				for (int y = 0; y < height2; y++)
				{
					for (int x = 0; x < width2; x++)
					{
						value_1 = bitmap_backup_1.getPixel(x, y);
						value_2 = bitmap_backup_2.getPixel(x, y);
						value_3 = bitmap_backup_3.getPixel(x, y);

						ivalue_T_A = (((value_1 & 0x00ffffff) + (value_2 & 0x00ffffff) + (value_3 & 0x00ffffff))/3) & 0x00ffffff;
						ivalue_T_A = (ivalue_T_A + 0xff000000) & 0xffffffff;

						bitmap.setPixel(x, y, ivalue_T_A);
					}
				}	*/
				// fix,	아래와 같이 R/G/B pixel값을 따로 분리 시켜서 평균화 작업을 실행시켜야지만 정확한 처리가 이뤄짐
				//		만약 상기와 같이 처리하면 R/G/B값이 SUM을 하면 ex)B값이 G로 올라갈 수 있고 나중에 더한 만큼 나눈다고 해도 올라간 B값과 G값이 정확하게 다시 원상태로 복원될 가능성은 없음
				//		이유는, B값이 G로 올라간 이후 부터는 B값이 G값과 섞이게 되고 이에 어떤 값이 어떤 값이 없는지 불명확하게 되기 때문에 나중에 정확하게 분리시킨 다는 것은 말이 안됨.
				int value_1 = 0, value_2 = 0, value_3 = 0; 
				int value_1_R = 0, value_2_R = 0, value_3_R = 0;
				int value_1_G = 0, value_2_G = 0, value_3_G = 0;
				int value_1_B = 0, value_2_B = 0, value_3_B = 0;
				int value_R_A = 0, value_G_A = 0, value_B_A = 0;
				int value_T_A = 0;

				for (int y = 0; y < height2; y++)
				{
					for (int x = 0; x < width2; x++)
					{
						value_1 = bitmap_backup_1.getPixel(x, y);
						value_2 = bitmap_backup_2.getPixel(x, y);
						value_3 = bitmap_backup_3.getPixel(x, y);

						value_1_R = value_1 & 0x00ff0000;
						value_2_R = value_2 & 0x00ff0000;
						value_3_R = value_3 & 0x00ff0000;
						value_1_G = value_1 & 0x0000ff00;
						value_2_G = value_2 & 0x0000ff00;
						value_3_G = value_3 & 0x0000ff00;
						value_1_B = value_1 & 0x000000ff;
						value_2_B = value_2 & 0x000000ff;
						value_3_B = value_3 & 0x000000ff;

						value_R_A = ((value_1_R + value_2_R + value_3_R)/3) & 0x00ff0000;				// 값을 더하고 나눈 이후에도 0x00ff0000등으로 R/G/B값을 구분시켜줘야 함, 이유) 3으로 나눠줄 때 반올림되어서 값이 다음차순으로 올라갈 수 있기 때문
						value_G_A = ((value_1_G + value_2_G + value_3_G)/3) & 0x0000ff00;
						value_B_A = ((value_1_B + value_2_B + value_3_B)/3) & 0x000000ff;

						value_T_A = (value_R_A + value_G_A + value_B_A + 0xff000000) & 0xffffffff;

						bitmap.setPixel(x, y, value_T_A);
					}
				}
				// fix

				CUtil.saveBitmapFile(bitmap, "/sdcard/imageSum.jpg");
			}
		}
		// add	

	20)	[안드로이드 ] android file 처리 정리
앱 내부 메모리 (Internal Memory)
	- 캐시 폴더 : this.getCacheDir()
		4.0.3 버전 경로 : /data/data/패키지명/cache/파일명
	- 파일 폴더 : this.getFilesDir()
		4.0.3 버전 경로 : /data/data/패키지명/files/파일명, ex) cAES_Lib.crypt(Cipher.ENCRYPT_MODE, strKey, initVector, new File(getFilesDir(), "source.jpg"), new File(getFilesDir(), "encrypt.jpg"));
	- 직접 만드는 폴더 : this.getDir("폴더명", mode) -> mode에는 0 또는 MODE_PRIVATE 입력
		4.0.3 버전 경로 : /data/data/패키지명/app_폴더명/파일명
		-> https://developer.android.com/reference/android/content/Context.html#getDir(java.lang.String, int)

	createTempFile(String prefix, String suffix, File directory)
		prefix 는 3글자 이상, suffix는 확장자개념(null일 경우 :  ".tmp"), 
		directory는 저장할 폴더(null일 경우 : 눈으로 확인 가능.
									4.0.3 버전 경로 : /sdcard/파일명
								)

		prefix : test, suffix : null = 파일 명 : test(...).tmp
		prefix : test, suffix : .txt = 파일 명 : test(...).txt
		prefix : test, suffix : txt = 파일 명 : test(...)txt

	앱 내부 파일 만들기
		1. File file = File.createTempFile("test",".txt", this.getDir("폴더명", 0));
			-> 만들어지는 경로 : 4.0.3 버전 경로 : /data/data/패키지명/app_폴더명/test(temp번호).txt -> (test1837506.txt)
		2. File path = this.getDir("폴더명", 0);
			File file = new File(path, "test.txt");
			-> 만들어지는 경로 : 4.0.3 버전 경로 : /data/data/패키지명/app_폴더명/파일명
		FileOutputStream fos = new FileOutputStream(파일);

앱 외부 메모리 (External Memory)
	4.0.3 : getExternalFilesDirs , listView.setNestedScrollingEnabled(false);  -> NoSuchMethodError
		Environment.getExternalStorageDirectory().getAbsolutePath();         -> /mnt/sdcard
		Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(); -> /mnt/sdcard/Download
	7.0 : getExternalFilesDirs(ContactsContract.Directory.PACKAGE_NAME); 
		-> [0] : /storage/emulated/0/Android/data/패키지명/files/packageName
		-> [1]  : /storage/외장sdcard/Android/data/패키지명/files/packageName
		Environment.getExternalStorageDirectory().getAbsolutePath(); -> /storage/emulated/0
		Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath();
		-> /storage/emulated/0/Download
		getExternalFilesDir() 앱을 삭제하면 이 메소드를 사용하여 저장한 모든 파일은 사라짐. 이유는 그 패키지를 가진 폴더가 사라짐.

	21)	[Android] Android data path and method (안드로이드 저장소 경로 및 경로 획득 함수)
Data path and method (저장소 경로 및 경로 획득 함수)

이 글은 이 글을 참고하여 작성하였다.
안드로이드 시스템에서 데이터 저장 장소는 크게 2가지로 나뉘어진다.
첫번째는 내부 저장소로 이 공간은 해당 앱에서만 접근 가능하다. 유저도 이 공간에는 직접 접근할 수 없다.
두번째는 외부 저장소로 외부저장소는 공용영역과 고유영역으로 나뉘���진다.
외부저장소의 공용영역은 다양한 어플이 접근할 수 있는 영역이며 어플이 삭제되어도 이 경로에 저장된 데이터는 유지된다.
반면 외부저장소의 고유영역은 다른 어플도 접근 가능하며, 어플이 삭제시 이 공간의 데이터도 삭제된다.
보안을 위해서는 외부 어플이 접근할 수 없도록 내부 저장소에 저장하는 것이 안전하며,
만약 내부 저장소에 저장된 데이터를 외부 어플로 전달하고 싶은경우 (email 첨부, 다른어플로 열기 등)에는 fileprovider를 사용해야 한다.
fileprovider를 이용해서 데이터를 전달하는 방법에 대해서는 다음 글을 참고하기 바란다.

내부저장소
각 애플리케이션에서만 데이터를 읽고 쓸 수 있다.

1. 캐시(Cache)
임시 파일들이 저장된다. File Context.getCacheDir() 내부 저장소의 캐시 디렉터리 경로를 반환한다. 경로: /data/data/패키지 이름/cache

2. 데이터베이스(Database)
데이터베이스 파일들이 저장된다. File Context.getDatabasePath(String name) 데이터베이스 파일의 경로를 반환. 인자로 데이터베이스 파일의 이름을 넘겨준다. 경로: /data/data/패키지 이름/databases

3. 일반 파일
일반 파일이 저장되는 영역이다. 
이 경로는 Context.openFileOutput(String, int)를 사용하여 생성되는 파일이 저장되는 경로와 동일하다. File Context.getFilesDir() 일반 파일들의 저장 경로를 반환한다. 경로: /data/data/패키지 이름/files
각 일반 파일들의 경로를 가져오기 File Context.getFileStreamPath(String name) 일반 파일이 저장된 공간에서 특정 이름을 가지는 파일의 경로를 반환한다. 인자로 확장자를 포함한 파일 이름을 넘겨준다. 
경로: /data/data/패키지 이름/files/파일이름

외부저장소 (공용영역)
애플리케이션을 삭제해도 데이터는 남아있다.

1. 최상위 경로
외부 저장소(SD카드)의 최상위 경로를 반환한다. static File Environment.getExternalStorageDirectory() 경로: /mnt/sdcard 또는 /storage/emulated/0 등 기종마다 다르다.   

2. 특정 데이터를 저장하는 영역
여러 애플리케이션에서 공용으로 사용할 수 있는 데이터들을 저장하며 데이터의 유형에 따라 별도의 디렉터리를 사용한다.
이 영역에 데이터를 저장하기 전에, 해당 디렉터리가 존재하는지 확인해야 한다. 존재하지 않으면 FileNotFoundException이 발생하기 때문에 File.mkdirs()를 사용하여 없을 경우 새 디렉터리를 생성해 준다.  
다음의 함수를 이용해서 external 디렉터리가 존재하는지, 그리고 write가 가능한지 확인할 수 있다.


public static boolean checkAvailable() {

    // Retrieving the external storage state
    String state = Environment.getExternalStorageState();

    // Check if available
    if (Environment.MEDIA_MOUNTED.equals(state)) {
        return true;
    }
    return false;
}

public static boolean checkWritable() {
    // Retrieving the external storage state
    String state = Environment.getExternalStorageState();

    // Check if writable
    if (Environment.MEDIA_MOUNTED.equals(state){
        if(Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
            return false;
        }else{
            return true;
        }
    }
    return false;
}

외부 저장소의 해당 경로를 얻기위해서는 다음 함수를 사용한다 static File Environment.getExternalStoragePublicDirectory(String type) 인자로 디렉터리의 유형을 넘겨준다.

[각 인자 및 경로]
?Environment.DIRECTORY_ALARMS : 알람으로 사용할 오디오 파일 저장 (/mnt/sdcard/Alarms)
?Environment.DIRECTORY_DCIM : 카메라로 촬영한 사진 저장 (/mnt/sdcard/DCIM)
?Environment.DIRECTORY_DOWNLOADS : 다운로드한 파일 저장 (/mnt/sdcard/Download)
?Environment.DIRECTORY_MUSIC : 음악 파일 저장 (/mnt/sdcard/Music)
?Environment.DIRECTORY_MOVIES : 영상 파일 저장 (/mnt/sdcard/Movies)
?Environment.DIRECTORY_NOTIFICATIONS : 알림음으로 사용할 오디오 파일 저장 (/mnt/sdcard/Notifications)
?Environment.DIRECTORY_PICTURES : 그림 파일 저장 (/mnt/sdcard/Pictures)
?Environment.DIRECTORY_PODCASTS : 팟캐스트 파일 저장 (/mnt/sdcard/Podcasts)

외부저장소 (고유영역)
외부 저장소 - 애플리케이션 고유 영역 이 영역에 저장된 데이터는 애플리케이션이 삭제될 때 같이 삭제되며 다른 애플리케이션에서 해당 데이터에 접근하는 것이 가능하다.

1. 특정 데이터를 저장하는 영역
애플리케이션 고유 영역에도 공용 영역과 마찬가지로 각 데이터 유형별로 데이터를 저장하는 표준 디렉터리를 제공한다. File Context.getExternalFilesDir(String type) 인자로 디렉터리의 유형을 넘겨준다.

[각 인자 및 경로]
?Environment.DIRECTORY_ALARMS (/mnt/sdcard/Android/data/패키지 이름/files/Alarms)
?Environment.DIRECTORY_DCIM (/mnt/sdcard/Android/data/패키지 이름/files/DCIM)
?Environment.DIRECTORY_DOWNLOADS (/mnt/sdcard/Android/data/패키지 이름/files/Download)
?Environment.DIRECTORY_MUSIC  (/mnt/sdcard/Android/data/패키지 이름/files/Music)
?Environment.DIRECTORY_MOVIES (/mnt/sdcard/Android/data/패키지 이름/files/Movies)
?Environment.DIRECTORY_NOTIFICATIONS (/mnt/sdcard/Android/data/패키지 이름/files/Notifications)
?Environment.DIRECTORY_PICTURES (/mnt/sdcard/Android/data/패키지 이름/files/Pictures)
?Environment.DIRECTORY_PODCASTS (/mnt/sdcard/Android/data/패키지 이름/files/Podcasts)
?null (/mnt/sdcard/Android/data/패키지 이름/files)

2. 캐시 데이터를 저장하는 영역
애플리케이션에서 사용하는 임시 데이터를 외부 저장소에 저장한다. File Context.getExternalCacheDir() 경로: /mnt/sdcard/Android/data/패키지 이름/cache
?외부 저장소는 사용자 데이터(사진, 음악 등)이 저장되는 영역이다. 일반적으로 단말기의 외장 SD카드를 지칭하지만, 
단말기에 따라서는 이 영역이 외장 SD카드가 아닌 단말기 내부에 탑재되어 있는 경우도 있다.(넥서스S) 또는, 단말기 내에 탑재된 외장 메모리 영역 외에 별도의 SD카드도 지원하는 단말기도 있다.(갤럭시S)


[60+1]	Beaglebard-xm

안드로이드 소스,커널 소스, 레퍼런스 메뉴얼 다운법
http://beagleboard.org/
Support에 들어가면 하드웨어, 소프트웨어목록이 있음
하드웨어는 보드에따른 레퍼런스 메뉴얼을,
소프트웨어는 보드에따른 안드로이드 소스, 커널소스를 다운가능

1-1.	Beagleboard-xm 보드 사용 순서
	반드시 하기와 같은 순서로 실행해야만 1번에 정상적으로 부팅 된다.
	1)	5V 전원을 전원PORT에 입력
	2)	부팅이 완전히 완료된 이후(adb_open 실행)
	3)	OTG USB Cable 연결

1-2.	Beagleboard-xm Pre-built 안드로이드 이미지
	http://code.google.com/p/rowboat/downloads/list
	하기 Pre-built 이미지를 가지고 Beagleboard-xm 보드를 부팅 했을 때
	
	1)	beagleboard-xm.tar.gz			->	부팅 조차 되지 않음
	2)	beagleboard_xm_sgx.tar.gz		->	부팅 됨, 하지만 UsbController(안드로이드어플) 실행하면 보드가 멈춰 버림
	3)	beagleboard-xm-jb.tar.gz		->	cf)	SD-Memory로 이미지 복사하는 ./mkmmc-android.sh /dev/sdb 명령 실행 시 cp: 'START _HERE'를 설명할 수 없음, 에러가 발생
												-> beagleboard-xm.tar.gz 에 있는 'START _HERE' 폴더 beagleboard-xm-jb 폴더에 복사 시킴
											부팅 됨, UsbController(안드로이드어플) 실행하면 보드가 멈추지는 않지만 USB 제어 명령이 동작하지 않음
											ex) deviter.hasNext() -> USB를 연결시켜도 항상 null
	4)	image_folder(rowboat-android)	->	부팅 됨, UsbController(안드로이드어플) 실행하면 보드가 멈추지는 않지만 USB 제어 명령이 동작하지 않음
											ex) deviter.hasNext() -> USB를 연결시켜도 항상 null

1-3.	Beagle Board 입문기MrKiss | 2011/10/02 15:01 | Electronics | 11  
몇 년전 부터 써보려고 벼르던 비글 보드를 드디어 샀다. 비글보드는 리눅스를 돌릴수 있는 마이크로 프로세서가 박혀있는 하나의 보드로된 컴퓨터이자 아두이노 같은 마이크로컨트롤러 보드의 하이엔드 급 되겠다. 요즘 나오는 스마트폰 정도의 프로세싱 파워를 가지고 있다. 아두이노 급들과의 차이라면 하나의 보드에 비디오/오디오 출력과 USB호스트포트를 가지고 있고 리눅스 같은 상대적으로 대용량의 OS를 돌릴수 있을 정도의 메모리를 가지고 있고 또 돌릴만한 속도를 가지고 있어서 마우스와 키보드 전원 모니터를 연결하면 리눅스가 깔린 컴퓨터로 바로 작동한다.
역시나 AVR처음 시작할때 만큼 삽질 중이다. 먼저 전원공급도 딱 5V가 아니면 받아들이질 않아서 5.7V가량 나오는 어댑터를 꽂으면 아예 빨간 과전압경고등이 들어 오면서 켜지질 않는다. 그 어댑터도 플러그 사이즈가 작아서 큰거랑 바꾸느라고 땜질까지 한건데 --. 호스트 기능이 없는 미니 USB 포트도 하나 있어서 그쪽으로 전원을 공급받을 수도 있지만 모니터에 신호를 보내줄 정도로 전류가 충분하지가 못해서 모니터를 켤수가 없었다.
그래서 12V를 5V로 낮추는 자작 전원공급장치를 만들었으나 3A까지 밀어줄 수 있다는 78T05 레귤레이터가 130도를 육박하는 열을 내다가 뻗어 버린다. 비글 보드입력 전류 최대치1A가 안되는걸로 메뉴얼에서 본 것 같은데 이해할 수가 없는 상황이다. 레귤레이터 두개를 꽂으니 모니터까지는 돌리는데 마우스와 키보드를 꽂으니 또 바로 뻗는다. 그래서 레귤레이터를 5개까지 꽂아봤는데 역시나 안된다. 냉각핀이 너무 작아서 그런걸까? 결국은 CNC전원으로 사용하던 300W가 넘는 PC용 전원공급장치를 뜯어다 꽂으니 잘 돌아간다. 보드가 작으면 뭐하나 PC용 전원공급장치를 꽂으니 단번에 맥미니를 능가하는 위용을 자랑한다. 제대로된 3A짜리 어댑터를 사서 써봐야겠다. 어쩌면 내가 썼던 12V어댑터가 문제 일지도 모르니까.
(추가: 인터넷공유기용 5V 2A짜리 어댑터가 있길래 써보니 열도 별로 없이 잘만 된다. 내가 썼던 12V어댑터와 레귤레이터의 조합이 안좋았던 모양이다. 그냥 쉽게 가는게 가장 좋은길인데 괜히 레귤레이터 좀 만져봤다고 자작해서 쓴다고 시간만 날리고 시작부터 좌절감만 맛봤다 --;) 
아무튼 PC용 파워서플라이를 써서 돌아는 가는데 살때 기본으로 들어있는 microSD카드에는 우분투가 아니라 비글보드 자체 버전의 리눅스가 들어 있는데 Angstrom이라는 임베디드용 리눅스 버전인듯싶다. 난 이 비글보드로 억세스포인트 기능을 가진 무선 비디오 스트리밍 서버를 만들려는 것이기 때문에 아무래도 널리쓰이는 우분투를 깔아야할것같아서 우분투를 깔기로 했다. 아직 이 결정이 맞는지는 잘 모르겠다. 꼭 우분투를 깔 필요가 있을까 하는 생각이 스물 스물 드는중이다.
비글보드 웹사이트(www.beagleboard.org)에서 우분투 설치링크(http://www.elinux.org/BeagleBoardUbuntu)를 찾아들어가니 엄청 복잡한 위키페이지가 나온다. 우분투 설치 위키페이지는 항목을 잘 나눠놓기는 했지만 초보자가 장착해야할 기본 개념을 잡아주는데는 친절하지 않게 되어 있다. 그래서 물론 엄청 삽질을 했다. 게다가 내가 산 비글 보드가 새로나온 XM버전이라 오리지날 버전에 대한 설명에 추가적으로 XM용 업데이트가 추가되어 있는 양상이라 더 보기가 어려운듯 싶다. 
처음시도는 우분투PC를 써서 SD카드에 부팅가능한 우분투를 집어 넣는 것이었다. 위키페이지가 하도 길어서 여기 저기 보다가 SD카드 포멧이야기가 나오길래 포멧을 먼저 하고 필요한 화일들을 복사해 넣는것인가 했더니 그러지 않아도 한큐에 이미지로 넣어버리는 방법이 있었다. 리눅스에서 포맷 좀 해보려다가 뭔 에러가 나고몇번 삽질 하다가 포기하고 제일 간단해보이는 윈도우즈에서 이미지를 바로 써버리는 방법을 써봤으나 역시 실패, 윈도우즈에서는 gz압축도 안풀려서 그거 푸는 프로그램 찾느라 삽질하다 포기, 맥에서 받은 이미지 화일 압축풀어서 USB로 윈도우즈에 옮겨서 이미지 라이터라는 프로그램 써서 한번에 부팅SD카드를 만들긴 했으나 XM버전용 화일 두개 복사하고 해봐도 부팅실패였다.
우분투 CD이미지 다운로드사이트에 보니 OMAP3용과 OMAP4용이 있는데 난 XM버전이 나중에 나온거니까 무심코OMAP4려니 하고 그걸 다운받았었는데 그게 실패의 원인이었다. 비글보드는 어떤 버전이든 OMAP3기반이었다 --;; 잘 모르면서 함부로 단정짓지 말라고 맨날 말하면서도 나도 같은 실수를 저질러버렸다.
알고보니 SD카드 포멧이고 자시고 필요없이 그냥 리눅스에서 이미지 압축풀어서 dd 명령으로 이미지 구우면 되는거였다. https://wiki.ubuntu.com/ARM/OmapNetbook <- 여기 나온대로 하면 그냥 된다. 다만 XM보드용 추가 사항이 페이지 아래에 있다. 화일 두개 복사해 넣으면 된다. 
그래서 온갖 삽질끝에 우분투가 빨간 이쁜 화면과 함께 부팅이 되는가 싶더니 마우스와 키보드가 안먹는다. 분명 기본제공 버전에서는 잘 되던 것들이 우분투에서 안된다는 것은 우분투의 문제인데 인터넷 여기 저기 뒤져보니 외부전원을 쓰는 USB 2.0허브를 써야된다는 말들이 있다. 고속USB기기만 취급해주기 때문에 저속기기를 위해서는 허브를 써야하고 또 외부전원까지 필요하다고 하다는데... 이 시점에서 부터 우분투에 회의가 들기 시작했다. 과연 우분투가 AP형 비디오 스트리밍을 설치하기 더 쉬울까하는 의문이다. 리눅스는 다 기본은 같은건데 배포판마다 다른건 주로 어플리케이션 설치 구조나 인터페이스같은게 아닌가? 
아무튼 이제 이틀정도 삽질했는데 이거 만만한 작업은 아니라는 생각이 빡! 든다. 마트에가서 USB허브 사다가 또 시도해봐야겠다.주말을 개쉐이(beagle은 3대 지랄견의 하나죠?)와 함께~ 

추가: 마트에 가니 전원공급 가능한 USB허브가 있긴 하나 어댑터를 팔지 않아서, 내가 가진 어댑터와 구멍이 안맞아서 못쓰는 가지고 있는 외부전원가능한 허브를 뜯어서 납땜까지 해서 해봤으나 그래도 마우스와 키보드를 인식하지 못함. 비글보드에 기본제공되는 Angstrom 리눅스를 가지고 이후의 프로그램들을 설치해봐야겠다. 

1.	Support → Software Support
	Software Support Resources 항목에서
	Android 소제목에서
	Enable Anroid on the Beagles with Project Rowboat 클릭
	http://arowboat.org로 갈수 있는 페이지가 뜸
	들어가보면
	Android Jellybean for AM335x based BeagleBone, Starter Kit and EVM
	AM37x EVM and Beagleboard XM
	두개가 있는데 XM을 예로 하므로 XM으로 접속

	Pre-built images 목록에서는 스크립트로 쉽게 설치할수있는 파일이 있으며
	ICS소스는 TI Andorid ICS 4.0.3 AM37x Sources 목록에서 확인가능
	Documents → UserGuide->1.3 Setup 을 가보면 Pre-built images에서 다운 받은 파일들로 설치하는 법이 설명되 있고
	Documents → DevelopersGuide에 가보면 x-loader 부터 file system까지 만드는법이 자세히 나와있다.

	Support → Hardware Support
	Device-Level Hardware Documentation->BeagleBoard-xM->Hardware Files
	에서 보드의 rec에 따른 메뉴얼을 다운 받을수있다. 현재우리꺼는 B 이다.

2.	안드로이드 포팅
	http://software-dl.ti.com/dsps/dsps_public_sw/sdo_tii/TI_Android_DevKit/TI_Android_ICS_4_0_3_DevKit_3_0_0/index_FDS.html
	접속

	TI Android ICS 4.0.3 DevKitV3.0.0 AM37x Sources
	Beagleboard XM
	다운

	tar.bz2 압축파일은
	tar xvfz 로 풀고
	bin 파일은 chmod 777 로 퍼미션 바꾼후 실행(10기가 정도)

	*sdcard에 image설치하기
	다운받은 pre-built image 폴더로 들어가서
	ex) /GLORY/XM/beagleboard/

	df로 sdcard 디바이스 확인
	./mk탭 /dev/(sdcard)

	*READEM.txt를 보면 3가지 설치법이 나온다.

3.	busybox 설치
	강의자료 ppt 참고
	1. busybox 다운로드 및 설치
	http://www.busybox.net/ 에서 최신 버전 다운로드 링크 주소
	$ wget http://busybox.net/downloads/busybox-1.19.4.tar.bz2 //다운로드
	$ tar xvf busybox-1.19.4.tar.bz2
	make menuconfig					// busybox-1.19.4.tar.bz2 압축 푼 폴더에서 실행
	Busybox Settings ---> Build Options --->
	옵션 메뉴를 타고 들어가시면 Build Busybox as static binary (no shared libs) 라고 되어 있는 메뉴를 활성화한다. 그리고 과감하게 make 해주시면 됩니다.
	그리고 그 아래 Build with Lage file Support (for accessing files > 2 GB) (NEW)를 *로 수정
	바로 아래 Cross compiler prefix를 선택, arm-none-linux-gnueabi- 입력
	(arm-none-linux-gnueabi-)라고 나와야함
	General Configuration -> [*] Don't use /usr 선택
	#make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- install
	#cd _install
	#cp -a ./bin/* /media/rootfs/system/bin/.					// */
	#cp -a ./sbin/* /media/rootfs/sbin/.						// */

	xm의 경우 에러 안뜨고 잘됨.
	이제 xm을 부팅한다.
	그리고 xm에 파일을 넣어놀 폴더를 한개 만들어 놓는다

//	adb start-server (adb 시작)
	adb kill-server
	adb devices (adb로 잡을수있는 디바이스 체크)
	adb install test.apk

	adb -s 20100720 shell			cf) 여러개의 adb server가 있을 경우 -s 20100720 명령으로 server 지정
	cd /data/
	mkdir app
	(/data/dd 예 넣어둘예정)
	adb push gpio.ko /data/app
	
	adb pull /data/app/gpio.ko c:\gpio.ko	cf)	안드로이드 기기 상의 /data/app/gpio.ko 파일을 개발자 컴퓨터 c:\gpio.ko 으로 복사
	
	exit
	
	2.	i.MX6 보드에 busybox 설치
	1-3.arm-2009q3-67-arm-none-linux-gnueabi-i686-pc-linux-gnu.tar.bz2 툴체인을 다운 받아서(반드시 본 툴체인으로 컴파일시켜야지만 에러 없이 buid 됨)
		/usr/local/arm-2009q3/bin 경로로 압축 풀기(리눅스용gcc(본, 폴더 안에 arm-none-linux-gnueabi-gcc gcc가 들어가 있음))
	1-2.~$vi .bashrc			->	아래와 같이 변경
		export PATH=/usr/local/arm-2009q3/bin:$PATH
	1-1.source ~/.bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령	

	http://www.busybox.net/ 에서 최신 버전 다운로드 링크 주소
	$ wget http://busybox.net/downloads/busybox-1.19.4.tar.bz2 //다운로드
	$ tar xvf busybox-1.19.4.tar.bz2
	make menuconfig					// busybox-1.19.4.tar.bz2 압축 푼 폴더에서 실행
	Busybox Settings ---> Build Options --->
	옵션 메뉴를 타고 들어가시면 Build Busybox as static binary (no shared libs) 라고 되어 있는 메뉴를 활성화한다. 그리고 과감하게 make 해주시면 됩니다.
	그리고 그 아래 Build with Lage file Support (for accessing files > 2 GB) (NEW)를 *로 수정
	바로 아래 Cross compiler prefix를 선택, arm-none-linux-gnueabi- 입력
	General Configuration -> [*] Don't use /usr 선택
	#make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- install
	#cd _install
	i.MX6 SD-Memory card를 reader기에 연결 후 Linux PC에 연결시킨 다음
	#cp -a bin /media/root/data/busybox
	#cp -a sbin /media/root/data/busybox		->	/media/root & /media/root/system directory는 read-only 설정이기 때문에 mount 설정 등을 변경시키지 않는 한 절대 복사 할 수 없기 때문에
												->	복사가 가능한 /media/root/data/busybox에 복사 시키고
												->	실행은 어쩔 수 없이 /media/root/data/busybox 안에 있는 busybox 명령이 실행되도록 해서 사용(ex, i.MX6 터미널 창에서 ./data/busybox/bin/vi 명령 실행)
												->	cf) /media/root/init.rc 등의 파일도 read-only 설정이기 때문에 수정 불가 함
	
	cf)	방법1)	한번 상기와 같이 busybox를 compile 시킨 경우 다음 부터는 간단히
		1)	compile 되어 있는 ~~/_install/bin & ~~/_install/sbin 폴더를 i.MX6 /data/busybox에 복사 시킨 다음
			#cp -a bin /media/root/data/busybox
			#cp -a sbin /media/root/data/busybox
		2)	./data/busybox/bin/vi 와 같이 실행시켜서 사용 함
	
	cf)	방법2)	한번 상기와 같이 busybox를 compile 시킨 경우 다음 부터는 간단히
		1)	compile 되어 있는 ~~/_install/bin 안에 있는 busybox 파일을
			~/myandroid/out/targer/product/sabresd_6dq/system/bin 폴더에 복사 시킨 다음
		2)	i.MX6 Terminal 창에서 busybox vi 등과 같이 실행하면 됨

4.	gpio
	다음 예제로 진행해본다.
	http://coherentmusings.wordpress.com/2012/11/25/beagleboard-xm-gpio-kernel-module-driver/

	Makefile만 수정한다.
	===============================================================
	KERN_SRC=/GLORY/XM/TI-Android-ICS-4.0.3_AM37x_3.0.0/kernel
	#안드로이드커널 있는 주소
	obj-m := gpio.o
	PWD=$(shell pwd)
	all:
	make -C $(KERN_SRC) ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- M=$( PWD) modules
	clean:
	make -C $(KERN_SRC) ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- M=$( PWD) clean
	===========================================================
	그리고 gpio_app를 컴파일할경우에는 반드시 -static옵션을 넣어줘야한다
	#arm-none-linux-gnueabi-gcc -o gpio_app gpio_app.c -static

	그리고 adb로 xm으로 넘긴다
	adb push gpio.ko /data/dd
	adb push gpio_app /data/dd
	adb shell
	cd /data/dd
	insmod gpio.ko
	dmesg
	(디바이스 번호확인. 아무것도 추가안햇을경우 248일것임.
	안나올경우엔 cat /proc/device 로 확인)
	mknod /dev/gpio c 248 0
	./gpio_app

	근데 이렇게 해보면 실행은 되지만 불은 안들어온다.
	다음 사이트를 참고한다.

	http://blog.naver.com/jjong_w?Redirect=Log&logNo=60178946778
	http://infoarts.tistory.com/21
	
	cd /sys/class/gpio/
	echo “149” > export
	echo “150” > export (이건 나중에 150번도 할려고 그냥함)
	cd gpio149
	echo “high” > direction
	cd ../gpio150
	echo “high” > direction
	
	cd /data/dd
	./gpio_app

5.	app
	http://asurada0320.blogspot.kr/2013/03/android-android-ndk.html
	을 참고한다.
	소스는 그대로 쓰기엔 너무 길기에 직접 작성함(첨부파일 참고)
	헤더파일과 c파일, 컴파일 방법은 홈페이지를 그대로 따라하면된다.
	소스를 다 작성하면 apk 를 install 해야되는데. 이때 전에 있던 파일이 workspace에 남아있는경우에는 c파일만을 수정한경우에 이클립스에서 apk컴파일이 새롭게 제일 되지 않아 bin/안의 apk를 지우고 빌드해야된다.

1-4.	Beagleboard-xm, i2c 속도 변경
	You can change this by modifying the kernel code and rebuilding. 
	The i2c bus speed is set in arch/arm/mach-omap2/board-omap3beagle.c
	Look for the omap3_beagle_i2c_init function.  Change the speed in the call
	to omap_register_i2c_bus.




[61]	그림으로 쉽게 설명하는 안드로이드 프로그래밍
	Page 75, 	먼저 import 문장을 입력하지 말고 소스만 입력한 후에 Ctrl+Shift-O 를 누르면 자동으로 필요한 import 문장들이 소스에 삽입된다.
	Page 76,	@Override은 어노테이션을 나타내는 기호이다. @Override은 메소드가 부모 클래스의 메소드를 재정의(오버라이드)하였다는 것을
				명확하게 컴파일러에게 전달한다.
	Page 170,	XML을 이용한 이벤트 처리
	Page 180,	커스텀 버튼(이미지 버튼)
	Page 475,	Thread를 사용하고 싶다면 AsyncTask를 사용하자
				AsyncTask는 Thread 기능도 하면서 복잡하지 않게 Thread 정의 method 안에서 UI를 변경시키는 것을 가능하게 해준다.




[62]	Windows XP & Windows 10
	하드디스크 용량이 계속 줄어들 때 하기 디렉토리 파일을 지울 것
	C:\Documents and Settings\rhkang.INFOPIA21\Local Settings\Temp

	cf)	윈도우 환경변수 확인
->	cmd.exe 명령창에서 set 명령으로 환경변수 사항 알 수 있음
C:\WINDOWS\system32>set
ALLUSERSPROFILE=C:\ProgramData
APPDATA=C:\Users\user\AppData\Roaming
CommonProgramFiles=C:\Program Files\Common Files
CommonProgramFiles(x86)=C:\Program Files (x86)\Common Files
CommonProgramW6432=C:\Program Files\Common Files
COMPUTERNAME=RHKANG
ComSpec=C:\WINDOWS\system32\cmd.exe
FSHARPINSTALLDIR=C:\Program Files (x86)\Microsoft SDKs\F#\4.1\Framework\v4.0\
GTK_BASEPATH=C:\Program Files (x86)\GtkSharp\2.12\
HOMEDRIVE=C:
HOMEPATH=\Users\user
JAVA_HOME=G:\Util\Android\Android Studio\jre
LOCALAPPDATA=C:\Users\user\AppData\Local
LOGONSERVER=\\RHKANG
MSMPI_BIN=C:\Program Files\Microsoft MPI\Bin\
NUMBER_OF_PROCESSORS=8
OneDrive=G:\Util\OneDrive
OS=Windows_NT
Path=C:\Program Files\Microsoft MPI\Bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;C:\Program Files\dotnet\;C:\Program Files\Anaconda3;C:\Program Files\Anaconda3\Scripts;C:\Program Files\Anaconda3\Library\bin;C:\Program Files\Git\cmd;C:\Program Files (x86)\GtkSharp\2.12\bin;C:\Program Files (x86)\Microsoft Emulator Manager\1.0\;G:\Util\Android\Android Studio\jre\bin;C:\Users\user\AppData\Local\Microsoft\WindowsApps;
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC
PROCESSOR_ARCHITECTURE=AMD64
PROCESSOR_IDENTIFIER=Intel64 Family 6 Model 158 Stepping 9, GenuineIntel
PROCESSOR_LEVEL=6
PROCESSOR_REVISION=9e09
ProgramData=C:\ProgramData
ProgramFiles=C:\Program Files
ProgramFiles(x86)=C:\Program Files (x86)
ProgramW6432=C:\Program Files
PROMPT=$P$G
PSModulePath=C:\Program Files\WindowsPowerShell\Modules;C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules;C:\Program Files\WindowsPowerShell\Modules\;C:\Program Files (x86)\Microsoft SDKs\Azure\PowerShell\ResourceManager\AzureResourceManager\;C:\Program Files (x86)\Microsoft SDKs\Azure\PowerShell\ServiceManagement\;C:\Program Files (x86)\Microsoft SDKs\Azure\PowerShell\Storage\
PUBLIC=C:\Users\Public
SESSIONNAME=Console
SystemDrive=C:
SystemRoot=C:\WINDOWS
TEMP=C:\Users\user\AppData\Local\Temp
TMP=C:\Users\user\AppData\Local\Temp
USERDOMAIN=RHKANG
USERDOMAIN_ROAMINGPROFILE=RHKANG
USERNAME=user
USERPROFILE=C:\Users\user
VBOX_MSI_INSTALL_PATH=C:\Program Files\Oracle\VirtualBox\
VS140COMNTOOLS=C:\Program Files (x86)\Microsoft Visual Studio\Shared\14.0\Common7\Tools\
windir=C:\WINDOWS

	cf)	일반적 방법으로 종료되지 않는 특정 프로세스 강제 종료 방법

taskkill /f /im xxxx.exe
taskkill /f /pid 0000

/f 옵션은 강제로 종료하겠다는 말이고
/im 옵션은 이미지 이름을 지정하겠다는 말입니다.
/pid 옵션은 말 그대로 PID 값(숫자)을 지정하겠다는 말이구요.

이미지 이름이나 PID는 어떻게 확인할까요? 	->	작업관리자 -> 세부정보

출처: http://www.snoopybox.co.kr/1623 [snoopybox]

	cf)	컴퓨터 로그 기록 삭제
인터넷 - 옵션 - 속성 -검색기록 사용 삭제.,

컴퓨터 한 시간은 대체적으로
윈도우 -> 이벤트 -> 로그 -> 삭제 하시면됩니다.


[63]	램타이밍(tCL, tRCD, tRP, tRAS)

※ 메모리를 구매하면 메모리의 스펙을 적어 놓은 곳에 666-18와 같은 숫자를 볼 수 있다. 램의 성능을 나타내는 숫자다. [램 타이밍, 램타]이라고 한다. 앞의 것부터 tCL, tRCD, tRP, tRAS를 의미한다.
※ 메모리는 작은 콘덴서의 집합이다. 콘덴서를 각각의 RAS#에 CAS#개씩 직렬로 붙여 만든다.

RAS1 - CAS1 - CAS2 - CAS3
 |
RAS2 - CAS1 - CAS2 - CAS3
 |
RAS3 - CAS1 - CAS2 - CAS3
 |
...

이런식으로 구성되어있다. (주의! 정확하게 그린건 아니다. 실제로는 훨씬 더 복잡하다) 이를 잘 생각하면서 아래의 내용을 봐야 한다.

※ tCL(CAS# Latency)
- CAS란 Column Address Strobe 또는 Column Address Select 을 의미한다.
- 시작 CAS# 부터 마지막 CAS#까지 '읽거나 쓰는데' 걸리는 클럭수.
- 낮을수록 좋다. 메모리 성능에 1% 정도 영향을 미친다.

※ tRCD(RAS# to CAS# Delay)
- RAS 란 Row Address Strobe 을 의미한다.
- 메모리는 RAS(행)을 먼저 찾고 CAS(열)을 찾는데, tRCD는 선택한 RAS#에서 CAS#를 '선택'하는데 걸리는 클럭 수다.
- 낮을수록 좋다. 메모리 성능에 1% 정도 영향을 미친다.

※ tRP(RAS# Precharge)
- 콘덴서는 시간이 지나면 자연방전된다. 따라서 주기적으로 충전해줘야 콘덴서안의 내용을 유지할 수 있다. 충전시에는 메모리에 접근할 수 없기 때문에 충전 주기를 정하는 건 중요하다. 
   너무 높거나 낮게 설정하면, 충전이 덜 되거나 과충전 되기 때문에 주의해야 한다. 충전하는 클럭수가 tRP다.
- 낮을수록 좋다. (낮을 수록 좋긴 하지만, tRP값은 tCL, tRCD값과 조화를 이뤄야 한다) 메모리 성능에 많은 영향을 미치지는 않는다.

※ tRAS(Row Address Strobe, Cycle Time)
- RAS#를 얻을 수 있는 간격. 모든 메모리 오퍼레이션의 시작은 RAS#를 받는 명령으로 시작하기 때문에, 사이클 타임이라고 부른다.
- 보통 tRAS = tCL + tRCD + tRP + 0~2 정도 된다. 
- 낮을수록 좋다.

※ SPD(Serial Pressence Detect)
- 메모리 모듈에 메모리의 정보를 넣어놓은 칩. JEDEC 표준이다. 타이밍을 자동으로 알아낼때 사용한다. 요즘 마더보드에서 SPD값 못 읽는 마더보드는 없다.

※ XMP(Extreme Memory Profiles)
- 인텔에서 개발한 오버클럭용 메모리 프로파일. JEDEC 표준은 아니지만 오버클러커들에게 유용하고 자세한 메모리 정보를 바이오스에 제공해준다. 고급 메모리 모듈에서나 지원한다.

※ CR(Command Rate)
- 명령과 클럭의 비율.
- 낮을수록 좋다. 1T로도 설정할 수 있지만, 보통 안정성을 위해 2T로 설정한다.

※ tRC(Row Cycle Time)
- RAS#를 얻을 때부터 데이터를 읽는데 걸리는 클럭수. 
- tRC = tRAS + tRP + 0~2
- 낮을수록 좋다.

※ tRFC(Row Refresh Cycle time)
- 메모리 뱅크의 RAS를 재충전하는 타이밍. 단위는 클럭. 매 tRFC클럭마다 무조건 충전한다는 의미다. 충전시에는 메모리에 접근하지 못한다는 것을 상기하자.
- 낮을수록 좋다.
cf)	▲ 지금 보실 tRFC와 뒤에 나올 tREF는 지금까지의 램 타이밍 항목들과는 성격이 약간 다릅니다.
이 둘은 램이라는 전자 제품의 전기적인 특성과 관련된 항목인데, 램은 일종의 콘덴서인 '셀'의 집합체로 가만히 두면 서서히 방전되는 성질이 있기 때문에 일정 주기마다 셀에 저장된 값을 다시 써줘야 합니다.
tRFC는 셀에 '다시 쓴' 이후 램이 다시 액세스 가능한 상태로 활성화되기까지의 시간을 지정합니다.
즉 '시간'에 관련된 항목이다 보니 여타 램 타이밍 항목들이 클럭 사이클을 단위로 갖는 데 비해 tRFC와 tREF는 직접 시간 값(나노초 / 밀리초)을 단위로 갖는 것이 특징입니다.

아무튼 tRFC의 테스트 결과를 보면, 우선 옵션들 사이의 값 차가 커서인지 연산시간 결과도 큰 차이가 납니다.
특히 tRFC 160ns와 300ns 사이의 결과가 큰 편인데, 이 사이에서 무려 18초나 되는 연산시간 차이가 났습니다.
이 사이의 값을 제외하더라도 tRFC 설정값이 변할 때마다 연산시간이 약 3~4초 가량 변화하고 있습니다.

※ tREF(REFresh time)
- tRFC마다 충전하는데 필요한 시간. 단위는 μsec
- 클수록 좋다.
cf)	▲ 위에서 본 tRFC가 램이 '셀에 다시 쓴' 때로부터 해당 셀이 활성화되기까지의 시간이라면 tREF는 바로 그 '다시 쓰기'를 얼마만에 한번씩 할 것인지를 지정하는 항목입니다. 
셀에 데이터를 다시 쓰는 동안은 액세스가 불가능하기 때문에 다시 쓰는 간격이 멀수록 성능에 유리합니다. 따라서 tREF만큼은 다른 램 타이밍 항목과 달리 설정값이 클수록 성능이 좋은 것이죠.
제 메인보드에서는 3.9ms / 7.8ms 두 값밖에 설정할 수 없었지만 15.6ms를 지원하는 메인보드도 있다는군요.

디폴트인 tREF 7.8ms를 3.9ms로 줄여 보니 연산시간이 약 7초 정도 늘어났습니다. 이는 단일 램 타이밍 항목으로는 tREF가 연산시간에 가장 큰 영향을 미치는 결과입니다.

※ tWR(Write Recovery Time)
- Write burst end와 Pre-charge 사이의 clock cycle
- DDR2에서 도입됨.




[63+1]	OPENiceEDS
	1)	부팅(메모리 다운로드) 시 Stack Data View 창을 열어 놓으면 부팅이 되지 않는 문제 있음


	

[64]	C언어 - volatile의 활용 Windows/Windows Internals 2013/05/03 19:46  
1. volatile의 정의
       1) volatile의 기능적 의미는 캐시 사용 안 함(No-Cache)이다. 보통 프로그램이 실행될 때 속도를 위해 필요한 데이터를 메
          모리에서 직접 읽어오지 않고 Cache로부터 읽어온다. 하지만, 하드웨어에 의해서 변경되는 값들은 Cache에 즉각적으로 
          반영되지 않으므로 데이터를 Cache 로부터 읽어오지 말고 주 메모리 에서 직접 읽어오도록 해야 한다. 이러한 특성 때문
          에 하드웨어가 사용하는 메모리 는 volatile로 선언해야 하드웨어에 의해 변경된 값들이 프로그램에 제대로 반영 된다. 
		  volatile은 Embedded Software에서 자주 사용하는 타입 한정자이다. 
	   cf) volatile 변수
	      변수를 register가 아닌 메모리에 저장한다. 아무리 많은 register 변수를 선언하더라도 CPU의 register 개수에는 한계가 있기 때문에 
	      register 선언이 효과를 지니지 않고 메모리 변수로 되는 경우도 있다.

2. volatile이 필요한 경우
  1) Optimize Option을 켜기 전까지는 코드가 잘 동작한다.
  2) 어떤 인터럽트를 disable 시킨 동안에는 코드가 잘 동작한다.
  3) RTOS가 탑재된 Mutitasking System에서 어떤 Task가 enable 되기 전까지는 Task가 잘 동작한다.

3. volatile을 사용하는 대상
  1) Memory-mapped periherral registers
  2) 인터럽트 서비스 루틴
  3) Multitasking 또는 Multithread 

4. volatile의 사용 예
  1) Memory-mapped periherral registers
         -. Embedded System에서는 진보되고 복잡한 실질적인 주변 디바이스(Peripheral)를 포함하게 된다. 이런 Peripheral
            들은 프로그램 흐름과 비동기적으로 값들이 변하는 레지스터들을 가지고 있는 경우가 대부분이다.
         -. Example
           : INT8U *ptr = (INT8U *)0x1234;
             while(*ptr == 0);
             간단한 예로 0x1234 Address에 위치한 8bit Status Register가 0이 아닌 값을 가질 때까지 Polling(하나의 장치 또는
             프로그램이 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치 또는 프로그램의 상태를 주 기적으로 검사) 한다.

             Optimize Option을 켰을 경우 
             { move ptr, #0x1234
               move a, @ptr
               loop bz loop } 
    이러한 어셈블러가 생성되고 처음에 한번만 0x1234를 Access해서 값을 로딩한 후 다시는 0x1234를 Access하지 않
    는다. 왜냐하면 Accumulator(CPU 내에서 계산의 중간 결과를 저장하는 레지스터)에 이미 Loading이 되어 있기 때문
    에 값을 재 Loading할 필요가 없다고 Compiler는판단하기 때문이다. 그러므로 마지막에는 무한 Loop에 빠지게 된다.

             volatile을 사용했을 경우 
             { move ptr, #0x1234
                loop move a, @ptr
                bz loop } 
                이러한 경우는 매번 메모리에 Access하여 값을 가져오기 때문에 정상적인 Polling역할을 수행하게 된다.

  2) 인터럽트 서비스 루틴에 의해 수정되는 전역변수
     -. 인터럽트 서비스 루틴은 메인함수에서 테스트하는 변수를 셋팅하게 된다. 
     -. Example
        : Int ETXRcvd = FALSE;

         void main(void)
         {
                 While(!ETXRcvd)
           {
                      // Something
           }

         }

         Interrupt void RxlSR(void)
         {
                 If(rx_char == ETX)
                {
                        ETXRcvd = TRUE;
                }
         }

        이러한 경우 Optimize Option을 꺼놓은 동안에는 코드가 올바르게 작동할 것이다. 그러나 Optimize Option을 켜놓게 되
        면 ETXRcvd의 값을 Register에 두고 연산을 처리하게 되어 인터럽트 서비스 루틴에 의해서 값이 바뀌었을 경우 이를 알 
        수 없는 경우가 생긴다. 이를 방지하기 위해 volatile로 값의 Read / Write를 메모리에 직접 접근하여 수행하게끔 한다.

3) Multitasking 또는 Multithread
     -. Example
        : int strawberry(int arg)
         {
            int *dummy;
            dummy = &arg;
           *dummy = 1;
           *dummy = 2;
           *dummy = 3;
           *dummy = 4;
           *dummy = 5;
           *dummy = 6;
           *dummy = 7;
           *dummy = 8;
           *dummy = 9;
           *dummy = 10;
           return *dummy;
        }

        이 함수가 하는 일은 dummy가 가리키는 주소에 1부터 10까지 넣는 일을 하고 있는데, Code Creator는 무슨 일이 있더
        라도 꼭 dummy가 가리키는 주소에 1부터 10까지 순차적으로 집어 넣어야 직성이 풀린다는 의지를 표현하고 있다. 만일 
        우리가 이 함수를 Compile하게 된다면, Compiler는 Optimization을 시도해서 아래와 같이 의도 하지 않는 방향으로 
        Code를 만들어 버립니다. 여기서 dummy 변수를 메모리에 저장하여 사용하지 않고 레지스터에 올려놓고 사용할 경우 
        다른 스레드에서는 공유 변수의 변경을 알 수가 없게 되어 잘못된 Cummunication으로 오류가 발생할 수 있다.

        int strawberry(int arg)
       {
         int *dummy;
         dummy = &arg;
         *dummy = 10;
         return *dummy;
       } 

5. 사용 시 고려 사항
1) 최적화를 막게 되어 프로그램 수행 속도가 떨어진다.
2) 어떤 장치의 한 영역을 나타내는 변수가 있고 이 변수를 통하여 그 장치의 상황을 받아들여 특정한 일을 처리함에 있어서 자주 값이 변경되는 경우인지 확인한다.
3) volatile 선언은 디버그 모드에서는 작동하지 않고 보통 Release Mode에서 최적화 시 발생한다.




[65]	CPU(Magic i, VR3511F) <-> SDRAM H/W Interface 참고 자료
	CPU가 SDRAM과의 통신이 안정적이지 않은 경우는
	하기와 같이 디바이스가 어뚱한 동작을 하는 문제가 발생할 수 있고
	본, 경우에는 하기와 같이 삼성 SDRAM을 사용해야 함
	
	측정값 저장 중 미터기 Halt 되는 문제 원인 파악 및 문제 해결
		가) 원인 분석 결과
			CPU <-> SDRAM 간 H/W적 통신 에러로 인해서 Buffer 변수가 오염 -> 이로 인해서
			미터기가 Halt되는 문제 발생한 것으로 파악
		나) 이유
			SDRAM을 기존 Hynix H5DU5162ETR-E3 에서 삼성 K4H511638D-UCB3으로 교체하니
		    미터기 Halt 현상이 72% -> 1.3%로 98% 성능 개선 됨 확인
		Cf) 삼성 K4H511638D-UCB3이 Hynix H5DU5162ETR-E3 보다 SDRAM 통신Timing 여유분이 좋고
		    실제 통신 파형을 OSC로 찍어봐도 깨끗하고 일정한 안정된 파형을 보여 줌
		
		다)	상기와 같이 삼성 SDRAM으로 변경한 경우에도 하기와 같이 동작시키면 미터기가 100% HALT 되는 문제 발생 함
			=>	최종원인분석결과
				본 미터기 HALT현상이 일어나는 원인은 기존에 있던 마스터 미터기 Memory -> QC -> Standard strip 에 저장되어 있던 data가 옳바르지 않게 저장된 것이 문제로 보임
				이유는, Memory -> QC -> Standard strip을 확인한 다음 미터기 전원을 OFF->ON 하면 본 HALT현상이 일어나지 않기 때문임
				(하기 c)~f) 실행해도 미터기 HALT 현상 일어나지 않음)
				cf)	신규 미터기(제일 처음 F/W Writing)에 하기 c)~f)를 실행해도 미터기 HALT 현상 일어나지 않음
				cf) Memory -> QC -> Standard strip 에 옳바르지 않게 저장된 상태에서 QC -> Standard strip을 실행해서 신규 Standard strip QC 결과가 옳바르지 않은 DATA 이후에 추가 저장되게 되니
					엉뚱한 메모리 포인터로 이동되어서 pImageDataProcess Address = 0x0 현상이 발생되면서 미터기가 HALT 되는 것으로 보임
				
			cf)	하기 Halt 현상은 제일 처음 한번만 일어나며 이후 미터기 전원 OFF -> ON 한 이후, 하기 과정을 a) ~ f) 똑같이 2회 이상 실행하는 경우에는 발생하지 않음
			cf)	하기 Halt 현상은 QC Test -> Standard Strip Test -> Standard1 하고서 다시 Standard1을 다시 실행해도 똑같이 발생함
			cf)	본 현상은 F/W Upgrade 후 미터기 전원 OFF -> ON 이후 다시 미터기 전원 OFF -> ON 한 다음 실행해도 똑같이 발생함
				미터기 Halt 현상이 일어난 직후 미터기 전원 OFF -> ON 실행해야만 일어나지 않음
			cf)	본 현상은 하기 a)번 하고도 무관함
				Upgrade하지 않고 기존에 있던 마스터 미터기에 b)~f) 실행하면 pImageDataProcess Address = 0x0 현상이 발생하며
				본 현상이 일어난 다음 미터기 전원 OFF -> ON하고 다시 실행하면 미터기 Halt 현상 일어나지 않음
			cf)	본 현상은 하기 a)번 b)과 무관함
				a), b)번 실행하지 않고 기존에 있던 마스터 미터기에 c)~f) 만 실행해도 pImageDataProcess Address = 0x0 현상이 발생하며
				본 현상이 일어난 다음 미터기 전원 OFF -> ON하고 다시 실행하면 미터기 Halt 현상 일어나지 않음
			
			a)	CardiacProduct(Ver1.00.05)_20151214.bin S/W로 미터기 Upgrade 시킨 이후, 전원 OFF -> ON
			b)	#RAWOFF 명령 실행
			c)	RFID등록(CODE: 0206 처음 등록)
			d)	QC Test -> Standard Strip Test -> Standard1 -> standard strip 삽입해서 QC 실행(자동으로 QC측정값 저장) -> OK
			e)	Standard Strip Test -> Standard2	=>	본 동작을 버튼을 아주 빠르게 눌러서 순식간에 두 화면이 넘어가도록 실행(아주 천천히 진행해도 발생함)
			f)	standard strip 삽입해서 QC 실행		=>	본 동작 실행 중에 미터기 HALT 되는 확률 70%이상 발생함(아래 debug message를 남기고서 HALT)
				cf)	미터기 HALT 당시 Debug message
					아래 정상적인 경우와 다른 점은 pImageDataProcess Address = 0x0 으로 지정되어 있다					
					
					-	첫번째 Standard1 QC 진행 시
					LFI_QC_TEST
					QCTest_CST_SelectLevel()::Button = 18
					Data Address -----------------------------------------
					g_iGUIframe Address = 0x8006c0d0
					
					Heap Address -----------------------------------------
					pControlLfiDetector Address = 0x818d0c88
					pImageDataProcess Address = 0x8191bce0
					
					Stack Address ----------------------------------------
					bPCInterface Address = 0x81ffac1c
					
					Size of Class ----------------------------------------
					sizeof(CControlLfiDetector) = 40
					sizeof(CImageDataProcess) = 2105064
					
					Lfi_User_PatientTest_NRT()
					
					......................................................................................................
				
					-	두번째 Standard2 QC 진행 시
					LFI_QC_TEST
					QCTest_CST_SelectLevel()::Button = 19
					Data Address -----------------------------------------
					g_iGUIframe Address = 0x8006c0d0
					
					Heap Address -----------------------------------------
					pControlLfiDetector Address = 0x818d0c88
					pImageDataProcess Address = 0x0
					
					Stack Address ----------------------------------------
					bPCInterface Address = 0x81ffac1c
					
					Size of Class ----------------------------------------
					sizeof(CControlLfiDetector) = 40
					sizeof(CImageDataProcess) = 2105064
					
					Lfi_User_PatientTest_NRT()
				
				cf)	미터기 HALT 되지 않고 정상적으로 구동 시 Debug message
					QCTest_CST_SelectLevel()::Button = 19
					Data Address -----------------------------------------
					g_iGUIframe Address = 0x8006c0d0
					
					Heap Address -----------------------------------------
					pControlLfiDetector Address = 0x818d0c88
					pImageDataProcess Address = 0x8191bce0
					
					Stack Address ----------------------------------------
					bPCInterface Address = 0x81ffac1c
					
					Size of Class ----------------------------------------
					sizeof(CControlLfiDetector) = 40
					sizeof(CImageDataProcess) = 2105064
					
					Lfi_User_PatientTest_NRT()

				cf)	미터기 HALT 당시 Debug message
					-	두번째 Standard1 QC 진행 시 하기와 같이 pImageDataProcess Address = 0x0 현상이 일어나서
						스트립을 삽입하지 않고 return 버튼 눌러서 나왔다가 "Standard2" 버튼을 눌러서 다시 들어가니
						이제는 하기와 같이 pControlLfiDetector Address = 0x10, pImageDataProcess Address = 0x4b068 모두 엉뚱한 값을 가리키며
						미터기가 HALT됨

					*state = 19
					LFI_QC_TEST
					QCTest_CST_SelectLevel()::Button = 19
					Data Address -----------------------------------------
					g_iGUIframe Address = 0x8006c0d0
					
					Heap Address -----------------------------------------
					pControlLfiDetector Address = 0x818d0c88
					pImageDataProcess Address = 0x0
					
					Stack Address ----------------------------------------
					bPCInterface Address = 0x81ffac1c
					
					Size of Class ----------------------------------------
					sizeof(CControlLfiDetector) = 40
					sizeof(CImageDataProcess) = 2105064
					
					Lfi_User_PatientTest_NRT()
					 Insert Strip for barcode read ! count = 0
					 Insert Strip for barcode read ! count = 1
					 Insert Strip for barcode read ! count = 2
					 Insert Strip for barcode read ! count = 3
					 Insert Strip for barcode read ! count = 4
					 Insert Strip for barcode read ! count = 5
					 Insert Strip for barcode read ! count = 6
					 Insert Strip for barcode read ! count = 7
					 Insert Strip for barcode read ! count = 8
					 Insert Strip for barcode read ! count = 9
					 Insert Strip for barcode read ! count = 10
					 Insert Strip for barcode read ! count = 11
					 Insert Strip for barcode read ! count = 12
					 Insert Strip for barcode read ! count = 13
					 Insert Strip for barcode read ! count = 14
					 Insert Strip for barcode read ! count = 15
					Go to previous state
					*state = 19
					LFI_QC_TEST
					QCTest_CST_SelectLevel()::Button = 19
					Data Address -----------------------------------------
					g_iGUIframe Address = 0x8006c0d0
					
					Heap Address -----------------------------------------
					pControlLfiDetector Address = 0x10
					pImageDataProcess Address = 0x4b068
					
					Stack Address ----------------------------------------
					bPCInterface Address = 0x81ffac1c
					
					Size of Class ----------------------------------------
					sizeof(CControlLfiDetector) = 40
					sizeof(CImageDataProcess) = 2105064
					
					Lfi_User_PatientTest_NRT()




[66]	Thread
1)	예제(Linux)
#include <cstdio>
#include <string>
#include <iostream>
#include <pthread.h>

void* print(void* data)
{
    std::cout << *((std::string*)data) << "\n";
    return NULL; // We could return data here if we wanted to
}

int main()
{
    std::string message = "Hello, pthreads!";
    pthread_t threadHandle;

    pthread_create(&threadHandle, NULL, &print, &message);

    
    pthread_join(threadHandle, NULL);

    return 0;
}

A better alternative, if you're able to, is to use the new C++11 thread library. It's a simpler, 
RAII interface that uses templates so that you can pass any function to a thread, including class member functions (see this thread).
Then, the above exmaple simplifies to this:

#include <cstdio>
#include <string>
#include <iostream>
#include <thread>

void print(std::string message)
{
    std::cout << message << "\n";
}

int main()
{
    std::string message = "Hello, C++11 threads!";
    std::thread t(&print, message);

    t.join();
    return 0; 
} 


2)	예제(MFC)
2013/07/09 12:40MFC Thread 사용 (AfxbeginThread)

CWinThread*     pThread = NULL;
bool  isThreadRunning;
static UINT ThreadFunction(LPVOID pParam);


//////////////////////////////////////////////////////////////////////////
//
//              Thread 생성 함수
//
//////////////////////////////////////////////////////////////////////////
void MyClass::CreateThread(UINT _method)
{
        if(pThread!=NULL)
        {
                AfxMessageBox("thread가 이미 실행중입니다!");
                return;
        }

        pThread = AfxBeginThread(ThreadFunction, this,
                THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);

        if(pThread == NULL)
           cout<<"Fail to create camera thread!!";

		isThreadRunning = TRUE;
        pThread->m_bAutoDelete = FALSE;
        pThread->ResumeThread();
}

//////////////////////////////////////////////////////////////////////////
//
//              Thread 소멸 함수
//
//////////////////////////////////////////////////////////////////////////
bool MyClass::DestroyThread(void)
{
		isThreadRunning = FALSE;

        if(NULL != pThread)
        {
                DWORD dwResult = ::WaitForSingleObject(pThread->m_hThread,500);

                if(dwResult == WAIT_TIMEOUT)
                {
                    cout<<"time out!"<<endl;
                    ::TerminateThread(m_hTestThread, 0)
                }
                else if(dwResult == WAIT_OBJECT_0)
                        cout<<"Thread END"<<endl;

                delete pThread;
                pThread = NULL;
        }
        return true;
}

//////////////////////////////////////////////////////////////////////////
//
//                      Thread 함수
//     
//////////////////////////////////////////////////////////////////////////

UINT MyClass::ThreadFunction(LPVOID pParam)
{
	CTestDlg* pWnd = (CTestDlg*)lpParam;

    while (pWnd->isThreadRunning)
    {
                // Check to see if the thread should die.
                if( !isThreadRunning )
                        break;

                // 소스 입력...
                //
    }

        return returnValue;
}
 

[함수 설명]
CWinThread* AfxBeginThread(
   AFX_THREADPROC pfnThreadProc,
   LPVOID pParam,
   int nPriority = THREAD_PRIORITY_NORMAL,
   UINT nStackSize = 0,
   DWORD dwCreateFlags = 0,
   LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL 
);

CWinThread* AfxBeginThread(
   CRuntimeClass* pThreadClass,
   int nPriority = THREAD_PRIORITY_NORMAL,
   UINT nStackSize = 0,
   DWORD dwCreateFlags = 0,
   LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL 
);
// - msdn :http://msdn.microsoft.com/ko-kr/library/s3w9x78e(v=VS.80).aspx
thread를 생성할 때 사용한다.
pfnThreadProc : 함수의 주소가 들어간다. (반드시 정적함수여야 한다.)
pParam : 스레드로 실행할 함수에 인자로 전달되는 값으로 보통은 주소가 된다.
nPriority: 스레드의 우선순위를 지정한다. 보통으로 사용하기 위해서는 THREAD_PRIORITY_NORMAL 을 쓴다. 
nStackSize: 스레드의 최대 스택 크기를 지정한다. 0을 넣으면 프로세스 생성시 최초 실행되는 스레드의 크기와 같게 할당된다.
dwCreateFlags: 스레드를 생성한 다음 즉시 실행할 것인지 아니면 대기했다가 실행할 것인지를 명시한다. 
CREATE_SUSPENDED를 사용하면 스레드는 실행되지 않고 대기하게 되며 이 경우 ResumeThread()
함수를 소출하여 스레드를 시작할 수 있다.

DWORD WaitForSingleObject( 
  HANDLE hHandle, 
  DWORD dwMilliseconds 
); 
// msdn - http://msdn.microsoft.com/ko-kr/library/aa450988
::WaitForSingleObject() 함수는 특정 object의 상태가 설정될 때 까지 현재 thread의 실행을 멈추는 역할을 한다. dwMilliseconds 시간만큼 기다리며 이 시간안에 object의 상태가 변화되면 값을 반환한다.
이때 반환값으로 WAIT_TIMEOUT이 반환되면, 기다리는 동안 object의 상태가 설정되지 않아서 그냥 반환했다는 것을 의미하며 WAIT_OBJECT_0를 반환했다면 object의 상태가 설정되어서 반환했다는 것을 의미한다.
여기서 hHandle에는 object의 핸들이나 프로세스의 핸들과 같은 각종 핸들이 들어간다.


[주의]
thread를 종료할 때 thread 함수 안에서 DestroyThread() 함수를 호출하면 thread가 정상적으로 종료 되지 않는다. (무한정 기다리게 되거나..)
그러므로 DestroyThread 함수는 반드시 thread 함수 밖에서 호출 해 줘야한다. (따로 종료 버튼을 만들거나, 메시지 방식 등..)
[출처] [MFC] mfc thread 사용하기 |작성자 hextrial


3)	예제(MFC)
CEvent m_hTestEvent;
BOOL m_bStopTestThread;
CWinThread* m_pTestThread;
HANDLE m_hTestThread;

void StartTestThread();
void StopTestThread();
static UINT TestThreadFunc(LPVOID pParam);

TestDlg.cpp에 다음과 같이 구현한다.

void CTestDlg::StartTestThread()
{
	StopTestThread();
	m_bStopTestThread = FALSE;
	m_pTestThread = AfxBeginThread(TestThreadFunc, (LPVOID)this);
	m_hTestThread = m_pTestThread->m_hThread;
}

void CTestDlg::StopTestThread()
{
	if(!m_hTestThread)
		return;
	
	m_bStopTestThread = TRUE;
	DWORD dwExitCode = 0;
	::GetExitCodeThread(m_hTestThread, &dwExitCode);
	if(dwExitCode != 0)
	{
		if(::WaitForSingleObject(m_hTestThread, 500) == WAIT_TIMEOUT)
		{
			if(::TerminateThread(m_hTestThread, 0))
			{
				delete m_pTestThread;
				m_pTestThread = NULL;
				m_hTestThread = NULL;
			}
		}
	}
	else
	{
		m_pTestThread = NULL;
		m_hTestThread = NULL;
	}
}

UINT CTestDlg::TestThreadFunc(LPVOID pParam)
{
	CTestDlg* pWnd = (CTestDlg*)pParam;
	
	while(!pWnd->m_bStopTestThread)
	{
		if(::WaitForSingleObject(pWnd->m_hTestEvent, 1000) != WAIT_TIMEOUT)
		{
			pWnd->m_hTestEvent.ResetEvent();
		}
	}
	
	pWnd->m_hTestThread = NULL;
	
	AfxEndThread(0, TRUE);
	
	return 0:
}

실제 실행되는 클래스 내에서 또 다른 Polling Routine이 도는 것과 같다.
특히 ThreadFunc의 Parameter로 넘기는 클래스 인스턴스는 실제 ThreadFunc 내부에서
클래스의 멤버 변수나 함수를 사용할 수 있게 해준다. 또한 ThreadFunc 내부에 있는
WaitForSingleObject의 Event 변수가 Set(m_hTestEvent.SetEvent()) 되어 있을 때
(1000ms 마다 체크) 실행되게끔 Code를 구현하고자 한다면, 실행시키고픈 Routine을
if문 안쪽에 넣어주면 된다.




[67]	Bio(바이오)
1.	혈장 혈청 혈구 혈병의 차이
◈혈장[Plasma]
혈액중 세포성분인 적혈구, 백혈구 , 혈소판 등이 제거된 액체를 말하며
이 안에는 피브리노젠[Fibrinogen]이 함유 되어있습니다.
혈액중 혈장을 얻을려면 혈액을 채취해서 항응고제를 첨부해서 혈액응고를 방지시킨후
시험관에서 오랫동안 세워서 방치하거나 원심분리기를 이용해서 분리하여 얻을수 있습니다.

◈혈청[Serum]
혈청은 혈장성분중에서 피브리노젠이 제거 된 액체를 말하며
이것을 얻기 위해서는 혈액을 채취하여 아무런 처리를 하지 않은 상태에서
시험관에 넣고 오랫동안 방치하거나 원심분리기를 이용해서 분리하여 얻을수 있습니다.
주의 할점은 혈액 채취후 원심분리기로 바로 분리하면 피브리노젠이 완전히 제거가 되지은 액체가 생기므로
일반적으로 실온에서 20-30분정도 방치를 해야 합니다.

◈혈구[Blood cell]
말 그대로 혈액속에 들어있는 세포를 말하며
종류는 적혈구, 백혈구, 혈소판 등이 있습니다.

◈혈병[Blood clot]
혈병은 혈액 채취후 아무런 처리를 하지 않은 상태로 방치했을 경우
시험관아래에 혈구가 혈액의 응고 기전에 의해 응고가 되어서 생기는 물질을 혈병이라고 합니다.

2.	hs-CRP등의 항원도 Gold항체에 비해서 숫자가 적을 수 밖에 없다.
	이유)
	가설1 :	hs-CRP항원의 개수가 Gold항체 보다 숫자가 많은 것이 진실이라면
			하기 예제가 진실이어야 함
			하지만 실제로는 하기 예제와 같은 상황에서도 Myoglobin을 제대로 측정할 수 있기 때문에 가설1은 틀린 것이 맞음
	예제 :	
	예를 들어서 Myoglobin 측정하려고 하는데 이 사람이 hs-CRP항원이 고농도인 사람임
	이런 사람의 혈액을 Myoglobin strip에 넣으면 Gold항체와 hs-CRP항원이 포화가 되서 Myoglobin을 제대로 측정할 수 없어야 함

3.	Competition 방식
T4, Vitamin-D 처럼 항원의 사이즈가 너무 작은 경우는 항원에 항체가 1개 밖에 붙을 수 없기 때문에
하기 2가지 조합을 모두 항체가 있는 Test line에 흘려 보내서 경쟁적으로 붙게 만들어서 측정하는 방식 임
1번조합 : 금나노 + 항체 + 항원(인공적으로 만든 항원, Vitamin-D경우는 Vitamin-D-BSA)
2번조합 : 항원(실제 혈액 속의 항원)

경우1) 고농도 : 2번조합이 많은 경우 Test line에 2번조합이 거의 다 붙어 버려서 1번조합이 붙을 확률이 떨어짐
-> 따라서, 금나노 발색이 거의 일어나지 않음, cf) 골드 발색이 덜 할수록 고농도
경우2) 저농도 : 2번조합이 적은 경우 Test line에 2번조합이 붙을 확률 떨어지기 때문에 1번조합이 붙을 확률은 높아짐
-> 따라서, 금나노 발색이 많이 일어나게 됨, cf) 골드 발색이 많을수록 저농도 

Cf) Vitamin-D 가 임상혈액에서 변별력이 없는 이유
   1. 상기 1번조합은 Test line에 붙은 Vitamin-D 항체와 잘 붙지만(인공적으로 만든 항원이 Test line에 있는 Vitamin-D 항체와 잘 붙음)
   2. 상기 2번조합이 Test line에 붙은 Vitamin-D 항체와 잘 붙지 않기 때문임
     (혈액내의 Vitamin-D 항원이 Test line에 있는 Vitamin-D 항체와 잘 붙지 않는 것으로
      이유는, 혈액내의 Vitamin-D 항원이 잡 Protein과 엉켜 있기 때문에 잘 붙지 않는 것으로 파악됨. 따라서 잡 Protein만 잘 띠어 내면 해결될 것으로 보임)
     (아니면 Test line에 있는 Vitamin-D 항체가 실제 혈액 속에 있는 항원과 잘 붙지 않는 것이 원인일 수도 있음)

cf) 2017년4월6일 현재
	1.	Vitamin-D를 Dilution buffer에 넣어서 Vitamin-D를 덮고 있는 잡 Protein을 벗겨낸 상태에서
	2.	Magnetic bead를 사용하는 Centaur로 측정하면 Vitamin-D가 어느정도 측정된다고 함(저/고농도 변별력 있음)
		cf)	상기 1.번 결과물을 기존 SelexOn strip에 적용하는 경우는 측정이 안 된다고 함
			반드시 1번 결과물을 Magnetic bead를 사용해서 벗겨진 Vitamin-D와 벗기는데 사용한 여러가지 Dilution buffer에 들어 있는 화학 조성물을 분리시킨 다음
			측정해야지만 된다고 함.
			->	이유는 상기 1.번 결과물에 기존 SelexOn strip 측정 방식 처럼 금나노와 붙은 항체를 집어 넣으면
				금나노가 벗기는데 사용하는 높은 PH의 Dilution와 반응되서 금나노가 망가져서
				결국 Lateral flow로 흘려도 Test line에서 Gold 발색이 일어나지 않는 다고 함
				cf)	만약 Gold 대신 형광을 사용 한다면 형광이 망가지지 않아서 발색할 수도 있을 것 같다고 함
					단 해보지는 않았다고 함




[68]	전기시험인증
1.	전기인증
	1)	IVD(체외진단용 의료기기), In Vitro Diagnostic Medical Device Directive, 대상품목(혈액검사기등)
	2)	RTTE(통신단말기), RTTE Radio and Tele-communi-cations Terminal Equipment, 대상품목(유, 무선통신 단말기)
	
[라포르시안]  '의료기기의 전기·기계적 안전에 관한 공통기준규격' 개정에 따라 지난 7월부터 국내에서 생산되는 3등급 의료기기 제품에 대해서도 ‘IEC60601-3판'의 적용을 받게 됐다. 

그러나 이를 놓고 의료기기 업계가 국내 현실에 맞는 규정 적용을 호소하고 있다. 
17일 한국의료기기공업협동조합(이사장 이재화)에 따르면 지난 12일 ‘IEC60601-3판 관련 간담회’를 열고 최근 국내에 도입된  새로운 의료기기 규정에 대한 애로사항을 공유하고 제도 운영에 대한 시정·보완을 요구하는 의견을 수렴했다. 
IEC60601-1 3판 규정(이하 3판 규정)은 국제전기기술위원회(IEC)가 제정한 의료기기의 전기·기계적 안전에 관한 공통기준규격이다.
개정된 '의료기기 전기·기계적 안전에 관한 공통기준규정'에 따라 추가되는 규격은 ▲국제규격인 방사선안전(IEC 60601-1-3) ▲사용적합성(IEC 60601-1-6) ▲경보시스템(IEC 60601-1-8) ▲생리적폐회로(IEC 60601-1-10) 
▲체외진단용분석기기(IE C61010) 및 인체삽입형 전자의료기기(ISO 14708) 등이다. 

국내에서는 ‘전기·기계적 안전에 관한 공통기준규격’이라는 명칭으로 올해 1월부터 위해도가 큰 4등급 의료기기부터 의무 적용을 해 왔다. 
4등에 이어 3등급은 올해 7월부터, 2등급은 내년 1월부터, 그리고 1등급은 내년 7월부터 순차적으로 의무 적용된다. 
문제는 2판에 비해 3판의 공통기준규격 심사기준 항목수가 더욱 늘어나면서 이에 따른 심사비용과 행정적 부담이 훨씬 커졌다는 점이다. 
이날 간담회에서 의료기기업계는 새로운 규정 도입과 관련한 제조현장에서 느끼는 애로사항을 공유했다. 
의료기기업체 관계자들은 "3판 규정 적용이 국내 의료기기 산업 발전에 필요하다는 점은 동의하지만 적용시기, 적용범위 등 적용방식에 대해서는 상식적이지 않다"고 불만을 토로했다.
특히 식��처에서 기존 2�� 규정으로 허가를 받은 제품에 대해서도 모두 소급해 3판 규정을 적용 받도록 한 것에 대해 어려움을 호소했다.  
의료기��조합은 이날 간담회에서 나온 내용을 정리해 식약처에 개선방안 마련을 요구할 방침이다.
그동안 조합은 3판 규정 도입과 관련해 정책적으로 ▲의료기기의 전기·기계적 안전에 관한 공통기준규격 가이드라인 작성 참여 ▲IEC60601-1 3판 적용 관련 간담회 개최(3회) ▲IEC60601-1 3판 적용 유예 요청 ▲조합 내 제도개선협의회를 통해 지속적인 대응방안 논의 ▲제조사들의 3판 관련 애로사항을 조사해 식약처에 현황 및 건의 사항 전달 등의 활동을 진행했다.
조합 이재화 이사장은 "국내 의료기기 제조기업 상당수가 3판 규정 도입을 위해서 인력을 보강하고 있고 관련 스터디도 지속적으로 진행하고 있는 것으로 알고 있다"며 "식약처가 추진하는 국민 안전 노력에 우리 기업들도 적극 참여해야 하지만 현실적으로 현장에서 느끼는 소급 적용의 어려움과 준비 기간 부족에 대해서 식약처에 개선방안을 마련해 주도록 요청할 것"이라고 말했다.   
김상기 기자  bus19@rapportian.com
<저작권자 ⓒ 라포르시안, 무단 전재 및 재배포 금지>		

cf)	IEC60601-1 vs IEC61010-1
일반적으로 전자의료기기의 안전성 평가규격으로 의료기기의 전기 및 기계적 안전성 시험규격인 IEC60601-1 을 적용하나 
체외진단(I.V.D)용 의료기기는 측정, 제어 및 실험실에서 사용하는 전자기기의 안전요구사항 - 제1부 : 일 반 요구사항 규격인 IEC61010-1 규격을 미국 FDA승인, 유럽 CE인증에 적용하고 있다. 
IEC61010-1 국제규격은 화 재나 폭발, 감전, 화상, 독성, 유해가스 등 실험실 환경에 대한 안전성 평가항목이 강화된 규격으로 실험실에 사용하 는 의료기기의 안전성 평가에 적합한 규격이다.
따라서 주로 실험실 환경에서 사용하는 체외진단용 의료기기에 대한 안전성 평가방법의 국제조화를 위해 IEC60601규격과 IEC61010-1규격의 주요시험항목에 대한 차이점을 시험을 통하 여 
객관적으로 증명하여 체외진단용 의료기기에 대한 IEC60601-1규격적용의 타당성 제시하며 체외진단용 의료기기 의 안전성 평가를 위한 공통기준규격의 제정을 위한 연구자료로써 활용코자한다.


cf)	ESD(Electrostatic Discharge)


cf) EMI & EMC & ESD & EMS  하드웨어  

EMC란 ElectroMagnetic Compatibility의 약어로 전자환경 문제에서의 전자기적 양립
성 또는 전자적합성을 말한다. 
　 
전자기로 인한 전자파장애 등 전자환경 문제에는 많은 문제들이 있으며 무선통신에서
의 채널간 상호간섭문제, 주파수 스펙트럼 효용문제, 방송전파의 고스트(ghost)문제, 
로봇시스템 등 컴퓨터 응용기기의 오동작 및 안전성문제,정보통신 네트워크의 신뢰성
문제 등이 있으며 나아가 인체 등 생물생태계에 대한 전자에너지의 영향이 보다 중요
한 EMC의 문제로 돼 있다. 
　 
예를들면 텔레비전의 수신장애에서는 고층빌딩, 송전선, 고가교탑 등으로부터 반사되
는 전파에 의한 고스트발생, 정보통신 네트워크에서는 무선이동통신에서의 주행성 패
이징이나 도시전파 잡음에 의한 오동작, 사람을 비롯한 생물체에 미치는 생체장해
(hazard) 등 많은 문제들이 있다. 이들 불요전자 에너지의 방사원에 대한 대책만이 아
니라 장해를 받는 쪽도 내방해파특성(immunity)의 강화책을 강구, 실시해 조화있는 해
결책을 탐구하는 것을 바탕으로 전자기적양립성(EMC)이란 개념이 생겨났으며 이에 관
련된 학문체계를 환경전자공학이라고 한다. 
　 
전자환경은 예전에는 전파잡음으로 일원적으로 파악되고 있었으나 전기적 에너지 이
용의 증가에 따라 불요전자 에너지 방사가 증대, 이를 환경문제로 취급하게 됐으며, 
미국전기전자공학회(IEEE)는 58년 전자파장해 전문그룹으로 GRFI(Group Radio Fr-
equency Interference)를 만들었고 그 후 EMC 소사이어티로 개칭하게 됐으며 매년 국
제학회를 개최하고 있다. 

Electro Magnetic Interference(전자파간섭 또는 전자파장해) 

EMI(전자파간섭 또는 전자파장해)는 전기·전자기기로부터 직접방사, 또는 전도되는 전자파가 다른 기기의 전자기 수신 기능에 장해를 주는 것을 말하며 Electro Magnetic Interference의 줄임말이다. 
　 
국제전기표준회의(IEC)의 정의에 의하면 "EMI는 불필요한 전자기신호 또는 전자기잡음에 의해 희망하는 전자기신호의 수신이 장해를 받는 것"으로 돼 있다. 
　 
1930년대 부터 대두되기 시작한 EMI가 50년대까지는 주로 전파잡음 간섭의 범위에서 다루어졌으며 1958년에 전기·전자기기로부터 직접방사하는 방사잡음간섭(Radiated EMI)과 전원선을 따라 새어나오는 전도잡음간섭(Conductive EMI)등을 취급하는 전문그룹으로 GRFI(Group Radio Frequency Interference)를 미국전기전자학회(IEEE)내에 설치했다. 
　 
각종 전자기기의 사용이 폭발적으로 증가함과 동시에 디지털기술과 반도체기술 등의 발달로 정밀전자기기의 응용분야가 광범위해지면서 이들로부터 발생하는 전자파 장해가 전파잡음 간섭을 비롯해 정밀전자기기의 상호 오동작, 인체등 생체에 미치는 생체악영향(Biological hazard)등을 낳게 되어 생물생태계에의 전자에너지의 영향이 큰 문제로 대두되면서 1973년에 IEC는 EMC(전자환경문제-Electro Magnetic Compatibility)를 다루는 기술위원회인 TC-77을 만들어 전자환경문제를 중점적으로 심의하고 있다. 
　 
특히 전자파가 생체에 미치는 영향은 심각한 것으로 생체에 미치는 열적효과의 경우 생체에 의해 흡수된 전자에너지가 원인으로 온도상승이 발생, 이 때문에 생체의 조직·기능이 손상을 입기도 한다. 
　 
따라서 사람에게 안전하다고 인정되는 전자계 레벨이 국제기구(WHO, IRPA)나 미국(ANSI, NIOSH, ACGIH) 캐나다, 소련, 독일 등 각국에서 설정되어 있다. 
EMI (ElectroMagnetic Interference) 전자파 장해
 
전자 기기로부터 부수적으로 발생된 전자파가 그 자체의 기기 또는 타 기기의 동작에 영향을 미치는 것. 예를 들면, 컴퓨터에 내장된 클록 펄스 발생기는 수많은 고조파 성분을 포함하고, 이러한 고조파 성분은 공간으로 방사되거나 전원선을 통해 전도되어 근처 텔레비전 수상기 화면이나 음성의 질을 떨어뜨릴 수 있다. 이러한 현상은 자동차나 비행기가 지나갈 때도 느낄 수 있다. 전자파 잡음(무선 주파수 잡음)은 원하지 않는 전자파 에너지로, 전파법에서는 무선 주파수 범위를 10kHz~3,000GHz로 정의하고 있다. 대부분의 전자 기기는 정도의 차이는 있지만 전자파 잡음을 발생하며, 발생된 전자 에너지는 어떠한 매질의 경로를 통해 타 기기에 장해를 주게 된다. 이와 같이 타 기기에 전자파 장해를 끼치는 것을 능동적 장해라고 한다. 이에 반해 대부분의 전자 기기는 외부로부터 침입한 전자파 잡음에 의해 장해를 받는데, 이러한 장해를 수동적 장해라고 한다.
 
ESD (ElectroStatic Discharge) 정전방전
 
정전기를 띤 물체에서 정전기가 방출하는 것. 
 
* 정전기 (Static Electricity) 
전기(電氣)의 일종으로 접촉이나 마찰에 의해 부도체(不導體)의 물체에 발생하는 전기. 이는 인쇄용지의 제지(製紙)나 인쇄작업에서 커다란 장애요인의 하나가 되고 있다. 인쇄공정에서는 인쇄용지의 수분이나 습도의 과소, 인쇄압의 과대 등으로 이러한 정전기가 생기게 된다. 그러면 인쇄용지가 서로 달라붙어서 잘 떨어지지 않기 때문에 삽지(揷紙)가 곤란할 뿐 아니라, 인쇄기의 헛돌림이 생기게 되고 또한 압동(壓胴)에 인쇄지가 달아붙어 배지장치로 잘 흘러가지 않게 되며, 종이받이에 가지런히 쌓이지 않게 되고 쌓인 인쇄지도 서로 달라붙어 뒤묻음이 생기는 등 여러가지 인쇄고장을 일으킨다. 따라서 정전기가 발생하지 않도록 방지해야 하는데, 그 방지법으로는 제전장치(除電裝置)를 설치하거나, 그렇지 못할 경우는 인쇄소의 실내 습도를 높이거나 인쇄압을 적정하게 조정하는 방법 등이 있다.
 
ESD(Electronic Software Delivery)
 
정전기는 중간에 절연물(공기,유리등등)을 두고 두 도체가 대전된 상태를 말합니다. 이때 어느 한극은 +이고, 다른 한극은 -죠. 따라서 DC라 할수 있습니다. 
교류는 +,-극이 수시로 바뀌어야 하지만 그렇지는 않죠. 
그리고 PULSE라는 것은 짧은 시간에 순간적으로 방전되는 파형을 흔히 펄스라 하는데 이것은 정전기가 전압은 높고,전하량은 적기 때문에 나타나는 현상일뿐입니다. 만약 정전기도 전하량이 많은 상태에서 높은 저항으로 방전시키면 펄스가 아닌 일반 건전지 방전처럼 서서히 낮아지는 형태가 됩니다. 
 
.E.M.I(Electromagnetic Interference) : 전자파간섭 또는 전자파장애로 해석되며 법규에 의하면 '방사 또는 전도되는 전자파가 다른 기기의 기능에 장애를 주는 것'이라 정의되어 있으며, 그 영향으로는 전자회로의 기능을 약화시키고 동작을 불량하게 할 수 있읍니다. 

.E.M.S(Electromagnetic Susceptibility) : 전자파내성, 즉 어떤기기에 대해 전자파방사 또는 전자파 전도에 의한 영향으로부터 정상적으로 동작할 수 있는 능력을 말함. 이것은 E.M.I와는 대응이 되는 용어로서 전자파로부터의 보호라고 부르기도합니다 


.E.M.C(Electromagnetic Compatibility) : 전자파적합, 양립성이라 해석되며 '전자파를 주는 측과 받는 측의 양쪽에 적용하여 성능을 확보할 수 있는 기기의 능력'으로 법규상 정의되어 있다. 이 용어는 E.M.S와 E.M.I를 모두 포함하는 포괄적인 용어로서 어떤 기기가 동작 중에 발생되는 전자파를 최소한으로 하여 타기기에 간섭을 최소화해야 하며(E.M.I), 또한 외부로부터 들어오는 각종의 전자파에 대해서도 충분히 영향을 받지 않고 견딜 수 있는 능을 갖추어야 한다(E.M.S)는 의미입니다.
[출처] EMI & EMC & ESD & EMS|작성자 묵님

cf)	Medical adaptor 사용하면 IVD 로 인증 받을 수 없는 지?
	에스케이테크(신승철) 답변
	-	IVD인증을 위한 특확된 Adaptor는 없으며
	-	IVD인증 받을 때 Adaptor 스펙은 보통 60601로 받은 Adaptor면 상관 없다
	-	Medical adaptor를 사용하고 있다고 IVD 인증을 받을 수 없다는 단서 조항은 없다.




[69]	인덕터와 비드위 차이 (주파수 특성에 대해서)??? kdsgo 답변채택률84.2%2004.08.18 22:32답변 추천하기 
	1)	구조나, 특성및 해석은 인덕터나 비드나 같습니다. 
	비드도 인덕터입니다. 다만 직류저항이 매우 낮고, 직류전류에 대해서 자기포화가 되지 않게끔 개방구조로 되어 있어
	주로 전원단의 고주파 차단을 위해서라든지 외부단자의 EMI 특성을 개선시키기 위해 사용합니다. 
	인덕터는 말그대로 L이 필요한곳 - 발진회로라든지, 필터회로등에 주로 사용하므로 아무래도 인덕터보다는 비드사용이 많을 뿐이죠.

	2)	비드의 주목적은 처리하는 신호의 고조파성분을 제거하는 것입니다. 
	유럽의 경우 EMI 와 같은 전자파관련 법규에 꽤 엄격합니다. 이런 경우 전원이나 신호LINE에 비드를 삽입하여 고주파성분이 전달되는 것을 막는 역활을 하죠. 
	위의 비드에 대한 의미를 잠시 보면 
	FB:페라이트 비드(재질이 페라이트란 의미임)
	2012 : 외부 사이즈를 의미할것입니다. 
	30 @ 100Mhz :100Mhz 에서 30옴의 임피던스를 가짐(비드의 주파수 특성)

	3)	비드는 보통 전원LINE중간에 넣어 고주파성분을 제거하는데 주로 사용하죠. 
	여기에는 DC(직류)에 대한 사양과 AC(교류)에 대한 사양이 있습니다. 
	1.4A라는 의미는 직류허용전류라 할수 있습니다. 즉 4A까지 사용가능하단 의미죠.
	2.Impeadance는 교류적인 값으로 30Ω은 특정 주파수에 대한 교류저항값이라 할수 있죠. 아마 spec에 보시면 주파수가 1Mhz라든지 하는 측정조건이 나와 있을 것입니다. 
	즉 이 비드는 1Mhz에서 교류임피던스값이 30Ω이란 의미입니다. 
	3.Max Rdc 0.01Ω 이란 것은 직류저항값을 말합니다. 비드의 역활을 보면 직류는
	잘통하고, 교류는 안통하게 하는 것이 주 목적입니다. 따라서 직류저항값은 낮을수록 좋고, 교류임피던스는 높을수록 좋다고 할수 있죠. 
	4.300nH라는 인덕터값이 주어지면 사용주파수에 대한 임피던스값을 구할수 있죠.
	XL = 2πFL 로 주어집니다. 예를 들어 300nH라면 100Mhz에서 약 188Ω의 임피던스를 갖는다는 것을 알수 있죠. 이러한 계산치에 의해 감쇄량이라든지, 효과등을
	예측할수 있는 것입니다. 
	참고하세요.

	4)	Impedance
		가)	bead	-> Max로 높은 Impedance가 100MHz일 때 2.5Kohm 임(Inductor 보다 사이즈 적음)
			a)	10MHz		: 75ohm,	Impedance 낮다(inductive)
			b)	300MHz		: 250ohm,	Impedance 높다(resistive)
			c)	900MHz이상	: 75ohm,	Impedance 낮다(capacitive)
		나)	Inductor-> 중간 정도 Impedance가 100MHz일 때 29.5Kohm 임(bead 보다 사이즈 큼)
			Xl = 2πfL = 주파수가 높아질 수록 Impedance도 높아짐




[70]	Bluetooth 직렬 통신 연결 방법(옴니아2 폰 사용)
	1)	bluetooth 검색(cf, myglucohealth가 검색 창에 이미 저장되어 있으면 삭제 시킨 다음에 새로 검색)
	2)	신규 myglucohealth 아이콘을 SCH-M710 아이콘에 끌어다 놓음
	3)	비밀번호 입력 : 0000 입력
	4)	메뉴 -> 장치 서비스 -> 직렬통신 -> 설정
		가)	-> COM포트 -> "새 송신 포트" 누름 -> myglucohealth 선택
			-> 다음 -> COM2선택 & [v]보안 연결 -> 마침
		나)	-> 장치 -> "myglucohealth" 길게 누름 -> [v]직렬 포트 -> 저장
		다)	ok 눌러서 빠져 나옮
	5)	Terminal1v01_nc 실행(WinCE 용 터미널 창)
		가)	Menu -> File -> Open Port -> Port = COM2: 선택, Baud Rate = 9600 -> Open
		나)	"[      ] Send" 박스 안에 송신하고자 하는 명령을 집어 넣은 다음 "Send" 버튼을 눌러서 송신 시킴
			cf)	M1, M2, M3, M4, M5 버튼을 사용하면 미리 지정된 명령을 송신 시킬 수 있음
				->	설정 방법
					A)	Menu -> Tools -> Config
						a)	M1:[              ] 등의 창에 송신 시킬 명령 집어 넣은 다음
						b)	Delay(ms) : 1, Interval(ms) : 10, Repeat : 1을 집어 넣고서 "ok"버튼 누름




[71]	i.MX6(i.MX 6 Series SABRE for Smart Devices)
	cf)	www.nxp.com & https://boundarydevices.com/my-account/
			아 : 한메일
			패 : 기본8
	cf)	boundary devices BOM Request e-mail
I bought your board and I asked a BOM(Hardware part list) yesterday
, but I have not received it yet.
- boundary devices NITROGEN6-MAX_REV4  03-21-2016

I would like to know when to give it.(Please answer fast)

Email : icbm12@hanmail.net


Why do not you have a reply?

Is it possible to give a bom file? Is not it?
- boundary devices NITROGEN6-MAX_REV4  03-21-2016

For reference, the NXP evaluation board gives the BOM file.
Why does BOUNDARY not give me a BOM file?





	1-8)Boundary Devices 평가보드
		cf)	
From: 박경서 [mailto:sun@cmelec.co.kr] 
Sent: Thursday, July 3, 2014 8:09 AM
To: 'rhkang@infopia21.com'
Subject: 견적서_씨엠일렉트론

안녕하세요!

첨부와 같이 견적서 및 사업자 등록증을 보내 드립니다. 

확인 하시고 발주 진행 여부 확인 부탁 드립니다. 

감사합니다. 

******************************************************
CM Electron Co.,Ltd.
박 경서 과장 / Sales Team Manager
#201,Wonjong Kumho Center, 470, Wonjong-dong,
Ojeong-gu, Bucheon-si, Gyeonggi-do, Korea
Tel : 070-4829-3590 
Fax : 032-677-3599 
Mobile : 010-9331-8779
E-mail : sun@cmelec.co.kr

*****************************************************


	
		Android Marshmallow 6.0.1 GA release

		We are glad to deliver the latest?Android Marshmallow 6.0.1?GA release for all our platforms:?BD-SL-i.MX6 (SABRE Lite),?Nitrogen6x, Nitrogen6_Max?(Quad and QuadPlus), Nitrogen6_SOM, Nitrogen6_SOMv2,?Nitrogen6_Lite, Nit6_SoloX?and Nitrogen6_VM.
		This release went under the same testing as our previous?releases?which is why we now recommend this release?for new designs.
		
		For the impatient
		You can download images from here:
		m601-nitrogen6x-20170224.img.gz?for Nitrogen6X, BD-SL-i.MX6 (SABRE Lite), Nitrogen6_Max, Nitrogen6_SOM and Nitrogen6_SOMv2
		m601-nit6xlite-20170224.img.gz?for Nitrogen6_Lite 
		NOTE: After several remarks, we recommend only Nitrogen6_Lite with 1GB of RAM for this version. For boards with only 512MB or RAM, KitKat 4.4.3 is the best option.
		m601-nitrogen6sx-20170224.img.gz?for Nit6_SoloX
		As usual, you’ll need to register on our site and agree to the EULA because it contains Freescale content.
		Update 20170224 changelog:
		Fixed BT A2DP connection for TiWi-BLE
		Fixed USB storage management
		Fixed 6QP media profile
		Updated TiWi firmware files (both BT & WiFi)
		Update 20161129 changelog:
		Fix ft5x06 firmware bug (timeout)
		Fix dirty cow kernel exploit?(CVE-2016-5195)
		Add hwrotation override capability from U-Boot
		Updated TiWi firmware files to latest
		Updated TC358743 HDMI input driver
		Update 20160811 changelog:
		Navigation bar buttons working on both Landscape and Portrait mode
		WiFi auto-connect at bootup
		Can now skip the “ANDROID_” text at bootup (ro.init.skip.text)
		Updated TiWi wpa_supplicant lib
		Fixed CPUFreq permissions for Power HAL
		Update 20160620 changelog:
		Adds basic OV564x autofocus support
		The image is a 4GB SD card image that can be restored using zcat and dd under Linux.
		?
		1
		~$ zcat m601*.img.gz | sudo dd of=/dev/sdX bs=1M
		For Windows users, please use?Alex Page’s USB Image Tool.

	1-7)i.MX6 Board -> Android OS 상에 App 설치하는 방법
		가)	Main화면 ->	Ethernet icon 실행 -> DHCP로 설정
		나)	Main화면 ->	Browser icon 실행 -> http://www.apkmirror.com 에 접속해서 download하고자 하는 *.apk 파일 download
			ex)	www.apkmirror.com -> Search 선택 -> explorer 입력 -> explorer 해당되는 여러개 파일 리스트 보여줌
				ES File Explorer File Manager ~를 선택
		다)	Main화면 ->	Settings icon 실행 -> Security -> Enable 'Unknown Sources'
		라)	Main화면 ->	Download icon 실행 -> 해당되는 *.apk 파일 install
			ex)	상기 나)에서 다운 받은 ES File Explorer File Manager ~를 선택하면 install 됨
			cf)	본, ES File Explorer File Manager ~를 install 해 두면 나중에 임의로 SD-Memory로 수동 입력한 *.apk 설치 파일 등도 선택해서 install할 수 있음
			
	1-6)i.MX6 Board -> Android OS 상에 App 프로그램 update
		가)	Eclipse -> 해당프로젝트선택 -> File -> Export -> Export Android Application 선택 -> 이미 존재하는 키스토어 파일 선택하던지 새로운 키스토어 파일 선택해서 "개인키를 이용하여서 서명되고 정렬까지 된" *.apk 파일을 만듦
		나)	i.MX6 Board를 OTG-USB Cable을 사용해서 PC(Windows)와 연결 함
		다)	PC -> 탐색기 -> SABRESD-MX6DQ 항목으로 USB-Memory 항목이 추가 됨 -> Download 폴더에 상기 가)에서 만들어진 update하고자 하는 *.apk파일을 복사 함
		라)	i.MX6 Board -> Main화면 -> ES File Explorer File Manager ~ 앱을 실행 함
		마)	상기 나)번 Download 폴더를 선택한 다음 -> 해당하는 *.apk파일을 선택해서 install 시킴		

	1-5)i.MX6 Board 에서 SDK Unit Test 수행하기
		가)	imx6_platform_sdk_v1.1.0(Software Development Kits).tar.gz 파일을 Ubuntu OS 상에서 압축 해제
		나)	~/.bashrc 파일을 하기와 같이 설정 함
			export PATH=/opt/arm-2014.05/bin:$PATH
		다)	source ~/.bashrc 명령 실행
		라)	iMX6_Platform_SDK 폴더로 이동한 다음
			./tools/build_sdk 명령 실행
		마)	SD Memory Reader에 SD Memory를 삽입한 다음 USB에 연결(Ubuntu OS 상에서 연결)
		바)	dd if=output/mx6dq/sdk_unit_test/smart_device_rev_c/sdk_unit_test_ALL.bin of=/dev/sdb seek=2 skip=2 bs=512 && sync 명령을 실행해서
			SD Memory에 writing
		사)	재 부팅하면 아래와 같은 화면이 출력되고
			SDK Unit Tests
			--------------
			e - epit test
			g - gpt test
		아)	Console 창에서 "e" 키를 눌러서 e - epit test 명령을 실행시키는 방식으로 Unit test 실행
			
	1-4)i.MX6 Board 에서 "Hello world" 문구 띠우는 프로그램 실행 과정 총정리
		가)	test.c
			#include <stdio.h>

			int main(void)
			{
				printf("Hello Embedded\n");
			
				return 0;
			}
		나)	Makefile
			#CC=/home/krh/rowboat-android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-gcc
			CC=/usr/local/arm-2009q3/bin/arm-none-linux-gnueabi-gcc
			CFLAGS=
			OBJS=test.o
			test : ${OBJS}
				${CC} -o test ${CFLAGS} ${OBJS} -static
		다)	make	->	Ubuntu 에서 make 명령 실행
		라)	i.MX6 Board Terminal창에서
			chmod 777 /data			명령 실행
		마)	Eclipse에서 i.MX6 Board 와 adb 연결 시킨 다음
			DDMS -> Push 명령을 사용해서
			Ubuntu에 저장되어 있는(cf, 상기 다)에서 실행시켜서 나온) test 파일을
			i.MX6 Board /data		폴더에 복사 시킴
		바)	i.MX6 Board Terminal창에서
			cd /data
			chmod 777 ./test
			./test					명령을 실행시키면 "Hello Embedded" 문구가 Terminal 창에 표시됨

	1-3)UART 통신
		가-1)UART 기능을 i.MX6 보드에서 테스트 하려면
			// add, UART
			/* 본 UART 기능을 i.MX6 보드에서 테스트 하려면(아래와 같이 실행하면 정상적으로 UART3으로 UART 통신이 구현 됨) 
				1.	chmod 777 /dev/ttymxc*
				2.	chmod 777 /data/app-lib/net.krh.selexon2-1/libJavaComm.so
				3.	H/W적으로 DEBUG UART TO USB CONVERSION(U22, FT232RQ)에 기존 UART1이 연결되어 있던 것을 강제적으로 UART3이 연결되도록
					변경 시킨 다음에 아래 명령을 실행시켜여 함		*/
			m_eventHandler = new EventHandler();
	
			// 직렬포트 스레드 객체 생성 및 시작
			m_comm = new JavaComm(m_eventHandler, 256); // 직렬통신용 스레드 객체생성
	
			m_fd = m_comm.openPort("/dev/ttymxc2", 115200, 1, 5);
			Log.d(TAG, "m_fd = " + m_fd);
	
			/* 본 start() 명령으로 JavaComm 메서드 안의 public void run() 메서드를 Thread로 돌리게 됨	*/
			m_comm.start(); // 직렬포트로 데이터 수신 시작
	
			m_comm.send("Start of UART /dev/ttymxc2");
			// add
			
			// add, UART
			/*	메시지 핸들러 클래스	*/
			public class EventHandler extends Handler
			{
				EventHandler()
				{
				}
		
				public void handleMessage(Message msg)
				{
					Log.d(TAG, "msg.what = " + msg.what);
		
					try
					{
						if (msg.what == COMM_RECV)
						{
							m_RecvMsg = m_comm.recv();
							Log.d(TAG, "m_RecvMsg = " + m_RecvMsg);
						}
					}
					catch (Exception e)
					{
					}
		
					return;
				}
			}		
			// add	
		가)	i.MX6 board terminal 창에서 하기 명령 실행하면 "test" 문구가 echo로 들어오는 것을 알 수 있다
			#echo "test" > /dev/ttymxc0			->	It is simple as opening the device as a file and writing data to it:
			#cat /dev/ttymxc0					->	To receive data (ASCII in that case):
			cf)	Changing port parameters
				1)	To get current parameters (change serial port device name depending on your board, here ttySMX0):
					# stty -F /dev/ttySMX0
					speed 115200 baud;
					intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = ^J;
					eol2 = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W;
					lnext = ^V; flush = ^O; min = 1; time = 0;
					-brkint ixoff -imaxbel
					-iexten -echoctl
				2)	To only get actual speed:
					# stty -F /dev/ttySMX0 speed
					115200
				3)	By default serial ports are configured as terminal emulator. If you want to use them as "raw" serial port you will have to do first (example for port 1):
					# stty -F /dev/ttySMX1 raw
					# stty -F /dev/ttySMX1 -echo -echoe -echok
				4)	To change baudrate of port 2 to 115200 :
					# stty -F /dev/ttySMX2 115200
			cf)	ls -al /dev/ttymxc*
				crw------- root     root     207,  16 1970-01-02 05:27 ttymxc0
				crw-rw---- system   gps      207,  18 1970-01-02 05:27 ttymxc2
			cf)	ttymxc0 이 하기 리스트 중 UART1 인 것 같고
				ttymxc2 이 하기 리스트 중 UART3 인 것 같다.
				~/myandriod/kernel_imx/arch/arm/mach-mx6/board-mx6q_sabresd.h
				......................................................................................................
				/* UART1 for debug */
				MX6Q_PAD_CSI0_DAT10__UART1_TXD,
				MX6Q_PAD_CSI0_DAT11__UART1_RXD,
			
				/* UART3 for gps */
				MX6Q_PAD_EIM_D24__UART3_TXD,
				MX6Q_PAD_EIM_D25__UART3_RXD,
				......................................................................................................
		나)	i.MX6 보드에 UART 4 & 5 추가시키는 방법
			Finaly I foud a solution to make UART 4&5 working.
			I will try to write simple guide, how to achieve that.
			Thanks to xizhou wang I was able to find the way how to do that.
			
			1. In schematics http://www.element14.com/community/servlet/JiveServlet/previewBody/65504-102-1-287949/RIoTboard_Schematics.pdf on page 8 you can find how the UART 4&5 are pinned.   
			So in file /linux-imx/arch/arm/mach-mx6/board-mx6dl_riot.h you have to add UART4&5
			 
			+ expand sourceview plaincopy to clipboard
			#if 0
			        /* UART1 for debug */
			        MX6DL_PAD_CSI0_DAT10__UART1_TXD,			// 확인 사항, i.MX6 Board CSI0_DAT10 핀에 UART1_TXD 핀이 연결되어 있음, DEBUG UART TO USB CONVERSION에 연결 됨
			        MX6DL_PAD_CSI0_DAT11__UART1_RXD,			// 확인 사항, i.MX6 Board CSI0_DAT11 핀에 UART1_RXD 핀이 연결되어 있음
			#else
			        /* UART2 for debug */
			        MX6DL_PAD_EIM_D26__UART2_TXD,				// 확인 사항, i.MX6 Board EIM_D26 핀에 UART2_TXD 핀이 연결되어 있음, Touch Panel decoder(Analog to Digital conveter)에 연결 됨
			        MX6DL_PAD_EIM_D27__UART2_RXD,				// 확인 사항, i.MX6 Board EIM_D27 핀에 UART2_RXD 핀이 연결되어 있음
			#endif
			        /* UART3 */
			        MX6DL_PAD_EIM_D24__UART3_TXD,				// 확인 사항, i.MX6 Board EIM_D24 핀에 UART3_TXD 핀이 연결되어 있음, GPS에 연결 됨
			        MX6DL_PAD_EIM_D25__UART3_RXD,				// 확인 사항, i.MX6 Board EIM_D25 핀에 UART3_RXD 핀이 연결되어 있음
			
			        /********************** ADDED ***********************/
			        /* UART4 */
			        MX6DL_PAD_KEY_COL0__UART4_TXD,				// 확인 사항, i.MX6 Board KEY_COL0 핀에 UART4_TXD 핀이 연결되어 있음, 4MB SPI NOR FLASH에 연결 됨(Bluetooth에는 H/W적으로 open 상태로 연결되어 있지 않음)
			        MX6DL_PAD_KEY_ROW0__UART4_RXD,				// 확인 사항, i.MX6 Board KEY_ROW0 핀에 UART4_RXD 핀이 연결되어 있음
			
			        /* UART5 */
			        MX6DL_PAD_KEY_COL1__UART5_TXD,				// 확인 사항, i.MX6 Board KEY_COL1 핀에 UART5_TXD 핀이 연결되어 있음, 4MB SPI NOR FLASH에 연결 됨(Bluetooth에는 H/W적으로 open 상태로 연결되어 있지 않음)
			        MX6DL_PAD_KEY_ROW1__UART5_RXD,				// 확인 사항, i.MX6 Board KEY_ROW1 핀에 UART5_RXD 핀이 연결되어 있음
			        /***************************************************/
			
			2. Then in /linux-imx/arch/arm/mach-mx6/board-mx6q_riot.c you have to initialize UART 4&5
			 
			+ expand sourceview plaincopy to clipboard
			static inline void mx6q_riot_init_uart(void)
			{
			        imx6q_add_imx_uart(0, NULL);
			        imx6q_add_imx_uart(1, NULL);
			        imx6q_add_imx_uart(2, NULL);
			         
			/********************** ADDED ***********************/
			        imx6q_add_imx_uart(3, NULL);
			        imx6q_add_imx_uart(4, NULL);
			/***************************************************/
			}
			 
			And now you have to recompile the kernel and flash it to your RiotBoard.
			After that you will have:
			 
			/dev/ttymxc0 - still don't know what is for 
			/dev/ttymxc1 - debug serial port
			/dev/ttymxc2 - UART3
			/dev/ttymxc3 - UART4
			/dev/ttymxc4 - UART5
			
			Hope it will help

			예제)	실제하기와 같이 실행하면 UART4와 UART5가 생성됨
			1.	static iomux_v3_cfg_t mx6q_sabresd_pads[] = {
					......................................................................................................
					// temp
					#if 1
					/********************** ADDED ***********************/
					/* UART4 */
					MX6Q_PAD_CSI0_DAT12__UART4_TXD,	
					MX6Q_PAD_CSI0_DAT13__UART4_RXD,
				
					/* UART5 */
					MX6Q_PAD_CSI0_DAT14__UART5_TXD,
					MX6Q_PAD_CSI0_DAT15__UART5_RXD,
					/***************************************************/ 
					#endif
					// temp
					......................................................................................................
				
				static inline void mx6q_sabresd_init_uart(void)
				{
					imx6q_add_imx_uart(2, NULL);				// UART3
					imx6q_add_imx_uart(0, NULL);				// UART1
					// temp
					/********************** ADDED ***********************/
					imx6q_add_imx_uart(3, NULL);				// UART4
					imx6q_add_imx_uart(4, NULL);				// UART5
					/***************************************************/
					// temp
				}
			2.	cf)	전체 소스에서 일부분만 다시 빌드(X:\root\myandroid\kernel_imx 내부의 kernel image Rebuild)
				# Boot image for SABRE-SD board
				$ cd ~/myandroid
				$ source build/envsetup.sh
				$ lunch sabresd_6dq-user
				$ make bootimage			->	boot.img 이미지 내부에 kernel image도 포함되어 있으며
												본, 명령을 실행하면 X:\root\myandroid\out\target\product\sabresd_6dq\ 폴더 내부의 boot.img & uImage 이미지를 rebuild 시킴
		다)	Android UART open & read 명령 관계
			/*	vtime = inter-character timer unused, vmin = blocking read until 1 character arrives

			일반적으로 VMIN과 VTIME의 상관관계는 이렇게 됩니다.
			VMIN > 0 && VTIME > 0 이면 일정 문자가 들어 오든 시간이 종료 되던
			VMIN == 0 && VTIME > 0 이면 시간이 종료될때까지.
			VMIN > 0 && VTIME == 0 이면 일정 문자가 들어올때까지.
			VMIN == 0 && VTIME == 0 즉시 Return합니다.
			시간은 (1/1000)이고요 Min은 문자 단위입니다.
			
			ex)	vtime = 1, vmin = 5인 경우
		 		문자가 1개라도 들어오기 전 까지는 read 명령에서 무한대로 계속 대기하고 있다가
		 		1개라도 들어오면 문자가 5개가 들어오기를 기다리며 이때 기다리는 시간은 1/1000초 임
		 		cf)	문자가 1개만 들어오고 1/1000초가 지나면 read 명령에서 빠져나와 문자 1개만 받은 것으로 처리 함	*/
			m_fd = open(strDevPath, String.valueOf(nBaudRate), vtime, vmin);

	1-2)I2C 통신
		가)	하기와 같이 수정하면 정말, mag3110 routine을 이용해서 ISL29023 Ambient Light Sensor 값을 읽어들일 수 있음
			cf)	ISL29023 IC 위에 손을 얹으면 광량값이 작아져서 DATA값도 작아지며
				이에 Android -> JAVA app 상의 -> onSensorChanged 처리값도 작아짐
			X:\root\myandroid\kernel_imx\drivers\hwmon\mag3110.c
			#if 0
			#define POLL_INTERVAL_MAX       500
			#define POLL_INTERVAL_MIN       1
			#define POLL_INTERVAL           100
			/* if sensor is standby ,set POLL_STOP_TIME to slow down the poll */
			#define POLL_STOP_TIME          200
			#else
			// temp, 하기와 같이 수정하면 Polling interval이 0.9초 간격으로 무한 반복 됨(0.9초 간격으로 센서값을 읽어 들임)
			#define POLL_INTERVAL_MAX       900
			#define POLL_INTERVAL_MIN       900
			#define POLL_INTERVAL           900
			/* if sensor is standby ,set POLL_STOP_TIME to slow down the poll */
			#define POLL_STOP_TIME          900
			// temp
			#endif
			......................................................................................................
			/***************************************************************
			*
			* read sensor data from mag3110
			*
			***************************************************************/
			static int mag3110_read_data(struct i2c_client *client,
					struct mag3110_data_axis *pdata)
			{
			#if 0
				struct mag3110_data *mag = i2c_get_clientdata(client);
				u8 tmp_data[MAG3110_XYZ_DATA_LEN];
			
				if (!mag || mag->active == MAG_STANDBY)
					return -EINVAL;
			#if MAG3110_IRQ_USED
				if (!wait_event_interruptible_timeout
					    (mag->waitq, mag->data_ready != 0,
					    msecs_to_jiffies(INT_TIMEOUT))) {
					dev_dbg(&mag->client->dev, "interrupt not received\n");
					return -ETIME;
				}
			#endif
				mag->data_ready = 0;
				if (mag3110_read_block_data(client,
							    MAG3110_OUT_X_MSB,
								MAG3110_XYZ_DATA_LEN, tmp_data) < 0)
					return -1;
				pdata->x = ((tmp_data[0] << 8) & 0xff00) | tmp_data[1];
				pdata->y = ((tmp_data[2] << 8) & 0xff00) | tmp_data[3];
				pdata->z = ((tmp_data[4] << 8) & 0xff00) | tmp_data[5];
			
				return 0;
			#else
			// temp, mag3110_read_data routine을 사용하면서 ISL29023 Ambient Light Sensor를 제어 함
				struct mag3110_data *mag = i2c_get_clientdata(client);
				int lsb, msb, tsb;
			
				if (!mag || mag->active == MAG_STANDBY)
					return -EINVAL;
			
				mag->data_ready = 0;
			
//				printk(KERN_INFO"Before change client->addr = 0x%x\n", client->addr);
				client->addr = 0x44;
//				printk(KERN_INFO"After change client->addr = 0x%x\n", client->addr);
			
				lsb = i2c_smbus_read_byte_data(client, 0x02);
				msb = i2c_smbus_read_byte_data(client, 0x03);
				tsb = ((msb << 8) | lsb);
			
				pdata->x = pdata->y = pdata->z = (short)tsb;
//				printk(KERN_INFO"pdata->x = pdata->y = pdata->z = %d\n", pdata->x);
			
				return 0;
			// temp
			#endif
			}
			
			static void mag3110_report_data(struct mag3110_data *mag)
			{
				......................................................................................................
				// temp, Skip to change data
			//	mag3110_data_convert(mag->position, &data);
				// temp
				......................................................................................................

			~/SensorTest2/src/kr/co/company/SensorTest2
			package kr.co.company.SensorTest2;

			import android.app.Activity;
			import android.content.Context;
			import android.hardware.Sensor;
			import android.hardware.SensorEvent;
			import android.hardware.SensorEventListener;
			import android.hardware.SensorManager;
			import android.os.Bundle;
			import android.widget.TextView;
			
			public class SensorTest2 extends Activity implements SensorEventListener {
				private SensorManager mSensorManager;
				private Sensor mOrientation;
				TextView text;
			
				public void onCreate(Bundle savedInstanceState) {
					super.onCreate(savedInstanceState);
					setContentView(R.layout.main);
			
					mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
			//		mOrientation = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);
					// temp
					mOrientation = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
					// temp
					text = (TextView) findViewById(R.id.text);
				}
			
				protected void onResume() {
					super.onResume();
					mSensorManager.registerListener(this, mOrientation,
							SensorManager.SENSOR_DELAY_UI);
				}
			
				protected void onPause() {
					super.onPause();
					mSensorManager.unregisterListener(this);
				}
			
				public void onAccuracyChanged(Sensor sensor, int accuracy) {
				}
			
				public void onSensorChanged(SensorEvent event) {
					float[] values = event.values;
			//		if (event.sensor.getType() == Sensor.TYPE_ORIENTATION) {
					// temp
					if (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {
					// temp
						text.setText("방향 센서값\n\n방위각: " + values[0] + "\n피치:" + values[1]
								+ "\n롤:" + values[2]);
					}
				}
			}


		나)	I2C 통신 sequence 설명
			static iomux_v3_cfg_t mx6dl_sabresd_pads[] = {
				......................................................................................................
				/* I2C1 */
				MX6DL_PAD_CSI0_DAT8__I2C1_SDA,
				MX6DL_PAD_CSI0_DAT9__I2C1_SCL,
			
				/* I2C2 */
				MX6DL_PAD_KEY_COL3__I2C2_SCL,
				MX6DL_PAD_KEY_ROW3__I2C2_SDA,
			
				/* I2C3 */
				MX6DL_PAD_GPIO_3__I2C3_SCL,
				......................................................................................................
	
			#define MX6DL_PAD_GPIO_3__I2C3_SCL                                             \
					IOMUX_PAD(0x05F8, 0x0228, 2 | IOMUX_CONFIG_SION, 0x0878, 1, MX6DL_I2C_PAD_CTRL)
	
			X:\root\myandroid\kernel_imx\arch\arm\mach-mx6\board-mx6q_sabresd.c
			static void __init mx6_sabresd_board_init(void)
			{
				......................................................................................................
				imx6q_add_imx_i2c(0, &mx6q_sabresd_i2c_data);
				imx6q_add_imx_i2c(1, &mx6q_sabresd_i2c_data);
				imx6q_add_imx_i2c(2, &mx6q_sabresd_i2c_data);
				if (cpu_is_mx6dl())
					imx6q_add_imx_i2c(3, &mx6q_sabresd_i2c_data);
				i2c_register_board_info(0, mxc_i2c0_board_info,
						ARRAY_SIZE(mxc_i2c0_board_info));
				i2c_register_board_info(1, mxc_i2c1_board_info,
						ARRAY_SIZE(mxc_i2c1_board_info));
				i2c_register_board_info(2, mxc_i2c2_board_info,
						ARRAY_SIZE(mxc_i2c2_board_info));
				......................................................................................................
			static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
				{
					I2C_BOARD_INFO("max17135", 0x48),
					.platform_data = &max17135_pdata,
				},
				{
					I2C_BOARD_INFO("egalax_ts", 0x4),
					.irq = gpio_to_irq(SABRESD_CAP_TCH_INT1),
				},
				{
					I2C_BOARD_INFO("mag3110", 0x0e),
					.irq = gpio_to_irq(SABRESD_eCOMPASS_INT),
					.platform_data = (void *)&mag3110_position,
				},
				{
					I2C_BOARD_INFO("isl29023", 0x44),
					.irq  = gpio_to_irq(SABRESD_ALS_INT),
					.platform_data = &ls_data,
				}, {
					I2C_BOARD_INFO("elan-touch", 0x10),
					.irq = gpio_to_irq(SABRESD_ELAN_INT),
				},
				{
					I2C_BOARD_INFO("mxc_ldb_i2c", 0x50),
					.platform_data = (void *)1,	/* lvds port1 */
				},
			};
			
			Digital eCompass I2C 제어의 경우(IC, MAG3110)
			Freescale Orientation sensor
			X:\root\myandroid\kernel_imx\drivers\hwmon\mag3110.c
			
			Ambient Light Sensor I2C 제어의 경우(IC, ISL29023)
			X:\root\myandroid\kernel_imx\drivers\input\misc\isl29023.c
			
			3-AXIS ACCELEROMETER I2C 제어의 경우(IC, MMA8451Q)
			X:\root\myandroid\kernel_imx\drivers\hwmon\mma8x5x.c
	
			public class SensorTest1 extends Activity {
				public void onCreate(Bundle savedInstanceState) {
					super.onCreate(savedInstanceState);
					setContentView(R.layout.main);
			
					String report = "";
					SensorManager manager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
					List<Sensor> sensors = manager.getSensorList(Sensor.TYPE_ALL);
					report += "전체 센서수: " + sensors.size() + "\n";
					int i = 0;
					for (Sensor s : sensors) {
						report += "" + i++ + " name: " + s.getName() + "\npower: "
								+ s.getPower() + "\nres: " + s.getResolution()
								+ "\nrange: " + s.getMaximumRange() + "\n\n";
					}
					......................................................................................................
			
			X:\root\myandroid\frameworks\base\core\java\android\hardware\Sensor.java
			public final class Sensor {
					......................................................................................................
			    /**
			     * @return maximum range of the sensor in the sensor's unit.
			     */
			    public float getMaximumRange() {
			        return mMaxRange;
			    }
					......................................................................................................
	
			X:\root\myandroid\frameworks\base\core\java\android\hardware\SystemSensorManager.java
			public void addSensorEvent(Sensor sensor) {
	            SensorEvent t = new SensorEvent(Sensor.getMaxLengthValuesArray(sensor,
	                    mManager.mTargetSdkLevel));
	            synchronized (mSensorsEvents) {
	                mSensorsEvents.put(sensor.getHandle(), t);
	            }
	        }
	        
	        protected void dispatchSensorEvent(int handle, float[] values, int inAccuracy,
	                long timestamp) {
	            final Sensor sensor = sHandleToSensor.get(handle);
	            SensorEvent t = null;
	            synchronized (mSensorsEvents) {
	                t = mSensorsEvents.get(handle);
	            }
	
	            if (t == null) {
	                // This may happen if the client has unregistered and there are pending events in
	                // the queue waiting to be delivered. Ignore.
	                return;
	            }
	            // Copy from the values array.
	            System.arraycopy(values, 0, t.values, 0, t.values.length);
	            t.timestamp = timestamp;
	            t.accuracy = inAccuracy;
	            t.sensor = sensor;
	            switch (t.sensor.getType()) {
	                // Only report accuracy for sensors that support it.
	                case Sensor.TYPE_MAGNETIC_FIELD:
	                case Sensor.TYPE_ORIENTATION:
	                    // call onAccuracyChanged() only if the value changes
	                    final int accuracy = mSensorAccuracies.get(handle);
	                    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
	                        mSensorAccuracies.put(handle, t.accuracy);
	                        mListener.onAccuracyChanged(t.sensor, t.accuracy);
	                    }
	                    break;
	                default:
	                    // For other sensors, just report the accuracy once
	                    if (mFirstEvent.get(handle) == false) {
	                        mFirstEvent.put(handle, true);
	                        mListener.onAccuracyChanged(
	                                t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
	                    }
	                    break;
	            }
	            mListener.onSensorChanged(t);
	        }
	
			X:\root\myandroid\frameworks\base\core\java\android\hardware\LegacySensorManager.java
	        public void onSensorChanged(SensorEvent event) {
	            final float v[] = mValues;
	            v[0] = event.values[0];
	            v[1] = event.values[1];
	            v[2] = event.values[2];
	            int type = event.sensor.getType();
	            int legacyType = getLegacySensorType(type);
	            mapSensorDataToWindow(legacyType, v, LegacySensorManager.getRotation());
	            if (type == Sensor.TYPE_ORIENTATION) {
	                if ((mSensors & SensorManager.SENSOR_ORIENTATION_RAW)!=0) {
	                    mTarget.onSensorChanged(SensorManager.SENSOR_ORIENTATION_RAW, v);
	                }
	                if ((mSensors & SensorManager.SENSOR_ORIENTATION)!=0) {
	                    v[0] = mYawfilter.filter(event.timestamp, v[0]);
	                    mTarget.onSensorChanged(SensorManager.SENSOR_ORIENTATION, v);
	                }
	            } else {
	                mTarget.onSensorChanged(legacyType, v);
	            }
	        }
	        
	        X:\root\myandroid\frameworks\native\services\sensorservice\SensorService.cpp
	        bool SensorService::threadLoop()
			{
			    ALOGD("nuSensorService thread starting...");
				......................................................................................................


		다)	정식 I2C port에 등록하여 사용하기
			1)	mach-모델명.c 파일 등에서 i2c_board_info 구조체 형태로 각 포트에 맞게 이름과 slave address를 저장합니다.
				static struct i2c_board_info i2c0_devs[] __initdata = 
				{
					{ I2C_BOARD_INFO("KXSD9", 0x18), },			/* accelerator */
					{ I2C_BOARD_INFO("USBIC", 0x25), },			/* uUSB ic */
					{ I2C_BOARD_INFO("max17040", 0x36), },		/* max17040 fuel gauge */
				};
				
				s3c_i2c0_set_platdata(NULL);
				i2c_register_board_info(0, i2c0_devs, ARRAY_SIZE(i2c0_devs));
	
			2)	드라이버 모듈 init 시 동일한 스트링을 i2c_device_id 구조체에 등록시켜서
				i2c_add_driver을 요청하면 됩니다.
				cf)	본 프로그램 추가는 해당 폴더의 Makefile에 ex)obj-$(CONFIG_SENSORS_MAG3110)   += mag3110.o
					와 같이 추가시키면 됨
				static const struct i2c_device_id max17040_id[] =
				{
					{ "max17040", 0 },
					{}
				};
				MODULE_DEVICE_TABLE(i2c, max17040_id);
				
				static struct i2c_driver max17040_i2c_driver =
				{
					.driver =
					{
						.name = "max17040",
						.owner = THIS_MODULE,
					},
					.probe = max17040_probe,
					.remove = max17040_remove,
					.id_table = max17040_id,
				};
				
				static int __init max17040_init(void)
				{
					return i2c_add_driver(&max17040_i2c_driver);
				}
				
				module_init(max17040_init);
			
			3)	이렇게 등록시켜 주면 probe가 호출할 때
				파리미터로 등록시켜 놓은 i2c client와 id값을 받을 수 있습니다.
				static int max17040_probe(struct i2c_client *client, const struct i2c_device_id *id)
				{
					struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
					.................................................................
					max17040_client = client;
				}
	
			4)	이렇게 전역에 저장시켜 놓은 i2c client를 i2c r/w 시 사용합니다.
				static int max17040_write(u8 reg, u8 value)
				{
					int ret;
					ret = i2c_smbus_write_byte_data(max17040_client, reg, value);
					
					if(ret < 0)
						pr_err("%s: error!(%d)\n", __func__, ret);
					
					return ret;
				}
				
				static int max17040_read(u8 reg)
				{
					int ret;
					ret = i2c_smbus_read_byte_data(max17040_client, reg);
					
					if(ret < 0)
						pr_err("%s: error!(%d)\n", __func__, ret);
					
					return ret;
				}


	1-1)i.MX6 Board 지원 카메라
		CSI camera support
		Micron mt9v111 camera support
		OmniVision ov2640 camera support
		OmniVision ov3640 camera support
		OmniVision ov5640 camera support
		OmniVision ov8820 camera support using mipi
		OmniVision ov5642 camera support
		Analog Device adv7180 TV Decoder Input support
		OmniVision ov5640 camera support using mipi
		Analog Devices adv7280 TV Decoder Input support using mipi-cs

	1)	MMC memory로 부팅(i.MX6 Board 내부에 H/W Chip type으로 장착되어 있음)
		i.MX6 Board의 SW6을 11010110(from 1-8 bit)로 설정
		cf) SW6 핀 설정이 어이가 없는 것은 정말 11010110 에서 맨 앞 1이 정말 LSB 1번째 bit값이라는 것임 맨 뒤 0은 MSB 8번째 bit 값 임
	cf)	eMMC memory boot 환경설정(default)(Linux)
		MX6Q SABRESD U-Boot > print
		bootdelay=3
		baudrate=115200
		ipaddr=192.168.1.103
		serverip=192.168.1.101
		netmask=255.255.255.0
		loadaddr=0x10800000
		rd_loadaddr=0x11000000
		netdev=eth0
		ethprime=FEC0
		splashimage=0x30000000
		splashpos=m,m
		lvds_num=1
		stdin=serial
		stdout=serial
		stderr=serial
		fastboot_dev=mmc3
		bootcmd=booti mmc3
		ethact=FEC0
				
		Environment size: 301/8188 bytes

	1+1)SD memory로 부팅(2015년1월29일 입고된 i.MX6 보드 Default 환경)
		i.MX6 Board의 SW6이 01000010(from 1-8 bit)로 설정되어 있음

	cf)	SD memory boot 환경(default)(Android)
		U-Boot 2009.08 (Apr 29 2013 - 18:01:51)
		
		CPU: Freescale i.MX6 family TO1.2 at 792 MHz
		Thermal sensor with ratio = 182
		Temperature:   25 C, calibration data 0x5804c87d
		mx6q pll1: 792MHz
		mx6q pll2: 528MHz
		mx6q pll3: 480MHz
		mx6q pll8: 50MHz
		ipg clock     : 66000000Hz
		ipg per clock : 66000000Hz
		uart clock    : 80000000Hz
		cspi clock    : 60000000Hz
		ahb clock     : 132000000Hz
		axi clock   : 264000000Hz
		emi_slow clock: 132000000Hz
		ddr clock     : 528000000Hz
		usdhc1 clock  : 198000000Hz
		usdhc2 clock  : 198000000Hz
		usdhc3 clock  : 198000000Hz
		usdhc4 clock  : 198000000Hz
		nfc clock     : 24000000Hz
		Board: i.MX6Q-SABRESD: unknown-board Board: 0x63012 [POR ]
		Boot Device: SD
		I2C:   ready
		DRAM:   1 GB
		MMC:   FSL_USDHC: 0,FSL_USDHC: 1,FSL_USDHC: 2,FSL_USDHC: 3
		In:    serial
		Out:   serial
		Err:   serial
		Found PFUZE100! deviceid=10,revid=11
		Net:   got MAC address from IIM: 00:04:9f:03:8b:a1
			cf)	i.MX6 Board에는 Ethernet chip으로 AR8031을 사용하고 있고 본 칩 datasheet에 아래와 같이 쓰여 있음
				따라서 Ehternet chip 제조사에서 아래와 같이 이미, mac address(맥어드레스)를 사서 writing 해 놓았기 때문에 임베디드 개발자는 mac address 설정 등은 신경쓸 필요가 없음
				Supports automatic detection of a specific frame containing anywhere within its 
				payload: 6 bytes of ones (resulting in hexadecimal FF FF FF FF FF FF), followed 
				by sixteen repetitions of the target computer's AR8031 internal MAC address(48-bit address written in MMD3 0x804A, 0x804B, 0x804C)and notification via 
				dedicated hardware interrupt
		FEC0 [PRIME]
		Hit any key to stop autoboot:  0
		MX6Q SABRESD U-Boot > print
		bootdelay=3
		baudrate=115200
		ipaddr=192.168.1.103
		serverip=192.168.1.101
		netmask=255.255.255.0
		loadaddr=0x10800000
		rd_loadaddr=0x11000000
		netdev=eth0
		ethprime=FEC0
		fastboot_dev=mmc3
		splashimage=0x30000000
		splashpos=m,m
		lvds_num=1
		ethact=FEC0
		bootargs=console=ttymxc0,115200 init=/init video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0 androidboot.hardware=freescale
		bootcmd=booti mmc2
		stdin=serial
		stdout=serial
		stderr=serial
		
		Environment size: 507/8188 bytes
		MX6Q SABRESD U-Boot >

	cf)	SD memory boot ~ Android Main 모드 진입까지의 부팅 환경(default)(Android)
		U-Boot 2009.08 (Apr 29 2013 - 18:01:51)
		
		CPU: Freescale i.MX6 family TO1.2 at 792 MHz
		Thermal sensor with ratio = 182
		Temperature:   35 C, calibration data 0x5804c87d
		mx6q pll1: 792MHz
		mx6q pll2: 528MHz
		mx6q pll3: 480MHz
		mx6q pll8: 50MHz
		ipg clock     : 66000000Hz
		ipg per clock : 66000000Hz
		uart clock    : 80000000Hz
		cspi clock    : 60000000Hz
		ahb clock     : 132000000Hz
		axi clock   : 264000000Hz
		emi_slow clock: 132000000Hz
		ddr clock     : 528000000Hz
		usdhc1 clock  : 198000000Hz
		usdhc2 clock  : 198000000Hz
		usdhc3 clock  : 198000000Hz
		usdhc4 clock  : 198000000Hz
		nfc clock     : 24000000Hz
		Board: i.MX6Q-SABRESD: unknown-board Board: 0x63012 [POR ]
		Boot Device: SD
		I2C:   ready
		DRAM:   1 GB
		MMC:   FSL_USDHC: 0,FSL_USDHC: 1,FSL_USDHC: 2,FSL_USDHC: 3
		In:    serial
		Out:   serial
		Err:   serial
		Found PFUZE100! deviceid=10,revid=11
		Net:   got MAC address from IIM: 00:04:9f:03:8b:a1
		FEC0 [PRIME]
		Hit any key to stop autoboot:  0
		kernel   @ 10808000 (4709132)
		ramdisk  @ 11800000 (183078)
		kernel cmdline:
		        use uboot command line:
		        console=ttymxc0,115200 init=/init video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0 androidboot.hardware=freescale
		
		Starting kernel ...
		
		Uncompressing Linux... done, booting the kernel.
		Initializing cgroup subsys cpu
		Linux version 3.0.35-06114-g3b96084 (enrique@enrique-desktop) (gcc version 4.6.x-google 20120106 (prerelease) (GCC) ) #1 SMP PREEMPT Sat May 11 10:48:26 CDT 2013
		CPU: ARMv7 Processor [412fc09a] revision 10 (ARMv7), cr=10c53c7d
		CPU: VIPT nonaliasing data cache, VIPT aliasing instruction cache
		Machine: Freescale i.MX 6Quad/DualLite/Solo Sabre-SD Board
		Ignoring unrecognised tag 0x54410008
		Memory policy: ECC disabled, Data cache writealloc
		CPU identified as i.MX6Q, silicon rev 1.2
		PERCPU: Embedded 7 pages/cpu @c12f5000 s6592 r8192 d13888 u32768
		Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 208352
		Kernel command line: console=ttymxc0,115200 init=/init video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0 androidboot.hardware=freescale
		PID hash table entries: 2048 (order: 1, 8192 bytes)
		Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)
		Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)
		Memory: 379MB 202MB 240MB = 821MB total
		Memory: 821484k/821484k available, 227092k reserved, 442240K highmem
		Virtual kernel memory layout:
		    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
		    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
		    DMA     : 0xfbe00000 - 0xffe00000   (  64 MB)
		    vmalloc : 0xd9800000 - 0xf2000000   ( 392 MB)
		    lowmem  : 0xc0000000 - 0xd9000000   ( 400 MB)
		    pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)
		    modules : 0xbf000000 - 0xbfe00000   (  14 MB)
		      .init : 0xc0008000 - 0xc0045000   ( 244 kB)
		      .text : 0xc0045000 - 0xc08cacd4   (8728 kB)
		      .data : 0xc08cc000 - 0xc09639e0   ( 607 kB)
		       .bss : 0xc0963a04 - 0xc0aeb748   (1568 kB)
		Preemptible hierarchical RCU implementation.
		NR_IRQS:624
		MXC GPIO hardware
		sched_clock: 32 bits at 3000kHz, resolution 333ns, wraps every 1431655ms
		arm_max_freq=1GHz
		MXC_Early serial console at MMIO 0x2020000 (options '115200')
		bootconsole [ttymxc0] enabled
		Calibrating delay loop... 1581.05 BogoMIPS (lpj=7905280)
		pid_max: default: 32768 minimum: 301
		Mount-cache hash table entries: 512
		Initializing cgroup subsys debug
		Initializing cgroup subsys cpuacct
		Initializing cgroup subsys freezer
		CPU: Testing write buffer coherency: ok
		hw perfevents: enabled with ARMv7 Cortex-A9 PMU driver, 7 counters available
		CPU1: Booted secondary processor
		CPU2: Booted secondary processor
		CPU3: Booted secondary processor
		Brought up 4 CPUs
		SMP: Total of 4 processors activated (6324.22 BogoMIPS).
		print_constraints: dummy:
		NET: Registered protocol family 16
		print_constraints: vddpu: 725 <--> 1300 mV at 700 mV fast normal
		print_constraints: vddcore: 725 <--> 1300 mV at 1150 mV fast normal
		print_constraints: vddsoc: 725 <--> 1300 mV at 1200 mV fast normal
		print_constraints: vdd2p5: 2000 <--> 2775 mV at 2400 mV fast normal
		print_constraints: vdd1p1: 800 <--> 1400 mV at 1100 mV fast normal
		print_constraints: vdd3p0: 2625 <--> 3400 mV at 3000 mV fast normal
		ram_console: got buffer at 3ffe0000, size 20000
		ram_console: uncorrectable error in header
		ram_console: no valid data in buffer (sig = 0xc06284a0)
		console [ram-1] enabled
		No AHCI save PWR: PDDQ enabled
		hw-breakpoint: found 6 breakpoint and 1 watchpoint registers.
		hw-breakpoint: 1 breakpoint(s) reserved for watchpoint single-step.
		hw-breakpoint: maximum watchpoint size is 4 bytes.
		L310 cache controller enabled
		l2x0: 16 ways, CACHE_ID 0x410000c7, AUX_CTRL 0x02070000, Cache size: 1048576 B
		bio: create slab <bio-0> at 0
		mxs-dma mxs-dma-apbh: initialized
		print_constraints: SPKVDD: 4200 mV
		print_constraints: vmmc: 3300 mV
		vgaarb: loaded
		SCSI subsystem initialized
		spi_imx imx6q-ecspi.0: probed
		usbcore: registered new interface driver usbfs
		usbcore: registered new interface driver hub
		usbcore: registered new device driver usb
		Freescale USB OTG Driver loaded, $Revision: 1.55 $
		mc_pfuze 1-0008: ID: 0,Full lay: 1 ,Metal lay: 1
		mc_pfuze 1-0008: FAB: 0 ,FIN: 0
		print_constraints: PFUZE100_SW1A: 300 <--> 1875 mV at 1300 mV
		print_constraints: PFUZE100_SW1B: 300 <--> 1875 mV at 300 mV
		print_constraints: PFUZE100_SW1C: 300 <--> 1875 mV at 1300 mV
		print_constraints: PFUZE100_SW2: 800 <--> 3950 mV at 3300 mV
		print_constraints: PFUZE100_SW3A: 400 <--> 1975 mV at 1500 mV
		print_constraints: PFUZE100_SW3B: 400 <--> 1975 mV at 1500 mV
		print_constraints: PFUZE100_SW4: 800 <--> 3950 mV at 3150 mV
		print_constraints: PFUZE100_SWBST: 5000 <--> 5150 mV at 5000 mV
		print_constraints: PFUZE100_VSNVS: 1200 <--> 3000 mV at 1800 mV
		print_constraints: PFUZE100_VREFDDR: at 750 mV
		print_constraints: PFUZE100_VGEN1: 800 <--> 1550 mV at 1500 mV
		print_constraints: PFUZE100_VGEN2: 800 <--> 1550 mV at 1500 mV
		print_constraints: PFUZE100_VGEN3: 1800 <--> 3300 mV at 2800 mV
		print_constraints: PFUZE100_VGEN4: 1800 <--> 3300 mV at 1800 mV
		print_constraints: PFUZE100_VGEN5: 1800 <--> 3300 mV at 3000 mV
		print_constraints: PFUZE100_VGEN6: 1800 <--> 3300 mV at 3300 mV
		imx-ipuv3 imx-ipuv3.1: IPU DMFC NORMAL mode: 1(0~1), 5B(4,5), 5F(6,7)
		mxc_mipi_csi2 mxc_mipi_csi2: i.MX MIPI CSI2 driver probed
		mxc_mipi_csi2 mxc_mipi_csi2: i.MX MIPI CSI2 dphy version is 0x3130302a
		MIPI CSI2 driver module loaded
		Advanced Linux Sound Architecture Driver Version 1.0.24.
		Bluetooth: Core ver 2.16
		NET: Registered protocol family 31
		Bluetooth: HCI device and connection manager initialized
		Bluetooth: HCI socket layer initialized
		Bluetooth: L2CAP socket layer initialized
		Bluetooth: SCO socket layer initialized
		max17135_regulator_init abort: EPDC not enabled
		max17135 2-0048: PMIC MAX17135 for eInk display
		i2c-core: driver [max17135] using legacy suspend method
		i2c-core: driver [max17135] using legacy resume method
		Switching to clocksource mxc_timer1
		NET: Registered protocol family 2
		IP route cache hash table entries: 16384 (order: 4, 65536 bytes)
		TCP established hash table entries: 65536 (order: 7, 524288 bytes)
		TCP bind hash table entries: 65536 (order: 7, 786432 bytes)
		TCP: Hash tables configured (established 65536 bind 65536)
		TCP reno registered
		UDP hash table entries: 256 (order: 1, 8192 bytes)
		UDP-Lite hash table entries: 256 (order: 1, 8192 bytes)
		NET: Registered protocol family 1
		RPC: Registered named UNIX socket transport module.
		RPC: Registered udp transport module.
		RPC: Registered tcp transport module.
		RPC: Registered tcp NFSv4.1 backchannel transport module.
		PCI: CLS 0 bytes, default 32
		Unpacking initramfs...
		Freeing initrd memory: 176K
		PMU: registered new PMU device of type 0
		Static Power Management for Freescale i.MX6
		wait mode is enabled for i.MX6
		cpaddr = d9880000 suspend_iram_base=d9930000
		PM driver module loaded
		link up failed, DB_R0:0x00f9f000, DB_R1:0x08200000!
		IMX PCIe port: link down with power supply 1!
		IMX usb wakeup probe
		the wakeup pdata is 0xd46f0f60
		add wake up source irq 75
		IMX usb wakeup probe
		the wakeup pdata is 0xd46f0ce0
		cpu regulator mode:ldo_bypass
		_regulator_get: get() with no identifier
		mx6_cpu_regulator_init: failed to get pu regulator
		i.MXC CPU frequency driver
		highmem bounce pool size: 64 pages
		ashmem: initialized
		NTFS driver 2.1.30 [Flags: R/O].
		JFFS2 version 2.2. (NAND) c 2001-2006 Red Hat, Inc.
		fuse init (API version 7.16)
		msgmni has been set to 741
		NET: Registered protocol family 38
		cryptodev: driver loaded.
		io scheduler noop registered
		io scheduler deadline registered
		io scheduler cfq registered (default)
		mxc_mipi_dsi mxc_mipi_dsi: i.MX MIPI DSI driver probed
		MIPI DSI driver module loaded
		mxc_sdc_fb mxc_sdc_fb.0: register mxc display driver ldb
		_regulator_get: get() with no identifier
		mxc_sdc_fb mxc_sdc_fb.1: Can't get fb option for mxcfb1!
		mxc_sdc_fb mxc_sdc_fb.2: Can't get fb option for mxcfb2!
		imx-sdma imx-sdma: loaded firmware 1.1
		imx-sdma imx-sdma: initialized
		Serial: IMX driver
		imx-uart.2: ttymxc2 at MMIO 0x21ec000 (irq = 60) is a IMX
		imx-uart.0: ttymxc0 at MMIO 0x2020000 (irq = 58) is a IMX
		console [ttymxc0] enabled, bootconsole disabled
		console [ttymxc0] enabled, bootconsole disabled
		loop: module loaded
		m25p80 spi0.0: found m25p32, expected sst25vf016b
		m25p80 spi0.0: m25p32 (4096 Kbytes)
		Creating 2 MTD partitions on "m25p80":
		0x000000000000-0x000000100000 : "bootloader"
		0x000000100000-0x000000400000 : "kernel"
		GPMI NAND driver registered. (IMX)
		vcan: Virtual CAN interface driver
		CAN device driver interface
		flexcan netdevice driver
		FEC Ethernet Driver
		fec_enet_mii_bus: probed
		PPP generic driver version 2.4.2
		PPP Deflate Compression module registered
		PPP BSD Compression module registered
		PPP MPPE Compression module registered
		NET: Registered protocol family 24
		PPTP driver version 0.8.5
		tun: Universal TUN/TAP device driver, 1.6
		tun: (C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>
		ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
		fsl-ehci fsl-ehci.0: Freescale On-Chip EHCI Host Controller
		fsl-ehci fsl-ehci.0: new USB bus registered, assigned bus number 1
		fsl-ehci fsl-ehci.0: irq 75, io base 0x02184000
		fsl-ehci fsl-ehci.0: USB 2.0 started, EHCI 1.00
		hub 1-0:1.0: USB hub found
		hub 1-0:1.0: 1 port detected
		add wake up source irq 72
		fsl-ehci fsl-ehci.1: Freescale On-Chip EHCI Host Controller
		fsl-ehci fsl-ehci.1: new USB bus registered, assigned bus number 2
		fsl-ehci fsl-ehci.1: irq 72, io base 0x02184200
		fsl-ehci fsl-ehci.1: USB 2.0 started, EHCI 1.00
		hub 2-0:1.0: USB hub found
		hub 2-0:1.0: 1 port detected
		usbcore: registered new interface driver cdc_acm
		cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
		Initializing USB Mass Storage driver...
		usbcore: registered new interface driver usb-storage
		USB Mass Storage support registered.
		usbcore: registered new interface driver usbserial
		usbserial: USB Serial Driver core
		USB Serial support registered for GSM modem (1-port)
		usbcore: registered new interface driver option
		option: v0.7.2:USB Driver for GSM modems
		USB Serial support registered for Qualcomm USB modem
		usbcore: registered new interface driver qcserial
		ARC USBOTG Device Controller driver (1 August 2005)
		android_usb gadget: Mass Storage Function, version: 2009/09/11
		android_usb gadget: Number of LUNs=1
		 lun0: LUN: removable file: (no medium)
		Gadget Android: controller 'fsl-usb2-udc' not recognized
		android_usb gadget: android_usb ready
		Suspend udc for OTG auto detect
		USB Host suspend begins
		will suspend roothub and its children
		ehci_fsl_bus_suspend begins, DR
		ehci_fsl_bus_suspend ends, DR
		host suspend ends
		USB Gadget resume begins
		fsl_udc_resume, Wait for wakeup thread finishes
		dr_controller_run: udc out low power mode
		USB Gadget resume ends
		fsl-usb2-udc: bind to driver android_usb
		mousedev: PS/2 mouse device common for all mice
		input: gpio-keys as /devices/platform/gpio-keys/input/input0
		input: max11801_ts as /devices/platform/imx-i2c.1/i2c-1/1-0048/input/input1
		egalax_ts 1-0004: egalax_ts: failed to read firmware version
		egalax_ts: probe of 1-0004 failed with error -5
		input: eGalax Touch Screen as /devices/platform/imx-i2c.2/i2c-2/2-0004/input/input2
		android_work: did not send uevent (0 0   (null))
		android_work: sent uevent USB_STATE=CONNECTED
		elan - Read Hello Packet Failed
		elan-touch: probe of 2-0010 failed with error -22
		input: isl29023 light sensor as /devices/virtual/input/input3
		isl29023 2-0044: driver version 1.0 enabled
		i2c-core: driver [isl29023] using legacy suspend method
		i2c-core: driver [isl29023] using legacy resume method
		using rtc device, snvs_rtc, for alarms
		snvs_rtc snvs_rtc.0: rtc core: registered snvs_rtc as rtc0
		i2c /dev entries driver
		Linux video capture interface: v2.00
		camera ov5642 is not found
		USB Gadget resume begins
		fsl_udc_resume, Wait for wakeup thread finishes
		camera ov5640 is found
		android_work: sent uevent USB_STATE=DISCONNECTED
		camera ov5640_mipi is found
		mxc_v4l2_output mxc_v4l2_output.0: V4L2 device registered as video16
		mxc_v4l2_output mxc_v4l2_output.0: V4L2 device registered as video17
		usbcore: registered new interface driver uvcvideo
		USB Video Class driver (v1.1.0)
		android_work: sent uevent USB_STATE=CONNECTED
		mag3110 2-000e: check mag3110 chip ID
		input: mag3110 as /devices/virtual/input/input4
		mag3110 2-000e: mag3110 is probed
		i2c-core: driver [mag3110] using legacy suspend method
		i2c-core: driver [mag3110] using legacy resume method
		input: mma845x as /devices/virtual/input/input5
		imx2-wdt imx2-wdt.0: IMX2+ Watchdog Timer enabled. timeout=60s (nowayout=1)
		device-mapper: uevent: version 1.0.3
		device-mapper: ioctl: 4.20.0-ioctl (2011-02-02) initialised: dm-devel@redhat.com
		Bluetooth: Virtual HCI driver ver 1.3
		Bluetooth: HCI UART driver ver 2.2
		Bluetooth: HCIATH3K protocol initialized
		Bluetooth: Generic Bluetooth USB driver ver 0.6
		usbcore: registered new interface driver btusb
		sdhci: Secure Digital Host Controller Interface driver
		sdhci: Copyright(c) Pierre Ossman
		mmc0: SDHCI controller on platform [sdhci-esdhc-imx.3] using DMA
		mmc1: SDHCI controller on platform [sdhci-esdhc-imx.2] using DMA
		mmc2: SDHCI controller on platform [sdhci-esdhc-imx.1] using DMA
		mxc_vdoa mxc_vdoa: i.MX Video Data Order Adapter(VDOA) driver probed
		VPU initialized
		mxc_asrc registered
		revserved_memory_account:viv_gpu registerd
		Thermal calibration data is 0x5804c87d
		Thermal sensor with ratio = 182
		Anatop Thermal registered as thermal_zone0
		anatop_thermal_probe: default cooling device is cpufreq!
		Registered led device: chg_now_led
		usbcore: registered new interface driver usbhid
		usbhid: USB HID core driver
		logger: created 256K log 'log_main'
		logger: created 256K log 'log_events'
		logger: created 256K log 'log_radio'
		logger: created 256K log 'log_system'
		usbcore: registered new interface driver snd-usb-audio
		mxc_hdmi_soc mxc_hdmi_soc.0: MXC HDMI Audio
		Cirrus Logic CS42888 ALSA SoC Codec Driver
		i2c-core: driver [cs42888] using legacy suspend method
		i2c-core: driver [cs42888] using legacy resume method
		imx-hdmi-soc-dai imx-hdmi-soc-dai.0: Failed: Load HDMI-video first.
		mmc0: new high speed DDR MMC card at address 0001
		mmcblk0: mmc0:0001 SEM08G 7.39 GiB
		mmcblk0boot0: mmc0:0001 SEM08G partition 1 2.00 MiB
		mmcblk0boot1: mmc0:0001 SEM08G partition 2 2.00 MiB
		 mmcblk0: unknown partition table
		 mmcblk0boot1: unknown partition table
		android_work: sent uevent USB_STATE=DISCONNECTED
		 mmcblk0boot0: unknown partition table
		wm8962 0-001a: customer id 0 revision D
		input: WM8962 Beep Generator as /devices/platform/imx-i2c.0/i2c-0/0-001a/input/input6
		asoc: wm8962 <-> imx-ssi.1 mapping ok
		input: wm8962-audio DMIC as /devices/platform/soc-audio.5/sound/card0/input7
		input: wm8962-audio Headphone Jack as /devices/platform/soc-audio.5/sound/card0/input8
		imx_3stack asoc driver
		Initialize HDMI-audio failed. Load HDMI-video first!
		ALSA device list:
		  #0: wm8962-audio
		oprofile: using arm/armv7-ca9
		GACT probability NOT on
		Mirror/redirect action on
		u32 classifier
		    Actions configured
		Netfilter messages via NETLINK v0.30.
		nf_conntrack version 0.5.0 (12838 buckets, 51352 max)
		ctnetlink v0.93: registering with nfnetlink.
		NF_TPROXY: Transparent proxy support initialized, version 4.1.0
		android_work: sent uevent USB_STATE=CONNECTED
		android_work: sent uevent USB_STATE=DISCONNECTED
		NF_TPROXY: Copyright (c) 2006-2007 BalaBit IT Ltd.
		xt_time: kernel timezone is -0000
		IPv4 over IPv4 tunneling driver
		GRE over IPv4 demultiplexor driver
		ip_tables: (C) 2000-2006 Netfilter Core Team
		arp_tables: (C) 2002 David S. Miller
		TCP cubic registered
		NET: Registered protocol family 10
		Mobile IPv6
		ip6_tables: (C) 2000-2006 Netfilter Core Team
		IPv6 over IPv4 tunneling driver
		NET: Registered protocol family 17
		NET: Registered protocol family 15
		can: controller area network core (rev 20090105 abi 8)
		NET: Registered protocol family 29
		mmc1: new high speed SDHC card at address e624
		mmcblk1: mmc1:e624 SS08G 7.40 GiB
		 mmcblk1: p1 p2 p3 < p5 p6 p7 p8 > p4
		mmcblk1: p4 size 13352010 extends beyond EOD, truncated
		can: raw protocol (rev 20090105)
		can: broadcast manager protocol (rev 20090105 t)
		Bluetooth: RFCOMM TTY layer initialized
		Bluetooth: RFCOMM socket layer initialized
		Bluetooth: RFCOMM ver 1.11
		Bluetooth: BNEP (Ethernet Emulation) ver 1.3
		Bluetooth: BNEP filters: protocol multicast
		Bluetooth: HIDP (Human Interface Emulation) ver 1.2
		L2TP core driver, V2.0
		PPPoL2TP kernel driver, V2.0
		L2TP IP encapsulation support (L2TPv3)
		L2TP netlink interface
		L2TP ethernet pseudowire support (L2TPv3)
		lib80211: common routines for IEEE802.11 drivers
		lib80211_crypt: registered algorithm 'NULL'
		lib80211_crypt: registered algorithm 'WEP'
		lib80211_crypt: registered algorithm 'CCMP'
		lib80211_crypt: registered algorithm 'TKIP'
		VFP support v0.3: implementor 41 architecture 3 part 30 variant 9 rev 4
		Bus freq driver module loaded
		Bus freq driver Enabled
		mxc_dvfs_core_probe
		DVFS driver module loaded
		regulator_init_complete: PFUZE100_VGEN6: incomplete constraints, leaving on
		regulator_init_complete: PFUZE100_VGEN3: incomplete constraints, leaving on
		regulator_init_complete: PFUZE100_VGEN2: incomplete constraints, leaving on
		regulator_init_complete: PFUZE100_VGEN1: incomplete constraints, leaving on
		snvs_rtc snvs_rtc.0: setting system clock to 1970-01-02 00:07:34 UTC (86854)
		Freeing init memory: 244K
		init: cannot find '/system/etc/install-recovery.sh', disabling 'flash_recovery'
		android_usb: already disabled
		android_usb: already disabled
		root@android:/ # mtp_bind_config
		input: eCompass as /devices/virtual/input/input9
		android_work: sent uevent USB_STATE=DISCONNECTED
		android_work: sent uevent USB_STATE=CONNECTED
		android_work: sent uevent USB_STATE=DISCONNECTED
		android_work: sent uevent USB_STATE=CONNECTED
		android_work: sent uevent USB_STATE=DISCONNECTED
		imx-ipuv3 imx-ipuv3.0: IPU DMFC DP HIGH RESOLUTION: 1(0,1), 5B(2~5), 5F(6,7)
		android_work: sent uevent USB_STATE=CONNECTED
		android_work: sent uevent USB_STATE=DISCONNECTED
		android_work: sent uevent USB_STATE=CONNECTED
		android_work: sent uevent USB_STATE=DISCONNECTED
		android_work: sent uevent USB_STATE=CONNECTED
		android_work: sent uevent USB_STATE=DISCONNECTED
		android_work: sent uevent USB_STATE=CONNECTED
		warning: `zygote' uses 32-bit capabilities (legacy support in use)
		request_suspend_state: wakeup (3->0) at 18447120004 (1970-01-02 00:07:48.588181670 UTC)
		cpufreq_interactive_input_connect: connect to max11801_ts
		cpufreq_interactive_input_connect: connect to eGalax Touch Screen
		mma enable setting active
		eth0: Freescale FEC PHY driver [Generic PHY] (mii_bus:phy_addr=1:01, irq=-1)
		ADDRCONF(NETDEV_UP): eth0: link is not ready
		acc_open
		acc_release
		ehci_fsl_bus_resume begins, Host 1
		ehci_fsl_bus_resume ends, Host 1
		ehci_fsl_bus_resume begins, DR
		init: sys_prop: permission denied uid:1003  name:service.bootanim.exit
		ehci_fsl_bus_suspend begins, Host 1
		ehci_fsl_bus_suspend ends, Host 1


	2)	ADB 설정
		가-1)	ADB Driver 설치가 잘 되지 않을 때
			a)	Board 부팅 완료 후 Terminal 창에서
				adb kill-server 실행	->	adb start-server 실행	->	안드로이드 setting -> Developer options -> USB debugging [v] 체크	
		가)	USB 디버깅 메뉴를 찾을 수 없을 때
			a)	안드로이드의 젤리빈(4.3) 업그레이드와 함께 개발자 옵션과 USB 디버깅 메뉴가 숨겨졌습니다.
				아래와 같은 방법으로 해결하세요.
				->	시스템 설정 > 휴대폰 정보 > 소프트웨어 정보 메뉴로 들어가세요.
					[빌드 번호] 메뉴를 7번 연속으로 탭을 하면, [개발자가 되었습니다]는 메시지를 확인할 수 있습니다
				->	이제 시스템 설정 > 개발자 옵션 메뉴에서 USB 디버깅 항목의 체크박스를 활성화해 주세요.
				->	Power menu bug reports [v]
				->	Allow mock locations [v]
				->	Stay awake [v]
			b)	cmd -> adb shell 명령 실행
		나)	adb devices 명령 실행 시 ->	"0123456789ABCDEF	unauthorized" 문구가 나오고 eclipse에서 본 devices에 접근하지 못하는 경우
			->	USB를 Device에 꼽았을 때 나오는
				USB 디버깅을 허용할까요? -> PC의 RSA키 지문은 다음과 같습니다. -> 에서 아래와 같이 체크하면 본 에러 제거 됨
				-> [v] 항상 이 PC와 연결하는 것을 허용 -> 확인
		다)	eclipse -> DDMS에서 Devices -> freecale-sabresd_mx6dq-~ 연결이 USB Cable을 제대로 연결해도
			아무 이유도 없이 제대로 연결되지 않거나 자꾸 끊기는 경우 해결 방법
			->	제어판 -> 알림 영역 아이콘 -> Adb 와 freecale 관련 아이콘의 동작을 "동작안함"으로 설정할 것
		라)	adb shell로 실행하는 명령어를 root권한으로 실행하게 만들려면
			참고(http://android.stackexchange.com/questions/5884/is-there-a-way-for-me-to-run-adb-shell-as-root-without-typing-in-su)
			안드로이드 루트 폴더에 default.prop이라는 파일을 찾아서 ro.secure=1로 되어 있는 부분을 ro.secure=0으로 바꿔주고 시스템을 재시작한다.(검증 되지 않음)
			재시작후 adb root를 실행하면 adbd가 root권한을 갖게 되어서 이후 adb shell [명령어] 들은 모두 root권한으로 실행되게 된다고 한다.
		마)	장치관리자 -> 기타장치 -> !SABRESD-MX6DQ 문제가 발생하는 경우
			!SABRESD-MX6DQ -> 오른쪽마우스클릭 -> Driver update -> C:\Program Files\Android\adt-bundle-windows-x86\sdk 폴더를 선택해서 Driver update 해 주면 문제가 제거 됨
		바)	090ec1d4df6518e0 offline 발생 문제
			a)	부팅 전 부터
				Debug uart port 연결을 off 시키고 OTG USB Cable도 연결을 off 시킨 다음 부팅 시킨 후
				OTG USB Cable만 Connector에 아주 약간만 집어 넣고 조금 기다리면(2초)
				"이 장치의 성능이 향상 되었습니다.(USB 성능 향상)" POPUP창이 뜨며
				이때, 다시 Cable을 더 삽입하면
				eclipse -> DDMS 창에 "freescale-sabresd_mx6dq-090ec1d4df6518e0 Online" 문구가 표시되면서 정상적으로 OTG USB가 연결 됨
			b)	Debug uart port 연결을 off 시키고
				OTG USB Cable도 연결을 off 시켰다가 다시 Connector에 아주 약간만 집어 넣고 조금 기다리면(2초)
				"이 장치의 성능이 향상 되었습니다.(USB 성능 향상)" POPUP창이 뜨며
				이때, 다시 Cable을 더 삽입하면
				eclipse -> DDMS 창에 "freescale-sabresd_mx6dq-090ec1d4df6518e0 Online" 문구가 표시되면서 정상적으로 OTG USB가 연결 됨
				cf)	본 방법으로 문제가 해결되지 않을 때
					작업표시줄 -> 맨 오른쪽 -> 하드웨어 안전하게 제거 및 미디어 꺼내기 -> MTP 꺼내기 -> (곧바로 OTG USB Cable 연결 off시킴)
					->	"프로그램이 'Android Composite ADB Interface' 장치를 ~" 에러문구가 나옮 -> 3초 정도 기다림
					->	상기 방법을 다시 시도해 봄
			c)	Developer options -> USB debugging [ ] -> OTG USB Cable 연결 off시켰다가 다시 on시킴 -> 
				SABRESD-MX6DQ 연결 창이 열리고 -> Developer options -> USB debugging [v]시키면 "freescale-sabresd_mx6dq-090ec1d4df6518e0 Online" 문구가 나오면서 정상적으로 연결 됨


	3)	SD Memory/eMMC 로 부팅 하기
		가)	Android 부팅
			[A]	SD memory에 android image writing 하기(우리가 알고 있는 일반적 SD-Memory)
			a)	android_kk4.4.2_1.0.0-ga_full_image_6qsabresd
				폴더에 있는 u-boot-6dl.bin, u-boot-6q.bin 파일 2개와
				android_kk4.4.2_1.0.0-ga_full_image_6qsabresd\SD
				폴더에 있는 boot.img, recovery.img, system.img 파일 3개를
				아래 폴더에 모두 복사
				->	C:\Program Files\Default.corp\IP\i.mx6\tools\Mfgtools-Rel-4.1.0_130816_MX6Q_UPDATER\Profiles\MX6Q Linux Update\OS Firmware\files\android
			b)	Mfgtools-Rel-4.1.0_130816_MX6Q_UPDATER -> cfg.ini 파일을 하기와 같이 수정
				[profiles]
				chip = MX6Q Linux Update

				[platform]
				board = SabreSD

				[LIST]
				name = Android-SabreSD-SD
			c)	i.mx6 board의 SW6을 00001100 (from 1-8 bit) 와 같이 변경
			d)	MfgTool2.exe 실행 -> Start 버튼 누름 -> 상태표시창에 done 표시되면 -> Stop버튼 누름 -> Exit 버튼 누름

			b2)	~	e2)	->	MfgTool2.exe 을 사용하지 않고 Linux -> Card reader를 사용해서 SD memory에 android image writing 하는 경우
			b2)	/root/myandroid/device/fsl/common/tools/fsl-sdcard-partition.sh 파일을
				/root/myandroid/out/target/product/sabresd_6dq 로 복사
			c2)	cd /root/myandroid/out/target/product/sabresd_6dq
			d2)	fsl-sdcard-partition.sh 파일 하기와 같이 수정
				#dd if=u-boot.bin of=${node} bs=1k seek=1 skip=1	
				dd if=u-boot-6q.bin of=${node} bs=1k seek=1 skip=1	
			e2)	chmod a+x fsl-sdcard-partition.sh
				Card reader에 SD memory 삽입해서 PC에 꼽음
				sudo ./fsl-sdcard-partition.sh -f /dev/sdb	

			e)	i.mx6 board의 SW6을 01000010 (from 1-8 bit) 와 같이 변경
			f)	i.mx6 board 재 부팅 시킴
			g)	SD memory boot 환경설정(default)(2016년 1월 29일 현재 Android SD memory boot 환경이며 정상적으로 SD memory로 Android 부팅 되고 있다)
				MX6Q SABRESD U-Boot > print
				bootdelay=3
				baudrate=115200
				ipaddr=192.168.1.103
				serverip=192.168.1.101
				netmask=255.255.255.0
				loadaddr=0x10800000
				rd_loadaddr=0x11000000
				netdev=eth0
				ethprime=FEC0
				splashimage=0x30000000
				splashpos=m,m
				lvds_num=1
				stdin=serial
				stdout=serial
				stderr=serial
				fastboot_dev=mmc2
				bootcmd=booti mmc2
				ethact=FEC0
				
				Environment size: 301/8188 bytes

			[B]	eMMC memory에 android image writing 하기(i.MX6 Board 내부에 H/W Chip type으로 장착되어 있음)
			a)	android_kk4.4.2_1.0.0-ga_full_image_6qsabresd
				폴더에 있는 u-boot-6dl.bin, u-boot-6q.bin 파일 2개와
				android_kk4.4.2_1.0.0-ga_full_image_6qsabresd\SD
				폴더에 있는 boot.img, recovery.img, system.img 파일 3개를
				아래 폴더에 모두 복사
				->	C:\Program Files\Default.corp\IP\i.mx6\tools\Mfgtools-Rel-4.1.0_130816_MX6Q_UPDATER\Profiles\MX6Q Linux Update\OS Firmware\files\android
			b)	Mfgtools-Rel-4.1.0_130816_MX6Q_UPDATER -> cfg.ini 파일을 하기와 같이 수정
				[profiles]
				chip = MX6Q Linux Update

				[platform]
				board = SabreSD

				[LIST]
				name = Android-SabreSD-eMMC
			c)	i.mx6 board의 SW6을 00001100 (from 1-8 bit) 와 같이 변경
			d)	MfgTool2.exe 실행 -> Start 버튼 누름 -> 상태표시창에 done 표시되면 -> Stop버튼 누름 -> Exit 버튼 누름
			e)	i.mx6 board의 SW6을 11010110 (from 1-8 bit) 와 같이 변경
			f)	i.mx6 board 재 부팅 시킴
			g)	eMMC boot 환경설정(default)
				MX6Q SABRESD U-Boot > print
				bootdelay=3
				baudrate=115200
				ipaddr=192.168.1.103
				serverip=192.168.1.101
				netmask=255.255.255.0
				loadaddr=0x10800000
				rd_loadaddr=0x11000000
				netdev=eth0
				ethprime=FEC0
				splashimage=0x30000000
				splashpos=m,m
				lvds_num=1
				stdin=serial
				stdout=serial
				stderr=serial
				fastboot_dev=mmc3
				bootcmd=booti mmc3
				ethact=FEC0
				
				Environment size: 301/8188 bytes

		나)	Linux 부팅
			a)	L3.0.35_4.1.0_130816_images_MX6.tar.gz 에 있는
				u-boot-mx6q-sabresd.bin, uImage, rootfs.tzr.bz2 파일을 아래 폴더에 복사
				Mfgtools-Rel-1.1.0_121218_MX6Q_UPDATER\Profiles\MX6Q Linux Update\OS Firmware\files
			b)	Mfgtools-Rel-4.1.0_130816_MX6Q_UPDATER -> cfg.ini 파일을 하기와 같이 수정
				[profiles]
				chip = MX6Q Linux Update
				
				[platform]
				board = SabreSD
				
				[LIST]
				name = Sabre-SD
			c)	i.mx6 board의 SW6을 00001100 (from 1-8 bit) 와 같이 변경
			d)	MfgTool2.exe 실행 -> Start 버튼 누름 -> 상태표시창에 done 표시되면 -> Stop버튼 누름 -> Exit 버튼 누름
			e)	i.mx6 board의 SW6을 01000010 (from 1-8 bit) 와 같이 변경
			f)	i.mx6 board 재 부팅 시킴
			g)	FEC: Link is down 7949 에러가 무한반복 일어나면서 부팅되지 않을 경우
				(1)	boot 환경(default)
				bootdelay=3
				baudrate=115200
				ipaddr=192.168.1.103
				serverip=192.168.1.101
				netmask=255.255.255.0
				loadaddr=0x10800000
				rd_loadaddr=(0x1300000)
				netdev=eth0
				ethprime=FEC0
				uboot=u-boot.bin
				kernel=uImage
				nfsroot=/opt/eldk/arm
				bootargs_base=setenv bootargs console=ttymxc0,115200
				bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp
				bootcmd_net=run bootargs_base bootargs_nfs; tftpboot ${loadaddr} ${kernel}; bootm
				bootargs_mmc=setenv bootargs ${bootargs} ip=dhcp root=/dev/mmcblk0p1 rootwait
				bootcmd_mmc=run bootargs_base bootargs_mmc; mmc dev 3; mmc read ${loadaddr} 0x800 0x2000; bootm
				bootcmd=run bootcmd_net
				stdin=serial
				stdout=serial
				stderr=serial
				ethact=FEC0
				
				(2)	booting 시 "Enter"키를 눌러서 부트 환경 모드로 들어간 다음 하기 명령을 실행시켜서 boot 환경을 변경시키면 하기 print 명령처럼 변경 되며
					이후 재부팅 시키면 회색바탕의 실행아이콘이 나열되어 있는 리눅스 메인 화면이 정상적으로 LCD 화면에 출력 됨
				MX6Q SABRESD U-Boot > setenv bootargs_base 'setenv bootargs console=ttymxc0,115200'
				MX6Q SABRESD U-Boot > setenv bootargs_mmc 'setenv bootargs ${bootargs} ip=none root=/dev/mmcblk1p1 rootwait rw video=mxcfb0:dev=ldb, LDB-XGA, if=RGB666 ldb=sin1'
				MX6Q SABRESD U-Boot > setenv bootargs_base_lvds 'video=mxcfb0:dev=ldb,LDB-XGA,if=RGB666 ldb=sin1'
				MX6Q SABRESD U-Boot > setenv bootcmd_mmc 'run bootargs_base bootargs_mmc; mmc dev 2; mmc read ${loadaddr} 0x800 0x2000; bootm'
				MX6Q SABRESD U-Boot > setenv bootcmd run bootcmd_mmc
				MX6Q SABRESD U-Boot > saveenv
				MX6Q SABRESD U-Boot > run bootcmd
				
				부팅된 이후 "matchbox: can't open display! check your DISPLAY variable." 에러가 발생하면서
				LCD에 아무 화면도 출력되지 않는 다면 상기 c) ~ f)를 다시 한번 실행시켜서 SD Card에 이미지를 재 writing 시킴
				->	회색바탕의 실행아이콘이 나열되어 있는 리눅스 메인 화면이 정상적으로 LCD 화면에 출력 됨
				
				MX6Q SABRESD U-Boot > print
				bootdelay=3
				baudrate=115200
				ipaddr=192.168.1.103
				serverip=192.168.1.101
				netmask=255.255.255.0
				loadaddr=0x10800000
				rd_loadaddr=(0x1300000)
				netdev=eth0
				ethprime=FEC0
				uboot=u-boot.bin
				kernel=uImage
				nfsroot=/opt/eldk/arm
				bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp
				bootcmd_net=run bootargs_base bootargs_nfs; tftpboot ${loadaddr} ${kernel}; bootm
				ethact=FEC0
				bootargs_base=setenv bootargs console=ttymxc0,115200
				bootcmd_mmc=run bootargs_base bootargs_mmc; mmc dev 2; mmc read ${loadaddr} 0x800 0x2000; bootm
				bootcmd=run bootcmd_mmc
				bootargs=console=ttymxc0,115200 ip=none root=/dev/mmcblk1p1 rootwait
				bootargs_mmc=setenv bootargs ${bootargs} ip=none root=/dev/mmcblk1p1 rootwait rw video=mxcfb0:dev=ldb, LDB-XGA, if=RGB666 ldb=sin1
				bootargs_base_lvds=video=mxcfb0:dev=ldb,LDB-XGA,if=RGB666 ldb=sin1
				stdin=serial
				stdout=serial
				stderr=serial
				
				Environment size: 893/8188 bytes
				
				MX6Q SABRESD U-Boot > reset
					
	4)	Building Android for i.MX
		cf)	android_kk4.4.2_1.0.0-ga_docs -> Android_User's_Guide.pdf

2.1 Setting up your computer
$ sudo apt-get install uuid uuid-dev
$ sudo apt-get install zlib1g-dev liblz-dev
$ sudo apt-get install liblzo2-2 liblzo2-dev
$ sudo add-apt-repository ppa:git-core/ppa
$ sudo apt-get update
$ sudo apt-get install git-core curl
$ sudo apt-get install uboot-mkimage

3.1 Getting Android source code (Android/kernel/U-Boot)
$ cd ~
$ mkdir myandroid
$ mkdir bin
$ cd myandroid
$ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo
$ chmod a+x ~/bin/repo
$ ~/bin/repo init -u https://android.googlesource.com/platform/manifest -b android-4.4.2_r1
$ ~/bin/repo sync # this command loads most needed repos. Therefore, it can take several hours to load.
Get kk4.4.2_1.0.0-ga kernel source code from Freescale open source git:
$ cd myandroid
$ git clone git://git.freescale.com/imx/linux-2.6-imx.git kernel_imx # the kernel repo is heavy. Therefore, this process can take a while.
$ cd kernel_imx
$ git checkout kk4.4.2_1.0.0-ga

NOTE
If you use U-Boot as your bootloader, then you can clone the U-Boot git repository from Freescale open source git:
$ cd myandroid/bootable/bootloader
$ git clone git://git.freescale.com/imx/uboot-imx.git uboot-imx
$ cd uboot-imx
$ git checkout kk4.4.2_1.0.0-ga

3.2 Patch code for i.MX
1. Assume you have unzipped the i.MX Android release package to /opt/android_kk4.4.2_1.0.0-ga_source.
$ cd ~/myandroid
$ source /opt/android_kk4.4.2_1.0.0-ga_core_source/code/kk4.4.2_1.0.0-ga/and_patch.sh
$ help
2. You should see that the "c_patch" function is available.
$ c_patch /opt/android_kk4.4.2_1.0.0-ga_core_source/code/kk4.4.2_1.0.0-ga imx_kk4.4.2_1.0.0-ga
Here, "/opt/android_kk4.4.2_1.0.0-ga_source/code/kk4.4.2_1.0.0-ga" is the location of the patches, which is the
directory created when you unzip the release package.
"imx_kk4.4.2_1.0.0-ga" is the branch which will be created automatically for you to hold all patches (only in those
existing Google gits).
You can choose any branch name instead of "imx_kk4.4.2_1.0.0-ga".
3. If everything is OK, "c_patch" will generate the following output to indicate the successful patch:
**************************************************************
Success: Now you can build the Android code for FSL i.MX platform
**************************************************************

3.3 Building Android images
$ cd ~/myandroid
$ source build/envsetup.sh
$ lunch sabresd_6dq-user
$ make 2>&1 | tee build_sabresd_6dq_android.log

상기 명령 실행 완료 이후(2일 걸림) message

failed to reconstruct target deflate chunk 1 [(null)]; treating as normal
chunk 0: type 0 start 0 len 4843530
chunk 1: type 2 start 4843530 len 887040
chunk 2: type 0 start 5340021 len 1163
Construct patches for 3 chunks...
patch   0 is 211 bytes (of 4843530)
patch   1 is 401521 bytes (of 496491)
patch   2 is 190 bytes (of 1163)
chunk   0: normal   (         0,    4843530)         211
chunk   1: deflate  (   4843530,    1050903)      401521  (null)
chunk   2: normal   (   5894433,       1759)         190
Install system fs image: out/target/product/sabresd_6dq/system.img
out/target/product/sabresd_6dq/system.img+out/target/product/sabresd_6dq/obj/PACKAGING/recovery_patch_intermediates/recovery_from_boot.p maxsize=385389312 blocksize=4224 total=377889414 reserve=3894528

3.3.2 Building Android images for the SD card on the SABRE-SD
board
The default configuration in the source code package takes internal eMMC as the boot storage for i.MX 6Dual/6Quad and i.MX 6Solo/6DualLite SABRE-SD boards.
The default setting can be changed to make the SD card in SD Slot 3 be the boot storage as shown below:

1.	myandroid/device/fsl/sabresd_6dq/fstab.freescale 문서를 하기와 같이 변경
# Android fstab file.
#<src>                                                  <mnt_point>         <type>    <mnt_flags and options>                       <fs_mgr_flags>
# The filesystem that contains the filesystem checker binary (typically /system) cannot
# specify MF_CHECK, and must come before any filesystems that do specify MF_CHECK

#/devices/platform/sdhci-esdhc-imx.2/mmc_host/mmc1 /mnt/media_rw/extsd vfat defaults voldmanaged=extsd:auto
#/devices/platform/fsl-ehci /mnt/media_rw/udisk vfat defaults voldmanaged=udisk:auto
#/dev/block/mmcblk0p5    /system      ext4    ro                                                                               wait
#/dev/block/mmcblk0p4    /data        ext4    nosuid,nodev,nodiratime,noatime,nomblk_io_submit,noauto_da_alloc,errors=panic    wait,encryptable=footer
#/dev/block/mmcblk0p6    /cache       ext4    nosuid,nodev,nomblk_io_submit                                                    wait
#/dev/block/mmcblk0p7    /device      ext4    ro,nosuid,nodev                                                                  wait
#/dev/block/mmcblk0p1    /boot        emmc    defaults                                                                         defaults
#/dev/block/mmcblk0p2    /recovery    emmc    defaults                                                                         defaults
#/dev/block/mmcblk0p8    /misc        emmc    defaults                                                                         defaults
# fix, sdcard boot
/devices/platform/sdhciesdhcimx.1/mmc_host/mmc2 /mnt/media_rw/extsd vfat defaults voldmanaged=extsd:auto
/devices/platform/fsl-ehci /mnt/udisk vfat defaults voldmanaged=sdcard:auto
/dev/block/mmcblk1p5    /system      ext4    ro                                                                               wait
/dev/block/mmcblk1p4    /data        ext4    nosuid,nodev,nodiratime,noatime,nomblk_io_submit,noauto_da_alloc,errors=panic    wait,encryptable=footer
/dev/block/mmcblk1p6    /cache       ext4    nosuid,nodev,nomblk_io_submit                                                    wait
/dev/block/mmcblk1p7    /device      ext4    ro,nosuid,nodev                                                                  wait
/dev/block/mmcblk1p1    /boot        emmc    defaults                                                                         defaults
/dev/block/mmcblk1p2    /recovery    emmc    defaults                                                                         defaults
/dev/block/mmcblk1p8    /misc        emmc    defaults                                                                         defaults
# fix
2.	Follow the 3.3.1 to build the images.

3.3.1 User build mode
For a production release, the Android image should be built in the user mode.
When compared to eng mode, it will have the following differences:
# Build images for i.MX 6 SABRE-SD board
$ cd ~/myandroid
$ make PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log
or
$ make -j2 PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log
	->	-j2의 의미는 2개의 프로세서로 병렬 컴파일 한다는 의미로
		j다음의 개수는 "물리적코어 개수"로 설정하면 됨(ex, 물리적코어가 4개이면 -> -j4)

OR

$ cd ~/myandroid
$ source build/envsetup.sh
$ lunch sabresd_6dq-user
$ make -j2 2>&1 | tee build_sabresd_6dq_android.log
$ make dist # you can generate ota package with this command.	->	실행안해도 됨

cf)	User build 실행 시 /root/myandroid/hardware/imx/wlan/atheros/compat-wireless/......
	등의 compat-wireless build 등으로 인해 build 시간이 너무 오래 걸리는 경우
	1.	X:\root\myandroid\hardware\imx\wlan\atheros\compat-wireless\Android.mk 파일 내용을 하기와 같이 변경하면 compat-wireless을 다시 build 하지 않아서 build 시간을 줄일 수 있다.
$(mod_cleanup) :
#	$(MAKE) -C $(ATH_ANDROID_SRC_BASE) ARCH=arm CROSS_COMPILE=$(ATH_CROSS_COMPILE) KLIB=$(ATH_LINUXPATH) KLIB_BUILD=$(ATH_LINUXPATH) COMPAT_CURDIR=$(ATH_ANDROID_ROOT)/$(ATH_ANDROID_SRC_BASE) clean

	아래와 같이 변경시켜도 상기 wlan build를 다시 build 하는 현상 없앨 수 없다.
#	1.	Kernel 변경(iMX6 Board)
#	2.	Network device support -> Wirelss LAN --> 으로 들어가서 하기 설정을 Enable 시킴
#		1)	<M>	Atheros Wireless Cards	-->
#		2)	<M>	Atheros ath6kl support

cf)	전체 소스에서 일부분만 다시 빌드 - mmm 커맨드
안드로이드 프레임워크를 전체 빌드하는데에는 아무리 컴퓨터가 좋다고 하더라도
적게는 15분에서 많게는 30분 정도의 시간이 소요된다.
간단한 수정을 하고 나서 결과를 보기 위해 30분을 기다리는 것은 너무나도 시간 낭비인 것 같아서
부분적으로 빌드하는 방법이 없을까 구글링을 해보니 역시나 방법이 있다.
안드로이드에서는 mmm 이라는 명령을 사용하여 부분 빌드가 가능하도록 지원하고 있다.

cf)	- m:       Makes from the top of the tree.
	- mm:      Builds all of the modules in the current directory, but not their dependencies.
	- mmm:     Builds all of the modules in the supplied directories, but not their dependencies.
	- mma:     Builds all of the modules in the current directory, and their dependencies.
	- mmma:    Builds all of the modules in the supplied directories, and their dependencies.

먼저 
[taehyo@build-desktop:/android]# cd ~/myandroid
[taehyo@build-desktop:/android]# source build/envsetup.sh
[taehyo@build-desktop:/android]# lunch sabresd_6dq-user
으로 환경변수를 설정한다.

그리고 나서
[taehyo@build-desktop:/android]# mmm ./hardware/broadcom/wlan							->	거의 실행할 필요 없음
								 mmm ./hardware/imx/mx6/libcamera2						->	hardware 수정 시 실행
								 mmm ./frameworks/av/services/camera/libcameraservice	->	kernel 수정 시 실행
								 mmm ./frameworks/base/core/jni							->	주의) 본 명령 실행 후 실행 오류 발생하면 엄청 오래 걸리는 "make PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log" 명령을 실행해야 함
								 mmm ./frameworks/av/camera								->	주의) 본 명령 실행 후 실행 오류 발생하면 엄청 오래 걸리는 "make PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log" 명령을 실행해야 함
								 mmm ./frameworks/base

(mmm의 파라메터로는 Android.mk 파일이 존재하는 경로를 적어야 함)
를 실행하면 해당 경로에 대한 부분 빌드가 이루어진다.
cf)	mmm 명령 실행 시 해당 폴더의 하위폴더도 다시 build 됨
	이유) Android.mk 파일에 하위폴더도 build 시키도록 설정되어 있기 때문

cf)	mmm 명령 실행 시 하기와 같은 에러가 발생한 경우
	No private recovery resources for TARGET_DEVICE sabresd_6dq
	make: Entering directory `/root/myandroid'
	make: *** `out/target/product/sabresd_6dq/obj/EXECUTABLES/camera_client_test_intermediates/import_includes'에서 필요로 하는
	  타겟 `out/target/product/sabresd_6dq/obj/STATIC_LIBRARIES/libgtest_intermediates/export_includes'를 만들 규칙이 없습니다.  멈춤.
	make: Leaving directory `/root/myandroid'
	가)	아래 명령을 실행하면 에러가 제거 됨(단, 본 명령 실행하면 실행 완료까지 2시간 20분이 걸림)
		root@krh-VirtualBox:~/myandroid# make PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log
	나)	mmm ./frameworks/base -> mmma ./frameworks/base 명령으로 바꿔서 실행하면 에러가 제거될 수도 있음

cf)	mmm 명령 실행 시 하기와 같은 에러가 발생한 경우
	No private recovery resources for TARGET_DEVICE sabresd_6dq
	make: Entering directory `/root/myandroid'
	make: *** `out/target/common/obj/JAVA_LIBRARIES/framework-base_intermediates/classes-full-debug.jar'에서 필요로 하는
	  타겟 `frameworks/base/(사본).java'를 만들 규칙이 없습니다.  멈춤.
	make: Leaving directory `/root/myandroid'
	가)	/root/myandroid/frameworks/base/core/java/android/hardware	폴더 등에
		SystemSensorManager(사본).java 처럼 복사해 둔 사본 파일이 있는지 확인하고
		만약 있다면 삭제 시킴	->	이렇게 하고서 다시 mmm build 하면 본 문제가 제거 됨

cf)	X:\root\myandroid\frameworks\av\camera\CameraParameters.cpp
->	X:\root\myandroid\out\target\product\sabresd_6dq\obj\SHARED_LIBRARIES\libcamera_client_intermediates\CameraMetadata.P

마지막으로
[taehyo@build-desktop:/android]# make snod												->	실행시간 1분 정도 소요
로 이미지를 생성하면 완료.
make snod 는 현재의 소프트웨어 바이너리로 부터 시스템 이미지를 만들어 내는 명령이다.(system.img 를 다시 빠르게 생성)
cf)	system.img는 X:\root\myandroid\out\target\product\sabresd_6dq\system 폴더의 파일 등을 포함하고 있다.

참고로 make sdk 를 사용하여 SDK의 툴을 빌드할 수도 있다.

cf)	make systemimage																	->	실행시간 2시간 정도 소요
Then according to some guy's suggestion, I read the 'build/core/main.mk'.
I find that there is a 'droidcore' cmd in it, I try 'make droidcore', it works, the emulator can start successfully.
Reading the 'droidcore' cmd more carefully:

755 .PHONY: droidcore
756 droidcore: files \
757     systemimage \
758     $(INSTALLED_BOOTIMAGE_TARGET) \
759     $(INSTALLED_RECOVERYIMAGE_TARGET) \
760     $(INSTALLED_USERDATAIMAGE_TARGET) \
761     $(INSTALLED_FILES_FILE)

It seems that 'make droidcore' cmd means 'make systemimage' and so on.
So I try run 'make systemimage', it works fine too, and faster than 'make droidcore'.	->	make droidcore를 실행하면 거의 모든 시스템을 재 build 시키기 때문에 실행 시간이 무지 오래 걸림(4시간 이상..)

Solution:
1. After modify the source code in framework/base, do 'mm' in framework/base
2. Navigate to the root dir of ICS, do 'make systemimage'
3. Restart the AVD totally, not just run 'adb shell stop' && 'adb shell start'. (These cmds maybe not work).

PS:
'make snod' means make systemimage no dependence, it seems the dependence is needed, so we should use 'make systemimage' instead of 'make snod'.

cf)	전체 소스에서 일부분만 다시 빌드(X:\root\myandroid\kernel_imx 내부의 kernel image Rebuild)
# Boot image for SABRE-SD board
$ cd ~/myandroid
$ source build/envsetup.sh
$ lunch sabresd_6dq-user
$ make bootimage			->	boot.img 이미지 내부에 kernel image도 포함되어 있으며
								본, 명령을 실행하면 X:\root\myandroid\out\target\product\sabresd_6dq\ 폴더 내부의 boot.img & uImage 이미지를 rebuild 시킴

아래 명령은 uImage만 rebuild 시키는 명령 임
따라서, TFTP에서 사용할 uImage만 rebuild 시키는 것으로 Images for SABRE-SD SD 에서 필요로 하는 boot.img를 만들어 주는 것은 아님
1-2.~$vi .bashrc			->	아래와 같이 변경
	export PATH=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin:$PATH
1-1.source ~/.bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령				
1.	$ export PATH=~/myandroid/bootable/bootloader/uboot-imx/tools:$PATH
2.	$ cd ~/myandroid/kernel_imx
3.	$ echo $ARCH && echo $CROSS_COMPILE
Make sure you have those two environment variables set. If the two variables are not set, set them as:
4.	$ export ARCH=arm
5.	$ export CROSS_COMPILE=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
#6.	$ make menuconfig										->	cf) default kernel setting -> $ make imx6_android_defconfig
7.	$ make uImage											->	X:\root\myandroid\kernel_imx\arch\arm\boot\uImage 파일로 kernel image rebuild

cf)	안드로이드용 boot.img system.img ramdisk.img userdata.img 만들기, 만든후 unpack방법  Android  2012.10.24. 13:55
cf)
@@ -3594,6 +3594,7 @@  go	- start application at address 'addr'
 run	- run commands in an environment variable
 bootm	- boot application image from memory
 bootp	- boot image via network using BootP/TFTP protocol
+bootz   - boot zImage from memory
 tftpboot- boot image via network using TFTP protocol
 	       and env variables "ipaddr" and "serverip"
 	       (and eventually "gatewayip")
@@ -4414,6 +4415,13 @@  U-Boot supports the following image types:
 	useful when you configure U-Boot to use a real shell (hush)
 	as command interpreter.
 
+Booting the Linux zImage:
+-------------------------
+
+On some platforms, it's possible to boot Linux zImage. This is done
+using the "bootz" command. The syntax of "bootz" command is the same
+as the syntax of "bootm" command.

cf)	부팅 이미지 형식
ARM 시스템에서는 대부분의 경우 1가지나 2가지의 부팅 이미지 형식을 사용합니다.
(1) 표준 리눅스 zImage 형식의 커널 (“vmlinuz”) 및 표준 리눅스 초기 램디스크(“initrd.gz”),
(2) uImage 형식의 커널 (“uImage”) 및 거기 해당하는 최초 램디스크(“uInitrd”). 
uImage/uInitrd는 U-Boot 펌웨어에서 사용하려고 만들어진 이미지 형식입니다. u-boot는 여러 ARM 시스템에서(주로 32비트 시스템) 사용합니다. 
예전 버전의 U-Boot에서는 uImage/uInitrd 형식의 파일만 부팅할 수 있습니다. 즉 이 형식은 예전의 armel 시스템에서 주로 사용합니다. 
최근 버전의 U-Boot에서는 uImage/uInitrd 부팅 말고 표준 리눅스 커널과 램디스크 이미지로 부팅할 수 있습니다. 하지만 uImage 부팅과는 명령어 문법이 약간 다릅니다. 
멀티 플랫폼 커널을 사용하는 시스템에서는, 커널과 최초 램디스크 외에 디바이스-트리 파일(device-tree blob, “DTB”라고도 합니다)이 필요합니다. 
이 파일은 지원하는 시스템마다 다르고, 특정 하드웨어에 대한 설정이 들어 있습니다. DTB는 시스템의 펌웨어에서 만들어 내지만, 최근 시스템에서는 보통 따로 읽어들여야 합니다.

cf)	2.6. zImage VS uImage ¶
zImage와 uImage의 차이점 LDS2000에서는 uImage를 만들어야지 bootm을 사용하여 부팅가능 하다. zImgae는 go 명령을 사용한다. 

[edit]2.6.1. zImage ¶
압축된 Kernel의 image이다. 1M가 넘어가면 Big zImage라는 뜻으로 bzImage 라는 파일이름으로 명명한다. 
zImage 앞부분에는 zImage의 압축을 푸는 코드들이 들어있다. 이 코드들의 커널 소스내 위치는 arch/arm/boot/compressed/ 이고 
이 디렉토리 안에서 주로 head.S, head-xscale.S 파일을 보면 된다. 

[edit]2.6.2. uImage ¶
uImage이란 u-boot에서 사용하는 압축된 커널 이미지이다. 단순히 u-boot 의 tools/mkimage(u-boot source를 컴파일을 해야 생성된다)라는 툴을 이용해
zImage에 64byte 헤더를 추가시킨 이미지이다. 이 64byte 헤더에는 target architecture, operating system, image type, compression method, entry points, 
time stamp, CRC32 checksums 등과 같은 정보들이 들어간다. 

?uImage 만드는 방법 
$./mkimage -A arm(우리가 쓰는 임베디드 종류) -O linux -T kernel -C gzip -a 0xa0000000(ram address 올릴 주소) -e 0xa0000000(entry point) -n(name) "Linux Kernel Image" -d linux.bin.gz uImage
혹은 (PATH에 mkimage가 있을 경우) 
$make uImage
명령을 통해서 한번에 uImage를 만들 수 있다. 위에서 명령행 인자들이 그대로 uImage의 header가 된다. 

?예제 
$mkimage -A arm -O linux -T kernel -C none -a 0xa2000000 -e 0xa2000000 -n 'Linux-2.6.21.1' -d arch/arm/boot/zImage arch/arm/boot/uImage
uImage를 사용하는 경우 메모리의 어느 주소에 로드를 하더라도 커널에서 uImage를 만들때 설정한 주소로 압축이 풀린다. 


1.	boot.img - boot header + Linux kernel(zImage) + ramdisk/rootfs 합친 이미지.(recovery.img도 동일함.)
	zImage, ramdisk분리방법.
	첨부된 펄스크립트 파일(split_bootimg.pl)을 사용한다.

	boot.img생성방법 - 아래와 같이 mkbootimg명령으로 파라메터는 적당히 조절하여 생성한다.
	mkbootimg --kernel zImage --ramdisk ramdisk.img --base 0x80000000 --cmdline "console=ttyO2,115200n8 mem=456M@0x80000000 mem=512M@0xA0000000 init=/init vram=10M omapfb.vram=0:4M androidboot.console=ttyO2" --board omap4 -o boot.img.new

	cf)
	Partition type/index 	Name 			Start offset 		Size 			File system 		Content
	N/A 					BOOT Loader 	1 KB 				1 MB 			N/A 				bootloader
	Primary 1 				Boot 			8 MB 				8 MB 			boot.img format,	boot.img
																				kernel + ramdisk
	Primary 2 				Recovery 		Follow Boot 		8MB 			boot.img format,	recovery.img
																				kernel + ramdisk
	Logic 5 (Extended 3) 	SYSTEM 			Follow Recovery		512 MB 			EXT4. Mount as /	Android system files under /
																				system				system/ dir.
	Logic 6 (Extended 3) 	CACHE 			Follow SYSTEM.		512 MB 			EXT4. Mount as /	Android cache for image
																				cache.				store of OTA.
	Logic 7 (Extended 3)	Device 			follow CACHE 		8 MB 			Ext4.				To Store MAC address files.
																				Mount at /vender.
	Logic 8 (Extended 3)	Misc 			Follow Device		4M 				N/A 				For recovery store
																									bootloader message,
																									reserve.
	Primary 4 				DATA 			Follow Misc. 		Total - Other	EXT4. Mount at /	Application data storage for
																images			data.				the system application and
																									for internal media partition
																									in /mnt/sdcard/ dir.

2.	system.img - Android user space applications and libraries
	system.img 만들기.
	make_ext4fs -s -l 268435456 -a system system.img ./system
	-l : ext4 파티션 사이즈.
	-a : 안드로이드 마운트 지점.
	system.img : 생성될 파일이름.
	./system : 패키징할 디렉토리.	
	
	system.img unpack 방법.
	진저브레드 이전에는 system.img가 yaffs로 패키징되어 unyaffs를 사용하여 unpack시키면된다. 진저이후는 ext4파일시스템으로 패키징되어있으므로 아래와 같이 언팩을 수행한다.
	$ file system.img
	system.img: data	
	
	플랫폼sdk를 빌드하고나면 out디렉토리쪽에 sim2img파일이 생김.
	sparse파일을 ext4로 바꿈.
	simg2img system.img system.img.ext4	
	
	$ file system.img.ext4 
	system.img.ext4: Linux rev 1.0 ext4 filesystem data, UUID=57f8f4bc-abf4-655f-bf67-946fc0f9f25b (extents) (large files)	
	
	$ sudo mount -t ext4 -o loop ./system.img.ext4 /mnt
3.	ramdisk.img - 일반적인 리눅스 rootfs를 뜻함.
	ramdisk unpack방법.	
	
	$ file uInitrd 
	uInitrd: u-boot legacy uImage, Chipsee ramdisk for Linaro_1203, Linux/ARM, RAMDisk Image (gzip), 202817 bytes, Sun May 20 21:29:25 2012, Load Address: 0x00000000, Entry Point: 0x00000000, Header CRC: 0x6A85F17C, Data CRC: 0x2B51CF1A
		
	uInitrd일경우 mkimage헤더를 제거해야함.
	$ dd if=uInitrd of=ramdisk.img skip=64 bs=1
		
	ramdisk.img 파일 확인. gzip파일로 압축되있음.
	$ file ramdisk.img 
	ramdisk.img: gzip compressed data, from Unix
		
	gz파일로 이동 후 압축해제.
	$ mv ramdisk.img ramdisk.img.gz
	$ gzip -d ramdisk.img.gz 
		
	파일 확인. cpio 아카이브로 묶여있음.
	$ file ramdisk.img 
	ramdisk.img: ASCII cpio archive (SVR4 with no CRC)
		
	cpio를 푼다.
	$ cpio -i -F ramdisk.img
	2426 blocks
		
	ramdisk.img 만들기
	$ find . | cpio -o -H newc | gzip > ramdisk.img
	mkimage이용하여 64바이트 헤더를 씌운다.
	$ mkimage -A arm -O linux -T ramdisk -C gzip -a 0x0 -e 0x0 -n initramfs -d ./ramdisk.img ./uInitrd
4.	userdata.img 
	system.img와 동일.

cf)	android program source 위치
	File
	/bootable/diskinstaller/config.mk 
	/build/core/Makefile 
	/build/core/envsetup.mk 
	/external/sepolicy/Android.mk 
	/system/core/charger/Android.mk 
	/system/core/fs_mgr/Android.mk 
	/system/core/init/Android.mk 
	/system/core/rootdir/Android.mk
	
	/root/myandroid/out/target/product/sabresd_6dq/obj/EXECUTABLES/init_intermediates
	 
	Copying baseline ramdisk...
	cp -R out/target/product/odroidu/root out/target/product/odroidu/recovery
	rm out/target/product/odroidu/recovery/root/init*.rc
	Modifying ramdisk contents...
	cp -f bootable/recovery/etc/init.rc out/target/product/odroidu/recovery/root/init.rc
	cp -f out/target/product/odroidu/obj/EXECUTABLES/recovery_intermediates/recovery out/target/product/odroidu/recovery/root/sbin/
	rm -f out/target/product/odroidu/recovery/root/init.*.rc
	mkdir -p out/target/product/odroidu/recovery/root/system/bin
	cp -rf bootable/recovery/res out/target/product/odroidu/recovery/root/
	cp -f device/hardkernel/odroidu/recovery.fstab out/target/product/odroidu/recovery/root/etc/recovery.fstab
	cp out/target/product/odroidu/obj/PACKAGING/ota_keys_intermediates/keys out/target/product/odroidu/recovery/root/res/keys
	cat out/target/product/odroidu/root/default.prop out/target/product/odroidu/system/build.prop 
	            > out/target/product/odroidu/recovery/root/default.prop
	Modifying default.prop
	sed -i 's/ro.build.date.utc=.*/ro.build.date.utc=0/g' out/target/product/odroidu/recovery/root/default.prop
	----- Made recovery filesystem --------out/target/product/odroidu/recovery/root
	rm -rf out/target/product/odroidu/system/init
	rm -rf out/target/product/odroidu/system/sbin/adbdCopying baseline ramdisk...
	cp -R out/target/product/odroidu/root out/target/product/odroidu/recovery
	rm out/target/product/odroidu/recovery/root/init*.rc
	Modifying ramdisk contents...
	cp -f bootable/recovery/etc/init.rc out/target/product/odroidu/recovery/root/init.rc
	cp -f out/target/product/odroidu/obj/EXECUTABLES/recovery_intermediates/recovery out/target/product/odroidu/recovery/root/sbin/
	rm -f out/target/product/odroidu/recovery/root/init.*.rc
	mkdir -p out/target/product/odroidu/recovery/root/system/bin
	cp -rf bootable/recovery/res out/target/product/odroidu/recovery/root/
	cp -f device/hardkernel/odroidu/recovery.fstab out/target/product/odroidu/recovery/root/etc/recovery.fstab
	cp out/target/product/odroidu/obj/PACKAGING/ota_keys_intermediates/keys out/target/product/odroidu/recovery/root/res/keys
	cat out/target/product/odroidu/root/default.prop out/target/product/odroidu/system/build.prop 
	            > out/target/product/odroidu/recovery/root/default.prop
	Modifying default.prop
	sed -i 's/ro.build.date.utc=.*/ro.build.date.utc=0/g' out/target/product/odroidu/recovery/root/default.prop
	----- Made recovery filesystem --------out/target/product/odroidu/recovery/root
	rm -rf out/target/product/odroidu/system/init
	rm -rf out/target/product/odroidu/system/sbin/adbd
	cp -arp out/target/product/odroidu/root/* out/target/product/odroidu/system
	rm -rf out/target/product/odroidu/system/bin/init
	mv out/target/product/odroidu/system/init out/target/product/odroidu/system/bin/
	ln -sr out/target/product/odroidu/system/bin/init out/target/product/odroidu/system/init
	ln: 부적절한 옵션 -- 'r'
	더 많은 정보를 보려면 `ln --help' 하십시오.
	make: *** [out/target/product/odroidu/recovery/root.ts] 오류 1
	make: *** 파일 `out/target/product/odroidu/recovery/root.ts'을(를) 지웁니다
	make: *** 끝나지 않은 작업을 기다리고 있습니다....
	Note: Some input files use or override a deprecated API.
	Note: Recompile with -Xlint:deprecation for details.
	Note: Some input files use unchecked or unsafe operations.
	Note: Recompile with -Xlint:unchecked for details.
	
	cp -arp out/target/product/odroidu/root/* out/target/product/odroidu/system
	rm -rf out/target/product/odroidu/system/bin/init
	mv out/target/product/odroidu/system/init out/target/product/odroidu/system/bin/
	ln -sr out/target/product/odroidu/system/bin/init out/target/product/odroidu/system/init
	ln: 부적절한 옵션 -- 'r'
	더 많은 정보를 보려면 `ln --help' 하십시오.
	make: *** [out/target/product/odroidu/recovery/root.ts] 오류 1
	make: *** 파일 `out/target/product/odroidu/recovery/root.ts'을(를) 지웁니다
	make: *** 끝나지 않은 작업을 기다리고 있습니다....
	Note: Some input files use or override a deprecated API.
	Note: Recompile with -Xlint:deprecation for details.
	Note: Some input files use unchecked or unsafe operations.
	Note: Recompile with -Xlint:unchecked for details.
	

4 Downloading Images
4.1.2 Downloading images with MFGTool
1.	/root/myandroid/out/target/product/sabresd_6dq 폴더에 있는 아래 파일을
	Mfgtools-Rel-4.1.0_130816_MX6Q_UPDATER\Profiles\MX6Q Linux Update\OS Firmware\files\android 폴더에 복사 함
	boot.img
	recovery.img
	system.img
	u-boot.bin
	u-boot-6dl.bin
	u-boot-6q.bin
2.	i.mx6 board의 SW6을 00001100 (from 1-8 bit) 와 같이 변경
3.	MfgTool2.exe 실행 -> Start 버튼 누름 -> 상태표시창에 done 표시되면 -> Stop버튼 누름 -> Exit 버튼 누름
cf)	MfgTool2.exe 을 사용하지 않고 Linux -> Card reader를 사용해서 SD memory에 android image writing 하는 경우
	-> [71]	i.MX6(i.MX 6 Series SABRE for Smart Devices) -> 3)	SD Memory/eMMC 로 부팅 하기 -> 가) Android 부팅
4.	i.mx6 board의 SW6을 01000010 (from 1-8 bit) 와 같이 변경
5.	i.mx6 board 재 부팅 시킴	*/




	4+1)TFTP 개발환경 구현(정상적으로 동작함 확인 완료, KRH)
1.	Ubuntu에서 tftp 설치한다.
	sudo apt-get install tftp
	sudo apt-get install tftpd 를 실행한다.
2.	Ubuntu에서 tftp 설정해줘야 한다.
	sudo vi /etc/xinetd.d/tftp
service tftp
{
	protocol		= udp
	disable			= no
	socket_type		= dgram
	wait			= yes
	user			= root
	server			= /usr/sbin/in.tftpd
	server_args		= /tftpboot
}
3.	Ubuntu에서 /tftpboot이란 폴더를 만들고 권한을 주자.
	sudo mkdir /tftpboot
	sudo chmod -R 777 /tftpboot
	sudo chown -R root /tftpboot
4.	Ubuntu에서 xinetd를 재시작하자.
	sudo /etc/init.d/xinetd restart
5.	제대로 설정되었는지 확인하자.
	netstat -au
	............................
	udp 0 0 *:nfs  *:*
	............................
	udp 0 0 *:tftp *:*
	............................	
6.	호스트 PC의 ip주소를 설정하자.  (단, 타겟보드는 10.0.2.16 의 ip주소를 가진다.)(이때의 VirtualBox 네트워크 속성은 "브리지 어뎁터"로 설정시켜야 함)
	sudo ifconfig eth0 10.0.2.15 netmask 255.255.255.0
	sudo ifconfig
7.	ping 테스트를 통해서 제대로 접속되었는지 확인하자.
	1)	Ubuntu에서 -> target board
		ping 10.0.2.16
	2)	target board에서 -> Ubuntu
		busybox ping 10.0.2.15
8.	test.c 파일을 타겟보드에서 전송받자.
	1)	Ubuntu에서
		가)	cd /tftpboot
		나)	vi test.c
		다)	chmod 777 test.c
	2)	target board���서(10.0.2.15는 당연히 호스트 PC IP)
		tftp 10.0.2.15 -r test.c -g

cf)	AESOP S3C6410: 보드 부팅 환경 설정 방법2009.07.23 00:51 Embedded System 
	AESOP S3C6410 보드의 경우 커널의 부트 아규먼트를 uBoot에서 커널로 넘겨줄 수 있습니다.
	이외에 보드 환경 설정을 위한 다양한 환경 설정을 uBoot에서 지원 합니다.
	따라서, 커널의 재 컴파일 작업이 없이도, 간단하게 커널의 부트 환경 설정을 변경할 수 있습니다.
	
	1. NFS를 이용한 루트 파일 시스템 마운트 방법
	최초로 이솝 보드를 받았을 때 NAND Flash에 루트 파일 시스템을 기록하기 위해서 또는 어플리케이션 등을 개발할 때는
	NFS로 루트 파일 시스템을 마운트 하여 개발을 진행 합니다.
	이 경우, uBoot의 명령 프롬포트에서 다음의 명령을 수행하면, NFS로 루트 파일 시스템을 마운트 합니다.
	(해당 환경 설정을 수행하기 이전에, 호스트PC의 /nfsroot 디렉터리에 이솝 보드용 NFS 루트 파일 시스템이 있어야 합니다.)
	setenv bootargs console=ttySAC0,115200 root=/dev/nfs rw nfsroot=[호스트PC의 IP주소]:/nfsroot/RootFS-aESOP6410 ip=[타깃 보드의 IP주소]:[호스트 PC의 IP주소]:[게이트 웨이 주소]:[서브넷 마스크]::eth0:off mem=128M ethaddr=[이더넷 컨트롤러의 MAC 주소]
	saveenv => 환경 설정을 NAND Flash 저장
	boot       => 적용한 환경 설정을 가지고 부팅
	예)
	setenv bootargs console=ttySAC0,115200 root=/dev/nfs rw nfsroot=192.168.1.15:/nfsroot/RootFS-aESOP6410 ip=192.168.1.85:192.168.1.15:192.168.1.1:255.255.255.0::eth0:off mem=128M ethaddr=00:40:5c:26:0a:5b
	saveenv
	boot

	2. uBoot의 IP주소 설정 방법
	uBoot에서 호스트 PC의 TFTP를 이용한 다운로드를 하기위한 IP 주소 설정은 다음과 같이 합니다.
	setenv gatewayip [게이트 웨이 주소];setenv ipaddr [타깃 보드 IP주소];setenv serverip [호스트 PC IP주소]
	saveenv => 환경 설정을 NAND Flash 저장
	예)
	setenv gatewayip 192.168.1.1;setenv ipaddr 192.168.1.100;setenv serverip 192.168.1.15
	saveenv

	3. TFTP를 이용하여 리눅스 커널 이미지를 다운로드 한 후 부팅
	리눅스 커널 개발 시, 커널을 수정하면서 테스트가 필요할 경우 다음과 같이 옵션을 넣어주면,
	이솝 보드는 TFTP를 통하여 리눅스 커널 이미지를 다운로드 받은 후 다운로드 받은 커널 이미지를 가지고 부팅을 수행 합니다.
	setenv bootcmd tftp c0008000 zImage-aESOP6410\;bootm c0008000
	saveenv => 환경 설정을 NAND Flash 저장

	4. TFTP를 이용하여 커널을 다운로드 받고 NAND Flash에 기록
	다음은 TFTP를 이용하여 리눅스 커널 이미지를 다운로드 받고, 자동으로 다운로드 받은 커널을 NAND Flash에
	기록하는 명령 입니다.
	tftp 0xc0008000 zImage-aESOP6410;nand erase 60000 200000;nand write 0xc0008000 60000 200000
	
	5. NAND Flash에 저장된 커널로 자동 부팅
	다음의 명령을 입력하면, 이솝 보드는 부팅 시 자동으로 NAND Flash에 기록된 커널을 읽어서 부팅을 수행 합니다.
	setenv bootcmd nand read C0008000 60000 200000\;bootm C0008000
	saveenv => 환경 설정을 NAND Flash 저장
	
	6. TFTP를 이용하여 부트로더를 다운로드 받고 NAND Flash에 기록
	부트로더가 수정되었거나, 교체가 필요할 경우 다음의 명령을 입력하면, 부트로더를 다운로드 받고 이것을
	자동으로 NAND Flash에 기록 합니다.
	tftp 0xc0008000 uBoot-aESOP6410.bin;nand write 0xc0008000 0 30000
	
	7. NAND Flash에 저장된 루트 파일 시스템을 마운트 하여 부팅
	루트 파일 시스템이 NAND Flah에 저장되어 있을 경우 부트로더에서 다음의 옵션을 입력하면, NAND Flash에
	저장된 루트 파일 시스템을 마운트하여 부팅 합니다.
	setenv bootargs root=/dev/mtdblock3 rootfstype=yaffs2 console=ttySAC0,115200
	
	8. NAND Flash에 루트 파일 시스템을 기록하는 방법
	제공 되는 이솝 보드용 NFS 루트 파일 시스템으로 부팅을 수행 한 후, 다음의 명령을 이용하여 NAND Flash에
	루트 파일 시스템을 기록할 수 있습니다. (NAND Flash 기록된 루트 파일 시스템으로 부팅하려면 7번을 참조하세요.)

	# NFS로 부팅한 리눅스 프롬포트에서 수행
	flash_eraseall /dev/mtd3
	tar -C /mnt/nand -xf ~/RootFS-aESOP6410.tar
	sync
	umount /mnt/nand
	
	※ 출처: http://www.aesop.or.kr/?document_srl=41006


	4+2)NFS 개발환경 구현
1-1)4+1)TFTP 개발환경 구현(정상적으로 동작함 확인 완료, KRH)
	1~8까지를 먼저 실행

1.	/opt/nfsroot# chmod -R 755 *
	cf)	어처구니가 없는 것이 상기 명령을 /opt/nfsroot# chmod -R 777 * 로 실행하면
		부팅시, Freeing init memory: 256K 문구 이후 부팅이 진행되지 않는 황당한 에러가 발생 함
	cf)	이런 문제가 발생하는 것은
		X:\root\myandroid\system\core\init\util.c 파일 상의 하기 함수가 저렇게 황당한 permission으로 설정되어 있기 때문임(버그로 보임)
		void *read_file(const char *fn, unsigned *_sz)
		{
			...........................................................................
		    }
		    if ((sb.st_mode & (S_IWGRP | S_IWOTH)) != 0) {
		        ERROR("skipping insecure file '%s'\n", fn);
		        goto oops;
		    }
			...........................................................................
	cf)	chmod 755가 되어야 하는 자세한 이유는, 본 Program_수정_절차_설명 내부에 있는 chmod 명령 참고

1+1.Debug 확인용
	cf)	본 사항은 nfs가 제대로 동작하지 않을 때 Debugging 확인용으로
		만약, nfs가 제대로 동작한다면 변경 사항은 적용하지 않아도 됨
~/myandroid/system/core/init/init.c
int main(int argc, char **argv)
{
	.................................................................
	// add
	ERROR("~/myandroid/system/core/init/init.c execution\n");
	// add
	.................................................................
 	// add
	ERROR("Before, reading /init.rc\n");
	// add
    INFO("reading config file\n");
    init_parse_config_file("/init.rc");
	// add
	ERROR("After, reading /init.rc\n");
	// ad
	.................................................................

~/myandroid/kernel_imx/init/main.c
static void run_init_process(const char *init_filename)
{
	argv_init[0] = init_filename;

	// add, test
	printk("start, run_init_process, with %s\n", argv_init);
	// add

	kernel_execve(init_filename, argv_init, envp_init);
}

2.	NFS prgram 설치 및 환경 설정
	1)	$ sudo apt-get install nfs-kernel-server nfs-common portmap
	2)	$ vi /etc/exports
		# add
		/opt/nfsroot *(rw,no_root_squash,no_all_squash,sync)
		# add
	3)	$ /etc/init.d/nfs-kernel-server restart
		$ exportfs -r
	4)	Ubuntu PC의 ip주소를 설정하자.
		(단, 타겟보드는 10.0.2.16 의 ip주소를 가진다.)(이때의 VirtualBox 네트워크 속성은 "브리지 어뎁터"로 설정시켜야 함)
		$ ifconfig eth0 10.0.2.15 netmask 255.255.255.0
		$ ifconfig

3.	menuconfig
1-1)$ vi .bashrc			->	아래와 같이 변경                                                                                                         
	export PATH=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin:$PATH                                                                           
	$ source ~/.bashrc		->	PATH가 새롭게 적용되도록 설정시키는 명령	
	$ export PATH=~/myandroid/bootable/bootloader/uboot-imx/tools:$PATH
	$ cd ~/myandroid/kernel_imx
	$ echo $ARCH && echo $CROSS_COMPILE
	Make sure you have those two environment variables set. If the two variables are not set, set them as:
	$ export ARCH=arm
	$ export CROSS_COMPILE=~/myandroid/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
	# Generate ".config" according to default config file under arch/arm/configs.
	$ make menuconfig
1)	Under the "General --->" you need to have the following enabled: 
	[*] Prompt for development and/or incomplete code/drivers
2)	Userspace binary formats
	1)	<*> Kernel support for MISC binaries
3)	File systems
	1)	<*> Kernel automounter version 4 support (also supports v3)
	2)	Network File Systems
		<*>   NFS client support                                         x x
		[*]     NFS client support for NFS version 3                     x x
		[*]       NFS client support for the NFSv3 ACLprotocol extensionx x
		[*]     NFS client support for NFS version 4                     x x
		[*]       NFS client support for NFSv4.1(EXPERIMENTAL)          x x
		[*]  Root file system on NFS                                    x x
		[*]  Use the legacy NFS DNS resolver                            x x
		[*]  Use the new idmapper upcall routine                        x x
		<*>   NFS server support                                         x x
		[*]    Include support for deprecatedsyscall interface to NFSD x x
		-*-     NFS server support for NFS version 3                     x x
		[*]       NFS server support for the NFSv3 ACLprotocol extensionx x
		[*]    NFS server support for NFS version 4 (EXPERIMENTAL)
4)	Kernel Features  ---> 
    [*] Use the ARM EABI to compile the kernel                       
    [*]   Allow old ABI binaries to run with this kernel (EXPERIMENTAL)
5)	Networking support ---> In the "Networking options --->" menu you must have this enabled: 
		[*] IP: kernel level autoconfiguration
		[*]       BOOTP support (NEW)
6)	그리고 호스트의 NFS위치와 IP정보를 함께 세팅해야 한다. <.config> 파일의 CMDLINE 항목은 다음과 같이 직접 수정한다.
		# vi .config
		# vi ~/myandroid/kernel_imx/.config
		......................................................................................................
		#CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
		# fix, NFS
		CONFIG_CMDLINE="console=ttymxc0,115200 init=/init ip=10.0.2.16:10.0.2.15:10.0.2.1:255.255.255.0::eth0:on nfsroot=10.0.2.15:/opt/nfsroot,tcp,nolock nfsrootdebug video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0 androidboot.hardware=freescale"
		# fix
		......................................................................................................
	ip 항목은 순서대로 target ip : host ip : gateway ip : netmask 의 의미를 가진다.
7)	make menuconfig으로 변경한 kernel 설정을 default 설정으로 변경
	cp /root/myandroid/kernel_imx/.config /root/myandroid/kernel_imx/arch/arm/configs/imx6_android_defconfig
8)	Build
	가)	X:\root\myandroid\kernel_imx\ 폴더 내의 파일을 수정한 경우
		본 경우는 Build 후 하기 "4.	Setting up the TFTP and NFS root"에 있는 아래 명령을 수행하지 않아도 됨
		$ cp -r out/target/product/sabresd_6dq/root/* /opt/nfsroot/
		$ cp -r out/target/product/sabresd_6dq/system/* /opt/nfsroot/system/
		
	# Boot image for SABRE-SD board
	$ cd ~/myandroid
	$ source build/envsetup.sh
	$ lunch sabresd_6dq-user
	$ make bootimage			->	boot.img 이미지 내부에 kernel image도 포함되어 있으며
									본, 명령을 실행하면 X:\root\myandroid\out\target\product\sabresd_6dq\ 폴더 내부의 boot.img & uImage 이미지를 rebuild 시킴
									cf)	본 명령을 사용하면 kernel image가 make menuconfig 명령으로 설정을 변경해도 default 구성으로 다시 복구되어서 build되며
										이렇게 되는 이유는 build 시 하기 설정파일을 찾아서 build 하기 때문 임
										TARGET_KERNEL_DEFCONF = /root/myandroid/kernel_imx/arch/arm/configs/imx6_android_defconfig
									->	해결방법
										make menuconfig으로 변경한 kernel 설정을 default 설정으로 변경
										cp /root/myandroid/kernel_imx/.config /root/myandroid/kernel_imx/arch/arm/imx6_android_defconfig
	나)	X:\root\myandroid\frameworks\base\ or
		X:\root\myandroid\hardware\imx/mx6\libcamera2 폴더 내의 파일을 수정한 경우
		본 경우는 Build 후 하기 "4.	Setting up the TFTP and NFS root"에 있는 아래 명령을 수행해야 함
		$ cp -r out/target/product/sabresd_6dq/system/* /opt/nfsroot/system/
		
	[taehyo@build-desktop:/android]# cd ~/myandroid
	[taehyo@build-desktop:/android]# source build/envsetup.sh
	[taehyo@build-desktop:/android]# lunch sabresd_6dq-user
	으로 환경변수를 설정한다.

	그리고 나서
	[taehyo@build-desktop:/android]# mmm ./hardware/broadcom/wlan							->	거의 실행할 필요 없음
									 mmm ./hardware/imx/mx6/libcamera2						->	hardware 수정 시 실행
									 mmm ./frameworks/av/services/camera/libcameraservice	->	kernel 수정 시 실행
									 mmm ./frameworks/base/core/jni							->	주의) 본 명령 실행 후 실행 오류 발생하면 엄청 오래 걸리는 "make PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log" 명령을 실행해야 함
									 mmm ./frameworks/av/camera								->	주의) 본 명령 실행 후 실행 오류 발생하면 엄청 오래 걸리는 "make PRODUCT-sabresd_6dq-user 2>&1 | tee build_sabresd_6dq_android.log" 명령을 실행해야 함
									 mmm ./frameworks/base

	마지막으로
	[taehyo@build-desktop:/android]# make snod												->	이곳에서도 본 명령을 꼭 수행해줘야지 수정 사항이 적용 된다.
	
4.	Setting up the TFTP and NFS root
	1)	$ cd /opt
		$ mkdir nfsroot
		$ cd /
		$ mkdir tftpboot
	2)	$ cp /root/myandroid/out/target/product/sabresd_6dq/uImage /tftpboot/
	
	3)	. If you built out your own Android image, copy the generated Android files to the NFS root manually. For example:
		$ cd ~/myandroid
		$ rm -rf /opt/nfsroot/*
		$ cp -r out/target/product/sabresd_6dq/root/* /opt/nfsroot/							->	본, 명령을 새롭게 build를 해도 root 파일을 변경하지 않은 이상 거의 재 실행할 필요 없음
		$ cp -r out/target/product/sabresd_6dq/system/* /opt/nfsroot/system/				->	mmm ./frameworks/base or mmm ./hardware/imx/mx6/libcamera2 명령을 실행한 경우, 본 명령을 실행해야 함
	4)	$ cd /opt
		$ chmod -R 755 /opt/nfsroot
		$ chmod -R 777 /tftpboot

5.	/opt/nfsroot 내부 파일 수정
	Since the NFS uses system, data, and cache folders under /opt/nfsroot/, we have to
	change some settings and command sequence in /opt/nfsroot/init.rc and /opt/nfsroot/
	init.freescale.rc. Since the framework will clear ethernet's IP when suspended, which
	Downloading Images
	Android User's Guide, Rev kk4.4.2_1.0.0-ga, 07/2014
	14 Freescale Semiconductor, Inc.
	causes resume failure, the system property ethernet.clear.ip should be set to "no" in /opt/
	nfsroot/init.rc. For example:
	--- a/opt/nfsroot/init.rc
	+++ b/opt/nfsroot/init.rc
	@@ -144,7 +144,6 @@ loglevel 3
	on post-fs
	# once everything is setup, no need to modify /
	-mount rootfs rootfs / ro remount
	# We chown/chmod /cache again so because mount is run as root + defaults
	chown system cache /cache
	chmod 0770 /cache
	@@ -370,6 +369,7 @@ on boot
	class_start core
	class_start main
	+class_start late_start
	on property:sys.boot_completed=1
	# Set default CPU frequency governor
	@@ -400,8 +400,6 @@ on property:sys.interactive="active"
	chmod 0660 /sys/devices/system/cpu/cpufreq/interactive/input_boost
	-on nonencrypted
	-class_start late_start
	on charger
	class_start charger
	--- a/opt/nfsroot/init.freescale.rc
	+++ b/opt/nfsroot/init.freescale.rc
	@@ -93,6 +93,7 @@ on boot
	# No bluetooth hardware present
	setprop hw.bluetooth 0
	setprop wlan.interface wlan0
	+setprop ro.nfs.mode yes
	# mount the debugfs
	mount debugfs none /sys/kernel/debug/
	@@ -126,6 +127,6 @@ service iprenew_wlan0 /system/bin/dhcpcd -n
	disabled
	oneshot
	-on fs
	+#on fs
	# mount ext4 partitions
	-mount_all /fstab.freescale
	+#mount_all /fstab.freescale

6.	하기와 같이 boot 설정 수정
MX6Q SABRESD U-Boot > print
bootdelay=3
baudrate=115200
rd_loadaddr=0x11000000
netdev=eth0
ethprime=FEC0
splashimage=0x30000000
splashpos=m,m
lvds_num=1
fastboot_dev=mmc2
ethact=FEC0
rootpath=/opt/nfsroot
loadaddr=0x10800000
nfsroot=opt/nfsroot
filesize=5C1F40
fileaddr=10800000
ipaddr=10.0.2.16
serverip=10.0.2.15
bootfile=uImage
netmask=255.255.255.0
bootcmd=tftpboot 0x10800000 uImage;bootm 0x10800000
bootargs=console=ttymxc0,115200 init=/init ip=10.0.2.16:10.0.2.15:10.0.2.1:255.255.255.0::eth0:on nfsroot=10.0.2.15:/opt/nfsroot,tcp,nolock nfsrootdebug video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0 androidboot.hardware=freescale
stdin=serial
stdout=serial
stderr=serial

Environment size: 734/8188 bytes

cf)	setenv bootcmd 'tftpboot 0x10800000 uImage;bootm 0x10800000'
cf) setenv bootargs 'console=ttymxc0,115200 init=/init ip=10.0.2.16:10.0.2.15:10.0.2.1:255.255.255.0::eth0:on nfsroot=10.0.2.15:/opt/nfsroot,tcp,nolock nfsrootdebug video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0 androidboot.hardware=freescale'
cf)	client(target board) nfs debug message 표시 방법
	boot 환경 -> bootargs 설정에 nfsrootdebug 명령을 추가 시키면 됨
	ex)	U-Boot > setenv bootargs root=/dev/nfs rw console=ttymxc0,115200 nfsroot=10.0.2.15:/opt/nfsroot,nolock nfsrootdebug ip=10.0.2.16:10.0.2.15:10.0.2.1:255.255.255.0::eth0:off init=/init video=mxcfb0:dev=ldb,bpp=32 video=mxcfb1:off video=mxcfb2:off fbmem=10M fb0base=0x27b00000 vmalloc=400M androidboot.console=ttymxc0
cf)	saveenv

7.	재부팅하면 NFS 가 정상적으로 작동되어서 Android main 화면이 출력 됨
	cf)	bootloader -> tftpboot 로 uImage loading 이후 kernel load -> /opt/nfsroot ROOT파일시스템 읽어들여서 Android main 화면 출력

8.	NFS 참고사항

NFS(Network File System)구축하기
http://sulac.egloos.com/5600299

인터넷의 바다에 용자들은 참 많다는걸 느끼네요.. 1. NFS(Network File System)이란?(1) 개요: NFS는 Sun Microsystems사에서 개발된 것으로 TCP/IP네트워크 상에서 다른 컴퓨터의 파일
          시스템을 마운트하고 공유하여 상대방의 파일 시스템 일부를 마치 자기 자신의 디렉토리인
          것처럼 사용할 수 있게 해준다. NFS가 사용되는 주된 이유는 고용량의 하드디스크를 탑재
          하고 있는 몇 대의 워크스테이션이 네트워크의 다른 컴퓨터들에게 파일 시스템서비스를 
          해줌으로써 모든 컴퓨터들이 필요 이상의 자원을 가질 필요도 없고 소프트웨어를 여기저기
          깔아둘 필요도 없어지게 된다. NFS는 사용이 편리한 대신에 보안에 상당히 미약하기 때문
          에 주의해서 사용해야 한다.
(2) NFS서버의 설정
   1) 설명: NFS서버는 언제든지 클라이언트가 마운트할 수 있도록 준비되어 있어야 하며 NFS는 rpc.
          mountd와 rpc.nfsd 두 데몬을 가지고 있다. 참고로 /etc/rc.d/init.d/nfs 스트립트를 실행
          하면 이 두 데몬을 실행시킨다.
   2) 관련데몬: NFS를 사용하기 위해서는 다음과 같은 데몬을 실행시켜야 한다.
     ㄱ. netfs: 삼바, NFS, NCP등을 마운트하거나 언마운트해주는 데몬으로 NFS 서버데몬을 띄우기
               전에 미리 실행시켜야 한다.
     ㄴ. nfs: NFS서비스를 해주는 데몬이다. 참고로 이 데몬을 실행시키려면 먼저 /etc/exports
             파일을 설정해야 한다.
     ㄷ. portmap: RPC(Remote Procedure Call)연결에 관여하는 데몬으로 NFS, NIS을 사용할 때 필
                 요함으로 실행시켜야 한다.
     ㄹ. nfslock: 파일잠금을 제공하는데 이것은 동시에 여러 사람들이 동일한 파일을 수정하는 
                 것을 막는다.
    (참고) 데몬의 확인
          [root@www init.d]# rpcinfo -p
             program vers proto   port
              100000    2   tcp    111  portmapper
              100000    2   udp    111  portmapper
              100024    1   udp  32768  status
              100024    1   tcp  32768  status
              100011    1   udp   1022  rquotad
              100011    2   udp   1022  rquotad
              100005    1   udp  32771  mountd
              100005    1   tcp  32769  mountd
              100005    2   udp  32771  mountd
              100005    2   tcp  32769  mountd
              100005    3   udp  32771  mountd
              100005    3   tcp  32769  mountd
              100003    2   udp   2049  nfs
              100003    3   udp   2049  nfs
              100021    1   udp  32772  nlockmgr
              100021    3   udp  32772  nlockmgr
              100021    4   udp  32772  nlockmgr
            => (설명)
              rpc.mountd: 외부의 요청에 반응하는 NFS 마운트 프로토콜이다. 클라이언트들이 서버
                         를 이용할 수 있도록 디렉토리를 공유해주는 역할을 한다. NFS는 접속해제
                         방식으로 웹서버처럼 접속요청이 있을 때만 연결이 이루어진다.
              rpc.nfsd: 서버측에서 rpc.mountd에 의해 마운트되면 클라이언트는 rpc.nfsd로 서버에
                       요구를 보내게 된다. 이 요구를 처리하는 주 데몬이다.
              rpc.lockd: 파일잠금을 제공하는데 이것은 동시에 여러 사람들이 동일한 파일을 수정
                        하는 것을 막는다.
              rpc.statd: rpc.lockd와 함께 작동하면 NFS서버가 비정상적으로 종료되었거나 리부팅
                        했을 경우 복구하는 역할을 한다.
              rpc.rquotad: 원격 쿼터 서버로서 NFS서버의 파일 시스템을 마운트한 로컬 유저의 쿼
                          터에 넘겨준다.
          [root@www /]# ps ax
            => rpc.mountd와 nfsd 데몬이 실행중인지 확인하면 된다.
   3) 관련파일: /etc/exports
     ㄱ. 개요: 파일에 마운트를 허가할 디렉토리와 마운트를 허가할 호스트 목록을 설정한다.
     ㄴ. /etc/exports에서 사용가능한 옵션들
        root_squash: 클라이언트에서 루트를 서버상에 nobody사용자로 매핑한다. 
        no_root_squash: 서버와 클라이언트 모두 같은 루트(root)를 사용한다. 즉 클라이언트에서의
                       root의 요청을 서버의 root로 매핑한다.
        ro: 파일 시스템을 읽기 전용(read only)로 마운트한다.
        rw: 파일 시스템을 읽고 쓸수 있도록 마운트한다.(read write)
        insecure: 인증되지 않은 접근도 가능하도록 한다.'
        link_relative: 심볼릭 링크를 상대 심볼릭 링크로 바꿀 때 사용한다.
        noaccess: 지정된 디렉토리에는 접근을 금지한다. 특정시스템에 대한 공유 디렉토리 일부를
                 접근 못하게 할 경우에 사용한다.
        (참고) 가장 많이 나오는 옵션으로 root_squash와 no_root_squash가 있는데 squash라는 뜻이
              '짓누르다', '억압하다'라는 뜻이 있다. 따라서 root_squash라는 것은 root를 짓누르
              다. 즉 root사용자를 무시한다는 뜻이고 no_root_squash는 그 반대의 뜻이다.
     ㄷ. /etc/exports파일의 예
        /home/ftp/pub *.sample.com(ro)
        / master(rw) trusty(rw,no_root_squash)
        /projects proj*.local.domain(rw)
        /data 192.168.0.0/255.255.255.0(ro)
        /work 192.168.0.2(rw)
        /pub *(ro, insecure, root_squash)
        /pub/private *.social.com(noaccess)
         => (설명)
           1. /home/ftp/pub디렉토리를 sample.com도메인을 사용하는 모든 사용자가 읽는 것을 허용
             한다.
           2. /디렉토리를 master, trusty호스트가 읽기/쓰기를 허용한다.
           3. 도메인이름이 local.domain이고 호스트이름이 proj로 시작하는 호스트에 대해서 /pro
             jects라는 디렉토리로 읽기/쓰기를 허용한다.
           4. 네트워크주소가 192.168.0 대역에 속한 모든 호스트에 대해서 data디렉토리를 읽기만
             허용한다.
           5. /work 디렉토리를 192.168.0.2 호스트만 read and write권한으로 설정한다.
           6. /pub디렉토리에 읽기전용으로 마운트할 수 있고, 인증없이 마운트가 가능하며 마운트하
             는 모든 컴퓨터의 루트를 서버에서 nobody로 접근할 수 있게한다.
           7. /pub/private디렉토리는 social.com에 해당하는 시스템은 접근할 수 없다.
   4) NFS 서버설정예
     ㄱ. /etc/exports에 설정한다.
       예) /data 192.168.3.220/255.255.255.0(rw)
     ㄴ. 데몬을 띄운다. (netfs, portmap, nfs)
       예) /etc/rc.d/init.d/nfs start
     ㄷ. 해당디렉토리의 퍼미션을 푼다.
       예) chmod 777 /data

(3) 관련명령어
   1) exportfs
     ㄱ. 설명: NFS에서 익스포트된 리스트를 보여준다.
     ㄴ. 사용법
        exportfs [option]
     ㄷ. 옵션
        -v : 익스포트된 리스트를 자세히 보여준다.
        -r : 익스포트된 내역을 다시 읽어들인다.
     ㄹ. 사용예
        a. [root@www /]# exportfs
           /data           192.168.0.3/255.255.255.0
        b. [root@www /]# exportfs -v
           /data           192.168.0.3/255.255.255.0(rw,async,wdelay,root_squash)
        c. [root@www /]# exportfs -ar
             => 현재 설정된 내역이나 변경된 내역을 다시 읽어들인다.
   2) showmount
     ㄱ. 설명: NFS서버의 마운트된 정보를 보여준다.
     ㄴ. 사용법
        showmount [option]
     ㄷ. option
        -a : host:dir 형태로 출력한다.
        -e : 익스포트리스트를 보여준다.
     ㄹ. 사용예
        a. [root@www /]# showmount
           Hosts on www:
           192.168.0,3
        b. [root@www /]# showmount -a
           All mount points on www:
           192.168.0.3:/data
        c. [root@www /]# showmount -e
           Export list for www:
           /data 192.168.0.3/255.255.255.0
     cf) showmount 로 마운트 된 정보가 제대로 구성되어 있지 않은 경우 초기화 방법
     	 # /var/lib/nfs/rmtab 정보를 수정하면 됨

 출처 : 대전국제IT교육센터 정성재 강사


	5)	i.MX6 Series Platform SDK Test
		(1)	Default SDK Build & 실행
			가)	iMX6_Platform_SDK 폴더로 이동후
				./tools/build_sdk -target mx6dq -board smart_device 명령을 실행시켜서 SDK를 Build 시킴
			나)	Linux Ubuntu 환경에서 SD Card Reader에 SD Card를 삽입한 이후(/dev/sdb 로 인식 됨)
			다)	/iMX6_Platform_SDK/output/mx6dq/sdk_unit_test/smart_device_rev_c 폴더로 이동해서
			라)	dd if=sdk_unit_test_ALL.bin of=/dev/sdb seek=2 skip=2 bs=512 && sync 명령을 실행
			마)	SD Card를 i.MX6 Board에 삽입 이후 재부팅하면
				하기와 같은 화면이 Terminal 창으로 표시되며 어떤 명령을 실행할지 기다림
				cf)	SD Card에 기존에 저장되어 있던 프로그램은 전혀 실행되지 않고 하기 명령만 실행 됨
					기존 저장되어 있던 프로그램으로 복구하기 위해서는 상기 "4 Downloading Images" 명령을 재 실행해야 함 
				**************************************************************************
				    Platform SDK (1.1) for MX6DQ TO1.2 Smart Device (SD) rev. C
				    Build: Dec 10 2014, 11:00:04
				    Copyright (c) 2012-2013 Freescale Semiconductor, Inc. All rights reserved.
				**************************************************************************
				========== Clock frequencies ===========
				CPU: 792000 kHz
				DDR: 528000 kHz
				IPG: 66000 kHz
				Debug UART: 80000000 Hz
				========================================
				  SDK Unit Tests
				  --------------
				  e - epit test
				  g - gpt test
				  .........................................
		(2)	추가된 SDK Build & 실행
			하기 설명은 iMX6_Platform_SDK\sdk\drivers\ 폴더 내부에 있는 gpio SDK 가
			파일만 추가되어 있고 실제 sdk_unit_test에는 추가되어 있지 않던 것을 추가되게 수정하는 것을 설명하고 있음
			가)	./sdk/drivers/<new_driver>/src, ./sdk/drivers/<new_driver>/test 폴더에 추가하고 싶은 SDK 파일 추가
			나)	./sdk/drivers/Makefile 에 해당 SDK 파일 내용 추가
			다)	./apps/sdk_unit_test/Makefile 에 해당 SDK 파일 내용 추가
			라)	./apps/sdk_unit_test/src/all_test.c 에 해당 SDK 파일 내용 추가
				ex)	// add
					extern void gpio_led_test(void);
					// add
					...............................................
					// add
					DEFINE_TEST_MENU_ITEM("go", "gpio led test", gpio_led_test),
					// add
			마)	iMX6_Platform_SDK# ./tools/build_sdk -target mx6dq -board smart_device -v c -clean 명령 실행시켜서 재 Build 함
			바)	상기 (1) Default SDK Build & 실행 -> 나)~ 부터 실행시켜서 SD Card에 Build 내용 추가 시킴
			
	6)	GPIO 제어
		가)	LED 제어
			cf)	2015년 4월 1일 수요일 LED 드라이버
				환경 :
				안드로이드 : 4.4
				커널 : 3.0.35
				iMX6Q
				
				표준 인터페이스이 파일의 LED-gpio.c을 주도을 통해, 당신은 led_classdev로 등록 메시지 GPIO 단자를 넣을 수 있습니다
				CONFIG_LEDS_GPIO = Y
				CONFIG_LEDS_GPIO_PLATFORM = Y
				CONFIG_LEDS_TRIGGER = Y
				
				보드 mx6q_sabresd.c
				
				#define GPIO_LED(gpio_led, name_led, act_low, state_suspend, trigger)
				{
				 .gpio = gpio_led, \
				 .NAME = name_led, \
				 .active_low = act_low, \
				 .retain_state_suspended = state_suspend, \
				 .default_state = 0, \
				 .default_trigger = "max8903-"trigger, \
				}
				
				/ * 외부 전원에 연결되어 표시하도록 사용
				 * GPIO_LED (SABRESD_CHARGE_DONE "chg_detect", 0, 1, "ac-online"),
				 * /
				static struct gpio_led imx6q_gpio_leds [] =
				{
					GPIO_LED(SABRESD_CHARGE_NOW, "chg_now_led", 0, 1, "charger-charging"),
				
				    // LED 조명에 대한 추가
				    GPIO_LED(SABRESD_CAP_TCH_INT1, "led-gpio8", 0, 1, "led-gpio8"),
				    GPIO_LED(SABRESD_CAN1_STBY, "led-gpio4", 0, 1, "led-gpio4"),
				    GPIO_LED(LED_GPIO3, "led-gpio3", 0, 1, "led-gpio"),
				};
				
				그리고 안드로이드 시스템 :
				echo 1 > /sys/class/leds/yourname/backlights
				LED가 오프를 제어 할 수 있다
				
				그러나 등록이 방법을 사용하여, 사용할 수 없습니다 sysfs를은 (원래 내가 할 수있는 생각, 나중에는 충분하지 않습니다 시도)
			cf)	class 에 sysfs node 등록하여 사용하기
				linux kernel에서 kernel 단과 user 사이에 통신을 위한 방법 중에 sysfs node를 사용하는 방법이 있다
				지원하는 함수는 아래 3가지 함수들이 있다
				devclass_create_file
				device_create_file
				class_create_file
			cf)	sysfs  Linux/Kernel / 개발자료  2011.06.03. 15:00
				http://blog.naver.com/yyg1368/60131371835 
				
				리눅스 2.6 커널에서는 pseduo filesystem인 sysfs에 대해 소개되었습니다. sysfs 파일 시스템은 proc, devfs, devpty 파일 시스템을 하나로 
				통합한 파일 시스템으로 설명될 수 있습니다. sysfs 파일 시스템은 시스템에 연결된 장치와 버스를 하나의 파일 시스템 구조처럼 나타내어 사용자가 액세스 가능하게 합니다. 
				이 파일 시스템은 이전에 /proc/ 파일 시스템에 위치하던 장치 및 드라이버 특정 옵션을 처리하도록 개발되었으며, 이전 커널에서 devfs가 제공하던 동적인 장치 추가 기능도 제공합니다. 
				sysfs 파일 시스템은 /sys/에 마운트되어야하며, 시스템에 연결된 장치를 다양한 방법으로 제어하는 디렉토리를 포함합니다. /sysfs/ 서브 디렉토리는 devices,, bus, class, block등이 있습니다.
				
				일반적으로 User Application과 통신하는 상위 드라이버와 같은 경우 커널공간과 유저공간사이에 통신 할 필요가 있거나 일련의 정보를 제공하고자 할 때, ioctl을 이용하게 된다.
				하지만 User Application과 직접 통신을 하지 않는, 예를 들면 버스드라이버나 플랫폼 드라이버와 같은 경우는 별도의 방법이 필요하게 됩니다.
				리눅스 커널 2.6에서는 이러한 요구사항을 수용하기 위하여 ramfs에 기반하는 ram-based파일시스템은 sysfs가 소개되었습니다.
				
				이는 유저공간과 커널공간사이에 대량의 데이터를 송수신 하기 보다는 커널의 자료구조나 어트리뷰트등을 유저공간에 export하는 용도로 개발되었습니다. 
				유저공간에 정보를 제공하거나 반대로 유저공간에서 정보를 전달하기 위한 용도로 사용할 수 도 있습니다.
				우선 sysfs를 사용하기 위해서는, sysfs를 사용하도록 커널을 컴파일 하여야 하며, 이는 Kernel Configuration의 File systems > Pseudo filesystems > sysfs file system support에 있습니다. 
				sysfs를 지원하도록 컴파일 된 커널에서 다음과 같이 sysfs를 마운트 합니다. 
				-> mount -t sysfs sysfs /sys
								
				실제 구현에 필요한 몇 가지 자료구조에 대해 알아보겠습니다.
				struct attribute {
					char*name;
					mode_tmode;
				};
				attribute는 sysfs에서 정규 파일로 표현되는 부분입니다. name필드는 파일명, mode는 파일에 대한 접근권한을 의미합니다.
								
				struct device에 대응되어 사용되는 다음과 같은 자료구조가 있습니다.								
				struct device_attribute {
					struct attribute attr;
					ssize_t (*show)(struct device *dev, char *buf);
					ssize_t (*store)(struct device *dev, const char *buf);
				};
						
				여기에 show와 store, 두 개의 함수 포인터가 있는데, 각각 read와 write에 대응되며, 여기에 등록한 함수가 실제 파일에 I/O가 발생할 때, 커널이 호출해 줍니다.
				또한 이 device_attrribute는 device에 대응하는 인터페이스이므로 show와 store함수의 첫 번째 인자로 device구조체 포인터가 넘어오게 됩니다.
				attribute를 선언하는 다음과 같은 helper매크로가 있습니다.
				
				#define DEVICE_ATTR(_name, _mode, _show, _store)
				이 attribute를 등록/제거하는데, 다음과 같은 두 개의 함수가 사용됩니다.
			
				int device_create_file(struct device *, struct device_attribute *);
				void device_remove_file(struct device *, struct device_attribute *);
			
				이 외에 bus driver, device driver 등에 해당하는 인터페이스가 있는데, 이름과 타입이 다를 뿐 사용방법은 동일합니다. 
			cf)	Flow
				1)	/root/myandroid/kernel_imx/arch/arm/mach-mx6/board-mx6q_sabresd.h
					static iomux_v3_cfg_t mx6q_sabresd_pads[] = {
						......................................................................................................
						MX6Q_PAD_GPIO_2__GPIO_1_2,		/* user defined red led */
						......................................................................................................
					X:\root\myandroid\kernel_imx\arch\arm\plat-mxc\include\mach\iomux-mx6q.h
					#define  MX6Q_PAD_GPIO_2__GPIO_1_2		\
							(_MX6Q_PAD_GPIO_2__GPIO_1_2 | MUX_PAD_CTRL(NO_PAD_CTRL))


				2)	/root/myandroid/kernel_imx/arch/arm/mach-mx6/board-mx6q_sabresd.c
					가)
					//	본 SABRESD_USR_DEF_RED_LED 과 아래 SABRESD_CHARGE_NOW은 동일한 GPIO_2 포트를 가리킴
					#define SABRESD_USR_DEF_RED_LED	IMX_GPIO_NR(1, 2)			// H/W 회로도에서 GPIO_2를 가리킴, GPIO_2 -> KEY_ROW6 -> USR_DEF_RED_LED -> CHG_NW_LED_EN, IMX_GPIO_NR(1, 2)에서 1은 GPIO를(bank) 가리키고 2는 GPIO 2번을 가리킴
					#define SABRESD_CHARGE_NOW	IMX_GPIO_NR(1, 2)				// SABRESD_USR_DEF_RED_LED 이 가리키는 포트와 동일한 GPIO_2포트를 가리킴
					
					#define GPIO_LED(gpio_led, name_led, act_low, state_suspend, trigger)	\
					{									\
						.gpio			= gpio_led,				\
						.name			= name_led,				\
						.active_low		= act_low,				\
						.retain_state_suspended = state_suspend,			\
						.default_state		= 0,					\
						.default_trigger	= "max8903-"trigger,		\
					}	
					나)
					static struct gpio_led imx6q_gpio_leds[] =
					{
						GPIO_LED(SABRESD_CHARGE_NOW, "chg_now_led", 0, 1,
							"charger-charging"),
						/* For the latest B4 board, this GPIO_1 is connected to POR_B,
							which will reset the whole board if this pin's level is changed,
							so, for the latest board, we have to avoid using this pin as
							GPIO.
						GPIO_LED(SABRESD_CHARGE_DONE, "chg_done_led", 0, 1,
							"charger-full"),
						*/
					};

					static struct gpio_led_platform_data imx6q_gpio_leds_data = {
						.leds		= imx6q_gpio_leds,
						.num_leds	= ARRAY_SIZE(imx6q_gpio_leds),
					};
					
					static struct platform_device imx6q_gpio_led_device = {
						.name		= "leds-gpio",
						.id		= -1,
						.num_resources  = 0,
						.dev		= {
							.platform_data = &imx6q_gpio_leds_data,
						}
					};
					
					/* For BT_PWD_L is conflict with charger's LED trigger gpio on sabresd_revC.
					 * add mutual exclusion here to be decided which one to be used by board config
					 */
					static void __init imx6q_add_device_gpio_leds(void)
					{
						if (!uart5_enabled)
							platform_device_register(&imx6q_gpio_led_device);
					}
					
					static void __init mx6_sabresd_board_init(void)
					{
						......................................................................................................
						imx6q_add_device_gpio_leds();
						......................................................................................................
						
				3)	X:\root\myandroid\kernel_imx\drivers\leds\led-class.c
					가)
					static struct device_attribute led_class_attrs[] = {
						__ATTR(brightness, 0644, led_brightness_show, led_brightness_store),
						__ATTR(max_brightness, 0444, led_max_brightness_show, NULL),
					#ifdef CONFIG_LEDS_TRIGGERS
						__ATTR(trigger, 0644, led_trigger_show, led_trigger_store),
					#endif
						__ATTR_NULL,
					};

					static int __init leds_init(void)
					{
						leds_class = class_create(THIS_MODULE, "leds");
						if (IS_ERR(leds_class))
							return PTR_ERR(leds_class);
						leds_class->suspend = led_suspend;
						leds_class->resume = led_resume;
						leds_class->dev_attrs = led_class_attrs;
						return 0;
					}
					나)	Bootload message
						Registered led device: chg_now_led
					다)
					/**
					 * led_classdev_register - register a new object of led_classdev class.
					 * @parent: The device to register.
					 * @led_cdev: the led_classdev structure for this device.
					 */
					int led_classdev_register(struct device *parent, struct led_classdev *led_cdev)
					{
						led_cdev->dev = device_create(leds_class, parent, 0, led_cdev,
									      "%s", led_cdev->name);
						if (IS_ERR(led_cdev->dev))
							return PTR_ERR(led_cdev->dev);
					
					#ifdef CONFIG_LEDS_TRIGGERS
						init_rwsem(&led_cdev->trigger_lock);
					#endif
						/* add to the list of leds */
						down_write(&leds_list_lock);
						list_add_tail(&led_cdev->node, &leds_list);
						up_write(&leds_list_lock);
					
						if (!led_cdev->max_brightness)
							led_cdev->max_brightness = LED_FULL;
					
						led_update_brightness(led_cdev);
					
						init_timer(&led_cdev->blink_timer);
						led_cdev->blink_timer.function = led_timer_function;
						led_cdev->blink_timer.data = (unsigned long)led_cdev;
					
					#ifdef CONFIG_LEDS_TRIGGERS
						led_trigger_set_default(led_cdev);
					#endif
					
						printk(KERN_DEBUG "Registered led device: %s\n",
								led_cdev->name);
					
						return 0;
					}
					EXPORT_SYMBOL_GPL(led_classdev_register);





			A)	Android OS 부팅
			B)	cd /sys/class/leds/chg_now
			C)	echo 0 > brightness			->	D3 LED OFF(i.MX6 Board)
			D)	echo 1 > brightness			->	D3 LED ON(i.MX6 Board)
		나)	GPIO 제어
			Replying to my own question here, but I'd love to hear from someone else on this...
			I managed to get the GPIO_4 issue resolved.  Turns out that uboot was configuring
			this pin to be an input (because that's how it was used on sabresd).  As soon as I
			changed uboot, then these commands (at the unix prompt) worked..
			 
			echo 4 >/sys/class/gpio/export
			echo out >/sys/class/gpio/gpio4/direction
			echo 1 >/sys/class/gpio/gpio4/value
			echo 0 >/sys/class/gpio/gpio4/value
			 
			This makes me wonder what (if anything) is done by the first
			two lines (which supposedly configured the direction to be output)...
			Can anyone explain this?
		
	7)	input 제어
		가)	# getevent									->	지원되는 event를 모두 볼 수 있음
			130|root@sabresd_6dq:/sys/class/input # getevent
			add device 1: /dev/input/event6
			  name:     "FreescaleAccelerometer"
			add device 2: /dev/input/event5
			  name:     "eCompass"
			add device 3: /dev/input/event4
			  name:     "FreescaleMagnetometer"
			add device 4: /dev/input/event3
			  name:     "isl29023 light sensor"
			could not get driver version for /dev/input/mice, Not a typewriter
			add device 5: /dev/input/event9
			  name:     "wm8962-audio Headphone Jack"
			add device 6: /dev/input/event8
			  name:     "wm8962-audio DMIC"
			add device 7: /dev/input/event0
			  name:     "gpio-keys"
			add device 8: /dev/input/event2
			  name:     "eGalax Touch Screen"
			add device 9: /dev/input/event1
			  name:     "max11801_ts"
			could not get driver version for /dev/input/mouse0, Not a typewriter
			add device 10: /dev/input/event7
			  name:     "WM8962 Beep Generator"
			/dev/input/event6: 0003 0001 ffffff4c
			/dev/input/event6: 0003 0002 00003f70
			.....................................................
		나)	# getevent -lt /dev/input/event6			->	이벤트 type에 대한 정보 보기
			# getevent -lt /dev/input/event2			->	이벤트 type에 대한 정보 보기, LCD 창을 touch 하면 touch event 정보가 terminal 창으로 출력 됨
			# getevent -lt /dev/input/event9			->	이벤트 type에 대한 정보 보기, J2-Headphone Output Jack에 Headphone jack을 꼽으면 EV_SW SW_HEADPHONE_INSERT 정보가 terminal 창으로 출력 됨
															cf)	~/myandroid/kernel_imx/arch/arm/mach-mx6/board-mx6q_sabresd.h
																MX6Q_PAD_SD3_RST__GPIO_7_8,			/* HEADPHONE_DET */
																MX6Q_PAD_GPIO_9__GPIO_1_9,			/* MICROPHONE_DET */
																~/myandroid/kernel_imx/arch/arm/plat-mxc/include/mach/iomux-mx6q.h
																#define _MX6Q_PAD_SD3_RST__GPIO_7_8			\
																		IOMUX_PAD(0x06B8, 0x02D0, 5, 0x0000, 0, 0)
															cf)	~/myandroid/kernel_imx/arch/arm/mach-mx6/board-mx6q_sabresd.c
																#define SABRESD_HEADPHONE_DET	IMX_GPIO_NR(7, 8)
															cf)	Android app -> KeyEvent -> case KeyEvent.KEYCODE_VOLUME_UP: 항목을 추가시켜서 간단하게 "키입력"을 처리할 수 있음
			# getevent -lt /dev/input/event0			->	이벤트 type에 대한 정보 보기, KEY_VOLUMEUP/KEY_VOLUMEDOWN 을 누르면 KEY event 정보가 terminal 창으로 출력 됨
		다)	# sendevent /dev/input/event2 3 53 100		->	Nexus S의 touch event로 EV_ABS type이며 ABS_MT_POSITION_X code, 100의 value로 event를 생성하여 전달
	
	8)	OS:Windows7 ->	OS:Linux 로 파일 옮기면 한글 깨짐 현상 해결 방법
		가)	OS:Linux 탐색기에서 OS:Windows7에 있는 파일을 직접 읽어 들이면 한글 깨짐 현상이 없으며(ex, /Media/sf_C_DRIVE/~)
			이를 모두 복사 시켜서 새 파일로 저장 시킴

	9)	카메라모듈 제어
		i.MX6 Board camera
		-	J5 : Back	OV5640 5M Pixel MIPI CMOS Sensor(H/W회로도),	01-02 04:23:14.760: I/FslCameraHAL(2366): DeviceAdapter: Create ov5640 mipi device
						지원 해상도
						640x480		15/30fps
						320x240		15/30fps
						720x480		15/30fps
						720x576		15/30fps
						1280x720	15/30fps
						1024x768	15/30fps
						1920x1080	15/30fps			->	본 해상도는 i.MX6 Device driver 단에서 지원해 주지 않음(16:9 비율의 wide image 임) 
						2592x1944	15fps(only)

		-	J9 : Front	OV5642 5M Pixel CSI CMOS Sensor(H/W회로도),		01-02 04:23:30.830: I/FslCameraHAL(2366): DeviceAdapter: Create ov5640 csi device	
		
		가-1)Patch
			0217-ENGR00163559-add-camera-hal-for-ics-in-imx6q.patch
		
		
		가)	i.MX6 -> Camera 제어
			a)	myandroid\kernel_imx\arch\arm\mach-mx6\board-mx6q_sabresd.c
				static void mx6q_mipi_sensor_io_init(void)
		
		
		
		
		나)	카메라모듈 초기 레지스터 제어
			~/myandroid/kernel_imx/drivers/media/video/mxc/capture/ov5642.c
			->	static struct reg_value ov5642_initial_setting[] 

static struct ov5640_control ov5640_ctrls[] = {
+	{
+		.set = ov5640_set_agc,
+		.ctrl = {
+			.id = V4L2_CID_AUTOGAIN,
+			.name = "Auto Gain/Exposure Control",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 1,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+		},
+	}, {
+		.set = ov5640_set_exposure,
+		.ctrl = {
+			.id = V4L2_CID_EXPOSURE,
+			.name = "Exposure",
+			.minimum = 0,
+			.maximum = 65535,
+			.step = 1,
+			.default_value = 0,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	}, {
+		.set = ov5640_set_gain,
+		.ctrl = {
+			.id = V4L2_CID_GAIN,
+			.name = "Gain",
+			.minimum = 0,
+			.maximum = 1023,
+			.step = 1,
+			.default_value = 0,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	}, {
+		.set = ov5640_set_hue,
+		.ctrl = {
+			.id = V4L2_CID_HUE,
+			.name = "Hue",
+			.minimum = 0,
+			.maximum = 359,
+			.step = 1,
+			.default_value = 0,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	}, {
+		.set = ov5640_set_contrast,
+		.ctrl = {
+			.id = V4L2_CID_CONTRAST,
+			.name = "Contrast",
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+			.default_value = 0,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	}, {
+		.set = ov5640_set_saturation,
+		.ctrl = {
+			.id = V4L2_CID_SATURATION,
+			.name = "Saturation",
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+			.default_value = 64,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	}, {
+		.set = ov5640_set_awb,
+		.ctrl = {
+			.id = V4L2_CID_AUTO_WHITE_BALANCE,
+			.name = "Auto White Balance",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 1,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+		},
+	}, {
+		.set = ov5640_set_red_balance,
+		.ctrl = {
+			.id = V4L2_CID_RED_BALANCE,
+			.name = "Red Balance",
+			.minimum = 0,
+			.maximum = 4095,
+			.step = 1,
+			.default_value = 0,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	}, {
+		.set = ov5640_set_blue_balance,
+		.ctrl = {
+			.id = V4L2_CID_BLUE_BALANCE,
+			.name = "Blue Balance",
+			.minimum = 0,
+			.maximum = 4095,
+			.step = 1,
+			.default_value = 0,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+		},
+	},
+};


		다)	OV5642 register
			A)	AEC
				a)	0x3A01	AEC CTRL01				0x04	RW	Minimum Exposure Output Limit
				b)	0x3A02	AEC MAX EXPO(60Hz)		0x03	RW	Maximum Exposure Output Limit(60Hz)	Bit[7:4]: Not used, Bit[3:0]: Max expo[19:16]
				c)	0x3A03	AEC MAX EXPO(60Hz)		0xD8	RW	Maximum Exposure Output Limit(60Hz)	Bit[7:0]: Max expo[15:8]
				d)	0x3A04	AEC MAX EXPO(60Hz)		0x00	RW	Maximum Exposure Output Limit(60Hz)	Bit[7:0]: Max expo[7:0]
				e)	0x3A14	AEC MAX EXPO(50Hz)		0x03	RW	Maximum Exposure Output Limit(50Hz)	Bit[7:4]: Not used, Bit[3:0]: Max expo[19:16]
				f)	0x3A15	AEC MAX EXPO(50Hz)		0x75	RW	Maximum Exposure Output Limit(50Hz)	Bit[7:0]: Max expo[15:8]
				g)	0x3A16	AEC MAX EXPO(50Hz)		0x00	RW	Maximum Exposure Output Limit(50Hz)	Bit[7:0]: Max expo[7:0]
				
			B)	Exposure compensation step 과 관련 있는 register
				a)	0x3A0A	AEC B60 STEP			0x0C	RW	60Hz Band Width,				60Hz banding filter value 8MSB
				b)	0x3A0B	AEC B60 STEP			0x30	RW	60Hz Band Width,				60Hz banding filter value 8LSB
				c)	0x3A0D	AEC CTRL0D				0x08	RW	60Hz Max Bands in One Frame,	60Hz maximum banding step

		라)	V4L2_CID_EXPOSURE
			a)	/root/myandroid/kernel_imx/drivers/media/video/v4l2-ioctl.c
				static long __video_do_ioctl(struct file *file,
						unsigned int cmd, void *arg)
				{
					......................................................................................................
					case VIDIOC_S_CTRL:
					{
						struct v4l2_control *p = arg;
						struct v4l2_ext_controls ctrls;
						struct v4l2_ext_control ctrl;
				
						if (!vfd->ctrl_handler &&
							!ops->vidioc_s_ctrl && !ops->vidioc_s_ext_ctrls)
							break;
				
						dbgarg(cmd, "id=0x%x, value=%d\n", p->id, p->value);
				
						// temp
						printk(cmd, "id=0x%x, value=%d\n", p->id, p->value);
						// temp
				
						if (vfd->ctrl_handler) {
							ret = v4l2_s_ctrl(vfd->ctrl_handler, p);
							break;
						}
						if (ops->vidioc_s_ctrl) {
							ret = ops->vidioc_s_ctrl(file, fh, p);
							break;
						}
						if (!ops->vidioc_s_ext_ctrls)
							break;
				
						ctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);
						ctrls.count = 1;
						ctrls.controls = &ctrl;
						ctrl.id = p->id;
						ctrl.value = p->value;
						if (check_ext_ctrls(&ctrls, 1))
							ret = ops->vidioc_s_ext_ctrls(file, fh, &ctrls);
						break;
					}
					......................................................................................................

			b)	/root/myandroid/kernel_imx/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
				static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
				{
					......................................................................................................
					case V4L2_CID_EXPOSURE:
						// temp
						pr_debug("cam->sensor = %d, c->value = %d\n", cam->sensor, c->value);
						// temp
						if (cam->sensor) {
							cam->ae_mode = c->value;
							ret = vidioc_int_s_ctrl(cam->sensor, c);
							// temp
							pr_debug("if (cam->sensor) == true\n");
							// temp
						} else {
							pr_err("ERROR: v4l2 capture: slave not found!\n");
							ret = -ENODEV;
						}
						break;
					......................................................................................................
			c)	/root/myandroid/kernel_imx/drivers/media/video/mxc/capture/ov5640_mipi.c
				static int ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
				{
					......................................................................................................
					case V4L2_CID_EXPOSURE:
						vc->value = ov5640_data.ae_mode;
						break;
					......................................................................................................
				static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
				{
					......................................................................................................
					case V4L2_CID_EXPOSURE:
						break;
					......................................................................................................




		마)	Booting
			/root/myandroid/kernel_imx/drivers/media/video/mxc/out/mxc_vout.c
			static int __init mxc_vout_setup_output(struct mxc_vout_dev *dev)
			{
				struct videobuf_queue *q;
				struct fb_info *fbi;
				struct mxc_vout_output *vout;
				int i, ret = 0;
			
				update_display_setting();
			
				/* all output/overlay based on fb */
				for (i = 0; i < num_registered_fb; i++) {
					fbi = registered_fb[i];
			
					vout = kzalloc(sizeof(struct mxc_vout_output), GFP_KERNEL);
					if (!vout) {
						ret = -ENOMEM;
						break;
					}
			
					dev->out[dev->out_num] = vout;
					dev->out_num++;
			
					vout->fbi = fbi;
					vout->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
					vout->vfd = video_device_alloc();
					if (!vout->vfd) {
						ret = -ENOMEM;
						break;
					}
			
					*vout->vfd = mxc_vout_template;
					vout->vfd->debug = debug;
					vout->vfd->v4l2_dev = &dev->v4l2_dev;
					vout->vfd->lock = &vout->mutex;
			
					mutex_init(&vout->mutex);
					mutex_init(&vout->task_lock);
			
					strlcpy(vout->vfd->name, fbi->fix.id, sizeof(vout->vfd->name));
			
					video_set_drvdata(vout->vfd, vout);
			
					if (video_register_device(vout->vfd,
						VFL_TYPE_GRABBER, video_nr + i) < 0) {
						ret = -ENODEV;
						break;
					}
			
					q = &vout->vbq;
					q->dev = dev->dev;
					spin_lock_init(&vout->vbq_lock);
					videobuf_queue_dma_contig_init(q, &mxc_vout_vbq_ops, q->dev,
							&vout->vbq_lock, vout->type, V4L2_FIELD_NONE,
							sizeof(struct videobuf_buffer), vout, NULL);
			
					v4l2_info(vout->vfd->v4l2_dev, "V4L2 device registered as %s\n",
							video_device_node_name(vout->vfd));
			
				}
			
				return ret;
			}

		바)	Test Digital Zoom of Camera Preview
			2012. 11. 23 오전 2:21에 Weiping Liu 님이 만들고 2013. 5. 20 오후 12:10에 Jodi Paul 님이 마지막으로 수정 버전 7
			Test digital zoom with ipu for camera preview.
			 
			Board :sarbre-sd (imx6dq)
			BSP   : android 13.4ga
			flow1.png
			In the above flow, one frame buffer is processed in four steps at camera preview.
			Add the step to change the frame buffer before step 4 , the added step which  zoom one preview frame.
			 
			The figure below shows the crop function of ipu lib, we use this function scale the frame.

		사)	안드로이드 sec
http://furmuwon.egloos.com/11069777
frameworks/base/services/camera/libcameraservice 의

CameraService::onFirstRef()
		#define CAMERA_HARDWARE_MODULE_ID "camera"
	-> hw_get_module(CAMERA_HARDWARE_MODULE_ID,(const hw_module_t **)&mModule) 로 mModule(첨부#1) 에
		-> hw_get_module
			-> hw_get_module_by_class 에서 내가 잘 알고 있듯이 camera.XXXX.so 로 얻어온다.
	-> mModule->get_number_of_cameras로 mNumberOfCameras 변수 값을 채운다. mModule->get_number_of_cameras 에 HAL_getNumberOfCameras가 연결 되어 있다.
		-> HAL_getNumberOfCameras 함수는... SecCameraHWInterface.cpp 에서 static CameraInfo sCameraInfo[] 선언 된거 개수로..
	-> mNumberOfCameras 값에 2가 들어 가겠지.. 보통 ( Back , Front.. )
	-> 끝....

CameraService::connect
	-> 예외처리들...  sys.secpolicy.camera.disabled가 1 이면 리턴...
	-> mClient[cameraId] 가 있는지 보고...
	-> mBusy[cameraId] 로 사용중인지도 보고...
	-> 예외처리가 끝 났으면 char camera_device_name[10] 에 문자열로 cameraID (아마도 0 ) "0" 이라는 문자열을 만들고
	-> hardware = new CameraHardwareInterface(camera_device_name); 호출 한다.
		-> CameraHardwareInterface.mDevice = 0;
		-> CameraHardwareInterface.mName = camera_device_name("0");
	-> CameraHardwareInterface->initialize 수행. 매개변수로 struct hw_module_t 넘어 간다. 이것은 안드로이드 대표적인 구조체로 hw에 대한 정보(첨부#1 참고)
		-> module->methods->open 수행. HAL_camera_device_open가 수행된다 (첨부#1 참고)
			-> HAL_camera_device_open
			-> 예외처리... g_cam_device가 없으면 g_cam_device mem alloc (첨부#2 참고)한다.
			-> g_cam_device->common 의 멤버변수들에 값 잘 채워 넣어 주고...
			-> g_cam_device->ops 에 camera_device_ops(첨부#3 참고)연결
			-> g_cam_device->priv = new CameraHardwareSec(cameraId, g_cam_device); 수행. CameraHardwareSec class 생성.
				-> CameraHardwareSec class 생성
				-> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				-> CameraHardwareSec->mSecCamera 실글톤.. mSecCamera 생성자...
					-> mSecCamera class 생성 많은 값을 가짐 ㅜㅜ
					-> !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				-> CameraHardwareSec->mGrallocHal hw 모듈 로드.. gralloc hal...
				-> mSecCamera->initCamera(cameraId); ( cameraID 0 일것이다.. )
					-> mSecCamera.m_cam_fd = open(CAMERA_DEV_NAME, O_RDWR); #define CAMERA_DEV_NAME   "/dev/video0" v4l2 open ( 드디어!! ㅜㅜ )
					-> fimc_v4l2_querycap 호출
						-> struct v4l2_capability cap; ioctl(fp, VIDIOC_QUERYCAP, &cap);
					-> fimc_v4l2_enuminput 호출. input.name 이 필표한듯
						-> struct v4l2_input input; ioctl(fp, VIDIOC_ENUMINPUT, &input);
					-> fimc_v4l2_s_input 호출. 읽어만 오고 아무것도 안함?;;;
						-> struct v4l2_input input; ioctl(fp, VIDIOC_S_INPUT, &input);
					-> m_cam_fd2 ( fimc2 를 open 함 )"/dev/video2"
					-> fimc_v4l2_querycap(m_cam_fd2); fimc_v4l2_enuminput(m_cam_fd2, index); fimc_v4l2_s_input(m_cam_fd2, index)
					-> m_camera_id = index; (아마 index 는 BACK 아니면 front 를 가정 하는듯 값은 0 )
					-> m_preview_max_width, m_preview_max_height, m_snapshot_max_width, m_snapshot_max_height 이렇게 값을 정하는 DEFINE 으로 되어 있음 나중에 바꿔줘야됨.
					-> setExifFixedAttribute 함수 수행
						-> property_get 으로 EXIF 정보? 같은걸 얻어옴...
					-> m_flag_init = 1 수행 완료.
				-> mSecCamera->getPostViewConfig(&mPostViewWidth, &mPostViewHeight, &mPostViewSize); 수행. mPostViewWidth,mPostViewHeight,mPostViewSize 삼형제 값 설정
				-> initDefaultParameters(cameraId) 함수 수행
					-> text 문자열로 parameter 정해서.. 뭘하지?
					-> 뭘 많이함...
					-> mCameraSensorName = mSecCamera->getCameraSensorName(); 를 통하여 SensorName 을 가지고 온다. 이는 kernel 에서 I2C bus type(Name) 을 가지고 오게 된다.
					-> CameraParameters p, ip 를 하는데 CameraParameters class 는 문자열을 저장하고.. ..
					-> p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES, "720x480,640x480,352x288,176x144");
						-> "preview-size-values" = "720x480,640x480,352x288,176x144" 이런형식으로 저장하는듯 (#첨부4 참고)
					-> "picture-size-values" = "640x480"
					-> "video-size-values" = "720x480,640x480,176x144"
					-> p.getSupportedPreviewSizes(mSupportedPreviewSizes) 통해
						-> mSupportedPreviewSizes 는 Size class 의 Vector 이다. Size class 는 width, height 값을 가지는 class 로써
						-> mSupportedPreviewSizes vector 에 위에서 KEY_SUPPORTED_PREVIEW_SIZES "preview-size-values" = "720x480,640x480,352x288,176x144" 를 파싱 하여 Size class 를 구성한다.
						-> mSupportedPreviewSizes[0] = width= 720, height=480
						-> mSupportedPreviewSizes[1] = width= 640, height=480
						-> mSupportedPreviewSizes[2] = width= 352, height=288
						-> mSupportedPreviewSizes[3] = width= 176, height=144
						-> 같은 형식으로...
					-> mSecCamera->getPreviewMaxSize(&preview_max_width, &preview_max_height) 를 통해 define 된 max width 와 height 를 가지고 온다.(m_preview_max_width, m_preview_max_height)
					-> mSecCamera->getSnapshotMaxSize(&snapshot_max_width, &snapshot_max_height) 위와 동일,
					-> previewColorString 문자열에 "yuv420sp,yuv420p" 꾸민 뒤
					-> p.setPreviewFormat -> set(KEY_PREVIEW_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420SP); 하여 "preview-format"="yuv420sp" 로 한다
					-> p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, previewColorString.string()); " preview-format-values"="yuv420sp,yuv420p"
					-> p.set(CameraParameters::KEY_VIDEO_FRAME_FORMAT, CameraParameters::PIXEL_FORMAT_YUV420P); "video-frame-format"="yuv420sp"
					-> p.setPreviewSize(preview_max_width, preview_max_height); "preview-size"="%d,%d"(m_preview_max_width,m_preview_max_height)
					-> p.setPictureFormat(CameraParameters::PIXEL_FORMAT_JPEG); "picture-format"="jpeg"
					-> p.setPictureSize(snapshot_max_width, snapshot_max_height); "picture-size"="%d.%d"(snapshot_max_width, snapshot_max_height)
					-> p.set(CameraParameters::KEY_JPEG_QUALITY, "100"); "jpeg-quality"="100"
					-> p.set(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS, CameraParameters::PIXEL_FORMAT_JPEG); "picture-format-values"="jpeg"
					-> p.set(CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, "720x480"); "preferred-preview-size-for-video"="720x480"
					-> parameterString만든뒤 "auto,infinity,macro"
					-> p.set(CameraParameters::KEY_SUPPORTED_FOCUS_MODES,parameterString.string());"focus-mode-values"="auto,infinity,macro"
					-> p.set(CameraParameters::KEY_FOCUS_MODE, CameraParameters::FOCUS_MODE_AUTO); "focus-mode"="auto"
					-> p.set(CameraParameters::KEY_FOCUS_DISTANCES,BACK_CAMERA_AUTO_FOCUS_DISTANCES_STR); "focus-distances"="0.10,1.20,Infinity"
					-> p.set(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, "320x240,0x0"); "jpeg-thumbnail-size-values"="320x240,0x0"
					-> p.set(CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH, "320");  "jpeg-thumbnail-width"="320"
						-> p.set(CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT, "240"); "jpeg-thumbnail-height"="240"
						-> p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES, "30"); "preview-frame-rate-values"="30"
						-> p.setPreviewFrameRate(30); set(KEY_PREVIEW_FRAME_RATE, fps); "preview-frame-rate"="30"
						-> parameterString에 "none,mono,negative,sepia"
						-> p.set(CameraParameters::KEY_SUPPORTED_EFFECTS, parameterString.string()); "effect-values"="none,mono,negative,sepia"
						-> parameterString에 "on,off,auto,torch"
						-> p.set(CameraParameters::KEY_SUPPORTED_FLASH_MODES, parameterString.string()); "flash-mode-values"="on,off,auto,torch"
						-> p.set(CameraParameters::KEY_FLASH_MODE, CameraParameters::FLASH_MODE_OFF); "flash-mode"="off"
						-> parameterString에 "auto,portrait,landscape,night,beach,sunset,fireworks,sports,party,candlelight"
						-> p.set(CameraParameters::KEY_SUPPORTED_SCENE_MODES, parameterString.string()); "scene-mode-values"="auto,portrait,landscape,night,beach,sunset,fireworks,sports,party,candlelight"
						-> p.set(CameraParameters::KEY_SCENE_MODE, CameraParameters::SCENE_MODE_AUTO); "scene-mode"="auto"
					-> p.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE, "(15000,30000)"); "preview-fps-range-values"="(15000,30000)"
					-> p.set(CameraParameters::KEY_PREVIEW_FPS_RANGE, "15000,30000"); "preview-fps-range"="15000,30000"
					-> p.set(CameraParameters::KEY_FOCAL_LENGTH, "3.43"); "focal-length"="3.43"
					-> parameterString에 "auto,incandescent,fluorescent,daylight,cloudy-daylight"
						-> p.set(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE, parameterString.string()); "whitebalance-values"="auto,incandescent,fluorescent,daylight,cloudy-daylight"
						-> ip.set("sharpness-min", 0);
						-> ip.set("sharpness-max", 4);
						-> ip.set("saturation-min", 0);
						-> ip.set("saturation-max", 4);
						-> ip.set("contrast-min", 0);
						-> ip.set("contrast-max", 4);
						-> p.set(CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY, "100"); "jpeg-thumbnail-quality"="100"
					-> p.set(CameraParameters::KEY_ROTATION, 0); "rotation"="0"
					-> p.set(CameraParameters::KEY_WHITE_BALANCE, CameraParameters::WHITE_BALANCE_AUTO); "whitebalance"="auto"
					-> p.set(CameraParameters::KEY_EFFECT, CameraParameters::EFFECT_NONE); "effect"="none"
					-> ip.set("sharpness", SHARPNESS_DEFAULT); 2
					-> ip.set("contrast", CONTRAST_DEFAULT); 2
					-> ip.set("saturation", SATURATION_DEFAULT); 2
					-> ip.set("iso", "auto");
					-> ip.set("metering", "center");
					-> ip.set("wdr", 0);
					-> ip.set("chk_dataline", 0);
					-> p.set(CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE, "51.2"); "horizontal-view-angle"="51.2"
					-> p.set(CameraParameters::KEY_VERTICAL_VIEW_ANGLE, "39.4"); "vertical-view-angle"="39.4"
					-> p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION, "0"); "exposure-compensation"="0"
					-> p.set(CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION, "4"); "max-exposure-compensation"="4"
					-> p.set(CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION, "-4"); "min-exposure-compensation"="-4"
					-> p.set(CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP, "0.5"); "exposure-compensation-step"="0.5"
					-> mParameters = p;               CameraHardwareSec class 의 mParameters 멤버 변수에 저장
					-> mInternalParameters = ip;      CameraHardwareSec class 의 mInternalParameters 멤버 변수에 저장
						-> setParameters(p); 호출
							-> status_t CameraHardwareSec::setParameters(const CameraParameters& params)
							-> waitCaptureCompletion() 함수로 지금 캡쳐 중인지? 확인.
						-> params.getPreviewSize(&new_preview_width, &new_preview_height); 로 "preview-size" 가져 온다. 위의 파싱값 참고
						-> const char *new_str_preview_format = params.getPreviewFormat(); new_str_preview_format에 포맷 가져오고 " "preview-format"="yuv420sp"
							-> mSecCamera->getPreviewSize(&current_preview_width, &current_preview_height, &current_frame_size); 로 width,height ,frame_size 구해온다.
								-> m_preview_width, m_preview_height 값과 m_frameSize함수를 이용해 1 frame(한 화면) size를 구해 간다. 근데 현재 m_preview_v4lformat는 V4L2_PIX_FMT_NV21일듯..
							-> int current_pixel_format = mSecCamera->getPreviewPixelFormat(); 로 현재 m_preview_v4lformat 구해 오고 V4L2_PIX_FMT_NV21일듯..
							-> mSecCamera->setPreviewSize(new_preview_width, new_preview_height, new_preview_format) 로 (new_preview_format = V4L2_PIX_FMT_YUV420;)
								-> mSecCamera.preview_width  = width, mSecCamera.m_preview_height = height, mSecCamera.m_preview_v4lformat = v4lpixelformat 설정
							-> mPreviewWindow 가 있다면... (현재 없다.. )
							-> mParameters.setPreviewSize(new_preview_width, new_preview_height); /* 상동 */
								-> mParameters.setPreviewFormat(new_str_preview_format);  /* 상동 */ "preview-format"="yuv420sp"
								-> params.getPictureSize(&new_picture_width, &new_picture_height);
								-> ........ 이 외에 엄청 많다. 스냅샷 JPEG 및 기타 등등등 설정 한다. 나중에 살펴보자
							-> mSecCamera->setISO(ISO_AUTO);
								-> SecCamera.m_params->iso = iso_value 저장하고.
								-> m_flag_camera_start 가 1 이면
								-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_ISO, iso_value)
					-> mSecCamera->setMetering(METERING_CENTER);
						-> m_params->metering = metering_value;
						-> m_flag_camera_start 가 1 이면
						-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_METERING, metering_value)
					-> mSecCamera->setContrast(CONTRAST_DEFAULT);
						-> m_params->contrast = contrast_value;
						-> m_flag_camera_start 가 1 이면
						-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_CONTRAST, contrast_value)
					-> mSecCamera->setSharpness(SHARPNESS_DEFAULT);
						-> m_params->sharpness = sharpness_value;
						-> m_flag_camera_start 가 1 이면
						-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_SHARPNESS, sharpness_value)
					-> mSecCamera->setSaturation(SATURATION_DEFAULT);
						-> m_params->saturation = saturation_value;
						-> m_flag_camera_start 가 1 이면
						-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_SATURATION, saturation_value)
					-> mSecCamera->setFrameRate(30);
							-> m_params->capture.timeperframe.denominator = frame_rate;
							-> m_flag_camera_start 가 1 이면
							-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_FRAME_RATE, frame_rate)
					-> initDefaultParameters 끝.
					-> mExitAutoFocusThread = false;
					-> mExitPreviewThread = false;
					-> mPreviewRunning = false;
					-> mPreviewStartDeferred = false;
				-> mPreviewThread = new PreviewThread(this);
					-> PreviewThread.mHardware = this(CameraHardwareSec)
				-> mAutoFocusThread = new AutoFocusThread(this);
					-> AutoFocusThread.mHardware = this(CameraHardwareSec)
				-> mPictureThread = new PictureThread(this);
					-> PictureThread.mHardware = this(CameraHardwareSec)
				-> CameraHardwareSec::CaeraHardwareSec(int cameraId, camera_device_t *dev) 끝.
			-> g_cam_device->priv = 위에서 생성한 CameraHardwareSec class
			-> HAL_camera_device_open 끝
		-> initHalPreviewWindow(CameraHardwareInterface.initHalPreviewWindow) 수행
			-> initHalPreviewWindow
			-> mHalPreviewWindow 구조체에 함수 포인터들 연결(struct camera_preview_window mHalPreviewWindow;) (#첨부5 참고)
	-> CameraHardwareInterface->mDevice 는 g_cam_device를 가짐.
	-> client = new Client(this, cameraClient, hardware, cameraId, info.facing, callingPid); Client 도 생성하고
		-> Client 생성하는데... 여기도 많네..
		-> Client 생성자에서.. 멤버변수들 초기화 하고
		-> mHardware->setCallbacks(notifyCallback, dataCallback, dataCallbackTimestamp, (void *)cameraId); 하는데.
		-> CameraHardwareInterface->setCallbacks mDevice->ops->set_callbacks 를 호출함.
			-> HAL_camera_device_set_callbacks (첨부#3 참고)
			-> obj(dev)->setCallbacks 를 호출 하는데
			-> CameraHardwareSec->setCallbacks 를 호출함.
				-> CameraHardwareSec::setCallbacks 결국에는 여기.
				-> CameraHardwareSec class 의 멤버변수 mNotifyCb, mDataCb, mDataCbTimestamp, mGetMemoryCb, mCallbackCookie에 값을 채움
	-> mClient[cameraId] = client; 생성된 client 넣어 준다.

CameraService::Client::setPreviewDisplay(const sp<Surface>& surface)
	-> sp<IBinder> binder(surface != 0 ? surface->asBinder() : 0);
	-> sp<ANativeWindow> window(surface);
	-> CameraService::Client::setPreviewWindow(binder, windows)
		-> native_window_api_connect(window.get(), NATIVE_WINDOW_API_CAMERA);
		-> disconnectWindow(mPreviewWindow);
			-> mSurface = binder;
			-> mPreviewWindow = window;

CameraService::Client::startPreview()
	-> startCameraMode(CAMERA_PREVIEW_MODE);
		-> CameraService::Client::startCameraMode(camera_mode mode)
			-> startPreviewMode();
				-> native_window_set_scaling_mode(mPreviewWindow.get(), NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
				-> native_window_set_buffers_transform(mPreviewWindow.get(), mOrientation);)
				-> mHardware->setPreviewWindow(mPreviewWindow); (CameraHardwareInterface->setPreviewWindow)
					-> mPreviewWindow = buf; mHalPreviewWindow.user = this;
					-> mDevice->ops->set_preview_window(mDevice, buf.get() ? &mHalPreviewWindow.nw : 0);
						-> HAL_camera_device_set_preview_window(struct camera_device *dev, struct preview_stream_ops *buf)
							-> CameraHardwareSec::setPreviewWindow(preview_stream_ops *w)
								-> mPreviewWindow = w; 여기서는 CameraHardwareInterface.mHalPreviewWindow(struct camera_preview_window mHalPreviewWindow)를 가르킨다.
								-> w 조사. get_min_undequeued_buffer_count. min_bufs >= kBufferCount (9)
								-> w->set_buffer_count(w, kBufferCount) 9로 설정...
								->
					-> mHardware->startPreview();
						-> HAL_camera_device_start_preview
							-> CameraHardwareSec::startPreview()
								-> waitCaptureCompletion 로 캡쳐 중인지 조사.. mCaptureInProgress 변수
								-> mPreviewRunning = true;
								-> mPreviewStartDeferred = false; , mPreviewWindow 가 없는지 체크.
								-> startPreviewInternal() 호출
									-> CameraHardwareSec::startPreviewInternal()
									-> mSecCamera->startPreview();
										-> SecCamera::startPreview(void)
										-> m_flag_camera_start함수로 이미 시작 됐는지 검사.
										-> m_cam_fd 로 file open 됐는지 검사. (/dev/video0)
										-> m_events_c pollfd 로 user 에서 대기 할 수 있는... 거 초기화
										-> fimc_v4l2_enum_fmt(m_cam_fd,m_preview_v4lformat); (m_preview_v4lformat의 format 을 video device 가 지원하는지 문의 한다.)
											-> static int fimc_v4l2_enum_fmt(int fp, unsigned int fmt)
											-> v4l2_fmtdesc 를 하나 선언 하여.     fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; fmtdesc.index = 0; 설정 후
											-> ioctl(fp, VIDIOC_ENUM_FMT, &fmtdesc) 수행하는데 fmtdesc.index 를 계속 반복 시킨다. 같은 것을 찾을 때까지.
											-> video deivce 에 m_preview_v4lformat 와 동일 포맷이 있는지 지원하는지 문의 하는 것이다.
											-> 들어온 매개변수 fmt=m_preview_v4lformat 은 V4L2_PIX_FMT_NV21,V4L2_PIX_FMT_YUV420 일 것이다.
											-> 그럼 지원 하는 video device는 자체 index를 바꿔가며 V4L2_PIX_FMT_NV21,V4L2_PIX_FMT_YUV420에 대한 v4l2_fmtdesc를 복사해 온다.
											-> 있다면 그걸로 끝.
										-> fimc_v4l2_s_fmt(m_cam_fd, m_preview_width,m_preview_height,m_preview_v4lformat, 0); width , height 내가 정한것...
											-> fimc_v4l2_s_fmt(int fp, int width, int height, unsigned int fmt, int flag_capture)
											-> struct v4l2_format v4l2_fmt; v4l2_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
											-> struct v4l2_pix_format pixfmt; pixfmt.width = width; pixfmt.height = height; pixfmt.pixelformat = fmt;
											-> pixfmt.sizeimage = (width * height * get_pixel_depth(fmt)) / 8; 로 frame size 구하고
											-> pixfmt.field = V4L2_FIELD_NONE; v4l2_fmt.fmt.pix = pixfmt;
											-> ioctl(fp, VIDIOC_S_FMT, &v4l2_fmt); width, height는 video 에 설정하고? 혹은 질의 하고? 끝. 원래는 설정하는 것 같은데.
										-> fimc_v4l2_reqbufs(m_cam_fd, V4L2_BUF_TYPE_VIDEO_CAPTURE, MAX_BUFFERS);
											-> fimc_v4l2_reqbufs(int fp, enum v4l2_buf_type type, int nr_bufs)
											-> struct v4l2_requestbuffers req;
											-> req.count = nr_bufs; req.type = type; req.memory = V4L2_MEMORY_MMAP;
											-> ioctl(fp, VIDIOC_REQBUFS, &req); 버퍼를 할당 요청 해 놓는다. width * height * pixelformat * 9
										-> fimc_v4l2_s_ctrl(m_cam_fd, V4L2_CID_CAMERA_CHECK_DATALINE, m_chk_dataline);
											-> fimc_v4l2_s_ctrl(int fp, unsigned int id, unsigned int value)
											-> struct v4l2_control ctrl; ctrl.id = id; ctrl.value = value;
											-> ioctl(fp, VIDIOC_S_CTRL, &ctrl);
											-> V4L2_CID_CAMERA_CHECK_DATALINE 명령어를 가지고 가는데 일단 현재 시스템에서는 아무런 기능이 없다.
										-> 0부터 MAX_BUFFERS(9) 까지 반복하면서 fimc_v4l2_qbuf(m_cam_fd, i)를 호출한다.
										-> fimc_v4l2_qbuf(m_cam_fd, i)
											-> static int fimc_v4l2_qbuf(int fp, int index)
											-> struct v4l2_buffer v4l2_buf;
											-> v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; v4l2_buf.memory = V4L2_MEMORY_MMAP; v4l2_buf.index = index;
											-> ioctl(fp, VIDIOC_QBUF, &v4l2_buf); 현재 index buf를 사용하겠다는 의미?
										-> fimc_v4l2_streamon(m_cam_fd); 호출
											-> fimc_v4l2_streamon(int fp)
											-> enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
											-> ioctl(fp, VIDIOC_STREAMON, &type);
										-> m_flag_camera_start = 1; 로 세팅
										-> fimc_v4l2_s_parm(m_cam_fd, &m_streamparm); 호출
											-> streamparm->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
											-> ioctl(fp, VIDIOC_S_PARM, streamparm);
											-> streamparm는 첨부5와 같은 구조체이다. v4l2_streamparm구조체 멤버변수 raw_data는 다음과 같이
											-> 초기에 raw_data 주소를  m_params = (struct sec_cam_parm*)&m_streamparm.parm.raw_data;
											-> m_params를 넘긴다.  struct sec_cam_parm   *m_params; 도 첨부5와 같은 구조체 인데
											-> v4l2_streamparm의 union struct v4l2_captureparm capture; 와 raw_data는 같은 주소를 가진다.
											-> struct sec_cam_parm 의 첫번째 멤버변수 struct v4l2_captureparm capture와 같은 곳을 가르킬 수 있다.
										-> fimc_poll(&m_events_c);
											-> ret = poll(events, 1, 10000); 10초 대기
												-> 사전에 이렇게 코딩 되어 있었다.
												-> memset(&m_events_c, 0, sizeof(m_events_c));
	   											-> m_events_c.fd = m_cam_fd;
												-> m_events_c.events = POLLIN | POLLERR;
											-> 일단, 10초가 지났든 wait 가 풀렸든 다음 코드가 실행 되고
											-> ret 값을 보고 판단 한다. 0보다 크면 wait 가 풀렸다고 보면 된다., 0 이면 타임아웃, 0보다 작으면 에러가 있다..
	}

-----------첨부 1--------------------------------------------------
typedef struct camera_module {
	hw_module_t common;
	int (*get_number_of_cameras)(void);
	int (*get_camera_info)(int camera_id, struct camera_info *info);
} camera_module_t;

위에 구조체와 1:1 매칭 이룬다. 아래와. SecCameraHWInterface.cpp

	struct camera_module HAL_MODULE_INFO_SYM = {
	 common : {
		 tag           : HARDWARE_MODULE_TAG,
		 version_major : 1,
		 version_minor : 0,
		 id            : CAMERA_HARDWARE_MODULE_ID,
		 name          : "SMDKC110/SMDKV210 camera HAL",
		 author        : "Samsung Corporation",
		 methods       : &camera_module_methods,
	 },
	 get_number_of_cameras : HAL_getNumberOfCameras,
	 get_camera_info       : HAL_getCameraInfo
	};

static hw_module_methods_t camera_module_methods = {
			open : HAL_camera_device_open
};

-----------첨부 1--------------------------------------------------
-----------첨부 2--------------------------------------------------
typedef struct camera_device {
	hw_device_t common;
	camera_device_ops_t *ops;
	void *priv;
} camera_device_t;
-----------첨부 2--------------------------------------------------

-----------첨부 3--------------------------------------------------
#define HAL_camera_device_(m) m : HAL_camera_device_##m

static camera_device_ops_t camera_device_ops = {
		SET_METHOD(set_preview_window),
		SET_METHOD(set_callbacks),
		SET_METHOD(enable_msg_type),
		SET_METHOD(disable_msg_type),
		SET_METHOD(msg_type_enabled),
		SET_METHOD(start_preview),
		SET_METHOD(stop_preview),
		SET_METHOD(preview_enabled),
		SET_METHOD(store_meta_data_in_buffers),
		SET_METHOD(start_recording),
		SET_METHOD(stop_recording),
		SET_METHOD(recording_enabled),
		SET_METHOD(release_recording_frame),
		SET_METHOD(auto_focus),
		SET_METHOD(cancel_auto_focus),
		SET_METHOD(take_picture),
		SET_METHOD(cancel_picture),
		SET_METHOD(set_parameters),
		SET_METHOD(get_parameters),
		SET_METHOD(put_parameters),
		SET_METHOD(send_command),
		SET_METHOD(release),
		SET_METHOD(dump),
};

	파싱하면 아래와 같이 됨.

		HAL_camera_device_set_preview_window,
		HAL_camera_device_set_callbacks,
		HAL_camera_device_enable_msg_type,
		HAL_camera_device_disable_msg_type,
		HAL_camera_device_msg_type_enabled,
		HAL_camera_device_start_preview,
		HAL_camera_device_stop_preview,
		HAL_camera_device_preview_enabled,
		HAL_camera_device_store_meta_data_in_buffers,
		HAL_camera_device_start_recording,
		HAL_camera_device_stop_recording,
		HAL_camera_device_recording_enabled,
		HAL_camera_device_release_recording_frame,
		HAL_camera_device_auto_focus,
		HAL_camera_device_cancel_auto_focus,
		HAL_camera_device_take_picture,
		HAL_camera_device_cancel_picture,
		HAL_camera_device_set_parameters,
		HAL_camera_device_get_parameters,
		HAL_camera_device_put_parameters,
		HAL_camera_device_send_command,
		HAL_camera_device_release,
		HAL_camera_device_dump,
-----------첨부 3--------------------------------------------------

-----------첨부 4--------------------------------------------------
const char CameraParameters::KEY_PREVIEW_SIZE[] = "preview-size";
const char CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES[] = "preview-size-values";
const char CameraParameters::KEY_PREVIEW_FORMAT[] = "preview-format";
const char CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS[] = "preview-format-values";
const char CameraParameters::KEY_PREVIEW_FRAME_RATE[] = "preview-frame-rate";
const char CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES[] = "preview-frame-rate-values";
const char CameraParameters::KEY_PREVIEW_FPS_RANGE[] = "preview-fps-range";
const char CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE[] = "preview-fps-range-values";
const char CameraParameters::KEY_PICTURE_SIZE[] = "picture-size";
const char CameraParameters::KEY_SUPPORTED_PICTURE_SIZES[] = "picture-size-values";
const char CameraParameters::KEY_PICTURE_FORMAT[] = "picture-format";
const char CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS[] = "picture-format-values";
const char CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH[] = "jpeg-thumbnail-width";
const char CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT[] = "jpeg-thumbnail-height";
const char CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES[] = "jpeg-thumbnail-size-values";
const char CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY[] = "jpeg-thumbnail-quality";
const char CameraParameters::KEY_JPEG_QUALITY[] = "jpeg-quality";
const char CameraParameters::KEY_ROTATION[] = "rotation";
const char CameraParameters::KEY_GPS_LATITUDE[] = "gps-latitude";
const char CameraParameters::KEY_GPS_LONGITUDE[] = "gps-longitude";
const char CameraParameters::KEY_GPS_ALTITUDE[] = "gps-altitude";
const char CameraParameters::KEY_GPS_TIMESTAMP[] = "gps-timestamp";
const char CameraParameters::KEY_GPS_PROCESSING_METHOD[] = "gps-processing-method";
const char CameraParameters::KEY_WHITE_BALANCE[] = "whitebalance";
const char CameraParameters::KEY_SUPPORTED_WHITE_BALANCE[] = "whitebalance-values";
const char CameraParameters::KEY_EFFECT[] = "effect";
const char CameraParameters::KEY_SUPPORTED_EFFECTS[] = "effect-values";
const char CameraParameters::KEY_ANTIBANDING[] = "antibanding";
const char CameraParameters::KEY_SUPPORTED_ANTIBANDING[] = "antibanding-values";
const char CameraParameters::KEY_SCENE_MODE[] = "scene-mode";
const char CameraParameters::KEY_SUPPORTED_SCENE_MODES[] = "scene-mode-values";
const char CameraParameters::KEY_FLASH_MODE[] = "flash-mode";
const char CameraParameters::KEY_SUPPORTED_FLASH_MODES[] = "flash-mode-values";
const char CameraParameters::KEY_FOCUS_MODE[] = "focus-mode";
const char CameraParameters::KEY_SUPPORTED_FOCUS_MODES[] = "focus-mode-values";
const char CameraParameters::KEY_MAX_NUM_FOCUS_AREAS[] = "max-num-focus-areas";
const char CameraParameters::KEY_FOCUS_AREAS[] = "focus-areas";
const char CameraParameters::KEY_FOCAL_LENGTH[] = "focal-length";
const char CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE[] = "horizontal-view-angle";
const char CameraParameters::KEY_VERTICAL_VIEW_ANGLE[] = "vertical-view-angle";
const char CameraParameters::KEY_EXPOSURE_COMPENSATION[] = "exposure-compensation";
const char CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION[] = "max-exposure-compensation";
const char CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION[] = "min-exposure-compensation";
const char CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP[] = "exposure-compensation-step";
const char CameraParameters::KEY_AUTO_EXPOSURE_LOCK[] = "auto-exposure-lock";
const char CameraParameters::KEY_AUTO_EXPOSURE_LOCK_SUPPORTED[] = "auto-exposure-lock-supported";
const char CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK[] = "auto-whitebalance-lock";
const char CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED[] = "auto-whitebalance-lock-supported";
const char CameraParameters::KEY_MAX_NUM_METERING_AREAS[] = "max-num-metering-areas";
const char CameraParameters::KEY_METERING_AREAS[] = "metering-areas";
const char CameraParameters::KEY_ZOOM[] = "zoom";
const char CameraParameters::KEY_MAX_ZOOM[] = "max-zoom";
const char CameraParameters::KEY_ZOOM_RATIOS[] = "zoom-ratios";
const char CameraParameters::KEY_ZOOM_SUPPORTED[] = "zoom-supported";
const char CameraParameters::KEY_SMOOTH_ZOOM_SUPPORTED[] = "smooth-zoom-supported";
const char CameraParameters::KEY_FOCUS_DISTANCES[] = "focus-distances";
const char CameraParameters::KEY_VIDEO_FRAME_FORMAT[] = "video-frame-format";
const char CameraParameters::KEY_VIDEO_SIZE[] = "video-size";
const char CameraParameters::KEY_SUPPORTED_VIDEO_SIZES[] = "video-size-values";
const char CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO[] = "preferred-preview-size-for-video";
const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_HW[] = "max-num-detected-faces-hw";
const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_SW[] = "max-num-detected-faces-sw";
const char CameraParameters::KEY_RECORDING_HINT[] = "recording-hint";
const char CameraParameters::KEY_VIDEO_SNAPSHOT_SUPPORTED[] = "video-snapshot-supported";
const char CameraParameters::KEY_VIDEO_STABILIZATION[] = "video-stabilization";
const char CameraParameters::KEY_VIDEO_STABILIZATION_SUPPORTED[] = "video-stabilization-supported";


const char CameraParameters::TRUE[] = "true";
const char CameraParameters::FALSE[] = "false";
const char CameraParameters::FOCUS_DISTANCE_INFINITY[] = "Infinity";


// Values for white balance settings.
const char CameraParameters::WHITE_BALANCE_AUTO[] = "auto";
const char CameraParameters::WHITE_BALANCE_INCANDESCENT[] = "incandescent";
const char CameraParameters::WHITE_BALANCE_FLUORESCENT[] = "fluorescent";
const char CameraParameters::WHITE_BALANCE_WARM_FLUORESCENT[] = "warm-fluorescent";
const char CameraParameters::WHITE_BALANCE_DAYLIGHT[] = "daylight";
const char CameraParameters::WHITE_BALANCE_CLOUDY_DAYLIGHT[] = "cloudy-daylight";
const char CameraParameters::WHITE_BALANCE_TWILIGHT[] = "twilight";
const char CameraParameters::WHITE_BALANCE_SHADE[] = "shade";


// Values for effect settings.
const char CameraParameters::EFFECT_NONE[] = "none";
const char CameraParameters::EFFECT_MONO[] = "mono";
const char CameraParameters::EFFECT_NEGATIVE[] = "negative";
const char CameraParameters::EFFECT_SOLARIZE[] = "solarize";
const char CameraParameters::EFFECT_SEPIA[] = "sepia";
const char CameraParameters::EFFECT_POSTERIZE[] = "posterize";
const char CameraParameters::EFFECT_WHITEBOARD[] = "whiteboard";
const char CameraParameters::EFFECT_BLACKBOARD[] = "blackboard";
const char CameraParameters::EFFECT_AQUA[] = "aqua";


// Values for antibanding settings.
const char CameraParameters::ANTIBANDING_AUTO[] = "auto";
const char CameraParameters::ANTIBANDING_50HZ[] = "50hz";
const char CameraParameters::ANTIBANDING_60HZ[] = "60hz";
const char CameraParameters::ANTIBANDING_OFF[] = "off";


// Values for flash mode settings.
const char CameraParameters::FLASH_MODE_OFF[] = "off";
const char CameraParameters::FLASH_MODE_AUTO[] = "auto";
const char CameraParameters::FLASH_MODE_ON[] = "on";
const char CameraParameters::FLASH_MODE_RED_EYE[] = "red-eye";
const char CameraParameters::FLASH_MODE_TORCH[] = "torch";


// Values for scene mode settings.
const char CameraParameters::SCENE_MODE_AUTO[] = "auto";
const char CameraParameters::SCENE_MODE_ACTION[] = "action";
const char CameraParameters::SCENE_MODE_PORTRAIT[] = "portrait";
const char CameraParameters::SCENE_MODE_LANDSCAPE[] = "landscape";
const char CameraParameters::SCENE_MODE_NIGHT[] = "night";
const char CameraParameters::SCENE_MODE_NIGHT_PORTRAIT[] = "night-portrait";
const char CameraParameters::SCENE_MODE_THEATRE[] = "theatre";
const char CameraParameters::SCENE_MODE_BEACH[] = "beach";
const char CameraParameters::SCENE_MODE_SNOW[] = "snow";
const char CameraParameters::SCENE_MODE_SUNSET[] = "sunset";
const char CameraParameters::SCENE_MODE_STEADYPHOTO[] = "steadyphoto";
const char CameraParameters::SCENE_MODE_FIREWORKS[] = "fireworks";
const char CameraParameters::SCENE_MODE_SPORTS[] = "sports";
const char CameraParameters::SCENE_MODE_PARTY[] = "party";
const char CameraParameters::SCENE_MODE_CANDLELIGHT[] = "candlelight";
const char CameraParameters::SCENE_MODE_BARCODE[] = "barcode";


const char CameraParameters::PIXEL_FORMAT_YUV422SP[] = "yuv422sp";
const char CameraParameters::PIXEL_FORMAT_YUV420SP[] = "yuv420sp";
const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
const char CameraParameters::PIXEL_FORMAT_RGB565[] = "rgb565";
const char CameraParameters::PIXEL_FORMAT_RGBA8888[] = "rgba8888";
const char CameraParameters::PIXEL_FORMAT_JPEG[] = "jpeg";
const char CameraParameters::PIXEL_FORMAT_BAYER_RGGB[] = "bayer-rggb";


// Values for focus mode settings.
const char CameraParameters::FOCUS_MODE_AUTO[] = "auto";
const char CameraParameters::FOCUS_MODE_INFINITY[] = "infinity";
const char CameraParameters::FOCUS_MODE_MACRO[] = "macro";
const char CameraParameters::FOCUS_MODE_FIXED[] = "fixed";
const char CameraParameters::FOCUS_MODE_EDOF[] = "edof";
const char CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO[] = "continuous-video";
const char CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE[] = "continuous-picture";
-----------첨부 4--------------------------------------------------

-----------첨부 5--------------------------------------------------

typedef struct preview_stream_ops {
	int (*dequeue_buffer)(struct preview_stream_ops* w,
						 buffer_handle_t** buffer, int *stride);
	int (*enqueue_buffer)(struct preview_stream_ops* w,
				buffer_handle_t* buffer);
	int (*cancel_buffer)(struct preview_stream_ops* w,
				buffer_handle_t* buffer);
	int (*set_buffer_count)(struct preview_stream_ops* w, int count);
	int (*set_buffers_geometry)(struct preview_stream_ops* pw,
				int w, int h, int format);
	int (*set_crop)(struct preview_stream_ops *w,
				int left, int top, int right, int bottom);
	int (*set_usage)(struct preview_stream_ops* w, int usage);
	int (*set_swap_interval)(struct preview_stream_ops *w, int interval);
	int (*get_min_undequeued_buffer_count)(const struct preview_stream_ops *w,
				int *count);
	int (*lock_buffer)(struct preview_stream_ops* w,
				buffer_handle_t* buffer);
} preview_stream_ops_t;

	void initHalPreviewWindow()
	{
		mHalPreviewWindow.nw.cancel_buffer = __cancel_buffer;
		mHalPreviewWindow.nw.lock_buffer = __lock_buffer;
		mHalPreviewWindow.nw.dequeue_buffer = __dequeue_buffer;
		mHalPreviewWindow.nw.enqueue_buffer = __enqueue_buffer;
		mHalPreviewWindow.nw.set_buffer_count = __set_buffer_count;
		mHalPreviewWindow.nw.set_buffers_geometry = __set_buffers_geometry;
		mHalPreviewWindow.nw.set_crop = __set_crop;
		mHalPreviewWindow.nw.set_usage = __set_usage;
		mHalPreviewWindow.nw.set_swap_interval = __set_swap_interval;


		mHalPreviewWindow.nw.get_min_undequeued

		마)	Linux 카메라 테스트 application
		* @file mxc_v4l2_tvin.c
		* @brief Mxc TVIN For Linux 2 driver test application

		바)	i.MX6 OV5647 Bayer sensor driver (ERROR: v4l2 capture: mxc_v4l_dqueue timeout enc_counter 0) 
이 질문은 답변됨 상태입니다.
 
 Dave McMordie 2013. 8. 9 오전 10:44 Hello,
 
I have implemented an OV5647 camera board which connects to my i.MX6 quad Wandboard.  I am having trouble getting images from the driver 
and need some help figuring out why.  I have reviewed about a dozen related threads on this forum, and tried to carefully implement their suggestions.
Here are the steps I have taken so far:

 1.Started with working kernel (based on John Weber's Yocto Kernel) and board which is known to work with OV5640 (YUV sensor) in this configuration.  
   rootfs is Linaro armhf with desktop ubuntu (so I can use VLC and other known tools for testing).
2.Made sure that the BSP sets GPR1 19 to 0 (select MIPI CSI interface to IPU0 CSI 0), and that the camera driver is detected by I2C.
3.Built a driver, OV5647_mipi.c, based on OV5640_mipi.c with the following changes:
1.Replaced modes (register programming code) with code appropriate to generate a 1280x960 30 fps preview on the OV5647
2.Changed the chip_id high and low bytes to 0x56 and 0x47 respectively
3.Changed ov5647_data.pix.pixelformat to V4L2_PIX_FMT_SBGGR10
4.Added code to detect this and call mipi_csi2_set_datatype with MIPI_DT_RAW10
5.Tried steps 3, 4 with GREY and RAW10
4.Added support for V4L2_PIX_FMT_SBGGR10 and V4L2_PIX_FMT_GREY to
1.drivers\media\video\mxc\capture\ipu_csi_enc.c
2.drivers\media\video\mxc\capture\mxc_v4l2_capture.c
3.drivers\mxc\ipu3\ipu_capture.c
4.drivers\mxc\ipu3\ipu_common.c
5.drivers\mxc\ipu3\ipu_param_mem.h
5.Tested
1.Sensor is correctly detected on I2C
2.Driver reports MIPI clock stabilized okay
3.Driver reports data being received from sensor

I have to guess that what is going on is that the image format is not being handled correctly, but I can't tell from the tracing.

Some specific questions:

1.How can I verify that I am talking to the correct IPU, CSI port and virtual channel?
2.Despite the driver's claim that it is receiving data, is it possible that this is a signal integrity issue?  
I have not been able to successfully probe the lanes (I see a ton of common mode noise)
3.Are there steps I have missed to support a 10 bit Bayer sensor just as grayscale?
4.What are the likely reasons why it is not getting frame interrupts?
5.Help!   

The following is what I get with DEBUG tracing on in the drivers:

[ 1160.505314] End of mxc_v4l2_g_fmt: crop_current widthxheight 1280 x 960
[ 1160.505352] In MVC:mxc_v4l_ioctl
[ 1160.505360] In MVC: mxc_v4l_do_ioctl c0405602
[ 1160.505373] In MVC:mxc_v4l_ioctl
[ 1160.505380] In MVC: mxc_v4l_do_ioctl c0405602
[ 1160.505458] In MVC:mxc_v4l_ioctl
[ 1160.505465] In MVC: mxc_v4l_do_ioctl c0445624
[ 1160.505472]    case default or not supported
[ 1160.505528] In MVC:mxc_v4l_ioctl
[ 1160.505535] In MVC: mxc_v4l_do_ioctl c02c563a
[ 1160.505540]    case VIDIOC_CROPCAP
[ 1160.505547] In MVC:mxc_v4l_ioctl
[ 1160.505552] In MVC: mxc_v4l_do_ioctl 4014563c
[ 1160.505561]    case VIDIOC_S_CROP
[ 1160.505567]    Cropping Input to ipu size 1280 x 960
[ 1160.505678] In MVC:mxc_v4l_ioctl
[ 1160.505686] In MVC: mxc_v4l_do_ioctl c0145608
[ 1160.505693]    case VIDIOC_REQBUFS
[ 1160.505697] In MVC:mxc_streamoff
[ 1160.505702] MVC: In mxc_free_frame_buf
[ 1160.505709] In MVC:mxc_allocate_frame_buf - size=152064
[ 1160.508739] In MVC:mxc_v4l_ioctl
[ 1160.508746] In MVC: mxc_v4l_do_ioctl c0445609
[ 1160.508752]    case VIDIOC_QUERYBUF
[ 1160.508759] In MVC:mxc_v4l2_buffer_status
[ 1160.508904] In MVC:mxc_mmap
[ 1160.508911]    pgoff=0x184c0, start=0x45dbd000, end=0x45de3000
[ 1160.508933] In MVC:mxc_v4l_ioctl
[ 1160.508939] In MVC: mxc_v4l_do_ioctl c0445609
[ 1160.508944]    case VIDIOC_QUERYBUF
[ 1160.508949] In MVC:mxc_v4l2_buffer_status
[ 1160.508966] In MVC:mxc_mmap
[ 1160.508972]    pgoff=0x18300, start=0x46549000, end=0x4656f000
[ 1160.508987] In MVC:mxc_v4l_ioctl
[ 1160.508992] In MVC: mxc_v4l_do_ioctl c0445609
[ 1160.508997]    case VIDIOC_QUERYBUF
[ 1160.509002] In MVC:mxc_v4l2_buffer_status
[ 1160.509013] In MVC:mxc_mmap
[ 1160.509019]    pgoff=0x18340, start=0x46700000, end=0x46726000
[ 1160.509033] In MVC:mxc_v4l_ioctl
[ 1160.509039] In MVC: mxc_v4l_do_ioctl c0445609
[ 1160.509044]    case VIDIOC_QUERYBUF
[ 1160.509049] In MVC:mxc_v4l2_buffer_status
[ 1160.509058] In MVC:mxc_mmap
[ 1160.509064]    pgoff=0x19f00, start=0x467ed000, end=0x46813000
[ 1160.509085] In MVC:mxc_v4l_ioctl
[ 1160.509092] In MVC: mxc_v4l_do_ioctl c044560f
[ 1160.509097]    case VIDIOC_QBUF
[ 1160.509104] In MVC:mxc_v4l_ioctl
[ 1160.509110] In MVC: mxc_v4l_do_ioctl c044560f
[ 1160.509115]    case VIDIOC_QBUF
[ 1160.509121] In MVC:mxc_v4l_ioctl
[ 1160.509126] In MVC: mxc_v4l_do_ioctl c044560f
[ 1160.509131]    case VIDIOC_QBUF
[ 1160.509138] In MVC:mxc_v4l_ioctl
[ 1160.509143] In MVC: mxc_v4l_do_ioctl c044560f
[ 1160.509148]    case VIDIOC_QBUF
[ 1160.509154] In MVC:mxc_v4l_ioctl
[ 1160.509160] In MVC: mxc_v4l_do_ioctl 40045612
[ 1160.509166]    case VIDIOC_STREAMON
[ 1160.509170] In MVC:mxc_streamon
[ 1160.509175] IPU:In prp_enc_enabling_tasks
[ 1160.509981] In prp_enc_setup
[ 1160.509988] YUV420
[ 1160.510026] eba 184c0000
[ 1160.510033] eba 18300000
[ 1160.510230] In MVC:mxc_poll
[ 1160.510243] In MVC:mxc_v4l_ioctl
[ 1160.510250] In MVC: mxc_v4l_do_ioctl c0445611
[ 1160.510256]    case VIDIOC_DQBUF
[ 1160.510261] In MVC:mxc_v4l_dqueue
[ 1170.504999] ERROR: v4l2 capture: mxc_v4l_dqueue timeout enc_counter 0
[ 1170.511966] In MVC:mxc_poll
[ 1170.511983] In MVC:mxc_v4l_ioctl
[ 1170.511991] In MVC: mxc_v4l_do_ioctl c0445611
[ 1170.511997]    case VIDIOC_DQBUF
[ 1170.512001] In MVC:mxc_v4l_dqueue
[ 1180.504959] ERROR: v4l2 capture: mxc_v4l_dqueue timeout enc_counter 0
[ 1180.511757] In MVC:mxc_poll
[ 1180.511773] In MVC:mxc_v4l_ioctl
[ 1180.511783] In MVC: mxc_v4l_do_ioctl c0445611
[ 1180.511789]    case VIDIOC_DQBUF
[ 1180.511794] In MVC:mxc_v4l_dqueue
[ 1190.504954] ERROR: v4l2 capture: mxc_v4l_dqueue timeout enc_counter 0

		아)	no jni_onload found in libnativehelper.so 0x0 skipping init 에러
			위 메세지는 이클립스에서 RUN할때 발생 하고 어플을 종료 했다가 다시 실행 시키면 NO Jni에러는 발생 하지 않습니다. 
			머털도사님이 말씀하시는 경로는 어떤것을 말씀 하신는건가요 따로 경로 설정을 해줘야 되는 것이 있습니까?
			->	문제해결했습니다. 디바이스 드라이버 파일의 권한이 600으로 되어 있길래 777로 변경 후 LED가 ON OFF동작을 합니다. 
				그런데 전원을 OFF하고 ON하면 다시 600으로 복귀 합니다. 궁금한것이 있습니다. 안드로이드 권한 설정 관련해서 규칙이 있는지 궁금 합니다. 
				아시는 분 있으시면 답변좀 부탁 합니다.
				[출처] LED 디바이스 드라이버 관련 동작 문제 (Embedded Crazy Boys) |작성자 jws7908
				
			/system/build.prop 파일에 하기 내용 추가
			dalvik.vm.checkjni=true

			오늘에서야 알았습니다. 다른 분들을 위해서 해결법 올려드립니다.
			
			1. 라이브러리 로드 오류
			2. NDK에 기록했던 패키지, 클래스명과의 동기화 되지 않았던 문제이었습니다.
			
			더 정확한 답변 원하시면 쪽지주세요^^ 

JNI programming - (7) JNI_OnLoad 함수
엄철웅
http://forum.falinux.com/zbxe/index.php?document_srl=5719362012.08.06 00:03:38 (*.140.185.33) 46824
JNI 를 사용하면서 java 함수와 c / c++ 함수를 mapping 하는 방법은 두가지가 있다.

c / c++ 함수의 이름을 규칙에 맞게 선언해서 사용하는 방법을 지난 번에 알아보았고,

두번째 방법인 JNI_OnLoad 함수에 대해 지금부터 알아보겠다.

JNI 에 대해서 가장 많은 예제를 포함하고 있는 것이 android 소스이므로,

android 소스에서 사용법은 확인하도록 해보자.

===== (7) JNI_OnLoad 함t수 =========================================================

1. JNI_OnLoad, JNI_OnUnload 의 선언

JNI 에서 java 로 library 가 load 되는 과정을 살펴보면,
System.loadLibrary() 함수가 호출될 때, 우선 JNI_OnLoad 함수하는지 확인하고
있을 경우에는 함수의 내용을 수행하고 없을 경우에는 기본 규칙에 따라 함수를 mapping 하게 된다.	

따라서 JNI_OnLoad 를 구현할 경우 함수의 mapping 을 직접해줘야 한다
하지만 경우에 따라서는 JNI_OnLoad 함수에 부가적이 내용 끼워넣어서
필요한 초기화 작업이 자동으로 이루어지도록 할 수도 있다.
jni.h 에서 함수의 선언을 찾을 수 있다.

/usr/lib/jvm/java-6-openjdk/include/jni.h
....
1943 /* Defined by native libraries. */
1944 JNIEXPORT jint JNICALL
1945 JNI_OnLoad(JavaVM *vm, void *reserved);
1946 
1947 JNIEXPORT void JNICALL
1948 JNI_OnUnload(JavaVM *vm, void *reserved);
....

2. android 에서의 구현

직접적인 사용의 예를 찾아보기 위해 android 소스를 살펴보자.

..../frameworks/base/services/jni/onload.cpp
#include "JNIHelp.h"
#include "jni.h"
#include "utils/Log.h"
#include "utils/misc.h"

namespace android {
int register_android_server_AlarmManagerService(JNIEnv* env);
....
};

using namespace android;

extern "C" jint JNI_OnLoad(JavaVM* vm, void* reserved)
{
    JNIEnv* env = NULL;
    jint result = -1; 

    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
        LOGE("GetEnv failed!");
        return result;
    }   
    LOG_ASSERT(env, "Could not retrieve the env!");

    register_android_server_AlarmManagerService(env);
    ....

    return JNI_VERSION_1_4;
} 

jni  소스 부분에서 JNI_OnLoad 함수를 찾을 수 있다.
jni 에서 필요한 함수들을 포함하고 있는 'JNIEnv* env' 를 얻어와서 register_android_server_XXX 함수들에
넘겨주고 실제적인 함수 등록은 각 소스파일에 구현되어 있는 register_android_server_XXX 함수에서 한다.

..../frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp
 ....
static JNINativeMethod sMethods[] = { 
     /* name, signature, funcPtr */
    {"init", "()I", (void*)android_server_AlarmManagerService_init},
    {"close", "(I)V", (void*)android_server_AlarmManagerService_close},
    {"set", "(IIJJ)V", (void*)android_server_AlarmManagerService_set},
    {"waitForAlarm", "(I)I", (void*)android_server_AlarmManagerService_waitForAlarm},
    {"setKernelTimezone", "(II)I", (void*)android_server_AlarmManagerService_setKernelTimezone},
};

int register_android_server_AlarmManagerService(JNIEnv* env)
{
    jclass clazz = env->FindClass("com/android/server/AlarmManagerService");

    if (clazz == NULL)
    {   
        LOGE("Can't find com/android/server/AlarmManagerService");
        return -1; 
    }   

    return jniRegisterNativeMethods(env, "com/android/server/AlarmManagerService",
                                    sMethods, NELEM(sMethods));
}

mapping 할 함수들의 정보는 "sMethods[]" 에 넣어둔다.
해당 클래스가 java 에 있는지 확인하고, 클래스 이름과 함수의 정보를 "jniRegisterNativeMethods" 에 넘겨준다.
"NELEM" 은 sMethods[] 의 길이를 알려주는 메크로이다.
모든 jni 소스는 이와 같은 형태로 구성되어 있으므로 "jniRegisterNativeMethods" 함수만 확인해서 이해하고 있으면 된다.

..../dalvik/libnativehelper/JNIHelp.c
....
 /*
 * Register native JNI-callable methods.
 *
 * "className" looks like "java/lang/String".
 */
int jniRegisterNativeMethods(JNIEnv* env, const char* className,
    const JNINativeMethod* gMethods, int numMethods)
{
    jclass clazz;

    LOGV("Registering %s natives\n", className);
    clazz = (*env)->FindClass(env, className);
    if (clazz == NULL) {
        LOGE("Native registration unable to find class '%s'\n", className);
        return -1; 
    }   

    int result = 0;
    if ((*env)->RegisterNatives(env, clazz, gMethods, numMethods) < 0) {
        LOGE("RegisterNatives failed for '%s'\n", className);
        result = -1; 
    }   

    (*env)->DeleteLocalRef(env, clazz);
    return result;
}
....

함수들의 이름은 낯설지만 생각보다 단순하다.
JNIEnv 에 선언되어 있는 RegisterNatives 함수에 mapping 에 필요한 몇가지 정보만 넘겨주면 된다.

android 가 아닌 다른 JNI 프로그램에서도 이 모듈을 때어다 써도 아무 지장에 없다.
잘 만들어진 모듈이므로 적절히 배치해서 그대로 사용해도 된다.

다만, JNINativeMethod 구조체에 함수 정보를 넣을 때 사용되는 문자열의 내용이 마치 암호와 같이 되어있다.

static JNINativeMethod sMethods[] = { 
     /* name, signature, funcPtr */
    {"init", "()I", (void*)android_server_AlarmManagerService_init},
    ....
}; 

결국 argument 와 반환형, 함수 이름에 대한 내용들인데...
이 부분에 대해서는 다음에 적도록 하겠다.

=============================================================================

		자)	안드로이드 소스 트리 구조
http://taehyo.egloos.com/4073971
 
├── bionic         	                : bionic libc(BSD의 libc 수정)를 포함
├── bootable                	       	: bootloader, recovery mode 관련 코드
├── build          	                : 빌드 관련 스크립트를 저장
│   ├── envsetup.sh     	       	: 환경 정보 설정 파일, 제조사의 Flag들에 대한 설정을 함
│   ├── core
│   │   └── prelink-linux-arm.map : shared library들이 로딩되는 번지를 미리 지정한 파일
│   └── target
│    	└── board
│          	└── generic
│                	├── AndroidBoard.mk    	: 최상위 directive 파일, Android 최종 결과물
│                	│               	       	       	 구성서 자동 포함 bin에 대한 install을 결정
│                	│               	       	          init.rc, init%hw%.rc 들을 install
│                	└── BoardConfig.mk   	: HAL의 en/disable 등을 결정
├── cts             	       	: Compatibility Test Suite, GMS를 탑재 위해 통과해야 하는 Test
├── dalvik         	       	: dalvik VM 관련 소스 코드
├── development          	: 개발용 application을 저장
├── device         	       	: 칩 관련 설정 파일 및 디버깅을 위한 cmm 파일 등을 포함
├── external                 	: 기존 작성된 library, binary등의 소스 코드를 포함
├── frameworks
│   ├── base                	: Android Framework Source Code
│   ├── cmds    	       	: binder 관련된 service manager 소스 코드 및 여러 가지 command
│   ├── libs                 	: Android base library (AudioFlinger, SurfaceFlinger, util, binder 등)
│   ├── media   	       	: media 관련 Client & Service 라이브러리
│   └── policies 	       	: Android 시스템을 background에서 제어하는 최상위 application
│                         	       	  KeyGuard 관련, 화면 제어(rotation..), event 관리 등의 작업 처리
├── hardware               	: Android에서 사용하는 h/w 관련 소스 코드 포함(HAL, include..)
│   ├── libhardware     	: Board H/W 의존성이 높은 하드웨어 모듈 포함
│   └── libhardware_legacy: 일반적으로 Android에 반드시 있어야 하는 H/W 모듈(wifi..)
├── out/target/product/sabresd_6dq	: Build 된 boot.img system.img 파일 등이 모여 있음
├── packages               	: Android 기본 Application 소스 코드를 포함
├── prebuilt                 	: 툴체인과 미리 빌드되어 들어가는 바이너리 파일 포함
├── system       	       	: Android의 기본 바이너리 소스 코드(init…)
│   ├── core
│   │    ├── init          	: Android init 소스 코드
│   │    └── vold         	: external storage 제어 모듈 (Eclair)
│   └── vold                	: external storage 제어 모듈 (Froyo/Gingerbread)
└── vendor        	       	: vendor specific code(HAL, product list 관리…)

		자+1)Android board root directory
			아래 root directory 파일들은 안드로이드 소스 상에서 /root/myandroid/out/target/product/sabresd_6dq/root 에 저장되어 있다.
acct
cache
charger
config
d
data
default.prop
dev
device						->	포팅시 디바이스의 각종 설정
etc
file_contexts
fstab.freescale
init
init.environ.rc
init.freescale.rc
init.freescale.usb.rc
init.rc						->	android의 init 코드
init.trace.rc
init.usb.rc
mnt							->	/mnt/shell/emulated/0 폴더가 /sdcard로 link되어 있으므로 /sdcard에 저장하면 /mnt/shell/emulated/0 폴더에 저장 됨
								본 폴더에 저장된 이미지를 보거나 복사하려면 윈도우탐색기->SABRESD-MX6DQ->Internal storage에서는 실시간으로 볼 수 없고
								Eclipse -> DDMS -> freescale-sabresd_mx6dq-~ -> File Explorer -> /mnt/shell/emulated/0 에서 실시간으로 볼 수 있음
								cf)	DDMS -> pull 명령이 동작하지 않는 다면
									1)	DDMS -> Devices -> freescal-sabresd_mx6dq~ -> kr.co.infinity.CameraCaptureTest~ 선택
									2)	pull 명령 다시 실행
proc
property_contexts
res
root
sbin
sdcard						->	/storage/emulated/legacy	->	/mnt/shell/emulated/0
								cf) 본 sdcard 폴더에 파일 저장 시 하기와 같이 sendBroadcast를 명령을 실행하지 않으면 Eclipse -> DDMS -> freescale-sabresd_mx6dq-~ -> File Explorer -> /mnt/shell/emulated/0 에서는 파일이
									존재하는 것이 확인되어도 안드로이드 보드 내부의 "Gallery" 프로그램 등에서는 파일이 존재하지 않는 것으로 확인 됨
								ex)	CUtil.saveBitmapFile(tmpBmp, "/sdcard/image_convert.jpg");				
								//	sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED,Uri.parse("file://"+Environment.getExternalStorageDirectory()+"/Pictures")));			// kikat 부터 지원하지 않음
								//	sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,Uri.parse("file://" + "/mnt/shell/emulated/0/image_convert.jpg")));			// 이렇게 path를 잡은면 이상하게 동작하지 않음
									sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,Uri.parse("file://" + "/sdcard/image_convert.jpg")));						// 이렇게 path를 설정해야만 정상 작동 함
								cf)	String root = "/storage/emulated/0/Android/data/com./files/";		// = /mnt/adcard/Android/data/com./files/
seapp_contexts
sepolicy
storage
sys
system
ueventd.freescale.rc
ueventd.rc					->	android의 init 코드
vendor





###		차)	Android Camera Subsystem
			중요, i.mx6 보드의 카메라 실행 구조와 유사한 흐름으로 설명해 주고 있음
startPreview

1．     Camera::startPreview()
frameworks/base/core/java/android/hardware/Camera.java
public native final voidstartPreview();

2．     android_hardware_Camera_startPreview()
frameworks/base/core/jni/android_hardware_Camera.cpp
static voidandroid_hardware_Camera_startPreview(JNIEnv *env, jobject thiz)
{
ALOGV("startPreview");

//得到本地Camera?象

   sp<Camera> camera =get_native_camera(env, thiz, NULL);
   if (camera == 0) return;

//?用本地Camera::startPreview方法

   if (camera->startPreview() != NO_ERROR){
       jniThrowRuntimeException(env, "startPreview failed");
       return;
    }
}

3．   Camera::startPreview()
frameworks/av/camera/Camera.cpp
// start preview mode
status_t Camera::startPreview()
{
   ALOGV("startPreview");

sp<ICamera> c = mCamera;  

// mCamera是CameraBase中的成??量，?指向的是一?BpCamera?象。
//在Camera open的?程中， mCamera?cs->connect（）返回中
//得到的是 BpCamera?象，因此c??BpCamera?象。

   if (c == 0) return NO_INIT;
   return c->startPreview();
}

4．   BpCamera::startPreview()
frameworks/av/camera/ICamera.cpp
class BpCamera: publicBpInterface<ICamera>
{
// start preview mode, must call setPreviewDisplay first
status_t startPreview()
{
       ALOGV("startPreview");
       Parcel data, reply;
       data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
       remote()->transact(START_PREVIEW,data, &reply);
       return reply.readInt32();
}
};

在 camera open?程中， cs->connect()??service回?reply中得到的一?binder?象（??上是一?CameraClient或Camera2Client?象），在interfaca_cast?，??依据???象??其??的本地接口(BpBinder?象),在?建BpCamera?象????BpBinder本地接口?象?入BpCamera的?造函?，最???BpBinder?象???BpCamera的mRemote成??量。而remote()函?就是返回mRemote成??量。
因此remote()->transact（）??上?用的是BpBinder::transact()

5．   BpBinder::transact()
Frameworks/native/libs/binder/BpBinder.cpp
status_t BpBinder::transact(
   uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
   // Once a binder has died, it will never come back to life.
   if (mAlive) {
       status_t status = IPCThreadState::self()->transact(
           mHandle, code, data, reply, flags);
       if (status == DEAD_OBJECT) mAlive = 0;
       return status;
    }

   return DEAD_OBJECT;
}

6.   IPCThreadState::transact()
Frameworks/native/libs/binder/IPCThreadState.cpp
status_t IPCThreadState::transact(int32_thandle,
                                  uint32_tcode, const Parcel& data,
                                  Parcel*reply, uint32_t flags)
{
   status_t err = data.errorCheck();
   flags |= TF_ACCEPT_FDS;

   IF_LOG_TRANSACTIONS() {
       TextOutput::Bundle _b(alog);
       alog << "BC_TRANSACTION thr " <<(void*)pthread_self() << " / hand "
           << handle << " / code " << TypeCode(code)<< ": "
           << indent << data << dedent << endl;
    }

   if (err == NO_ERROR) {
       LOG_ONEWAY(">>>> SEND from pid %d uid %d %s",getpid(), getuid(),
           (flags & TF_ONE_WAY) == 0 ? "READ REPLY" : "ONEWAY");
       err =writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);
    }

   if (err != NO_ERROR) {
       if (reply) reply->setError(err);
       return (mLastError = err);
    }

   if ((flags & TF_ONE_WAY) == 0) {
       #if 0
       if (code == 4) { // relayout
           ALOGI(">>>>>> CALLING transaction 4");
       } else {
           ALOGI(">>>>>> CALLING transaction %d",code);
       }
       #endif
       if (reply) {
           err = waitForResponse(reply);
       } else {
           Parcel fakeReply;
           err = waitForResponse(&fakeReply);
       }
       #if 0
       if (code == 4) { // relayout
           ALOGI("<<<<<< RETURNING transaction 4");
       } else {
           ALOGI("<<<<<< RETURNING transaction %d",code);
       }
       #endif

       IF_LOG_TRANSACTIONS() {
           TextOutput::Bundle _b(alog);
           alog << "BR_REPLY thr " << (void*)pthread_self()<< " / hand "
                << handle <<": ";
           if (reply) alog << indent << *reply << dedent <<endl;
           else alog <<"(none requested)" << endl;
       }
    }else {
       err = waitForResponse(NULL, NULL);
    }

   return err;
}

IPCThreadState::writeTransactionData()
IPCThreadState:: waitForResponse ()

7.   status_tIPCThreadState::executeCommand(int32_t cmd)
Frameworks/native/libs/binder/IPCThreadState.cpp
status_tIPCThreadState::executeCommand(int32_t cmd)
{
   BBinder* obj;
   RefBase::weakref_type* refs;
   status_t result = NO_ERROR;

   switch (cmd) {
   case BR_ERROR:
       result = mIn.readInt32();
       break;
……………………………………………………………..
   case BR_TRANSACTION:
       {
           binder_transaction_data tr;
           result = mIn.read(&tr, sizeof(tr));
           ALOG_ASSERT(result == NO_ERROR,
                "Not enough command datafor brTRANSACTION");
           if (result != NO_ERROR) break;

           Parcel buffer;
           buffer.ipcSetDataReference(
                reinterpret_cast<constuint8_t*>(tr.data.ptr.buffer),
                tr.data_size,
                reinterpret_cast<constsize_t*>(tr.data.ptr.offsets),
                tr.offsets_size/sizeof(size_t),freeBuffer, this);

           const pid_t origPid = mCallingPid;
           const uid_t origUid = mCallingUid;

           mCallingPid = tr.sender_pid;
           mCallingUid = tr.sender_euid;

           int curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
           if (gDisableBackgroundScheduling) {
                if (curPrio >ANDROID_PRIORITY_NORMAL) {
                    // We have inherited areduced priority from the caller, but do not
                    // want to run in thatstate in this process.  The driver setour
                    // priority already (thoughnot our scheduling class), so bounce
                    // it back to the defaultbefore invoking the transaction.
                    setpriority(PRIO_PROCESS,mMyThreadId, ANDROID_PRIORITY_NORMAL);
                }
           } else {
                if (curPrio >=ANDROID_PRIORITY_BACKGROUND) {
                    // We want to use theinherited priority from the caller.
                    // Ensure this thread is inthe background scheduling class,
                    // since the driver won'tmodify scheduling classes for us.
                    // The scheduling group isreset to default by the caller
                    // once this method returnsafter the transaction is complete.
                   set_sched_policy(mMyThreadId, SP_BACKGROUND);
                }
           }

           //ALOGI(">>>> TRANSACT from pid %d uid %d\n",mCallingPid, mCallingUid);

           Parcel reply;
           IF_LOG_TRANSACTIONS() {
                TextOutput::Bundle _b(alog);
                alog <<"BR_TRANSACTION thr " << (void*)pthread_self()
                    << " / obj" << tr.target.ptr << " / code "
                    << TypeCode(tr.code)<< ": " << indent << buffer
                    << dedent <<endl
                    << "Data addr = "
                    <<reinterpret_cast<const uint8_t*>(tr.data.ptr.buffer)
                    << ", offsetsaddr="
                    <<reinterpret_cast<const size_t*>(tr.data.ptr.offsets) << endl;
           }
           if (tr.target.ptr) {
//??的b??就是 Camera::open()?用?程中，在服?端生成的CameraClient
//或 Camera2Client?象
// class CameraClient : public CameraService::Client
// clas CameraService::Client : public BnCamera, publicBasicClient
// class BnCamera: public BnInterface<ICamera>
// class BnInterface : public INTERFACE, public BBinder
// class BBinder : public IBinder

               sp<BBinder>b((BBinder*)tr.cookie);
               const status_t error =b->transact(tr.code, buffer, &reply, tr.flags);
                if (error < NO_ERROR)reply.setError(error);
           } else {
                const status_t error =the_context_object->transact(tr.code, buffer, &reply, tr.flags);
                if (error < NO_ERROR)reply.setError(error);
           }

           //ALOGI("<<<< TRANSACT from pid %d restore pid %d uid%d\n",
           //     mCallingPid, origPid,origUid);
           if ((tr.flags & TF_ONE_WAY) == 0) {
                LOG_ONEWAY("Sending replyto %d!", mCallingPid);
                sendReply(reply, 0);
           } else {
                LOG_ONEWAY("NOT sendingreply to %d!", mCallingPid);
           }

           mCallingPid = origPid;
           mCallingUid = origUid;

           IF_LOG_TRANSACTIONS() {
                TextOutput::Bundle _b(alog);
                alog << "BC_REPLYthr " << (void*)pthread_self() << " / obj "
                    << tr.target.ptr<< ": " << indent << reply << dedent <<endl;
           }
       }
       break;
   …………………………………………………………….
}

8.    BBinder::transact()
Frameworks/native/libs/binder/binder.cpp
// class CameraClient : public CameraService::Client
// clas CameraService::Client : public BnCamera, publicBasicClient
// class BnCamera: public BnInterface<ICamera>
// class BnInterface : public INTERFACE, public BBinder
// class BBinder : public IBinder

由于CameraClient?有改?BBinder的transact(),因此上述b->transact()
??上就是?用BBinder的transact() .

status_t BBinder::transact(
   uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
   data.setDataPosition(0);

   status_t err = NO_ERROR;
   switch (code) {
       case PING_TRANSACTION:
           reply->writeInt32(pingBinder());
           break;
       default:
           err = onTransact(code, data, reply,flags);
           break;
    }

   if (reply != NULL) {
       reply->setDataPosition(0);
    }

   return err;
}

9.   BnCamera::onTransact ()
Frameworks/av/camera/ICamera.cpp
status_t BnCamera::onTransact(
    uint32_tcode, const Parcel& data, Parcel* reply, uint32_t flags)
{
   switch(code) {
       case DISCONNECT: {
           ALOGV("DISCONNECT");
           CHECK_INTERFACE(ICamera, data, reply);
           disconnect();
           return NO_ERROR;
       } break;

       case SET_PREVIEW_TEXTURE: {
           ALOGV("SET_PREVIEW_TEXTURE");
           CHECK_INTERFACE(ICamera, data, reply);
           sp<IGraphicBufferProducer> st =
               interface_cast<IGraphicBufferProducer>(data.readStrongBinder());
           reply->writeInt32(setPreviewTexture(st));
           return NO_ERROR;
       } break;

       case SET_PREVIEW_CALLBACK_FLAG: {
           ALOGV("SET_PREVIEW_CALLBACK_TYPE");
           CHECK_INTERFACE(ICamera, data, reply);
           int callback_flag = data.readInt32();
           setPreviewCallbackFlag(callback_flag);
           return NO_ERROR;
       } break;

       case START_PREVIEW: {
           ALOGV("START_PREVIEW");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(startPreview());
           return NO_ERROR;
       } break;

       case START_RECORDING: {
           ALOGV("START_RECORDING");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(startRecording());
           return NO_ERROR;
       } break;

       case STOP_PREVIEW: {
           ALOGV("STOP_PREVIEW");
           CHECK_INTERFACE(ICamera, data, reply);
           stopPreview();
           return NO_ERROR;
       } break;

        case STOP_RECORDING: {
           ALOGV("STOP_RECORDING");
           CHECK_INTERFACE(ICamera, data, reply);
           stopRecording();
           return NO_ERROR;
       } break;

       case RELEASE_RECORDING_FRAME: {
           ALOGV("RELEASE_RECORDING_FRAME");
           CHECK_INTERFACE(ICamera, data, reply);
           sp<IMemory> mem =interface_cast<IMemory>(data.readStrongBinder());
           releaseRecordingFrame(mem);
           return NO_ERROR;
       } break;

       case STORE_META_DATA_IN_BUFFERS: {
           ALOGV("STORE_META_DATA_IN_BUFFERS");
           CHECK_INTERFACE(ICamera, data, reply);
           bool enabled = data.readInt32();
           reply->writeInt32(storeMetaDataInBuffers(enabled));
           return NO_ERROR;
       } break;

       case PREVIEW_ENABLED: {
           ALOGV("PREVIEW_ENABLED");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(previewEnabled());
           return NO_ERROR;
       } break;

       case RECORDING_ENABLED: {
           ALOGV("RECORDING_ENABLED");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(recordingEnabled());
           return NO_ERROR;
       } break;

       case AUTO_FOCUS: {
           ALOGV("AUTO_FOCUS");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(autoFocus());
           return NO_ERROR;
       } break;

       case CANCEL_AUTO_FOCUS: {
           ALOGV("CANCEL_AUTO_FOCUS");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(cancelAutoFocus());
           return NO_ERROR;
       } break;

       case TAKE_PICTURE: {
           ALOGV("TAKE_PICTURE");
           CHECK_INTERFACE(ICamera, data, reply);
           int msgType = data.readInt32();
           reply->writeInt32(takePicture(msgType));
           return NO_ERROR;
       } break;

       case SET_PARAMETERS: {
           ALOGV("SET_PARAMETERS");
           CHECK_INTERFACE(ICamera, data, reply);
           String8 params(data.readString8());
           reply->writeInt32(setParameters(params));
           return NO_ERROR;
        } break;

       case GET_PARAMETERS: {
           ALOGV("GET_PARAMETERS");
           CHECK_INTERFACE(ICamera, data, reply);
            reply->writeString8(getParameters());
           return NO_ERROR;
        } break;

       case SEND_COMMAND: {
           ALOGV("SEND_COMMAND");
           CHECK_INTERFACE(ICamera, data, reply);
           int command = data.readInt32();
           int arg1 = data.readInt32();
           int arg2 = data.readInt32();
           reply->writeInt32(sendCommand(command, arg1, arg2));
           return NO_ERROR;
        } break;

       case CONNECT: {
           CHECK_INTERFACE(ICamera, data, reply);
           sp<ICameraClient> cameraClient =interface_cast<ICameraClient>(data.readStrongBinder());
           reply->writeInt32(connect(cameraClient));
           return NO_ERROR;

       } break;

       case LOCK: {
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(lock());
           return NO_ERROR;
       } break;

       case UNLOCK: {
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(unlock());
            return NO_ERROR;
       } break;

       default:
           return BBinder::onTransact(code, data, reply, flags);
    }
}

10.   CameraClient::startPreview()
Frameworks/av/services/camera/libcameraservice/CameraClient.cpp
上述case?句中startPreview()??上?用的是CameraClient::startPreview()
       case START_PREVIEW: {
           ALOGV("START_PREVIEW");
           CHECK_INTERFACE(ICamera, data, reply);
           reply->writeInt32(startPreview());
           return NO_ERROR;
       } break;
 
// start preview mode
status_t CameraClient::startPreview() {
   LOG1("startPreview (pid %d)", getCallingPid());
    returnstartCameraMode(CAMERA_PREVIEW_MODE);
}

// start preview or recording
status_tCameraClient::startCameraMode(camera_mode mode) {
   LOG1("startCameraMode(%d)", mode);
   Mutex::Autolock lock(mLock);
   status_t result = checkPidAndHardware();
   if (result != NO_ERROR) return result;
 
   switch(mode) {
       case CAMERA_PREVIEW_MODE:
           if (mSurface == 0 && mPreviewWindow == 0) {
                LOG1("mSurface is not setyet.");
                // still able to start previewin this case.
           }
           return startPreviewMode();

       case CAMERA_RECORDING_MODE:
           if (mSurface == 0 && mPreviewWindow == 0) {
                ALOGE("mSurface ormPreviewWindow must be set before startRecordingMode.");
                return INVALID_OPERATION;
           }
           return startRecordingMode();

       default:
           return UNKNOWN_ERROR;
    }
}

status_t CameraClient::startPreviewMode() {
   LOG1("startPreviewMode");
   status_t result = NO_ERROR;

   // if preview has been enabled, nothing needs to be done
   if (mHardware->previewEnabled()) {
       return NO_ERROR;
    }

   if (mPreviewWindow != 0) {
       native_window_set_scaling_mode(mPreviewWindow.get(),
               NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
       native_window_set_buffers_transform(mPreviewWindow.get(),
                mOrientation);
    }
    mHardware->setPreviewWindow(mPreviewWindow);
    result = mHardware->startPreview();

   return result;
}

11.   CameraClient::startPreview()
Frameworks/av/services/camera/libcameraservice/CameraHardwareInterface.h
//?用????例程
   status_t startPreview()
    {
       ALOGV("%s(%s)", __FUNCTION__, mName.string());
       if (mDevice->ops->start_preview)
           returnmDevice->ops->start_preview(mDevice);
       return INVALID_OPERATION;
    }

10.	Camera2Client 를 사용하는 경우

再看一??例，start preview ?是一???的?程？
Camera2Client::startPreview(...)
Camera2Client::startPreviewL(...)
StreamingProcessor::updatePreviewStream(...)
Camera2Device::createStream(...)
Camera2Device::StreamAdapter::connectToDevice(...)
camera2_device_t->ops->allocate_stream(...) 

??allocate_stream是Vendor??的，?于Qualcomm的Camera，位于/path/to/aosp/hardware/qcom/camera/QCamera/HAL2/wrapper/QualcommCamera.cpp 

android::allocate_stream(...)
QCameraHardwareInterface::allocate_stream(...)
QCameraStream::createInstance(...) 


###		카)	Android Camera Subsystem(실제 i.mx6 CameraClient -> setParameters 실행 순서)

X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\CameraClient.cpp
// set preview/capture parameters - key/value pairs
status_t CameraClient::setParameters(const String8& params) {
    LOG1("setParameters (pid %d) (%s)", getCallingPid(), params.string());

    Mutex::Autolock lock(mLock);
    status_t result = checkPidAndHardware();
    if (result != NO_ERROR) return result;

    CameraParameters p(params);
    return mHardware->setParameters(p);
}

X:\root\myandroid\frameworks\av\services\camera\libcameraservice\device1\CameraHardwareInterface.h
    status_t setParameters(const CameraParameters &params)
    {
        ALOGV("%s(%s)", __FUNCTION__, mName.string());
        // temp
	  ALOGI("In setParameters of CameraHardwareInterface.h, %s(%s)", __FUNCTION__, mName.string());
	  // temp
        if (mDevice->ops->set_parameters)
            return mDevice->ops->set_parameters(mDevice,
                                               params.flatten().string());
        return INVALID_OPERATION;
    }

X:\root\myandroid\hardware\imx\mx6\libcamera\CameraModule.cpp
int camera_device_open(const hw_module_t *module,
                       const char        *name,
                       hw_device_t      **device)
{
	......................................................................................................
        camera_ops->set_parameters          = camera_set_parameters;
	......................................................................................................

int camera_set_parameters(struct camera_device *device,
                          const char           *params)
{
    int rv                       = -EINVAL;
    fsl_camera_device_t *fsl_dev = NULL;

    ALOGV("%s", __FUNCTION__);

    if (!device)
        return rv;

    fsl_dev = (fsl_camera_device_t *)device;

    rv = gCameraHals[fsl_dev->cameraid]->setParameters(params);
    return rv;
}

X:\root\myandroid\hardware\imx\mx6\libcamera\CameraHal.cpp
status_t CameraHal::setParameters(const char *params)
{
	// temp
	FLOGI("In CameraHal::setParameters(const char *params)");
	// temp

    CameraParameters parameters;
    String8 str_params(params);

    parameters.unflatten(str_params);
    return setParameters(parameters);
}

status_t CameraHal::setParameters(CameraParameters& params)
{
    status_t ret = NO_ERROR;
    Mutex::Autolock lock(mLock);

	// temp
	FLOGI("In CameraHal::setParameters(CameraParameters& params)");
	// temp

    FSL_ASSERT(mDeviceAdapter.get() != NULL);
    ret = mDeviceAdapter->setParameters(params);
    if (ret) {
        FLOGE("CameraHal: initialize mDevice->setParameters failed");
        return ret;
    }

    FSL_ASSERT(mCameraBridge.get() != NULL);
    ret = mCameraBridge->setParameters(params);
    if (ret) {
        FLOGE("CameraHal: initialize mCameraBridge->setParameters failed");
        return ret;
    }

    mParameters = params;
    return ret;
}

    virtual status_t setParameters(CameraParameters& params) = 0;


########타)	Android Camera Subsystem(실제 i.mx6 Camera2Client -> setParameters 실행 순서)(카메라 노출계수도 수정할 수 있음)
C:\Program Files\Program\Java\workspace\OpenCamera_old\src\net\sourceforge\opencamera\CameraController.java
	boolean setExposureCompensation(int new_exposure) {
		Camera.Parameters parameters = this.getParameters();

		// temp
		Log.d(TAG, "Before of camera parameter: " + parameters.flatten());
		// temp

		int current_exposure = parameters.getExposureCompensation();
		if( new_exposure != current_exposure ) {
			if( MyDebug.LOG )
				Log.d(TAG, "change exposure from " + current_exposure + " to " + new_exposure);
			parameters.setExposureCompensation(new_exposure);
        	setCameraParameters(parameters);

		// temp
		Log.d(TAG, "After of camera parameter: " + parameters.flatten());
		// temp

        	return true;
		}
		return false;
	}

C:\Program Files\Program\Java\workspace\OpenCamera_old\src\net\sourceforge\opencamera\CameraController.java
	private void setCameraParameters(Camera.Parameters parameters)
	{
		if( MyDebug.LOG )
		{
			Log.d(TAG, "setCameraParameters");
	......................................................................................................
	   try {
			camera.setParameters(parameters);
	......................................................................................................


X:\root\myandroid\frameworks\base\core\java\android\hardware\Camera.java
    public void setParameters(Parameters params) {
    	// temp
    	Log.d(TAG, "In setParameters of Camera.java");
    	// tmep

        // If using preview allocations, don't allow preview size changes
        if (mUsingPreviewAllocation) {
            Size newPreviewSize = params.getPreviewSize();
            Size currentPreviewSize = getParameters().getPreviewSize();
            if (newPreviewSize.width != currentPreviewSize.width ||
                    newPreviewSize.height != currentPreviewSize.height) {
                throw new IllegalStateException("Cannot change preview size" +
                        " while a preview allocation is configured.");
            }
        }

        native_setParameters(params.flatten());
    }


X:\root\myandroid\frameworks\base\core\jni\android_hardware_Camera.cpp
static JNINativeMethod camMethods[] = {
	......................................................................................................
  { "native_setParameters",
    "(Ljava/lang/String;)V",
    (void *)android_hardware_Camera_setParameters },
	......................................................................................................

static void android_hardware_Camera_setParameters(JNIEnv *env, jobject thiz, jstring params)
{
    ALOGV("setParameters");
    sp<Camera> camera = get_native_camera(env, thiz, NULL);
    if (camera == 0) return;

    const jchar* str = env->GetStringCritical(params, 0);
    String8 params8;
    if (params) {
        params8 = String8(str, env->GetStringLength(params));
        env->ReleaseStringCritical(params, str);
    }
    if (camera->setParameters(params8) != NO_ERROR) {
	  // temp
	  ALOGI("camera->setParameters(params8) != NO_ERROR");
	  // temp
        jniThrowRuntimeException(env, "setParameters failed");
        return;
    }
}


X:\root\myandroid\frameworks\av\camera\Camera.cpp
status_t Camera::setParameters(const String8& params)
{
    ALOGV("setParameters");
    sp <ICamera> c = mCamera;
    if (c == 0) return NO_INIT;
    return c->setParameters(params);
}


X:\root\myandroid\frameworks\av\camera\ICamera.cpp
    status_t setParameters(const String8& params)
    {
        ALOGV("setParameters");
        Parcel data, reply;
        data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
        data.writeString8(params);
        remote()->transact(SET_PARAMETERS, data, &reply);
        return reply.readInt32();
    }


X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\Camera2Client.cpp
status_t Camera2Client::setParameters(const String8& params) {
    ATRACE_CALL();
    ALOGV("%s: Camera %d", __FUNCTION__, mCameraId);
    Mutex::Autolock icl(mBinderSerializationLock);
    status_t res;
    if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

    SharedParameters::Lock l(mParameters);

    res = l.mParameters.set(params);
    if (res != OK) return res;

    res = updateRequests(l.mParameters);

    // temp
    #if 0
    CameraParameters p(params);

    FSL_ASSERT(mDeviceAdapter.get() != NULL);
    res = mDeviceAdapter->setParameters(p);
    if (res) {
		FLOGE("CameraHal: initialize mDevice->setParameters failed");
		return res;
    }

    mParameters2 = params;
    #endif

    #if 1
    syncWithDevice();

    ALOGI("Start of CameraParameters p(params)");
    CameraParameters p(params);
    res = mDevice->setParameters(p);
    if (res) {
		ALOGE("Camera2Client::setParameters, mDevice->setParameters(p) failed");
		return res;
    }
    ALOGI("Camera2Client::setParameters, mDevice->setParameters(p) succeed = %d", res);
    #endif
    // temp

    return res;
}


X:\root\myandroid\frameworks\av\services\camera\libcameraservice\common\CameraDeviceBase.h
// temp
#include <camera/CameraParameters.h>
// temp

class CameraDeviceBase : public virtual RefBase {
	......................................................................................................
    // temp
//    virtual status_t setParameters(String8 params) = 0;
//    virtual status_t setParameters(const String8& params) = 0;
    virtual status_t setParameters(const CameraParameters &params) = 0;
    // temp
	......................................................................................................


X:\root\myandroid\frameworks\av\services\camera\libcameraservice\device2\Camera2Device.h
// temp
#include <camera/CameraParameters.h>
// temp

class Camera2Device: public CameraDeviceBase {
	......................................................................................................
    // temp
//    virtual status_t setParameters(String8 params);
//    virtual status_t setParameters(const String8& params);
    virtual status_t setParameters(const CameraParameters &params);
    // temp
	......................................................................................................


X:\root\myandroid\frameworks\av\services\camera\libcameraservice\device2\Camera2Device.cpp
// temp
//status_t Camera2Device::setParameters(String8 params)
//status_t Camera2Device::setParameters(const String8& params)
status_t Camera2Device::setParameters(const CameraParameters &params)
{
	ATRACE_CALL();
	ALOGV("%s: of Camera2Device::setParameters", __FUNCTION__);

#if 1
	if (mHal2Device->ops->set_Parameters)
	{
		ALOGV("(mHal2Device->ops->set_Parameters) == true");
		// String8 paramsFlattened;
		// paramsFlattened = newParams.flatten();
		return mHal2Device->ops->set_Parameters(mHal2Device,
										   params.flatten().string());
	}
#endif

	return INVALID_OPERATION;
}
// temp


camera2_device_ops_t fsl_camera_ops = {
	......................................................................................................
    dump:                                camera_dump,
    // temp
    set_Parameters:				set_Parameters,
    // temp
    get_instance_metadata:               NULL,
};


### Boundary Nitrogen6-MAX, Android Nougat 7.1.1 release for i.MX6 boards 의 경우 상단 ROUTINE 까지는 모두 구현되어 있는데
    바로 아래 Routine 부터 구현되어 있지 않음
X:\root\myandroid\hardware\imx\mx6\libcamera2\CameraModule.cpp
// temp
int set_Parameters(const struct camera2_device *device,
	const char *params)
{
	int ret = INVALID_OPERATION;
	CameraHal *camHal = fsl_get_camerahal(device);

	if (camHal != NULL) {
		ret = camHal->setParameters(params);
	}
	return ret;
}
// temp


X:\root\myandroid\hardware\libhardware\include\hardware\camera2.h
typedef struct camera2_device_ops {
	......................................................................................................
    // temp
    /**
     * setParameters state of the camera hardware
     */
    int (*set_Parameters)(const struct camera2_device *,
		const char *params);
    // temp
	......................................................................................................


X:\root\myandroid\hardware\imx\mx6\libcamera2\CameraHal.h
class CameraHal : public CameraErrorListener
{
public:
	......................................................................................................
    // temp
    status_t setParameters(const char *params);
    status_t setParameters(CameraParameters& params);
    // temp
	......................................................................................................
private:
	......................................................................................................
    // temp
    CameraParameters mParameters;
    sp<DeviceAdapter>  mDeviceAdapter;
    // temp
};


X:\root\myandroid\hardware\imx\mx6\libcamera2\CameraHal.cpp
// temp
status_t CameraHal::setParameters(const char *params)
{
	FLOGI("In CameraHal::setParameters(const char *params)");

	CameraParameters parameters;
	String8 str_params(params);

	parameters.unflatten(str_params);
	return setParameters(parameters);
}

status_t CameraHal::setParameters(CameraParameters& params)
{
	status_t ret = NO_ERROR;

	FLOGI("In CameraHal::setParameters(CameraParameters& params)");

#if 0
	FSL_ASSERT(mDeviceAdapter.get() != NULL);
	ret = mDeviceAdapter->setParameters(params);
	if (ret) {
		FLOGE("CameraHal: initialize mDevice->setParameters failed");
		return ret;
	}

	mParameters = params;
#elif 0
	int CameraHal::set_request_queue_src_ops(
		const camera2_request_queue_src_ops_t *request_src_ops)
	{
		// temp
		FLOGI("In CameraHal::set_request_queue_src_ops");
		// temp
		mRequestQueue = request_src_ops;
		return mRequestManager->setRequestOperation(request_src_ops);
	}
#elif 1
	ret = mRequestManager->setParameters(params);
	if (ret) {
		FLOGE("CameraHal::setParameters => mRequestManager->setParameters(params) failed");
		return ret;
	}

	mParameters = params;
#endif

	return ret;
}
// temp


X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.h
class RequestManager : public LightRefBase<RequestManager>,
                       public CameraErrorListener
{
	......................................................................................................
public:
	......................................................................................................
    // temp
    status_t setParameters(CameraParameters& params);
    // temp
	......................................................................................................
private:
	......................................................................................................
    // temp
    CameraParameters mParameters;
    // temp
};


X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.cpp
// temp
status_t RequestManager::setParameters(CameraParameters& params)
{
	FLOGI("In RequestManager::setParameters(CameraParameters& params)");

	status_t ret = NO_ERROR;

#if 1
	if(mDeviceAdapter.get() != NULL)
	{
		ret = mDeviceAdapter->setParameters(params);
		if (ret) {
			FLOGE("RequestManager::setParameters => mDeviceAdapter->setParameters(params) failed");
			return ret;
		}

		mParameters = params;
	}
	else
		return -1;
#endif
	return ret;
}
// temp


X:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5640Mipi.h
class Ov5640Mipi : public OvDevice {
public:
	virtual status_t initSensorInfo(const CameraInfo& info);
	// temp
	virtual status_t setParameters(CameraParameters& params);
	// temp
};


X:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5640Mipi.cpp
// temp
status_t Ov5640Mipi::setParameters(CameraParameters& params)
{
	......................................................................................................
#elif 1
	FLOGI("In Ov5640Mipi::setParameters");

	status_t ret = NO_ERROR;

	String8 params_str8;
	CameraParameters mParams = params;
	params_str8 = mParams.flatten();
	FLOGI("Ov5640Mipi::setParameters, CameraParameters mParams = %s", params_str8.string());

	if (mCameraHandle <= 0) {
		FLOGE("Ov5640Mipi::setParameters, mCameraHandle <= 0");
		return BAD_VALUE;
	}

	int newExposureCompensation = params.getInt(CameraParameters::KEY_EXPOSURE_COMPENSATION);
	FLOGI("newExposureCompensation = %d", newExposureCompensation);

	v4l2_control control;
	control.id = V4L2_CID_EXPOSURE;  
//	control.value = 52 + newExposureCompensation*3;						// cf) AE_Target = 52;
//	control.value = 300 + newExposureCompensation*100;						// cf) 0~600, newExposureCompensation = -3 ~ 3
	control.value = 900 + newExposureCompensation*300;						// cf) 0~1800, newExposureCompensation = -3 ~ 3
//	control.value = 3000 + newExposureCompensation*1000;					// cf) 0~6000, newExposureCompensation = -3 ~ 3
//	control.value = 6000 + newExposureCompensation*2000;					// cf) 1100~2900
//	control.value = 9000 + newExposureCompensation*3000;					// cf) 0~18000, newExposureCompensation = -3 ~ 3
//	control.value = 30000 + newExposureCompensation*10000;					// cf) 0~60000, newExposureCompensation = -3 ~ 3
//	control.value = 112 + newExposureCompensation*37;						// cf) 1~223, newExposureCompensation = -3 ~ 3

	ret = ioctl(mCameraHandle, VIDIOC_S_CTRL, &control);
	FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = %d", control.value);
	if (ret < 0) {
		FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control) Failed: %s", strerror(errno));
		return ret;
	}

	return ret;
#else
	FLOGI("In Ov5640Mipi::setParameters");
	return NO_ERROR;
#endif
}
// temp


/root/myandroid/kernel_imx/drivers/media/video/v4l2-ioctl.c
static long __video_do_ioctl(struct file *file,
	unsigned int cmd, void *arg)
{
	......................................................................................................
	case VIDIOC_S_CTRL:
	{
		struct v4l2_control *p = arg;
		struct v4l2_ext_controls ctrls;
		struct v4l2_ext_control ctrl;
				
		if (!vfd->ctrl_handler &&
			!ops->vidioc_s_ctrl && !ops->vidioc_s_ext_ctrls)
			break;
			
		dbgarg(cmd, "id=0x%x, value=%d\n", p->id, p->value);
				
		// temp
		printk(cmd, "id=0x%x, value=%d\n", p->id, p->value);
		// temp
				
		if (vfd->ctrl_handler) {
			ret = v4l2_s_ctrl(vfd->ctrl_handler, p);
			break;
		}
		if (ops->vidioc_s_ctrl) {
			ret = ops->vidioc_s_ctrl(file, fh, p);
			break;
		}
		if (!ops->vidioc_s_ext_ctrls)
			break;
				
		ctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);
		ctrls.count = 1;
		ctrls.controls = &ctrl;
		ctrl.id = p->id;
		ctrl.value = p->value;
		if (check_ext_ctrls(&ctrls, 1))
			ret = ops->vidioc_s_ext_ctrls(file, fh, &ctrls);
		break;
	}
	......................................................................................................


/root/myandroid/kernel_imx/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
{
	......................................................................................................
	case V4L2_CID_EXPOSURE:
		// temp
		pr_debug("cam->sensor = %d, c->value = %d\n", cam->sensor, c->value);
		// temp
		if (cam->sensor) {
			cam->ae_mode = c->value;
			ret = vidioc_int_s_ctrl(cam->sensor, c);
			// temp
			pr_debug("if (cam->sensor) == true\n");
			// temp
		} else {
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;
	......................................................................................................


X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\ov5640_mipi.c
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	......................................................................................................
	case V4L2_CID_EXPOSURE:								// = 9963793d = 0x980911
		AE_Target = vc->value;
		pr_debug("   V4L2_CID_EXPOSURE, AE_Target = %d\n", AE_Target);
		OV5640_set_AE_target(AE_Target);
		break;
	......................................................................................................

int OV5640_set_AE_target(int target)
{
#if 0
	/* stable in high */
	int fast_high, fast_low;
	AE_low = target * 23 / 25;	/* 0.92 */
	AE_high = target * 27 / 25;	/* 1.08 */
	// temp
//	AE_low = target * 15 / 25;	/* 0.92 */
//	AE_high = target * 35 / 25;	/* 1.08 */
	// temp

	fast_high = AE_high<<1;				// fast_high = AE_high * 2
	if (fast_high > 255)
		fast_high = 255;

	fast_low = AE_low >> 1;				// fast_low = AE_low / 2

	ov5640_write_reg(0x3a0f, AE_high);
	ov5640_write_reg(0x3a10, AE_low);
	ov5640_write_reg(0x3a1b, AE_high);
	ov5640_write_reg(0x3a1e, AE_low);
	ov5640_write_reg(0x3a11, fast_high);
	ov5640_write_reg(0x3a1f, fast_low);

	// temp
	pr_debug("target=%d, AE_low=%d, AE_high=%d\n", target, AE_low, AE_high);
	pr_debug("fast_high=%d, fast_low=%d\n", fast_high, fast_low);
	// temp

	return 0;
#elif 0
	int iTemp0 = 0, iTemp1 = 0, iTemp2 = 0, iTemp3 = 0;

	iTemp0 = target&0xffffff;				// 0xf1234
	iTemp1 = (iTemp0 >> 16)&0xff;			// 0xf
	iTemp2 = (iTemp0 >> 8)&0xff;				// 0x12
	iTemp3 = (iTemp0 >> 0)&0xff;				// 0x34

	ov5640_write_reg(0x3500, iTemp1);
	ov5640_write_reg(0x3501, iTemp2);
	ov5640_write_reg(0x3502, iTemp3);

	#if 0
	pr_debug("0x3402=%x, 0x3403=%x", iTemp5, iTemp4);

	iTemp4 = iTemp4 + 10;
	if(iTemp4 > 0xff)
	{
		ov5640_write_reg(0x3402, iTemp5);
		ov5640_write_reg(0x3403, iTemp4);

		iTemp4 = 0x00;
		iTemp5++;
	}
	#endif

	pr_debug("0x3500=%x, 0x3501=%x, 0x3502=%x", iTemp1, iTemp2, iTemp3);
	return 0;
#else
	/* 4.6.2 manual exposure control
		To manually change exposure value, you must first set both 0x3503[0], where 0x3503[0] enables manual exposure
		control. In auto exposure mode, the extra exposure values (larger than 1 frame) in registers 0x350C/0x350D
		automatically change. In manual exposure mode, these registers will not automatically change. The manually set
		exposure in registers 0x3500~0x3502 must be less than the maximum exposure value in {0x380E, 0x380F} +
		{0x350C,0x350D}. The exposure value in registers 0x3500~0x3502 is in units of line*16 - the low 4 bits (0x3502[3:0]) is
		the fraction of line, the maximum value in {0x380E + 0x380F} + {0x350C, 0x350D} is in unit of line. If the manually set
		exposure value is less than one pre-defined frame period (e.g., 1/15 second in 15fps), there is no need to change
		0x380E/0x380F. If the exposure value needs to be set beyond the pre-defined frame period; in other words, if the frame
		period needs to be extended to extend exposure time, then the maximum frame value in 0x380E/0x380F needs to be
		set first, then the exposure can be set in registers 0x3500~0x3502 accordingly.

		14.1 Shutter
		The shutter of OV5642 controls exposure time. The unit of shutter is line period.
		Shutter value has limitation for each output resolution. The limitation is stored in 2 registers,
		reg0x350c, reg0x350d
		Maxlines = reg0x350c<<8 + reg0x350d
		The shutter value are stored in 3 registers, reg0x3500, reg0x3501,reg3502 .
		Shutter = reg0x3500<<12+ reg0x3501<<4+reg3502>>4;

		참고)
			address		register name		default value	R/W		description
			0x3503 		AEC PK MANUAL 		0x00 			RW		AEC Manual Mode Control
																		Bit[1]: AGC manual
																			0: Auto enable
																			1: Manual enable
																		Bit[0]: AEC manual
																			0: Auto enable
																			1: Manual enable
			0x3500 		AEC PK EXPOSURE 	0x00 			RW 		Exposure Output,						cf)	Shutter value, Manual exposure mode일 경우 본 값을 조절해서 노출계수 조절
																		Bit[3:0]: Exposure [19:16]
			0x3501 		AEC PK EXPOSURE 	0x02 			RW 		Exposure Output,						cf)	Shutter value, Manual exposure mode일 경우 본 값을 조절해서 노출계수 조절
																		Bit[7:0]: Exposure [15:8]
			0x3502 		AEC PK EXPOSURE 	0x00 			RW		Exposure Output							cf)	Shutter value, Manual exposure mode일 경우 본 값을 조절해서 노출계수 조절
																		Bit[7:0]: Exposure [7:0]
																			Lower four bits are a fraction of a	line;
																			they should be 0 since OV5640 does not support
			0x350C 		AEC PK VTS 			0x00 			RW 		AEC VTS Output
																		Bit[7:0]: VTS[15:8]					cf)	Auto exposure mode에서는 주변환경에 따라서 자동으로 변경되지만
																												Manual exposure mode에서는 자동으로 변경되지 않고 Shutter value의 Limitation 값으로 사용 됨
			0x350D 		AEC PK VTS 			0x00 			RW 		AEC VTS Output							cf)	Auto exposure mode에서는 주변환경에 따라서 자동으로 변경되지만
																												Manual exposure mode에서는 자동으로 변경되지 않고 Shutter value의 Limitation 값으로 사용 됨
																		Bit[7:0]: VTS[7:0]

			0x380E 		TIMING VTS 			0x07 			RW 		Bit[7:0]: Total vertical size[15:8]		cf)	maximum frame value		
			0x380F 		TIMING VTS 			0xB0 			RW 		Bit[7:0]: Total vertical size[7:0]		cf)	maximum frame value

		예제)
			OV5640_set_shutter(target);에서의 target 값을 0~1800으로 설정하고
			ov5640_write_reg(0x350c, 5);
			ov5640_write_reg(0x380e, 10);					// 설정값을 5로 하면 본 0x350c & 0x380e register값을 수정하지 않은 노출영상과 비슷한 결과를 출력하며
															// 설정값을 10으로 하면 본 0x350c & 0x380e register값을 수정하지 않은 영상 보다 노출 정도가 2배 정도 증가된 영상이 출력됨
															// 설정값 10이상 부터는 10으로 설정한 경우 대비 별다른 차이점이 없음
			으로 설정하니 기존 보다 더 노출계수 효과가 늘어 났다.
	*/

	#if 1
	ov5640_write_reg(0x350c, 5);
	ov5640_write_reg(0x350d, 0);
	ov5640_write_reg(0x380e, 10);
	ov5640_write_reg(0x380f, 0);
	#endif

	OV5640_set_shutter(target);

	return 0;
#endif
}

cf) 아래와 같이 카메라 레지스터를 셋팅하면 수동으로 노출계수를 최대로 설정한 환경으로 변경할 수 있을 것 같다.
	#if 1
	ov5640_write_reg(0x3503, 0x07);
	ov5640_write_reg(0x3500, 0xff);
	ov5640_write_reg(0x3501, 0xff);
	ov5640_write_reg(0x3502, 0xff);
	ov5640_write_reg(0x350c, 0xff);
	ov5640_write_reg(0x350d, 0xff);
	ov5640_write_reg(0x380e, 0xff);
	ov5640_write_reg(0x380f, 0xff);
	#endif




		파)	Capture images using V4L2 on Linux
Posted on 25 June 2013
Under Blog
Tagged Open Source
Tweet 
I have always been using OpenCV’s VideoCapture API to capture images from webcam or USB cameras. 
OpenCV supports V4L2 and I wanted to use something other than OpenCV’s VideoCapture API so I started digging up about v4l2 and got few links using and few examples 
using which I successfully wrote a small code to grab an image using V4L2 and convert it to OpenCV’s Mat structure and display the image.

What is V4L2?
V4L2 is the second version of Video For Linux which is a video capturing API for Linux. 
Here you can find amazing documentation about the API. So it gives you a very easy inteface to use it with C, C++ and Python. I haven’t tried Python bindings yet.

How To Use V4L2 API?
I started reading documentation but didn’t really understand much until I found this example. 
The code had some issues and wasn’t working properly. But I just copied it and tried understanding it. So this is my understanding of the code.

Step 1: Open the Capture Device.
In Linux, default capture devide is generally /dev/video0, but if you’re using USB webcams, the index will vary accordingly.

int fd;
fd = open("/dev/video0", O_RDWR);
if (fd == -1)
{
    // couldn't find capture device
    perror("Opening Video device");
    return 1;
}

Step 2: Query the Capture
So, basically you check if the capture is available or not. V4L2 doesn’t support some cameras so it would throw an error here. 
We need to use v4l2_capability structure and VIDIOC_QUERYCAP to query the capture. Read More here.

struct v4l2_capability caps = {0};
if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &caps))
{
    perror("Querying Capabilites");
    return 1;
}

Here xioctl is a wrapper function over ioctl. ioctl() is a function to manipulate device parameters of special files. Read more here.

#include <sys/ioctl.h>

static int xioctl(int fd, int request, void *arg)
{
    int r;
        do r = ioctl (fd, request, arg);
        while (-1 == r && EINTR == errno);
        return r;
}

Step 3: Image Format
V4L2 provides an easy interface to check the image formats and colorspace that your webcam supports and provide. 
v4l2_format sturcture is to be used to change image format.

struct v4l2_format fmt = {0};
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.width = 320;
fmt.fmt.pix.height = 240;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;
fmt.fmt.pix.field = V4L2_FIELD_NONE;

if (-1 == xioctl(fd, VIDIOC_S_FMT, &fmt))
{
    perror("Setting Pixel Format");
    return 1;
}

I have set image width and height to be 320 and 240 respectively. You should check out the format that your camera supports. 
My Camera supports MJPEG and YUV and hence I have set image format to MJPEG.

Step 4: Request Buffers
A buffer contains data exchanged by application and driver using Streaming I/O methods. 
v4l2_requestbuffers is used to allocate device buffers. Read more here.

struct v4l2_requestbuffers req = {0};
req.count = 1;
req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
req.memory = V4L2_MEMORY_MMAP;
 
if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req))
{
    perror("Requesting Buffer");
    return 1;
}

The ioctl is used to initialize memory mapped(mmap), user pointer based I/O.

Step 5: Query Buffer
After requesting buffer from the device, we need to query the buffer in order to get raw data. Read more here

struct v4l2_buffer buf = {0};
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.memory = V4L2_MEMORY_MMAP;
buf.index = bufferindex;
if(-1 == xioctl(fd, VIDIOC_QUERYBUF, &buf))
{
    perror("Querying Buffer");
    return 1;
}

buffer = mmap (NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset);

The mmap() function asks to map length bytes starting at offset in the memory of the device specified 
by fd into the application address space, preferably at address start. Read more here

Step 6: Capture Image
After querying the buffer, the only thing left is capturing the frame and saving it in the buffer.

if(-1 == xioctl(fd, VIDIOC_STREAMON, &buf.type))
{
    perror("Start Capture");
    return 1;
}
 
fd_set fds;
FD_ZERO(&fds);
FD_SET(fd, &fds);
struct timeval tv = {0};
tv.tv_sec = 2;
int r = select(fd+1, &fds, NULL, NULL, &tv);
if(-1 == r)
{
    perror("Waiting for Frame");
    return 1;
}
 
if(-1 == xioctl(fd, VIDIOC_DQBUF, &buf))
{
    perror("Retrieving Frame");
    return 1;
}

Step 7: Store data in OpenCV datatype
I wanted to stored the retrieved data in OpenCV image structure. It took me few hours to figure out the perfect way. So here’s how I did it.

CvMat cvmat = cvMat(480, 640, CV_8UC3, (void*)buffer);
IplImage * img;
img = cvDecodeImage(&cvmat, 1);

So this how I captured frames from my webcam and stored in OpenCV Image data structure.

You can find the complete code here on my GitHub

P.S. Coding period for gsoc has started and I have to start working.

comments powered by Disqus 
If you have some feedback or questions regarding this post, please add comments. I'd be happy to get some feedback.


		하)	OpenCamera_old & i.mx6 보드 카메라 캡쳐 / 촬영 sequence
Camera driver(V4L2) 에 관한 간략한 설명
원본 : Camera driver(V4L2) 에 관한 간략한 설명 - MIZI Wiki by 구글캐쉬

V4L2 프로그램 구조(카메라 드라이버와 관련된)
- 쓰는 파일오퍼레이션의 종류

mmap() - VIDIOC_REQBUFS를 통해 할당한 버퍼를 mmap을 이용해 유저 공간에 맵핑해서 사용. 원래 read(), mmap(), 
user pointer 세 가지 경우가 있으나 일단 지금은 mmap()의 경우만 지원함.
ioctl()
poll()

- ioctl operation의 종류 
  VIDIOC_QUERYCAP (Query Capability) : 드라이버가 할 수 있는 정도를 유저가 요청
  VIDIOC_G_FMT (Get format) : 현재 드라이버에서 사용하는 format을 유저가 요청
  VIDIOC_S_FMT (Set format) : 드라이버에서 사용할 format을 유저가 지정
  VIDIOC_STREAMON (stream on) : 카메라의 스트림을 켬
  VIDIOC_STREAMOFF (stream off) : 카메라의 스트림을 끔
  VIDIOC_QUERYBUF (query buffer) : 특정 버퍼 정보 요청. offset값을 얻을때 사용.
  VIDIOC_QBUF (queue buffer) : 새로운 프레임을 달라고 드라이버에 요청
  VIDIOC_DQBUF (dequeue buffer) : 새로운 프레임을 가지고 감
  VIDIOC_REQBUFS (request buffers) : 버퍼를 할당하라고 드라이버에 요구함

- 흐름
	1.	.camera device를 open
	2.	.VIDIOC_QUERYCAP을 통해 Capture가 가능한지(V4L2_CAP_VIDEO_CAPTURE), 스트리밍 방식인지(V4L2_CAP_STREAMING) 판별
	3.	.VIDIOC_S_FMT를 통해 가지고 올 카메라 데이터의 포맷을 결정(버퍼 타입, 해상도, 컬러스페이스 등, 원래 픽셀 포맷도 결정해야
  		하나 일단은 이에 대해서는 지원하지 않음)
	4.	.VIDIOC_REQBUFS를 통해 버퍼를 결정(버퍼의 개수, 버퍼 타입, read, mmap, user pointer 방식 선택)
	5.	.VIDIOC_QUERYBUF를 통해, 원하는 버퍼의 인덱스를 넘겨주고 그 버퍼의 오프셋 정보를 가져옴.
		이 정보를 이용해 mmap()을 통해 버퍼를 유저공간에 맵핑함. 버퍼에 할당하는 공간만큼 메모리를 할당받아서
		( calloc(req.count, sizeof(*buffers)) ) 각각의 버퍼에 대해 따로 mmap()을 통해 공간을 할당함.
		즉 버퍼가 4개라면 0번 버퍼의 정보를 얻기 위해 VIDIOC_QUERYBUF, 인덱스는 0, ioctl을 실행하고
		그 결과 넘어온 버퍼의 offset값에 따라 mmap을 통해 그 버퍼에 대한 공간을 맵핑. 1번, 2번, 3번에 대해서도 
		똑같은 작업을 반복함. VIDIOC_QUERYBUF와 mmap()이 각각 네 번씩 실행.
	6.	.VIDIOC_QBUF를 통해 프레임을 달라고 요청
	7.	.VIDIOC_STREAMON을 통해 스트림을 켬.
	8.	.polling을 통해 새 프레임이 들어오기를 기다림.
	9.	.새 프레임이 들어오면 DQBUF를 통해 새로 들어온 프레임의 인덱스(!)를 가져옴.
	10.	.가져온 인덱스를 통해 mmap된 메모리 공간에서 이미지 데이터를 가져옴.
	11.	.다시 QBUF를 통해 프레임을 달라고 요청. 이 작업을 반복해서 데이터를 계속적으로 가져감.
	12.	.VIDIOC_STREAMOFF를 통해 스트림을 끔. munmap을 통해 메모리를 해제.
	13.	.camera device를 close

위 flow를 코드로 확인하려면 v4l2 spec에 함께 포함되어 있는 caputre.c 파일을 참조 


Step 1:	C:\Program Files\Program\Java\workspace\OpenCamera_old\src\net\sourceforge\opencamera\CameraController.java
	void takePicture(final CameraController.PictureCallback raw, final CameraController.PictureCallback jpeg) {
    	Camera.ShutterCallback shutter = new Camera.ShutterCallback() {
    		// don't do anything here, but we need to implement the callback to get the shutter sound (at least on Galaxy Nexus and Nexus 7)
            public void onShutter() {
    			if( MyDebug.LOG )
    				Log.d(TAG, "shutterCallback.onShutter()");
            }
        };
        Camera.PictureCallback camera_raw = raw == null ? null : new Camera.PictureCallback() {
    	    public void onPictureTaken(byte[] data, Camera cam) {
    	    	// n.b., this is automatically run in a different thread
    	    	raw.onPictureTaken(data);
    	    }
        };
        Camera.PictureCallback camera_jpeg = jpeg == null ? null : new Camera.PictureCallback() {
    	    public void onPictureTaken(byte[] data, Camera cam) {
    	    	// n.b., this is automatically run in a different thread
    	    	jpeg.onPictureTaken(data);
    	    }
        };

		camera.takePicture(shutter, camera_raw, camera_jpeg);
	}

Step 2:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\CaptureSequencer.cpp
status_t CaptureSequencer::startCapture(int msgType) {
    ALOGV("%s", __FUNCTION__);
    ATRACE_CALL();
    Mutex::Autolock l(mInputMutex);
    if (mBusy) {
        ALOGE("%s: Already busy capturing!", __FUNCTION__);
        return INVALID_OPERATION;
    }
    if (!mStartCapture) {
        mMsgType = msgType;
        mStartCapture = true;
        mStartCaptureSignal.signal();
    }
    return OK;
}

Step 3:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\CaptureSequencer.cpp
bool CaptureSequencer::threadLoop() {

    sp<Camera2Client> client = mClient.promote();
    if (client == 0) return false;

    CaptureState currentState;
    {
        Mutex::Autolock l(mStateMutex);
        currentState = mCaptureState;
    }

    currentState = (this->*kStateManagers[currentState])(client);

    Mutex::Autolock l(mStateMutex);
    if (currentState != mCaptureState) {
        if (mCaptureState != IDLE) {
            ATRACE_ASYNC_END(kStateNames[mCaptureState], mStateTransitionCount);
        }
        mCaptureState = currentState;
        mStateTransitionCount++;
        if (mCaptureState != IDLE) {
            ATRACE_ASYNC_BEGIN(kStateNames[mCaptureState], mStateTransitionCount);
        }
        ALOGV("Camera %d: New capture state %s",
                client->getCameraId(), kStateNames[mCaptureState]);
        mStateChanged.signal();
    }

    if (mCaptureState == ERROR) {
        ALOGE("Camera %d: Stopping capture sequencer due to error",
                client->getCameraId());
        return false;
    }

    return true;
}

Step 4:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\CaptureSequencer.cpp
CaptureSequencer::CaptureState CaptureSequencer::manageStart(
        sp<Camera2Client> &client) {
    ALOGV("%s", __FUNCTION__);
    status_t res;
    ATRACE_CALL();
    SharedParameters::Lock l(client->getParameters());
    CaptureState nextState = DONE;

    res = updateCaptureRequest(l.mParameters, client);
    if (res != OK ) {
        ALOGE("%s: Camera %d: Can't update still image capture request: %s (%d)",
                __FUNCTION__, client->getCameraId(), strerror(-res), res);
        return DONE;
    }

    if(l.mParameters.lightFx != Parameters::LIGHTFX_NONE &&
            l.mParameters.state == Parameters::STILL_CAPTURE) {
        nextState = BURST_CAPTURE_START;
    }
    else if (l.mParameters.zslMode &&
            l.mParameters.state == Parameters::STILL_CAPTURE &&
            l.mParameters.flashMode != Parameters::FLASH_MODE_ON) {
        nextState = ZSL_START;
    } else {
        nextState = STANDARD_START;
    }
    mShutterNotified = false;

    return nextState;
}

Step 5:	X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.cpp
bool RequestManager::handleRequest()
{
    FLOG_TRACE("%s running", __FUNCTION__);
    int res;
    camera_metadata_t *request=NULL;

    while(mRequestOperation && mWorkInProcess) {
        FLOG_RUNTIME("%s:Dequeue request" ,__FUNCTION__);
        mRequestOperation->dequeue_request(mRequestOperation, &request);
        if(request == NULL) {
            FLOGE("%s:No more requests available", __FUNCTION__);
            break;
        }

        /* Check the streams that need to be active in the stream request */
        sort_camera_metadata(request);

        res = mMetadaManager->setCurrentRequest(request);
        if (res != NO_ERROR) {
            FLOGE("%s: setCurrentRequest failed", __FUNCTION__);
            mRequestThread.clear();
            mPendingRequests--;
            sem_post(&mThreadExitSem);
            return false;
        }

        int requestType = 0;
        mMetadaManager->getRequestType(&requestType);
        FLOG_RUNTIME("%s:start request %d", __FUNCTION__, requestType);

        int numEntries = 0;
        int frameSize = 0;
        numEntries = get_camera_metadata_entry_count(request);
        frameSize = get_camera_metadata_size(request);
        camera_metadata_t *currentFrame = NULL;
        res = mFrameOperation->dequeue_frame(mFrameOperation, numEntries,
                               frameSize, &currentFrame);
        if (res < 0) {
            FLOGE("%s: dequeue_frame failed", __FUNCTION__);
            currentFrame = NULL;
        }
        else {
            res = mMetadaManager->generateFrameRequest(currentFrame);
            if (res == 0) {
                mFrameOperation->enqueue_frame(mFrameOperation, currentFrame);
            }
            else {
                mFrameOperation->cancel_frame(mFrameOperation, currentFrame);
            }
        }

        res = tryRestartStreams(requestType);
        if (res != NO_ERROR) {
            FLOGE("%s: tryRestartStreams failed", __FUNCTION__);
            mRequestThread.clear();
            mPendingRequests--;
            sem_post(&mThreadExitSem);
            return false;
        }

        /* Free the request buffer */
        mRequestOperation->free_request(mRequestOperation, request);
        FLOG_RUNTIME("%s:Completed request %d", __FUNCTION__, requestType);
    }//end while

Step 6:	X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.cpp
int RequestManager::tryRestartStreams(int requestType)
{
    FLOG_RUNTIME("%s running", __FUNCTION__);
    int res = 0;
    int fps = 30;
    res = mMetadaManager->getFrameRate(&fps);
    if (res != NO_ERROR) {
        FLOGE("%s: getFrameRate failed", __FUNCTION__);
        return res;
    }

    camera_metadata_entry_t streams;
    res = mMetadaManager->getRequestStreams(&streams);
    if (res != NO_ERROR) {
        FLOGE("%s: getRequestStreams failed", __FUNCTION__);
        return res;
    }

    bool streamRecord = false;
    bool streamPicture = false;
    bool videoSnapshot = false;
    for (uint32_t i = 0; i < streams.count; i++) {
        int streamId = streams.data.i32[i];
        if (streamId == STREAM_ID_RECORD) {
            streamRecord = true;
        }
        else if (streamId == STREAM_ID_JPEG) {
            streamPicture = true;
        }
    }

    if (streamRecord && streamPicture) {
        videoSnapshot = true;
    }

    for (int id = 0; id < MAX_STREAM_NUM; id++) {
        sp<StreamAdapter> stream = mStreamAdapter[id];
        if (!isStreamValid(requestType, id, videoSnapshot)) {
            if (stream.get() != NULL && stream->mPrepared) {
                FLOGI("%s stop unused stream %d", __FUNCTION__, id);
                stopStream(id);
            }
        }
    }

Step 7:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\CaptureSequencer.cpp
void CaptureSequencer::onFrameAvailable(int32_t requestId,
        const CameraMetadata &frame) {
    ALOGV("%s: Listener found new frame", __FUNCTION__);
    ATRACE_CALL();
    Mutex::Autolock l(mInputMutex);
    mNewFrameId = requestId;
    mNewFrame = frame;
    if (!mNewFrameReceived) {
        mNewFrameReceived = true;
        mNewFrameSignal.signal();
    }    
}

Step 7+1:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\CaptureSequencer.cpp
/*static*/ void CaptureSequencer::shutterNotifyLocked(const Parameters &params,
            sp<Camera2Client> client, int msgType) {
    ATRACE_CALL();

    if (params.state == Parameters::STILL_CAPTURE
        && params.playShutterSound
        && (msgType & CAMERA_MSG_SHUTTER)) {
        client->getCameraService()->playSound(CameraService::SOUND_SHUTTER);
    }

    {
        Camera2Client::SharedCameraCallbacks::Lock
            l(client->mSharedCameraCallbacks);

        ALOGV("%s: Notifying of shutter close to client", __FUNCTION__);
        if (l.mRemoteCallback != 0) {
            // ShutterCallback
            l.mRemoteCallback->notifyCallback(CAMERA_MSG_SHUTTER,
                                            /*ext1*/0, /*ext2*/0);

            // RawCallback with null buffer
            l.mRemoteCallback->notifyCallback(CAMERA_MSG_RAW_IMAGE_NOTIFY,
                                            /*ext1*/0, /*ext2*/0);
        } else {
            ALOGV("%s: No client!", __FUNCTION__);
        }
    }
}

C:\Program Files\Program\Java\workspace\OpenCamera_old\src\net\sourceforge\opencamera\CameraController.java
	void takePicture(final CameraController.PictureCallback raw, final CameraController.PictureCallback jpeg) {
    	Camera.ShutterCallback shutter = new Camera.ShutterCallback() {
    		// don't do anything here, but we need to implement the callback to get the shutter sound (at least on Galaxy Nexus and Nexus 7)
            public void onShutter() {
    			if( MyDebug.LOG )
    				Log.d(TAG, "shutterCallback.onShutter()");
            }
        };

X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.cpp
int RequestManager::allocateStream(uint32_t width,
        uint32_t height, int format,
        const camera2_stream_ops_t *stream_ops,
        uint32_t *stream_id,
        uint32_t *format_actual,
        uint32_t *usage,
        uint32_t *max_buffers)
{
	......................................................................................................
    else if (format == HAL_PIXEL_FORMAT_BLOB) {
        FLOGI("%s jpeg stream, w:%d, h:%d, fmt:0x%x", __FUNCTION__,
                      width, height, format);
        //*format_actual = HAL_PIXEL_FORMAT_BLOB;
        *usage = CAMERA_GRALLOC_USAGE_JPEG;
        *format_actual = mDeviceAdapter->getPicturePixelFormat();
        FLOGI("actual format 0x%x", *format_actual);
        sid = STREAM_ID_JPEG;
        *max_buffers = NUM_CAPTURE_BUFFER;

        cameraStream = new CaptureStream(sid);
    }
	......................................................................................................
    mStreamAdapter[sid] = cameraStream;
    FLOG_TRACE("RequestManager %s end...", __FUNCTION__);

    return 0;
}

X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.cpp
bool RequestManager::handleRequest()
{
    FLOG_TRACE("%s running", __FUNCTION__);
    int res;
    camera_metadata_t *request=NULL;

    while(mRequestOperation && mWorkInProcess) {
        FLOG_RUNTIME("%s:Dequeue request" ,__FUNCTION__);
        mRequestOperation->dequeue_request(mRequestOperation, &request);
        if(request == NULL) {
            FLOGE("%s:No more requests available", __FUNCTION__);
            break;
        }

        /* Check the streams that need to be active in the stream request */
        sort_camera_metadata(request);

        res = mMetadaManager->setCurrentRequest(request);
        if (res != NO_ERROR) {
            FLOGE("%s: setCurrentRequest failed", __FUNCTION__);
            mRequestThread.clear();
            mPendingRequests--;
            sem_post(&mThreadExitSem);
            return false;
        }

        int requestType = 0;
        mMetadaManager->getRequestType(&requestType);
        FLOG_RUNTIME("%s:start request %d", __FUNCTION__, requestType);

        int numEntries = 0;
        int frameSize = 0;
        numEntries = get_camera_metadata_entry_count(request);
        frameSize = get_camera_metadata_size(request);
        camera_metadata_t *currentFrame = NULL;
        res = mFrameOperation->dequeue_frame(mFrameOperation, numEntries,
                               frameSize, &currentFrame);
        if (res < 0) {
            FLOGE("%s: dequeue_frame failed", __FUNCTION__);
            currentFrame = NULL;
        }
        else {
            res = mMetadaManager->generateFrameRequest(currentFrame);
            if (res == 0) {
                mFrameOperation->enqueue_frame(mFrameOperation, currentFrame);
            }
            else {
                mFrameOperation->cancel_frame(mFrameOperation, currentFrame);
            }
        }

        res = tryRestartStreams(requestType);
        if (res != NO_ERROR) {
            FLOGE("%s: tryRestartStreams failed", __FUNCTION__);
            mRequestThread.clear();
            mPendingRequests--;
            sem_post(&mThreadExitSem);
            return false;
        }
	......................................................................................................

int RequestManager::tryRestartStreams(int requestType)
{
    FLOG_RUNTIME("%s running", __FUNCTION__);
    int res = 0;
    int fps = 30;
    res = mMetadaManager->getFrameRate(&fps);
    if (res != NO_ERROR) {
        FLOGE("%s: getFrameRate failed", __FUNCTION__);
        return res;
    }

    camera_metadata_entry_t streams;
    res = mMetadaManager->getRequestStreams(&streams);
    if (res != NO_ERROR) {
        FLOGE("%s: getRequestStreams failed", __FUNCTION__);
        return res;
    }

    bool streamRecord = false;
    bool streamPicture = false;
    bool videoSnapshot = false;
    for (uint32_t i = 0; i < streams.count; i++) {
        int streamId = streams.data.i32[i];
        if (streamId == STREAM_ID_RECORD) {
            streamRecord = true;
        }
        else if (streamId == STREAM_ID_JPEG) {
            streamPicture = true;
        }
    }

    if (streamRecord && streamPicture) {
        videoSnapshot = true;
    }

    for (int id = 0; id < MAX_STREAM_NUM; id++) {
        sp<StreamAdapter> stream = mStreamAdapter[id];
        if (!isStreamValid(requestType, id, videoSnapshot)) {
            if (stream.get() != NULL && stream->mPrepared) {
                FLOGI("%s stop unused stream %d", __FUNCTION__, id);
                stopStream(id);
            }
        }
    }

    for (uint32_t i = 0; i < streams.count; i++) {
        int streamId = streams.data.i32[i];
        if (!isStreamValid(requestType, streamId, videoSnapshot)) {
            continue;
        }
        sp<StreamAdapter> stream = mStreamAdapter[streamId];
        if (stream.get() == NULL) {
            continue;
        }

        if (!stream->mPrepared) {
            res = stream->configure(fps, videoSnapshot);
            if (res != NO_ERROR) {
                FLOGE("error configure stream %d", res);
                return res;
            }
        }

        stream->enableReceiveFrame();
        if (!stream->mStarted) {
            res = stream->start();
            if (res != NO_ERROR) {
                FLOGE("error start stream %d", res);
                return res;
            }
        }
    }

    for (uint32_t i = 0; i < streams.count; i++) {
        int streamId = streams.data.i32[i];
        if (!isStreamValid(requestType, streamId, videoSnapshot)) {
            continue;
        }

        sp<StreamAdapter> stream = mStreamAdapter[streamId];
        if (stream.get() == NULL) {
            continue;
        }

        if (!stream->mPrepared || !stream->mStarted) {
            continue;
        }

        stream->applyRequest();
    }

    return res;
}

X:\root\myandroid\hardware\imx\mx6\libcamera2\CaptureStream.cpp
int CaptureStream::configure(int fps, bool videoSnapshot)
{
    FLOG_TRACE("CaptureStream::configure");
    int stride = 0;
    int index = -1;
    int ret = NO_ERROR;
    int errCode = 0;

    mJpegBuilder->reset();
    mJpegBuilder->setMetadaManager(mMetadaManager);

    if (mFormat == HAL_PIXEL_FORMAT_BLOB) {
        mActualFormat = mDeviceAdapter->getPicturePixelFormat();
        //fmt = HAL_PIXEL_FORMAT_YCbCr_420_SP;
    }
    else {
        mActualFormat = mFormat;
    }

    mVideoSnapShot = videoSnapshot;
    if (mVideoSnapShot) {
        FLOGE("%s video Snapshot", __FUNCTION__);
        mPrepared = true;
        return ret;
    }

    fAssert(mDeviceAdapter.get() != NULL);
    ret = mDeviceAdapter->setDeviceConfig(mWidth, mHeight, mActualFormat, fps);
    if (ret != NO_ERROR) {
        FLOGE("%s setDeviceConfig failed", __FUNCTION__);
        errCode = CAMERA2_MSG_ERROR_DEVICE;
        goto fail;
    }

    fAssert(mPhysMemAdapter != NULL);
    mDeviceAdapter->setCameraBufferProvide(mPhysMemAdapter);

    ret = mPhysMemAdapter->allocateBuffers(mWidth, mHeight,
                        mActualFormat, 2/*MAX_CAPTURE_BUFFER*/);
	......................................................................................................

X:\root\myandroid\hardware\imx\mx6\libcamera2\PhysMemAdapter.cpp
int PhysMemAdapter::allocateBuffers(int width,int height,
                                   int format, int numBufs)
{
	......................................................................................................
    dispatchBuffers(&mCameraBuffer[0], numBufs, BUFFER_CREATE);

    return NO_ERROR;
}

void CameraBufferProvider::dispatchBuffers(CameraFrame *pBuffer,
                                           int          num,
                                           BufferState  bufState)
{
    CameraBufferListener *listener;
    size_t nSize = mBufferListeners.size();

    for (size_t i = 0; i < nSize; i++) {
        listener = (CameraBufferListener *)mBufferListeners[i];
        switch (bufState) {
            case BUFFER_CREATE:
                fAssert(pBuffer != NULL);
                listener->onBufferCreat(pBuffer, num);
                break;

            case BUFFER_DESTROY:
                listener->onBufferDestroy();
                break;
        } // end switch
    }     // end for
}

void DeviceAdapter::onBufferCreat(CameraFrame *pBuffer,
                                  int          num)
{
    registerCameraBuffers(pBuffer, num);
}

status_t DeviceAdapter::registerCameraBuffers(CameraFrame *pBuffer,
                                             int        & num)
{
    status_t ret = NO_ERROR;

    if ((pBuffer == NULL) || (num <= 0)) {
        FLOGE("requestCameraBuffers invalid pBuffer");
        return BAD_VALUE;
    }

    struct v4l2_requestbuffers req;
    memset(&req, 0, sizeof (req));
    req.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    req.memory = V4L2_MEMORY_USERPTR;
    req.count  = num;

    ret = ioctl(mCameraHandle, VIDIOC_REQBUFS, &req);
    if (ret < 0) {
        FLOGE("VIDIOC_REQBUFS failed: %s", strerror(errno));
        return ret;
    }

    struct v4l2_buffer buf;
    for (int i = 0; i < num; i++) {
        CameraFrame *buffer = pBuffer + i;
        memset(&buf, 0, sizeof (buf));
        buf.index    = i;
        buf.type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory   = V4L2_MEMORY_USERPTR;
        buf.m.offset = buffer->mPhyAddr;
        buf.length   = buffer->mSize;

        ret = ioctl(mCameraHandle, VIDIOC_QUERYBUF, &buf);
        if (ret < 0) {
            FLOGE("Unable to query buffer (%s)", strerror(errno));
            return ret;
        }

        // Associate each Camera buffer
        buffer->setObserver(this);
        mDeviceBufs[i] = buffer;
    }

    mBufferSize  = pBuffer->mSize;
    mBufferCount = num;

    return ret;
}

X:\root\myandroid\hardware\imx\mx6\libcamera2\CaptureStream.cpp
int CaptureStream::start()
{
    FLOG_TRACE("CaptureStream::start");
    int ret = 0;
    StreamAdapter::start();

    if (mVideoSnapShot) {
        FLOGE("%s video Snapshot", __FUNCTION__);
        return ret;
    }

    fAssert(mDeviceAdapter.get() != NULL);
    ret = mDeviceAdapter->startImageCapture();
    if (ret != NO_ERROR) {
        FLOGE("Couldn't start preview for DeviceAdapter");
        return ret;
    }
    return NO_ERROR;
}

X:\root\myandroid\hardware\imx\mx6\libcamera2\StreamAdapter.cpp
int StreamAdapter::start()
{
    FLOG_TRACE("StreamAdapter %s running", __FUNCTION__);

    mTime1 = mTime2 = 0;
    mTotalFrames = mFps = 0;
    mShowFps = false;
    char prop_value[CAMERA_SENSOR_LENGTH];
    if (property_get("sys.camera.fps", prop_value, "0")) {
        if (strcmp(prop_value, "1") == 0) {
            mShowFps = true;
        }
    }

    mStreamThread = new StreamThread(this);
    mThreadQueue.postSyncMessage(new SyncMessage(STREAM_START, 0));

    fAssert(mDeviceAdapter.get() != NULL);
    mDeviceAdapter->addFrameListener(this);
    mStarted = true;
    return NO_ERROR;
}

X:\root\myandroid\hardware\imx\mx6\libcamera2\DeviceAdapter.cpp
status_t DeviceAdapter::startImageCapture()
{
    status_t ret = NO_ERROR;

    if (mImageCapture) {
        FLOGE("DeviceAdapter: startPreview but preview running");
        return BAD_VALUE;
    }

    Mutex::Autolock lock(mBufsLock);
    mImageCapture = true;
    ret           = startDeviceLocked();

    return ret;
}

status_t DeviceAdapter::startDeviceLocked()
{
    status_t ret = NO_ERROR;

    fAssert(mBufferProvider != NULL);

    int state;
    struct v4l2_buffer buf;
    for (int i = 0; i < mBufferCount; i++) {
        CameraFrame* frame = mDeviceBufs[i];
        state = frame->getState();
        if (state != CameraFrame::BUFS_FREE) {
            continue;
        }
        frame->setState(CameraFrame::BUFS_IN_DRIVER);

        memset(&buf, 0, sizeof (struct v4l2_buffer));
        buf.index    = i;
        buf.type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        buf.memory   = V4L2_MEMORY_USERPTR;
        buf.m.offset = frame->mPhyAddr;
        ret = ioctl(mCameraHandle, VIDIOC_QBUF, &buf);
        if (ret < 0) {
            FLOGE("VIDIOC_QBUF Failed");
            return BAD_VALUE;
        }

        android_atomic_inc(&mQueued);
    }

    enum v4l2_buf_type bufType;
    if (!mVideoInfo->isStreamOn) {
        bufType = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        ret = ioctl(mCameraHandle, VIDIOC_STREAMON, &bufType);
        if (ret < 0) {
            FLOGE("VIDIOC_STREAMON failed: %s", strerror(errno));
            return ret;
        }

        mVideoInfo->isStreamOn = true;
    }

    mDeviceThread = new DeviceThread(this);

    FLOGI("Created device thread");
    return ret;
}



X:\root\myandroid\hardware\imx\mx6\libcamera2\RequestManager.cpp
bool RequestManager::handleRequest()
{
	......................................................................................................
    FLOG_TRACE("%s exiting", __FUNCTION__);
    stopAllStreams();
	......................................................................................................

void RequestManager::stopAllStreams()
{
    FLOG_TRACE("%s running", __FUNCTION__);
    for (int id = 0; id < MAX_STREAM_NUM; id++) {
        stopStream(id);
    }
    FLOG_TRACE("%s end", __FUNCTION__);
}

void RequestManager::stopStream(int id)
{
    sp<StreamAdapter> cameraStream = mStreamAdapter[id];
    FLOG_RUNTIME("%s steam id:%d", __FUNCTION__, id);
    if (cameraStream.get() != NULL) {
        if (cameraStream->mStarted) {
            cameraStream->stop();
        }
        if (cameraStream->mPrepared) {
            cameraStream->release();
        }
    }
    FLOG_RUNTIME("%s end", __FUNCTION__);
}

Step 8:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\JpegProcessor.cpp
bool JpegProcessor::threadLoop() {
    status_t res;

    {
        Mutex::Autolock l(mInputMutex);
        while (!mCaptureAvailable) {
            res = mCaptureAvailableSignal.waitRelative(mInputMutex,
                    kWaitDuration);
            if (res == TIMED_OUT) return true;
        }
        mCaptureAvailable = false;
    }

    do {
        res = processNewCapture();
    } while (res == OK);

    return true;
}

Step 9:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\JpegProcessor.cpp
status_t JpegProcessor::processNewCapture() {
    ATRACE_CALL();
    status_t res;
    sp<Camera2Heap> captureHeap;

    CpuConsumer::LockedBuffer imgBuffer;

    res = mCaptureConsumer->lockNextBuffer(&imgBuffer);
    if (res != OK) {
        if (res != BAD_VALUE) {
            ALOGE("%s: Camera %d: Error receiving still image buffer: "
                    "%s (%d)", __FUNCTION__,
                    mId, strerror(-res), res);
        }
        return res;
    }

    ALOGV("%s: Camera %d: Still capture available", __FUNCTION__,
            mId);

#if 0
>>>>>>> ENGR00214328 make jpegProcess support more format than HAL_PIXEL_FORMAT_BLOB.
    if (imgBuffer.format != HAL_PIXEL_FORMAT_BLOB) {
        ALOGE("%s: Camera %d: Unexpected format for still image: "
                "%x, expected %x", __FUNCTION__, mId,
                imgBuffer.format,
                HAL_PIXEL_FORMAT_BLOB);
        mCaptureConsumer->unlockBuffer(imgBuffer);
        return OK;
    }
#endif
    // Find size of JPEG image   
    int size = 0;
    if (imgBuffer.format != HAL_PIXEL_FORMAT_BLOB) {
        //now only support nv12.
        size = imgBuffer.stride * imgBuffer.height * 3/2;
    }
    else {
        size = mMaxJpegSize;
    }

    size_t jpegSize = findJpegSize(imgBuffer.data, size/*imgBuffer.width*/);
    if (jpegSize == 0) { // failed to find size, default to whole buffer
        jpegSize = size;//imgBuffer.width;
    }
    size_t heapSize = mCaptureHeap->getSize();
    if (jpegSize > heapSize) {
        ALOGW("%s: JPEG image is larger than expected, truncating "
                "(got %d, expected at most %d bytes)",
                __FUNCTION__, jpegSize, heapSize);
        jpegSize = heapSize;
    }

    // TODO: Optimize this to avoid memcopy
    sp<MemoryBase> captureBuffer = new MemoryBase(mCaptureHeap, 0, jpegSize);
    void* captureMemory = mCaptureHeap->getBase();
    memcpy(captureMemory, imgBuffer.data, jpegSize);

    mCaptureConsumer->unlockBuffer(imgBuffer);

    sp<CaptureSequencer> sequencer = mSequencer.promote();
    if (sequencer != 0) {
        sequencer->onCaptureAvailable(imgBuffer.timestamp, captureBuffer);
    }

    return OK;
}

Step 10:	X:\root\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\CaptureSequencer.cpp
void CaptureSequencer::onCaptureAvailable(nsecs_t timestamp,
        sp<MemoryBase> captureBuffer) {
    ATRACE_CALL();
    ALOGV("%s", __FUNCTION__);
    Mutex::Autolock l(mInputMutex);
    mCaptureTimestamp = timestamp;
    mCaptureBuffer = captureBuffer;
    if (!mNewCaptureReceived) {
        mNewCaptureReceived = true;
        mNewCaptureSignal.signal();
    }
}




		하+1)OpenCamera_old & i.mx6 보드 카메라 캡쳐 / 촬영 sequence(Tera Term, Terminal window capture)

int RequestManager::initialize(CameraInfo& info)
{
    status_t ret = NO_ERROR;

    FLOG_RUNTIME("initialize name:%s, path:%s", info.name, info.devPath);
    mDeviceAdapter = DeviceAdapter::Create(info);
    if (mDeviceAdapter == NULL) {
        FLOGE("CameraHal: DeviceAdapter create failed");
        return BAD_VALUE;
    }

    mMetadaManager = new MetadaManager(mDeviceAdapter.get(), mCameraId);
    mDeviceAdapter->setMetadaManager(mMetadaManager);
    ret = mDeviceAdapter->initialize(info);
    if (ret) {
        FLOGE("CameraHal: DeviceAdapter initialize failed");
        return ret;
    }

    ret = mMetadaManager->createStaticInfo(
               (camera_metadata_t**)&info.static_camera_characteristics, true);
    if (ret) {
        FLOGE("CameraHal: createStaticInfo failed");
        return ret;
    }

    ret = mMetadaManager->createStaticInfo(
               (camera_metadata_t**)&info.static_camera_characteristics, false);
    if (ret) {
        FLOGE("CameraHal: createStaticInfo 2 failed");
        return ret;
    }
    mPendingRequests=0;
    mWorkInProcess = true;

    return ret;
}

가)	Tera Term, Terminal window capture
clock_curr=mclk=24000000
In ov5640_mipi.c:ioctl_s_power, on = 1, sensor->on = 0
   Setting mclk to 24 MHz
In ov5640_mipi.c:ov5640_init_mode, frame_rate = 1, mode = 255
Func ov5640_init_mode -> if (mode == ov5640_mode_INIT)
In ov5640:ov5640_download_firmware
In ov5640:ov5640_download_firmware
ov5640_download_autofocus(mipi): Downloaded firmware successfully: 0
In ov5640:ov5640_download_firmware
0x3500=0, 0x3501=0, 0x3502=34
prev_sysclk=5600, prev_HTS=1896
band_step60=245, max_band60=4
band_step50=295, max_band50=3
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640:ioctl_g_parm 1
In ov5640:ioctl_s_parm 1
In ov5640_mipi.c:ov5640_init_mode, frame_rate = 1, mode = 8
Func ov5640_init_mode -> else
In ov5640:ov5640_download_firmware
0x3500=0, 0x3501=17, 0x3502=70
prev_sysclk=5600, prev_HTS=1896
band_step60=245, max_band60=4
band_step50=295, max_band50=3
   clock_curr=mclk=24000000
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640_mipi.c:ioctl_s_ctrl 0x98092c
   V4L2_CID_TEMP
iAddress = 12322, iData = 3
iAddress = 0x3022, iData = 0x3
Write
buffer[0]=1
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640_mipi.c:ioctl_s_ctrl 0x98092c
   V4L2_CID_TEMP
iAddress = 12322, iData = 3
iAddress = 0x3022, iData = 0x3
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 6000
0x3500=0, 0x3501=17, 0x3502=70
In ov5640_mipi.c:ioctl_s_ctrl 0x98092c
   V4L2_CID_TEMP
iAddress = 12322, iData = 3
iAddress = 0x3022, iData = 0x3
Write
buffer[0]=0
In ov5640:ioctl_g_parm 1
In ov5640:ioctl_s_parm 1
In ov5640_mipi.c:ov5640_init_mode, frame_rate = 1, mode = 8
Func ov5640_init_mode -> else
In ov5640:ov5640_download_firmware
0x3500=0, 0x3501=17, 0x3502=70
prev_sysclk=5600, prev_HTS=1896
band_step60=245, max_band60=4
band_step50=295, max_band50=3
   clock_curr=mclk=24000000
In ov5640_mipi.c:ioctl_s_power, on = 0, sensor->on = 1




   case VIDIOC_QBUF
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c008561c
   case VIDIOC_S_CTRL
In MVC:mxc_v4l2_s_ctrl
cam->sensor = -1063761860, c->value = 8000
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 8000
0x3500=0, 0x3501=1f, 0x3502=40
if (cam->sensor) == true
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c008561c
   case VIDIOC_S_CTRL
In MVC:mxc_v4l2_s_ctrl
cam->sensor = -1063761860, c->value = 8000
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 8000
0x3500=0, 0x3501=1f, 0x3502=40
if (cam->sensor) == true
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl 40045613
   case VIDIOC_STREAMOFF
In MVC:mxc_streamoff
In MVC:mxc_free_frames
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0045627
   case VIDIOC_S_INPUT
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0cc5616
   case VIDIOC_S_PARM
In mxc_v4l2_s_param
In ov5640:ioctl_g_parm 1
   Current capabilities are 1001
   Current capturemode is 8  change to 8
   Current framerate is 15  change to 30
In ov5640:ioctl_s_parm 1
In ov5640_mipi.c:ov5640_init_mode
In ov5640:ov5640_download_firmware
0x3500=0, 0x3501=1f, 0x3502=40
prev_sysclk=5600, prev_HTS=1896
band_step60=245, max_band60=4
band_step50=295, max_band50=3
   clock_curr=mclk=24000000
   clock_curr=mclk=24000000
   g_fmt_cap returns widthxheight of input as 1024 x 768
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0cc5605
   case VIDIOC_S_FMT
In MVC: mxc_v4l2_s_fmt
   type=V4L2_BUF_TYPE_VIDEO_CAPTURE
End of mxc_v4l2_s_fmt: v2f pix widthxheight 1024 x 768
End of mxc_v4l2_s_fmt: crop_bounds widthxheight 1024 x 768
End of mxc_v4l2_s_fmt: crop_defrect widthxheight 1024 x 768
End of mxc_v4l2_s_fmt: crop_current widthxheight 1024 x 768
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0145608
   case VIDIOC_REQBUFS
In MVC:mxc_streamoff
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445609
   case VIDIOC_QUERYBUF
In MVC:mxc_v4l2_release_bufs
In MVC:mxc_v4l2_prepare_bufs
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445609
   case VIDIOC_QUERYBUF
In MVC:mxc_v4l2_release_bufs
In MVC:mxc_v4l2_prepare_bufs
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl 40045612
   case VIDIOC_STREAMON
In MVC:mxc_streamon
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl 40045613
In MVC:camera_callback
   case VIDIOC_STREAMOFF
In MVC:mxc_streamoff
In MVC:mxc_free_frames
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c008561c
   case VIDIOC_S_CTRL
In MVC:mxc_v4l2_s_ctrl
cam->sensor = -1063761860, c->value = 8000
In ov5640_mipi.c:ioctl_s_ctrl 0x980911
   V4L2_CID_EXPOSURE, AE_Target = 8000
0x3500=0, 0x3501=1f, 0x3502=40
if (cam->sensor) == true
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0045627
   case VIDIOC_S_INPUT
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0cc5616
   case VIDIOC_S_PARM
In mxc_v4l2_s_param
In ov5640:ioctl_g_parm 1
   Current capabilities are 1001
   Current capturemode is 8  change to 8
   Current framerate is 30  change to 15
In ov5640:ioctl_s_parm 1
In ov5640_mipi.c:ov5640_init_mode
In ov5640:ov5640_download_firmware
0x3500=0, 0x3501=1f, 0x3502=40
prev_sysclk=2800, prev_HTS=1896
band_step60=122, max_band60=8
band_step50=147, max_band50=6
   clock_curr=mclk=24000000
   clock_curr=mclk=24000000
   g_fmt_cap returns widthxheight of input as 1024 x 768
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0cc5605
   case VIDIOC_S_FMT
In MVC: mxc_v4l2_s_fmt
   type=V4L2_BUF_TYPE_VIDEO_CAPTURE
End of mxc_v4l2_s_fmt: v2f pix widthxheight 1024 x 768
End of mxc_v4l2_s_fmt: crop_bounds widthxheight 1024 x 768
End of mxc_v4l2_s_fmt: crop_defrect widthxheight 1024 x 768
End of mxc_v4l2_s_fmt: crop_current widthxheight 1024 x 768
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0145608
   case VIDIOC_REQBUFS
In MVC:mxc_streamoff
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445609
   case VIDIOC_QUERYBUF
In MVC:mxc_v4l2_release_bufs
In MVC:mxc_v4l2_prepare_bufs
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445609
   case VIDIOC_QUERYBUF
In MVC:mxc_v4l2_release_bufs
In MVC:mxc_v4l2_prepare_bufs
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445609
   case VIDIOC_QUERYBUF
In MVC:mxc_v4l2_release_bufs
In MVC:mxc_v4l2_prepare_bufs
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445609
   case VIDIOC_QUERYBUF
In MVC:mxc_v4l2_release_bufs
In MVC:mxc_v4l2_prepare_bufs
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl 40045612
   case VIDIOC_STREAMON
In MVC:mxc_streamon
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f
   case VIDIOC_QBUF
In MVC:camera_callback
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c0445611
   case VIDIOC_DQBUF
In MVC:mxc_v4l_dqueue
In MVC:mxc_v4l_ioctl
In MVC: mxc_v4l_do_ioctl c044560f

나)	Eclipse LogCat
01-02 00:51:52.440: D/Preview(3184): onResume
01-02 00:51:52.440: D/Preview(3184): openCamera()
01-02 00:51:52.440: D/Preview(3184): cameraId: 0
01-02 00:51:52.440: D/Preview(3184): showGUI: true
01-02 00:51:52.440: D/Preview(3184): done showGUI
01-02 00:51:52.440: D/Preview(3184): try to open camera: 0
01-02 00:51:52.450: W/AudioTrack(2756): AUDIO_OUTPUT_FLAG_FAST denied by client due to mismatching sample rate (48000 vs 44100)
01-02 00:51:52.450: I/AwesomePlayer(2378): setDataSource_l(URL suppressed)
01-02 00:51:52.460: W/audio_hw_primary(2378): card 0, port 0 device 0x2
01-02 00:51:52.460: W/audio_hw_primary(2378): rate 44100, channel 2 period_size 0xc0
01-02 00:51:52.470: I/AwesomePlayer(2378): setDataSource_l(URL suppressed)
01-02 00:51:52.490: I/Camera2ClientBase(2378): Camera 0: Opened
01-02 00:51:52.490: I/FslCameraHAL(2378): camera_device open: 0
01-02 00:51:52.490: I/FslCameraHAL(2378): DeviceAdapter: Create ov5640 mipi device
01-02 00:51:55.580: W/audio_hw_primary(2378): do_out_standby... 1074546984
01-02 00:51:55.890: I/FslCameraHAL(2378): mMaxWidth:2592, mMaxHeight:1944
01-02 00:51:55.890: I/FslCameraHAL(2378): ov5640Mipi, mFocalLength:3.370000, mPhysicalWidth:3.628800, mPhysicalHeight 2.721600
01-02 00:51:55.890: E/FslCameraHAL(2378): cpu num 4
01-02 00:51:55.890: W/Camera2-Parameters(2378): buildFastInfo: Camera 0: activeArraySize is missing xmin/ymin!
01-02 00:51:55.890: I/Camera2-Parameters(2378): Camera 0: Disabling ZSL mode
01-02 00:51:55.890: D/Preview(3184): time after opening camera: 3444
01-02 00:51:55.890: D/Preview(3184): intent: Intent { cmp=net.krh.selexon2/.MainActivity }
01-02 00:51:55.890: D/Preview(3184): no intent data
01-02 00:51:55.890: D/Preview(3184): take_photo?: false
01-02 00:51:55.890: D/Preview(3184): setCameraDisplayOrientation()
01-02 00:51:55.890: D/Preview(3184):     degrees = 0
01-02 00:51:55.890: D/Preview(3184):     rotate_preview = 0
01-02 00:51:55.890: D/CameraController(3184):     info orientation is 0
01-02 00:51:55.890: D/CameraController(3184):     setDisplayOrientation to 0
01-02 00:51:55.890: D/Preview(3184): call setPreviewDisplay
01-02 00:51:55.890: D/Preview(3184): setupCamera()
01-02 00:51:55.890: D/Preview(3184): setupCameraParameters()
01-02 00:51:55.890: D/Preview(3184): set up scene mode
01-02 00:51:55.890: D/Preview(3184): saved scene mode: auto
01-02 00:51:55.890: D/CameraController(3184): supported value: auto
01-02 00:51:55.890: D/CameraController(3184): supported value: portrait
01-02 00:51:55.890: D/CameraController(3184): supported value: landscape
01-02 00:51:55.890: D/Preview(3184): grab info from parameters
01-02 00:51:55.890: D/CameraController(3184): get preview fps range
01-02 00:51:55.890: D/CameraController(3184):     current fps range: 23000 to 30000
01-02 00:51:55.890: D/CameraController(3184): convertFlashModesToValues()
01-02 00:51:55.890: D/CameraController(3184):  supports flash_off
01-02 00:51:55.890: D/CameraController(3184): convertFocusModesToValues()
01-02 00:51:55.890: D/CameraController(3184):  supports focus_mode_fixed
01-02 00:51:55.890: D/CameraController(3184): take video_sizes from preview sizes
01-02 00:51:55.890: D/CameraController(3184): camera parameters: zoom=0;recording-hint=false;max-num-detected-faces-hw=0;video-stabilization=false;zoom-supported=true;whitebalance=auto;scene-mode=auto;jpeg-quality=90;preview-format-values=yuv420sp,yuv420p,;rotation=0;jpeg-thumbnail-quality=90;preview-format=yuv420sp;metering-areas=(0,0,0,0,0);preview-size=1920x1080;focal-length=3.37;flash-mode-values=off;preview-frame-rate-values=30;max-num-metering-areas=0;preview-frame-rate=30;focus-mode-values=fixed;jpeg-thumbnail-width=160;video-size=1920x1080;scene-mode-values=auto,portrait,landscape;preview-fps-range-values=(23000,30000),(23000,30000);jpeg-thumbnail-size-values=96x96,160x120,0x0;zoom-ratios=100,103,106,109,112,115,118,121,124,127,130,133,136,139,142,145,148,151,154,157,160,163,166,169,172,175,178,181,184,187,190,193,196,199,203,206,209,212,215,218,221,224,227,230,233,236,239,242,245,248,251,254,257,260,263,266,269,272,275,278,281,284,287,290,293,296,299,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399;preview-size-values=1920x1080,320x240,720x480,720x576,1280x720,640x480,176x144,1024x768;picture-size-values=640x480,320x240,720x480,720x576,1280x720,2592x1944,1024x768;preview-fps-range=23000,30000;auto-whitebalance-lock=false;min-exposure-compensation=-3;antibanding=auto;max-num-focus-areas=0;vertical-view-angle=43.9775;horizontal-view-angle=56.5958;video-stabilization-supported=false;jpeg-thumbnail-height=120;smooth-zoom-supported=false;focus-mode=fixed;auto-whitebalance-lock-supported=true;video-frame-format=android-opaque;max-num-detected-faces-sw=0;picture-format-values=jpeg;max-exposure-compensation=3;focus-areas=(0,0,0,0,0);video-snapshot-supported=true;exposure-compensation=0;exposure-compensation-step=1;flash-mode=off;auto-exposure-lock=false;effect-values=none;picture-size=640x480;max-zoom=99;effect=none;whitebalance-values=auto;picture-format=jpeg;focus-distances=Infinity,Infinity,Infinity;auto-exposure-lock-supported=true;antibanding-values=off,auto
01-02 00:51:55.890: D/Preview(3184): set up zoom
01-02 00:51:55.890: D/Preview(3184): has_zoom? false
01-02 00:51:55.890: D/Preview(3184): set up face detection
01-02 00:51:55.890: D/Preview(3184): supports_face_detection?: false
01-02 00:51:55.890: D/Preview(3184): using_face_detection?: false
01-02 00:51:55.890: D/Preview(3184): set up video stabilization
01-02 00:51:55.890: D/Preview(3184): supports_video_stabilization?: false
01-02 00:51:55.890: D/Preview(3184): set up color effect
01-02 00:51:55.890: D/Preview(3184): saved color effect: none
01-02 00:51:55.890: D/CameraController(3184): supported value: none
01-02 00:51:55.890: D/Preview(3184): set up white balance
01-02 00:51:55.890: D/Preview(3184): saved white balance: auto
01-02 00:51:55.890: D/CameraController(3184): supported value: auto
01-02 00:51:55.890: D/Preview(3184): set up iso
01-02 00:51:55.890: D/Preview(3184): saved iso: auto
01-02 00:51:55.900: D/Preview(3184): set up exposure compensation
01-02 00:51:55.900: D/Preview(3184): saved exposure value: 0
01-02 00:51:55.900: D/Preview(3184): exposure: 0
01-02 00:51:55.900: D/Preview(3184): set up picture sizes
01-02 00:51:55.900: D/Preview(3184): supported picture size: 640 , 480
01-02 00:51:55.900: D/Preview(3184): supported picture size: 320 , 240
01-02 00:51:55.900: D/Preview(3184): supported picture size: 720 , 480
01-02 00:51:55.900: D/Preview(3184): supported picture size: 720 , 576
01-02 00:51:55.900: D/Preview(3184): supported picture size: 1280 , 720
01-02 00:51:55.900: D/Preview(3184): supported picture size: 2592 , 1944
01-02 00:51:55.900: D/Preview(3184): supported picture size: 1024 , 768
01-02 00:51:55.900: D/Preview(3184): resolution_value: 1024 768
01-02 00:51:55.900: D/Preview(3184): resolution_w_s: 1024
01-02 00:51:55.900: D/Preview(3184): resolution_h_s: 768
01-02 00:51:55.900: D/Preview(3184): resolution_w: 1024
01-02 00:51:55.900: D/Preview(3184): resolution_h: 768
01-02 00:51:55.900: D/Preview(3184): set current_size_index to: 6
01-02 00:51:55.900: D/Preview(3184): Current size index 6: 1024, 768
01-02 00:51:55.900: D/Preview(3184): save new resolution_value: 1024 768
01-02 00:51:55.900: D/Preview(3184): set up jpeg quality
01-02 00:51:55.900: D/Preview(3184): getImageQuality
01-02 00:51:55.900: D/CameraController(3184): setCameraParameters
01-02 00:51:55.900: I/FslCameraHAL(2378): DEBUG(CreateDefaultRequest): making template (1) 
01-02 00:51:55.900: I/FslCameraHAL(2378): DEBUG(CreateDefaultRequest): making template (3) 
01-02 00:51:55.910: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, temp_1 == NULL or temp_2 == NULL
01-02 00:51:55.910: D/CameraController(3184): done
01-02 00:51:55.910: D/Preview(3184): image quality: 90
01-02 00:51:55.910: D/Preview(3184): sortVideoSizes()
01-02 00:51:55.910: D/Preview(3184):     supported video size: 1920, 1080
01-02 00:51:55.910: D/Preview(3184):     supported video size: 1280, 720
01-02 00:51:55.910: D/Preview(3184):     supported video size: 1024, 768
01-02 00:51:55.910: D/Preview(3184):     supported video size: 720, 576
01-02 00:51:55.910: D/Preview(3184):     supported video size: 720, 480
01-02 00:51:55.910: D/Preview(3184):     supported video size: 640, 480
01-02 00:51:55.910: D/Preview(3184):     supported video size: 320, 240
01-02 00:51:55.910: D/Preview(3184):     supported video size: 176, 144
01-02 00:51:55.910: D/Preview(3184): initialiseVideoQuality()
01-02 00:51:55.910: D/Preview(3184): supports QUALITY_HIGH
01-02 00:51:55.910: D/Preview(3184): profile 1 is resolution 1920 x 1080
01-02 00:51:55.910: D/Preview(3184): added: 1
01-02 00:51:55.910: D/Preview(3184): supports QUALITY_1080P
01-02 00:51:55.910: D/Preview(3184): profile 6 is resolution 1920 x 1080
01-02 00:51:55.910: D/Preview(3184): supports QUALITY_720P
01-02 00:51:55.910: D/Preview(3184): profile 5 is resolution 1280 x 720
01-02 00:51:55.910: D/Preview(3184): added: 5
01-02 00:51:55.910: D/Preview(3184): supports QUALITY_480P
01-02 00:51:55.910: D/Preview(3184): profile 4 is resolution 640 x 480
01-02 00:51:55.910: D/Preview(3184): added: 4_r1024x768
01-02 00:51:55.910: D/Preview(3184): added: 4_r720x576
01-02 00:51:55.910: D/Preview(3184): added: 4_r720x480
01-02 00:51:55.910: D/Preview(3184): added: 4
01-02 00:51:55.910: D/Preview(3184): supports QUALITY_LOW
01-02 00:51:55.910: D/Preview(3184): profile 0 is resolution 640 x 480
01-02 00:51:55.910: D/Preview(3184): added: 0_r320x240
01-02 00:51:55.910: D/Preview(3184): added: 0_r176x144
01-02 00:51:55.910: D/Preview(3184): supported video quality: 1
01-02 00:51:55.910: D/Preview(3184): supported video quality: 5
01-02 00:51:55.910: D/Preview(3184): supported video quality: 4_r1024x768
01-02 00:51:55.910: D/Preview(3184): supported video quality: 4_r720x576
01-02 00:51:55.910: D/Preview(3184): supported video quality: 4_r720x480
01-02 00:51:55.910: D/Preview(3184): supported video quality: 4
01-02 00:51:55.910: D/Preview(3184): supported video quality: 0_r320x240
01-02 00:51:55.910: D/Preview(3184): supported video quality: 0_r176x144
01-02 00:51:55.910: D/Preview(3184): video_quality_value: 1
01-02 00:51:55.910: D/Preview(3184): set current_video_quality to: 0
01-02 00:51:55.910: D/Preview(3184): set up flash
01-02 00:51:55.910: D/Preview(3184): flash not supported
01-02 00:51:55.910: D/Preview(3184): set up focus
01-02 00:51:55.910: D/Preview(3184): focus not supported
01-02 00:51:55.910: D/Preview(3184): set up exposure lock
01-02 00:51:55.910: D/Preview(3184): time after setting up camera parameters: 24
01-02 00:51:55.910: D/Preview(3184): saved_is_video: false
01-02 00:51:55.910: D/Preview(3184): setPreviewSize()
01-02 00:51:55.910: D/Preview(3184): cancelAutoFocus
01-02 00:51:55.910: D/Preview(3184): autoFocusCompleted
01-02 00:51:55.910: D/Preview(3184):     manual? false
01-02 00:51:55.910: D/Preview(3184):     success? false
01-02 00:51:55.910: D/Preview(3184):     cancelled? true
01-02 00:51:55.910: D/CameraController(3184): set picture size: 1024, 768
01-02 00:51:55.910: D/CameraController(3184): setCameraParameters
01-02 00:51:55.930: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, temp_1 == NULL or temp_2 == NULL
01-02 00:51:55.930: D/CameraController(3184): done
01-02 00:51:55.930: D/Preview(3184): getOptimalPreviewSize()
01-02 00:51:55.930: D/Preview(3184): display_size: 1024 x 720
01-02 00:51:55.930: D/Preview(3184): set preview aspect ratio from photo size (wysiwyg)
01-02 00:51:55.930: D/Preview(3184): picture_size: 1024 x 768
01-02 00:51:55.930: D/Preview(3184): targetRatio: 1.3333333333333333
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 1920, 1080
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 320, 240
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 720, 480
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 720, 576
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 1280, 720
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 640, 480
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 176, 144
01-02 00:51:55.930: D/Preview(3184):     supported preview size: 1024, 768
01-02 00:51:55.930: D/Preview(3184): chose optimalSize: 1024 x 768
01-02 00:51:55.930: D/Preview(3184): optimalSize ratio: 1.3333333333333333
01-02 00:51:55.930: D/CameraController(3184): current preview size: 1920, 1080
01-02 00:51:55.930: D/CameraController(3184): new preview size: 1024, 768
01-02 00:51:55.930: D/CameraController(3184): setCameraParameters
01-02 00:51:55.940: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, temp_1 == NULL or temp_2 == NULL
01-02 00:51:55.940: D/CameraController(3184): done
01-02 00:51:55.940: D/Preview(3184): startCameraPreview
01-02 00:51:55.940: D/Preview(3184): starting the camera preview
01-02 00:51:55.940: D/Preview(3184): setRecordingHint: false
01-02 00:51:55.940: D/CameraController(3184): setCameraParameters
01-02 00:51:55.960: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, temp_1 == NULL or temp_2 == NULL
01-02 00:51:55.960: D/CameraController(3184): done
01-02 00:51:55.960: I/FslCameraHAL(2378): allocateStream preview stream, w:1024, h:768, fmt:0x22
01-02 00:51:55.960: I/FslCameraHAL(2378): actual format 0x103
01-02 00:51:55.970: I/FslCameraHAL(2378): registerBuffers total 4 buffer
01-02 00:51:55.970: I/FslCameraHAL(2378): allocateStream jpeg stream, w:1024, h:768, fmt:0x21
01-02 00:51:55.970: I/FslCameraHAL(2378): actual format 0x103
01-02 00:51:55.970: I/FslCameraHAL(2378): notify_request_queue_not_empty running
01-02 00:51:55.970: I/FslCameraHAL(2378): dispatchRequest running
01-02 00:51:55.970: I/FslCameraHAL(2378): handleRequest running
01-02 00:51:55.970: D/Preview(3184): time after starting camera preview: 26
01-02 00:51:55.970: D/Preview(3184): setPreviewPaused: false
01-02 00:51:55.970: I/FslCameraHAL(2378): PreviewStream configure running
01-02 00:51:55.970: I/FslCameraHAL(2378): pixel format: 0x3231564e
01-02 00:51:55.970: I/FslCameraHAL(2378): Width * Height 1024 x 768 format 0x3231564e, fps: 30
01-02 00:51:55.970: D/Preview(3184): showGUI: true
01-02 00:51:55.970: D/Preview(3184): setPopupIcon
01-02 00:51:55.970: D/Preview(3184): flash_value: null
01-02 00:51:55.970: D/Preview(3184): total time: 3530
01-02 00:51:55.970: D/MainActivity(3184): Start AutoFocus of preview.RegWrite
01-02 00:51:55.970: D/CameraController(3184): setCameraParameters
01-02 00:51:56.440: I/FslCameraHAL(2378): PreviewStream start running
01-02 00:51:56.440: I/FslCameraHAL(2378): stream thread received STREAM_START command
01-02 00:51:56.440: I/FslCameraHAL(2378): Created device thread
01-02 00:51:56.480: E/Camera2Client(2378): syncWithDevice: Camera 0: Timed out waiting sync with HAL
01-02 00:51:56.500: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, dAddress = 12322.000000, dData = 3.000000
01-02 00:51:56.500: I/FslCameraHAL(2378): ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = 3154435
01-02 00:51:56.510: D/CameraController(3184): done
01-02 00:51:56.510: V/NDK_LED(3184): [NDK_LIB] mango64 LED 1 OnOff 1
01-02 00:51:56.510: D/MainActivity(3184): takePicture
01-02 00:51:56.510: D/MainActivity(3184): close popup
01-02 00:51:56.510: D/Preview(3184): takePicturePressed
01-02 00:51:56.510: D/Preview(3184): startCameraPreview
01-02 00:51:56.510: D/Preview(3184): setPreviewPaused: false
01-02 00:51:56.510: D/Preview(3184): showGUI: true
01-02 00:51:56.510: D/Preview(3184): n_burst: 1
01-02 00:51:56.520: D/Preview(3184): takePicture
01-02 00:51:56.520: D/Preview(3184): removing location data from parameters...
01-02 00:51:56.520: D/CameraController(3184): setCameraParameters
01-02 00:51:56.560: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, dAddress = 12322.000000, dData = 3.000000
01-02 00:51:56.560: I/FslCameraHAL(2378): ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = 3154435
01-02 00:51:56.570: D/CameraController(3184): done
01-02 00:51:56.570: D/Preview(3184): showGUI: false
01-02 00:51:56.570: D/MainActivity(3184): close popup
01-02 00:51:56.570: D/Preview(3184): focus_value is null
01-02 00:51:56.570: D/Preview(3184): takePictureWhenFocused
01-02 00:51:56.570: D/Preview(3184): focus_value is null
01-02 00:51:56.570: D/Preview(3184): focus_success is 3
01-02 00:51:56.570: D/Preview(3184): remaining_burst_photos: 0
01-02 00:51:56.570: D/Preview(3184): getImageVideoRotation() from current_rotation 0
01-02 00:51:56.570: D/Preview(3184): getImageVideoRotation() returns current_rotation 0
01-02 00:51:56.570: D/CameraController(3184): setCameraParameters
01-02 00:51:56.610: I/FslCameraHAL(2378): Ov5640Mipi::setParameters, dAddress = 12322.000000, dData = 3.000000
01-02 00:51:56.610: I/FslCameraHAL(2378): ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = 3154435
01-02 00:51:56.620: D/CameraController(3184): done
01-02 00:51:56.620: D/Preview(3184): enable_sound? true
01-02 00:51:56.620: D/Preview(3184): about to call takePicture
01-02 00:51:56.620: I/FslCameraHAL(2378): DEBUG(CreateDefaultRequest): making template (2) 
01-02 00:51:56.620: D/Preview(3184): takePicture exit
01-02 00:51:56.620: E/Preview(3184): End of takePicture()
01-02 00:51:56.620: V/NDK_LED(3184): [NDK_LIB] mango64 LED 1 OnOff 0
01-02 00:51:56.620: E/Camera2-Device(2378): triggerPrecaptureMetering: Error triggering precapture metering (id 1)
01-02 00:51:56.620: D/Preview(3184): Low value !
01-02 00:51:56.620: D/Preview(3184): High value !
01-02 00:51:56.620: I/Choreographer(3184): Skipped 249 frames!  The application may be doing too much work on its main thread.
01-02 00:51:56.620: I/InputDispatcher(2756): Window 'Window{41e31948 u0 net.krh.selexon2/net.krh.selexon2.MainActivity}' spent 4174.5ms processing the last input event: MotionEvent(deviceId=8, source=0x00001002, action=7, flags=0x00000000, metaState=0x00000000, buttonState=0x00000000, edgeFlags=0x00000000, xPrecision=32.0, yPrecision=42.7, displayId=0, pointers=[1: (0.0, 0.0)]), policyFlags=0x42000000
01-02 00:51:56.620: D/Preview(3184): do startup autofocus
01-02 00:51:56.620: D/Preview(3184): tryAutoFocus
01-02 00:51:56.620: D/Preview(3184): startup? true
01-02 00:51:56.620: D/Preview(3184): manual? false
01-02 00:51:56.620: D/Preview(3184): currently taking a photo
01-02 00:51:56.640: I/FslCameraHAL(2378): tryRestartStreams stop unused stream 0
01-02 00:51:56.640: I/FslCameraHAL(2378): PreviewStream stop running
01-02 00:51:56.640: D/CameraController(3184): shutterCallback.onShutter()
01-02 00:51:56.670: I/FslCameraHAL(2378): device thread exit...
01-02 00:51:56.710: I/FslCameraHAL(2378): stream thread received STREAM_STOP command
01-02 00:51:56.710: I/FslCameraHAL(2378): PreviewStream release running
01-02 00:51:56.710: I/FslCameraHAL(2378): stream thread exiting...
01-02 00:51:56.710: E/BufferQueue(2375): [SurfaceView] cancelBuffer: slot 1 is not owned by the client (state=3)
01-02 00:51:56.710: I/FslCameraHAL(2378): CaptureStream::configure
01-02 00:51:56.710: E/FslCameraHAL(2378): getGpsCoordinates: error reading jpeg Coordinates tag
01-02 00:51:56.710: E/FslCameraHAL(2378): getGpsTimeStamp: error reading jpeg TimeStamp tag
01-02 00:51:56.710: E/FslCameraHAL(2378): getGpsProcessingMethod: error reading jpeg ProcessingMethod tag
01-02 00:51:56.710: I/FslCameraHAL(2378): pixel format: 0x3231564e
01-02 00:51:56.710: I/FslCameraHAL(2378): Width * Height 1024 x 768 format 0x3231564e, fps: 30
01-02 00:51:57.180: I/FslCameraHAL(2378): allocateBufferFromIon buffer num:2
01-02 00:51:57.180: I/FslCameraHAL(2378): CaptureStream::start
01-02 00:51:57.180: I/FslCameraHAL(2378): stream thread received STREAM_START command
01-02 00:51:57.180: I/FslCameraHAL(2378): Created device thread
01-02 00:51:57.220: I/FslCameraHAL(2378): device thread exit...
01-02 00:51:57.220: E/FslCameraHAL(2378): getGpsCoordinates: error reading jpeg Coordinates tag
01-02 00:51:57.220: E/FslCameraHAL(2378): getGpsTimeStamp: error reading jpeg TimeStamp tag
01-02 00:51:57.220: E/FslCameraHAL(2378): getGpsProcessingMethod: error reading jpeg ProcessingMethod tag
01-02 00:51:57.220: I/FslCameraHAL(2378): pixel format: 0x3231564e
01-02 00:51:57.250: I/vpu-lib(2378): Product Info: i.MX6Q/D/S
01-02 00:51:57.250: I/FslCameraHAL(2378): vpu lib version : major.minor.rel=5.4.25 
01-02 00:51:57.250: I/FslCameraHAL(2378): vpu fw version : major.minor.rel_rcode=3.1.1_r46058 
01-02 00:51:57.250: I/vpu-lib(2378): <gpu> alloc handle: 0x413fe890, paddr: 0x49392000, vaddr: 0x4723e000
01-02 00:51:57.250: I/vpu-lib(2378): <gpu> alloc handle: 0x40d95fb8, paddr: 0x45904000, vaddr: 0x437b0000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> alloc handle: 0x40d94a70, paddr: 0x4aace000, vaddr: 0x4897a000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> alloc handle: 0x400bd0a0, paddr: 0x4ac20000, vaddr: 0x48acc000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> alloc handle: 0x40d9b008, paddr: 0x4ad72000, vaddr: 0x48c1e000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> free handle: 0x40d95fb8, paddr: 0x45904000, vaddr: 0x437b0000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> free handle: 0x413fe890, paddr: 0x49392000, vaddr: 0x4723e000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> free handle: 0x40d94a70, paddr: 0x4aace000, vaddr: 0x4897a000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> free handle: 0x400bd0a0, paddr: 0x4ac20000, vaddr: 0x48acc000
01-02 00:51:57.260: I/vpu-lib(2378): <gpu> free handle: 0x40d9b008, paddr: 0x4ad72000, vaddr: 0x48c1e000
01-02 00:51:57.260: I/FslCameraHAL(2378): insertExifThumbnailImage. ReplaceThumbnail(). ret=1
01-02 00:51:57.270: E/FslCameraHAL(2378): handleRequest:No more requests available
01-02 00:51:57.270: I/FslCameraHAL(2378): handleRequest exiting
01-02 00:51:57.270: I/FslCameraHAL(2378): stopAllStreams running
01-02 00:51:57.270: I/FslCameraHAL(2378): CaptureStream::stop
01-02 00:51:57.270: I/FslCameraHAL(2378): stream thread received STREAM_STOP command
01-02 00:51:57.270: W/Camera2-CaptureSequencer(2378): Mismatched capture timestamps: Metadata frame 3147000510378, captured buffer 3147583767711
01-02 00:51:57.290: I/FslCameraHAL(2378): CaptureStream::release
01-02 00:51:57.290: I/FslCameraHAL(2378): stream thread exiting...
01-02 00:51:57.290: I/FslCameraHAL(2378): freeBufferToIon buffer num:2
01-02 00:51:57.290: I/FslCameraHAL(2378): stopAllStreams end
01-02 00:51:57.290: I/FslCameraHAL(2378): handleRequest end...
01-02 00:51:57.320: D/Preview(3184): onPause
01-02 00:51:57.320: D/Preview(3184): closeCamera()
01-02 00:51:57.320: D/Preview(3184): cancelTimer()
01-02 00:51:57.320: D/Preview(3184): pausePreview()
01-02 00:51:57.320: D/Preview(3184): setPreviewPaused: false
01-02 00:51:57.320: D/Preview(3184): showGUI: true
01-02 00:51:57.320: D/Preview(3184): showGUI: true
01-02 00:51:57.440: D/Preview(3184): onPictureTaken
01-02 00:51:57.440: D/Preview(3184): save to: /sdcard/image.jpg
01-02 00:51:57.440: D/Preview(3184): Do, outputStream.write(data);
01-02 00:51:57.440: D/Preview(3184): onPictureTaken saved photo
01-02 00:51:57.450: E/Cataloger(3248): syncFile:/storage/emulated/0/image.jpg
01-02 00:51:57.480: D/Preview(3184): Start, Bitmap analysis
01-02 00:51:58.820: D/CDatabase(3184): result = 30533736
01-02 00:51:59.130: D/Preview(3184): iSum = 30533736
01-02 00:51:59.130: D/Preview(3184): write temp file to record EXIF data
01-02 00:51:59.130: D/Preview(3184): read back EXIF data
01-02 00:51:59.130: D/Preview(3184): now write new EXIF data
01-02 00:51:59.140: E/Cataloger(3248): syncFile:/storage/emulated/0/image.jpg
01-02 00:51:59.140: E/Cataloger(3248): syncFile:/storage/emulated/0/image.jpg.t
01-02 00:51:59.140: E/Cataloger(3248): need not sync path:/storage/emulated/0/image.jpg.t
01-02 00:51:59.140: E/Cataloger(3248): syncFile:/storage/emulated/0/image.jpg
01-02 00:51:59.140: D/Preview(3184): now saved EXIF data
01-02 00:51:59.140: D/MainActivity(3184): broadcastFile
01-02 00:51:59.140: E/Cataloger(3248): syncFile:/storage/emulated/0/image.jpg
01-02 00:51:59.140: I/Camera2Client(2378): Camera 0: Closed
01-02 00:51:59.140: E/Cataloger(3248): syncFile:/storage/emulated/0/image.jpg.t
01-02 00:51:59.140: I/Camera2ClientBase(2378): Closed Camera 0
01-02 00:51:59.140: D/Preview(3184): pause_preview? false
01-02 00:51:59.140: D/Preview(3184): startCameraPreview
01-02 00:51:59.140: D/Preview(3184): setPreviewPaused: false
01-02 00:51:59.140: D/Preview(3184): showGUI: true
01-02 00:51:59.150: D/Preview(3184): showGUI: true
01-02 00:51:59.150: D/Preview(3184): onPictureTaken started preview
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=1711 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at libcore.io.BlockGuardOs.open(BlockGuardOs.java:106)
01-02 00:51:59.150: D/StrictMode(3184): 	at libcore.io.IoBridge.open(IoBridge.java:393)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.io.FileOutputStream.<init>(FileOutputStream.java:88)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.io.FileOutputStream.<init>(FileOutputStream.java:73)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:4903)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=1707 ms: android.os.StrictMode$StrictModeDiskWriteViolation: policy=31 violation=1
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onWriteToDisk(StrictMode.java:1109)
01-02 00:51:59.150: D/StrictMode(3184): 	at libcore.io.BlockGuardOs.write(BlockGuardOs.java:196)
01-02 00:51:59.150: D/StrictMode(3184): 	at libcore.io.IoBridge.write(IoBridge.java:450)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.io.FileOutputStream.write(FileOutputStream.java:187)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.io.OutputStream.write(OutputStream.java:82)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:4924)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=346 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForLong(SQLiteConnection.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setPageSize(SQLiteConnection.java:251)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:213)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=344 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForLong(SQLiteConnection.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setForeignKeyModeFromConfiguration(SQLiteConnection.java:281)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:214)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=342 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForString(SQLiteConnection.java:638)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setJournalMode(SQLiteConnection.java:320)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setWalModeFromConfiguration(SQLiteConnection.java:294)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:215)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=341 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForString(SQLiteConnection.java:638)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setJournalMode(SQLiteConnection.java:323)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setWalModeFromConfiguration(SQLiteConnection.java:294)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:215)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=339 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForString(SQLiteConnection.java:638)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setSyncMode(SQLiteConnection.java:301)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setWalModeFromConfiguration(SQLiteConnection.java:295)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:215)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=338 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForLong(SQLiteConnection.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setJournalSizeLimit(SQLiteConnection.java:271)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:216)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=336 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForLong(SQLiteConnection.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setJournalSizeLimit(SQLiteConnection.java:273)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:216)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): StrictMode policy violation; ~duration=334 ms: android.os.StrictMode$StrictModeDiskReadViolation: policy=31 violation=2
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.StrictMode$AndroidBlockGuardPolicy.onReadFromDisk(StrictMode.java:1135)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.applyBlockGuardPolicy(SQLiteConnection.java:1041)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.executeForLong(SQLiteConnection.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.setAutoCheckpointInterval(SQLiteConnection.java:261)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:217)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnection.open(SQLiteConnection.java:193)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.openConnectionLocked(SQLiteConnectionPool.java:463)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:185)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteConnectionPool.open(SQLiteConnectionPool.java:177)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openInner(SQLiteDatabase.java:804)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.open(SQLiteDatabase.java:789)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteDatabase.openDatabase(SQLiteDatabase.java:694)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ContextImpl.openOrCreateDatabase(ContextImpl.java:944)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.content.ContextWrapper.openOrCreateDatabase(ContextWrapper.java:256)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:224)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:164)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CDatabase.<init>(CDatabase.java:48)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.Preview$12.onPictureTaken(Preview.java:5116)
01-02 00:51:59.150: D/StrictMode(3184): 	at net.krh.selexon2.CameraController$4.onPictureTaken(CameraController.java:1073)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.hardware.Camera$EventHandler.handleMessage(Camera.java:917)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Handler.dispatchMessage(Handler.java:102)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.os.Looper.loop(Looper.java:136)
01-02 00:51:59.150: D/StrictMode(3184): 	at android.app.ActivityThread.main(ActivityThread.java:5017)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invokeNative(Native Method)
01-02 00:51:59.150: D/StrictMode(3184): 	at java.lang.reflect.Method.invoke(Method.java:515)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)
01-02 00:51:59.150: D/StrictMode(3184): 	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)
01-02 00:51:59.150: D/StrictMode(3184): 	at dalvik.system.NativeStart.main(Native Method)
01-02 00:51:59.160: E/Cataloger(3248): need not sync path:/storage/emulated/0/image.jpg.t
01-02 00:51:59.410: D/ExternalStorage(3184): Scanned /sdcard/image.jpg:
01-02 00:51:59.410: D/ExternalStorage(3184): -> uri=content://media/external/images/media/14
01-02 00:51:59.420: D/MainActivity(3184): file_path: /storage/emulated/legacy/image.jpg
01-02 00:51:59.420: D/MainActivity(3184): file_name: image.jpg
01-02 00:51:59.420: D/MainActivity(3184): mime_type: image/jpeg
01-02 00:52:00.430: D/Preview(3184): Low value !
01-02 00:52:01.050: D/Preview(3184): High value !

다)	Eclipse LogCat
	MX6Q-SDP ANDROID r4.2.2.1 원본 상태에서 OpenCamera신형(A Better Camera) -> Capture button 눌렀을 때 log화면, Capture는 1초 정도 걸리고 저장하는데 1초 걸리고 총 카메라 이미지 저장까지 2초 걸림
01-02 00:18:31.110: E/CameraController(3965): takeImage called
01-02 00:18:31.120: E/Camera2-Device(2349): triggerPrecaptureMetering: Error triggering precapture metering (id 5)
01-02 00:18:31.130: W/audio_hw_primary(2349): card 0, port 0 device 0x2
01-02 00:18:31.130: W/audio_hw_primary(2349): rate 44100, channel 2 period_size 0xc0
01-02 00:18:31.320: W/Camera2-CaptureSequencer(2349): Timed out waiting for precapture start
01-02 00:18:31.350: I/FslCameraHAL(2349): tryRestartStreams stop unused stream 0
01-02 00:18:31.350: I/FslCameraHAL(2349): PreviewStream stop running
01-02 00:18:31.350: I/FslCameraHAL(2349): StreamAdapter stop running
01-02 00:18:31.350: I/FslCameraHAL(2349): stream thread received STREAM_STOP command
01-02 00:18:31.350: I/FslCameraHAL(2349): StreamAdapter stop end
01-02 00:18:31.420: I/FslCameraHAL(2349): device thread exit...
01-02 00:18:31.480: I/FslCameraHAL(2349): PreviewStream release running
01-02 00:18:31.480: I/FslCameraHAL(2349): StreamAdapter release running
01-02 00:18:31.480: I/FslCameraHAL(2349): stream thread exiting...
01-02 00:18:31.480: E/BufferQueue(2346): [SurfaceView] cancelBuffer: slot 0 is not owned by the client (state=3)
01-02 00:18:31.480: E/BufferQueue(2346): [SurfaceView] cancelBuffer: slot 4 is not owned by the client (state=0)
01-02 00:18:31.480: I/FslCameraHAL(2349): tryRestartStreams stop unused stream 2
01-02 00:18:31.480: I/FslCameraHAL(2349): StreamAdapter stop running
01-02 00:18:31.480: I/FslCameraHAL(2349): stream thread received STREAM_STOP command
01-02 00:18:31.480: I/FslCameraHAL(2349): StreamAdapter stop end
01-02 00:18:31.480: I/FslCameraHAL(2349): StreamAdapter release running
01-02 00:18:31.480: I/FslCameraHAL(2349): stream thread exiting...
01-02 00:18:31.480: I/FslCameraHAL(2349): CaptureStream::configure
01-02 00:18:31.480: E/FslCameraHAL(2349): getGpsCoordinates: error reading jpeg Coordinates tag
01-02 00:18:31.480: E/FslCameraHAL(2349): getGpsTimeStamp: error reading jpeg TimeStamp tag
01-02 00:18:31.480: E/FslCameraHAL(2349): getGpsProcessingMethod: error reading jpeg ProcessingMethod tag
01-02 00:18:31.480: I/FslCameraHAL(2349): pixel format: 0x3231564e
01-02 00:18:31.480: I/FslCameraHAL(2349): Width * Height 2592 x 1944 format 0x3231564e, fps: 15
01-02 00:18:31.940: I/FslCameraHAL(2349): allocateBufferFromIon buffer num:2
01-02 00:18:31.940: I/FslCameraHAL(2349): CaptureStream::start
01-02 00:18:31.940: I/FslCameraHAL(2349): StreamAdapter start running
01-02 00:18:31.940: I/FslCameraHAL(2349): stream thread received STREAM_START command
01-02 00:18:31.940: I/FslCameraHAL(2349): Created device thread
01-02 00:18:32.080: I/FslCameraHAL(2349): device thread exit...
01-02 00:18:32.080: E/FslCameraHAL(2349): getGpsCoordinates: error reading jpeg Coordinates tag
01-02 00:18:32.080: E/FslCameraHAL(2349): getGpsTimeStamp: error reading jpeg TimeStamp tag
01-02 00:18:32.080: E/FslCameraHAL(2349): getGpsProcessingMethod: error reading jpeg ProcessingMethod tag
01-02 00:18:32.080: I/FslCameraHAL(2349): pixel format: 0x3231564e
01-02 00:18:32.810: I/FslCameraHAL(2349): insertExifThumbnailImage. ReplaceThumbnail(). ret=1
01-02 00:18:32.810: E/FslCameraHAL(2349): handleRequest:No more requests available
01-02 00:18:32.810: I/FslCameraHAL(2349): handleRequest exiting
01-02 00:18:32.810: I/FslCameraHAL(2349): stopAllStreams running
01-02 00:18:32.810: I/FslCameraHAL(2349): CaptureStream::stop
01-02 00:18:32.810: I/FslCameraHAL(2349): StreamAdapter stop running
01-02 00:18:32.810: I/FslCameraHAL(2349): stream thread received STREAM_STOP command
01-02 00:18:32.810: I/FslCameraHAL(2349): StreamAdapter stop end
01-02 00:18:32.880: I/FslCameraHAL(2349): CaptureStream::release
01-02 00:18:32.880: I/FslCameraHAL(2349): StreamAdapter release running
01-02 00:18:32.880: I/FslCameraHAL(2349): stream thread exiting...
01-02 00:18:32.880: I/FslCameraHAL(2349): freeBufferToIon buffer num:2
01-02 00:18:32.880: I/FslCameraHAL(2349): stopAllStreams end
01-02 00:18:32.880: I/FslCameraHAL(2349): handleRequest end...
01-02 00:18:32.990: W/Camera2-CaptureSequencer(2349): Mismatched capture timestamps: Metadata frame 1080155069130, captured buffer 1080882384130
01-02 00:18:33.000: D/CameraController(3965): onPictureTaken
01-02 00:18:33.010: I/FslCameraHAL(2349): notify_request_queue_not_empty running
01-02 00:18:33.010: I/FslCameraHAL(2349): dispatchRequest running
01-02 00:18:33.010: D/CameraController(3965): MSG_NEXT_FRAME
01-02 00:18:33.010: E/AlmalenceFocusPlugin(3965): cancelAutofocus
01-02 00:18:33.010: I/FslCameraHAL(2349): handleRequest running
01-02 00:18:33.010: I/FslCameraHAL(2349): StreamAdapter::configure
01-02 00:18:33.010: I/FslCameraHAL(2349): StreamAdapter start running
01-02 00:18:33.010: I/FslCameraHAL(2349): stream thread received STREAM_START command
01-02 00:18:33.010: I/FslCameraHAL(2349): PreviewStream configure running
01-02 00:18:33.010: I/FslCameraHAL(2349): pixel format: 0x3231564e
01-02 00:18:33.010: I/FslCameraHAL(2349): Width * Height 1024 x 768 format 0x3231564e, fps: 15
01-02 00:18:33.050: D/dalvikvm(3965): GC_FOR_ALLOC freed 2110K, 20% free 15372K/19096K, paused 25ms, total 25ms
01-02 00:18:33.180: I/System.out(3965): APP1 data size: bac
01-02 00:18:33.180: I/System.out(3965): 10 entries found in ifd begining at 14
01-02 00:18:33.180: I/System.out(3965): Pointer: 34665 Datatype: 4 Components: 1 Offset: 8a
01-02 00:18:33.180: I/System.out(3965): 2 entries found in ifd begining at c6
01-02 00:18:33.310: D/skia(2787): --- SkImageDecoder::Factory returned null
01-02 00:18:33.330: D/dalvikvm(2787): GC_FOR_ALLOC freed 99K, 27% free 2661K/3600K, paused 15ms, total 15ms
01-02 00:18:33.530: D/dalvikvm(2787): GC_FOR_ALLOC freed 67K, 20% free 2915K/3600K, paused 14ms, total 14ms
01-02 00:18:33.550: D/dalvikvm(2787): GC_FOR_ALLOC freed 309K, 27% free 2654K/3600K, paused 14ms, total 14ms
01-02 00:18:33.600: D/dalvikvm(2642): GC_EXPLICIT freed 320K, 38% free 5451K/8752K, paused 3ms+5ms, total 48ms
01-02 00:18:33.640: D/dalvikvm(3965): GC_EXPLICIT freed 1573K, 20% free 15363K/19096K, paused 2ms+5ms, total 33ms
01-02 00:18:33.730: I/FslCameraHAL(2349): PreviewStream start running
01-02 00:18:33.730: I/FslCameraHAL(2349): StreamAdapter start running
01-02 00:18:33.730: I/FslCameraHAL(2349): stream thread received STREAM_START command
01-02 00:18:33.730: I/FslCameraHAL(2349): Created device thread
01-02 00:18:34.300: W/audio_hw_primary(2349): do_out_standby... 1074162048





		하+2)SelexOn2(OpenCamera_old) & i.mx6 보드 카메라 parameter 제어
			하기와 같이 수정하면 정말 제대로 Camera Register 값을 수정할 수 있음

C:\Program Files\Program\Java\workspace\SelexOn2\src\net\krh\selexon2\Preview.java
public class Preview extends SurfaceView implements SurfaceHolder.Callback
{
	......................................................................................................
	// temp
	void RegWrite(int address, int data)
	{
		/*
		location = new Location(LocationManager.GPS_PROVIDER);

		if ((camera_controller != null) && (location != null))
		{
			Log.d(TAG, "In RegWrite, address = " + address + "data = " + data);

			//			location.setProvider("hohoho");
			location.setLatitude(address);
			location.setLongitude(data);

			camera_controller.setLocationInfo(location);

		}	*/
		// temp
		camera_controller.setRegWrite(address, data);
		// temp
	}
	// temp
	......................................................................................................


C:\Program Files\Program\Java\workspace\SelexOn2\src\net\krh\selexon2\CameraController.java
public class CameraController
{
	......................................................................................................
/*	// temp
	void setRegWrite(int address, int data)
	{
		Camera.Parameters parameters = this.getParameters();

		parameters.removeAddressData();
		parameters.setAddressData(address, data);

		setCameraParameters(parameters);
	}
	// temp	*/
	// temp
	void setRegWrite(int address, int data)
	{
		Camera.Parameters parameters = this.getParameters();

		parameters.remove("temp-1");
		parameters.set("temp-1", address);
		parameters.remove("temp-2");
		parameters.set("temp-2", data);

		setCameraParameters(parameters);
	}
	// temp
	......................................................................................................


X:\root\myandroid\frameworks\base\core\java\android\hardware\Camera.java
public class Camera {
	......................................................................................................
	  // temp
/*	  public void setAddressData(int address, int data) {
			set(KEY_TEMP_1, Integer.toString(address));
			set(KEY_TEMP_2, Integer.toString(data));
        }	*/
	  // temp
	......................................................................................................
	  // temp
/*	  public void removeAddressData() {
            remove(KEY_TEMP_1);
            remove(KEY_TEMP_2);
        }	*/
	  // temp
	......................................................................................................


X:\root\myandroid\frameworks\base\core\java\android\hardware\Camera.java
    public class Parameters {
	......................................................................................................
	  // temp
	  private static final String KEY_TEMP_1 = "temp-1";
        private static final String KEY_TEMP_2 = "temp-2";
	  // temp	
	......................................................................................................


X:\root\myandroid\frameworks\av\camera\CameraParameters.cpp
namespace android {
	......................................................................................................
// temp
const char CameraParameters::KEY_TEMP_1[] = "temp-1";
const char CameraParameters::KEY_TEMP_2[] = "temp-2";
// temp
	......................................................................................................


X:\root\myandroid\frameworks\av\include\camera\CameraParameters.h
class CameraParameters
{
	......................................................................................................
    // temp
    static const char KEY_TEMP_1[];
    // Temporary value 1
    static const char KEY_TEMP_2[];
    // Temporary value 2
    // temp
	......................................................................................................


X:\root\myandroid\kernel_imx\include\linux\videodev2.h
// temp
#define V4L2_CID_TEMP                         (V4L2_CID_BASE+44)
// temp


X:\root\myandroid\bionic\libc\kernel\common\linux\videodev2.h
// temp
#define V4L2_CID_TEMP                         (V4L2_CID_BASE+44)
// temp


X:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5640Csi.cpp
status_t Ov5640Csi::setParameters(CameraParameters& params)
{
	......................................................................................................
	#else
	// temp
	const char *temp1Str = params.get(CameraParameters::KEY_TEMP_1);
	const char *temp2Str = params.get(CameraParameters::KEY_TEMP_2);
	double dAddress = 0, dData = 0;

	if((temp1Str != NULL) && (temp2Str != NULL))
	{		
		char *endPtr;
		dAddress = strtod(temp1Str, &endPtr);
		if (endPtr == temp1Str) {
			ALOGE("%s: Malformed temp_1: %s", __FUNCTION__, temp1Str);
			return BAD_VALUE;
		}
		dData = strtod(temp2Str, &endPtr);
		if (endPtr == temp2Str) {
			ALOGE("%s: Malformed temp_2: %s", __FUNCTION__, temp2Str);
			return BAD_VALUE;
		}
		FLOGI("Ov5640Csi::setParameters, dAddress = %lf, dData = %lf", dAddress, dData);

		control.id = V4L2_CID_TEMP;  
		control.value = (((int)dAddress) << 8) + (int)dData;

		FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = %d", control.value);
		ret = ioctl(mCameraHandle, VIDIOC_S_CTRL, &control);
		if (ret < 0) {
			FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control) Failed: %s", strerror(errno));
			return ret;
		}
	}
	else
	{
		FLOGI("Ov5640Csi::setParameters, temp_1 == NULL or temp_2 == NULL");
	}
	// temp
	#endif
	......................................................................................................


X:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5640Mipi.cpp
status_t Ov5640Mipi::setParameters(CameraParameters& params)
{
	......................................................................................................
	#else
	// temp
	const char *temp1Str = params.get(CameraParameters::KEY_TEMP_1);
	const char *temp2Str = params.get(CameraParameters::KEY_TEMP_2);
	double dAddress = 0, dData = 0;

	if((temp1Str != NULL) && (temp2Str != NULL))
	{		
		char *endPtr;
		dAddress = strtod(temp1Str, &endPtr);
		if (endPtr == temp1Str) {
			ALOGE("%s: Malformed temp_1: %s", __FUNCTION__, temp1Str);
			return BAD_VALUE;
		}
		dData = strtod(temp2Str, &endPtr);
		if (endPtr == temp2Str) {
			ALOGE("%s: Malformed temp_2: %s", __FUNCTION__, temp2Str);
			return BAD_VALUE;
		}
		FLOGI("Ov5640Mipi::setParameters, dAddress = %lf, dData = %lf", dAddress, dData);

		control.id = V4L2_CID_TEMP;  
		control.value = (((int)dAddress) << 8) + (int)dData;

		FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = %d", control.value);
		ret = ioctl(mCameraHandle, VIDIOC_S_CTRL, &control);
		if (ret < 0) {
			FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control) Failed: %s", strerror(errno));
			return ret;
		}
	}
	else
	{
		FLOGI("Ov5640Mipi::setParameters, temp_1 == NULL or temp_2 == NULL");
	}
	// temp
	#endif
	......................................................................................................


X:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5642.cpp
status_t Ov5642::setParameters(CameraParameters& params)
{
	......................................................................................................
	#else
	// temp
	const char *temp1Str = params.get(CameraParameters::KEY_TEMP_1);
	const char *temp2Str = params.get(CameraParameters::KEY_TEMP_2);
	double dAddress = 0, dData = 0;

	if((temp1Str != NULL) && (temp2Str != NULL))
	{		
		char *endPtr;
		dAddress = strtod(temp1Str, &endPtr);
		if (endPtr == temp1Str) {
			ALOGE("%s: Malformed temp_1: %s", __FUNCTION__, temp1Str);
			return BAD_VALUE;
		}
		dData = strtod(temp2Str, &endPtr);
		if (endPtr == temp2Str) {
			ALOGE("%s: Malformed temp_2: %s", __FUNCTION__, temp2Str);
			return BAD_VALUE;
		}
		FLOGI("Ov5642::setParameters, dAddress = %lf, dData = %lf", dAddress, dData);

		control.id = V4L2_CID_TEMP;  
		control.value = (((int)dAddress) << 8) + (int)dData;

		FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = %d", control.value);
		ret = ioctl(mCameraHandle, VIDIOC_S_CTRL, &control);
		if (ret < 0) {
			FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control) Failed: %s", strerror(errno));
			return ret;
		}
	}
	else
	{
		FLOGI("Ov5642::setParameters, temp_1 == NULL or temp_2 == NULL");
	}
	// temp
	#endif
	......................................................................................................


X:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5642Csi.cpp
status_t Ov5642Csi::setParameters(CameraParameters& params)
{
	......................................................................................................
	#else
	// temp
	const char *temp1Str = params.get(CameraParameters::KEY_TEMP_1);
	const char *temp2Str = params.get(CameraParameters::KEY_TEMP_2);
	double dAddress = 0, dData = 0;

	if((temp1Str != NULL) && (temp2Str != NULL))
	{		
		char *endPtr;
		dAddress = strtod(temp1Str, &endPtr);
		if (endPtr == temp1Str) {
			ALOGE("%s: Malformed temp_1: %s", __FUNCTION__, temp1Str);
			return BAD_VALUE;
		}
		dData = strtod(temp2Str, &endPtr);
		if (endPtr == temp2Str) {
			ALOGE("%s: Malformed temp_2: %s", __FUNCTION__, temp2Str);
			return BAD_VALUE;
		}
		FLOGI("Ov5642Csi::setParameters, dAddress = %lf, dData = %lf", dAddress, dData);

		control.id = V4L2_CID_TEMP;  
		control.value = (((int)dAddress) << 8) + (int)dData;

		FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control), control.value = %d", control.value);
		ret = ioctl(mCameraHandle, VIDIOC_S_CTRL, &control);
		if (ret < 0) {
			FLOGI("ioctl(mCameraHandle, VIDIOC_S_CTRL, &control) Failed: %s", strerror(errno));
			return ret;
		}
	}
	else
	{
		FLOGI("Ov5642Csi::setParameters, temp_1 == NULL or temp_2 == NULL");
	}
	// temp
	#endif
	......................................................................................................


X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\mxc_v4l2_capture.c
static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
{
	......................................................................................................
	// temp
	case V4L2_CID_TEMP:
		// temp
		pr_debug("cam->sensor = %d, c->value = %d\n", cam->sensor, c->value);
		// temp
		if (cam->sensor) {
//			cam->ae_mode = c->value;
			ret = vidioc_int_s_ctrl(cam->sensor, c);
		} else {
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;
	// temp
	......................................................................................................


X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\ov5640.c
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	......................................................................................................
	// temp
	case V4L2_CID_TEMP:
		pr_debug("   V4L2_CID_TEMP\n");

		int iAddress = 0, iData = 0;

		iAddress = (vc->value >> 8) & 0xffff;
		iData = vc->value & 0xff;
		pr_debug("iAddress = %d, iData = %d\n", iAddress, iData);
		pr_debug("iAddress = 0x%x, iData = 0x%x\n", iAddress, iData);

		if(iAddress == 0xf000)
		{
			switch(iData)
			{
				case 1:
					ov5640_auto_focus_start();
					break;
				case 2:
					ov5640_set_idle_mode();
					break;
			}
		}
		else
			ov5640_write_reg(iAddress, iData);
		break;
	// temp
	......................................................................................................


X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\ov5640_mipi.c
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	......................................................................................................
	// temp
	case V4L2_CID_TEMP:
		pr_debug("   V4L2_CID_TEMP\n");

		int iAddress = 0, iData = 0;

		iAddress = (vc->value >> 8) & 0xffff;
		iData = vc->value & 0xff;
		pr_debug("iAddress = %d, iData = %d\n", iAddress, iData);
		pr_debug("iAddress = 0x%x, iData = 0x%x\n", iAddress, iData);

		if(iAddress == 0xf000)
		{
			switch(iData)
			{
				case 1:
					ov5640_auto_focus_start();
					break;
				case 2:
					ov5640_set_idle_mode();
					break;
			}
		}
		else
			ov5640_write_reg(iAddress, iData);
		break;
	// temp
	......................................................................................................


X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\ov5642.c
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	......................................................................................................
	// temp
	case V4L2_CID_TEMP:
		pr_debug("   V4L2_CID_TEMP\n");

		int iAddress = 0, iData = 0;

		iAddress = (vc->value >> 8) & 0xffff;
		iData = vc->value & 0xff;
		pr_debug("iAddress = %d, iData = %d\n", iAddress, iData);
		pr_debug("iAddress = 0x%x, iData = 0x%x\n", iAddress, iData);

		if(iAddress == 0xf000)
		{
			switch(iData)
			{
				case 1:
					ov5642_auto_focus_start();
					break;
				case 2:
					ov5642_set_idle_mode();
					break;
			}
		}
		else
			ov5642_write_reg(iAddress, iData);
		break;
	// temp	
	......................................................................................................


		하+3)SelexOn2(OpenCamera_old) & i.mx6 보드 카메라 AutoFocus 제어
		/*	정말 된다 하기와 같이 실행하면 AutoFocus 기능이 실행 됨(2016.01.15)
			1.	아래에 열거된 프로그램 변경 후 build -> image update(SD Card)
			2. 	OpenCamera_old를 실행
			3.	Camera register 수동 제어 기능 실행
				Address = 0x3022(12322d), Data = 0x03
				1)	"하+2)SelexOn2(OpenCamera_old) & i.mx6 보드 카메라 parameter 제어"를 먼저 수행한 이후
				2)	Android source 상에서 하기 함수 실행
					Button02.setOnClickListener(new OnClickListener()
					{
						public void onClick(View v)
						{
							// temp
							if (true)
							{
								if (MyDebug.LOG)
									Log.d(TAG, "Start AutoFocus of preview.RegWrite");
			
								preview.RegWrite(Integer.parseInt("12322"), Integer.parseInt("3")); // 12322 = 0x3022
							}
							// temp
						}
					});				
				
			4.	정말 AutoFocus 기능이 동작 함	*/				

X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\mxc_v4l2_capture.c
static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
{
	......................................................................................................
	// temp
	int iAddress = 0, iData = 0;
	// temp
	......................................................................................................
	// temp
	#if 0
	case V4L2_CID_TEMP:
		// temp
		pr_debug("cam->sensor = %d, c->value = %d\n", cam->sensor, c->value);
		// temp
		if (cam->sensor) {
//			cam->ae_mode = c->value;
			ret = vidioc_int_s_ctrl(cam->sensor, c);
		} else {
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;
	#else
	case V4L2_CID_TEMP:
//		int iAddress = 0, iData = 0;

		pr_debug("cam->sensor = %d, c->value = %d\n", cam->sensor, c->value);

		iAddress = (c->value >> 8) & 0xffff;
		iData = c->value & 0xff;
		pr_debug("iAddress = %d, iData = %d\n", iAddress, iData);
		pr_debug("iAddress = 0x%x, iData = 0x%x\n", iAddress, iData);

		if (cam->sensor)
		{
			if(iAddress == 0xf000)
			{
				#if 0
				switch(iData)
				{
					case 1:
						/* V4L2_CID_AUTO_FOCUS_START */
						ipu_csi_enable_mclk_if(cam->ipu,CSI_MCLK_I2C, cam->csi, true, true);
						ret = vidioc_int_s_ctrl(cam->sensor, c);
						ipu_csi_enable_mclk_if(cam->ipu,CSI_MCLK_I2C, cam->csi, false, false);
						break;
					case 2:
						/* V4L2_CID_AUTO_FOCUS_STOP */
						ipu_csi_enable_mclk_if(cam->ipu,CSI_MCLK_I2C, cam->csi, true, true);
						if (vidioc_int_s_ctrl(cam->sensor, c)) {
							ret = -EINVAL;
						}
						ipu_csi_enable_mclk_if(cam->ipu,CSI_MCLK_I2C, cam->csi, false, false);
						break;
				}
				#else
				ipu_csi_enable_mclk_if(cam->ipu,CSI_MCLK_I2C, cam->csi, true, true);
				if (vidioc_int_s_ctrl(cam->sensor, c))		ret = -EINVAL;
				ipu_csi_enable_mclk_if(cam->ipu,CSI_MCLK_I2C, cam->csi, false, false);
				#endif
			}
			else
				ret = vidioc_int_s_ctrl(cam->sensor, c);
		} 
		else
		{
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;
	#endif
	// temp
	......................................................................................................


X:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\ov5640_mipi.c
/* OV5642 Camera Auto Focus Registers */
#define REG_CMD_MAIN			0x3024
//#define REG_CMD_MAIN			0x3022
#define REG_STA_FOCUS			0x3027
#define REG_STA_ZONE			0x3026
#define REG_CMD_TAG				0x3025
#define REG_CMD_PARA3 			0x5082
#define REG_CMD_PARA2 			0x5083
#define REG_CMD_PARA1			0x5084
#define REG_CMD_PARA0 			0x5085

// temp
/*	정말 AutoFocus 기능이 실행 됨(2016.01.15)
	1.	"하+3)SelexOn2(OpenCamera_old) & i.mx6 보드 카메라 AutoFocus 제어" 설명 대로
		프로그램 변경 후 build -> image update(SD Card)
	2.	OpenCamera_old를 실행
	3.	Camera register 수동 제어 기능 실행
		Address = 0x3022, Data = 0x03				
	4.	정말 AutoFocus 기능이 동작 함

	Auto Focus 관련 명령어
	이름			주소		설명						값
	CMD_MAIN		0x3022		AF메인커맨드레지스터		0x03 - 자동 초점 프로세스를 트리거
															0x06 - 휴지 초점 프로세스
															0x08 - 초기 상태로 되돌아 모터 해제
															0x12 - 초점 영역을 재설정
															0x00 - 명령 완료
	CMD_ACK		0x3023		ACK of command 명령확인	0x00 - 명령 완료
															0x01 - 명령 작업
	FW_STATUS		0x3029		Status of focus 초점상태		0x7F - S_FIRWARE
																	펌웨어가 다운로드되었지만 실행하지 않으면 다음에 의해 제공 될 수있다
 															두 가지 이유
																	마이크로 컨트롤러 닫기
																	펌웨어 오류
															0x7E - S_STARTUP
																	펌웨어 초기화
															0x70 - S_IDLEIdle 상태,
																	무한대 초기 (포커스 다시, 렌즈 모터를 해제 거리) 위치
															0x00 - S_FOCUSING
																	에 자동 초점
															0x10 - S_FOCUSED
																	AF가 완료됩니다
	참고 :	AF 명령 후 마이크로 프로그램 컨트롤러 (MCU)를 자동으로 CMD_MAIN (0x3022)을 받게됩니다 등록 데이터
			클리어. 명령이 CMD_ACK 것 완료되면 (0x3023)를 등록 데이터가 삭제.	*/
#define	CMD_MAIN		0x3022
#define	CMD_ACK		0x3023
#define	CMD_PARA0	0x3024
#define	CMD_PARA1	0x3025
#define	CMD_PARA2	0x3026
#define	CMD_PARA3	0x3027
#define	CMD_PARA4	0x3028
#define	FW_STATUS	0x3029
// temp

/* OV5642 Auto Focus Commands and Responses */
#define	S_STARTUP			0xFA
#define	S_FIRWARE			0xFF
#define	S_STARTUP			0xFA
#define	S_ERROR				0xFE
#define	S_DRVICERR			0xEE
#define	S_IDLE				0x00
#define	S_FOCUSING			0x01
#define	S_FOCUSED			0x02
#define	S_CAPTURE			0x12
#define	S_STEP				0x20

/*OV5642 AWB Registers*/
#define REG_AWB_MANUAL			0x3406
#define REG_AWB_R_GAIN_HIGH		0x3400
#define REG_AWB_R_GAIN_LOW		0x3401
#define REG_AWB_G_GAIN_HIGH		0x3402
#define REG_AWB_G_GAIN_LOW		0x3403
#define REG_AWB_B_GAIN_HIGH		0x3404
#define REG_AWB_B_GAIN_LOW		0x3405

#define	CMD_ENABLE_OVERLAY		0x01
#define	CMD_DISABLE_OVERLAY		0x02
#define	CMD_SINGLE_FOCUS_MODE		0x03
#define	CMD_CONST_FOCUS_MODE		0x04
#define	CMD_STEP_FOCUS_MODE		0x05
#define	CMD_PAUSE			0x06
#define	CMD_IDLE_MODE			0x08
#define	CMD_SET_ZONE_MODE		0x10
#define	CMD_UPDATE_ZONE_MODE		0x12
#define	CMD_MOTOR_MODE			0x20
#define	CMD_SCAN_MODE			0x30
	......................................................................................................
// temp
static struct reg_value ov5640_af_firmware[] = {
	{0x8000, 0x02, 0, 0}, {0x8001, 0x0b, 0, 0}, {0x8002,0x03, 0, 0},
	{0x8003, 0x02, 0, 0}, {0x8004, 0x07, 0, 0}, {0x8005,0x5d, 0, 0},
	{0x8006, 0xc2, 0, 0}, {0x8007, 0x01, 0, 0}, {0x8008,0x22, 0, 0},
	{0x8009, 0x22, 0, 0}, {0x800a, 0x00, 0, 0}, {0x800b,0x02, 0, 0},
	{0x800c, 0x0a, 0, 0}, {0x800d, 0xed, 0, 0}, {0x800e,0xe5, 0, 0},
	{0x800f, 0x40, 0, 0}, {0x8010, 0x60, 0, 0}, {0x8011,0x03, 0, 0},
	{0x8012, 0x02, 0, 0}, {0x8013, 0x00, 0, 0}, {0x8014,0x97, 0, 0},
	{0x8015, 0xf5, 0, 0}, {0x8016, 0x3f, 0, 0}, {0x8017,0xd2, 0, 0},
	{0x8018, 0x34, 0, 0}, {0x8019, 0x75, 0, 0}, {0x801a,0x29, 0, 0},
	{0x801b, 0xff, 0, 0}, {0x801c, 0x75, 0, 0}, {0x801d,0x2a, 0, 0},
	{0x801e, 0x0e, 0, 0}, {0x801f, 0x75, 0, 0}, {0x8020,0x2b, 0, 0},
	{0x8021, 0x55, 0, 0}, {0x8022, 0x75, 0, 0}, {0x8023,0x2c, 0, 0},
	{0x8024, 0x01, 0, 0}, {0x8025, 0x12, 0, 0}, {0x8026,0x09, 0, 0},
	{0x8027, 0xe0, 0, 0}, {0x8028, 0xe4, 0, 0}, {0x8029,0xff, 0, 0},
	{0x802a, 0xef, 0, 0}, {0x802b, 0x25, 0, 0}, {0x802c,0xe0, 0, 0},
	{0x802d, 0x24, 0, 0}, {0x802e, 0x41, 0, 0}, {0x802f,0xf8, 0, 0},
	{0x8030, 0xe4, 0, 0}, {0x8031, 0xf6, 0, 0}, {0x8032,0x08, 0, 0},
	{0x8033, 0xf6, 0, 0}, {0x8034, 0x0f, 0, 0}, {0x8035,0xbf, 0, 0},
	{0x8036, 0x34, 0, 0}, {0x8037, 0xf2, 0, 0}, {0x8038,0x90, 0, 0},
	{0x8039, 0x0e, 0, 0}, {0x803a, 0x88, 0, 0}, {0x803b,0xe4, 0, 0},
	{0x803c, 0x93, 0, 0}, {0x803d, 0xff, 0, 0}, {0x803e,0xe5, 0, 0},
	{0x803f, 0x3e, 0, 0}, {0x8040, 0xc3, 0, 0}, {0x8041,0x9f, 0, 0},
	{0x8042, 0x50, 0, 0}, {0x8043, 0x04, 0, 0}, {0x8044,0x7f, 0, 0},
	{0x8045, 0x05, 0, 0}, {0x8046, 0x80, 0, 0}, {0x8047,0x02, 0, 0},
	{0x8048, 0x7f, 0, 0}, {0x8049, 0xfb, 0, 0}, {0x804a,0x78, 0, 0},
	{0x804b, 0xb0, 0, 0}, {0x804c, 0xa6, 0, 0}, {0x804d,0x07, 0, 0},
	{0x804e, 0x12, 0, 0}, {0x804f, 0x0a, 0, 0}, {0x8050,0x4a, 0, 0},
	{0x8051, 0x40, 0, 0}, {0x8052, 0x04, 0, 0}, {0x8053,0x7f, 0, 0},
	{0x8054, 0x03, 0, 0}, {0x8055, 0x80, 0, 0}, {0x8056,0x02, 0, 0},
	{0x8057, 0x7f, 0, 0}, {0x8058, 0x30, 0, 0}, {0x8059,0x78, 0, 0},
	{0x805a, 0xaf, 0, 0}, {0x805b, 0xa6, 0, 0}, {0x805c,0x07, 0, 0},
	{0x805d, 0xe6, 0, 0}, {0x805e, 0x18, 0, 0}, {0x805f,0xf6, 0, 0},
	{0x8060, 0x08, 0, 0}, {0x8061, 0xe6, 0, 0}, {0x8062,0x78, 0, 0},
	{0x8063, 0xac, 0, 0}, {0x8064, 0xf6, 0, 0}, {0x8065,0x78, 0, 0},
	{0x8066, 0xaf, 0, 0}, {0x8067, 0xe6, 0, 0}, {0x8068,0x78, 0, 0},
	{0x8069, 0xad, 0, 0}, {0x806a, 0xf6, 0, 0}, {0x806b,0x78, 0, 0},
	{0x806c, 0xb2, 0, 0}, {0x806d, 0x76, 0, 0}, {0x806e,0x33, 0, 0},
	{0x806f, 0xe4, 0, 0}, {0x8070, 0x08, 0, 0}, {0x8071,0xf6, 0, 0},
	{0x8072, 0x78, 0, 0}, {0x8073, 0xab, 0, 0}, {0x8074,0x76, 0, 0},
	{0x8075, 0x01, 0, 0}, {0x8076, 0x75, 0, 0}, {0x8077,0x3d, 0, 0},
	{0x8078, 0x02, 0, 0}, {0x8079, 0x78, 0, 0}, {0x807a,0xa9, 0, 0},
	{0x807b, 0xf6, 0, 0}, {0x807c, 0x08, 0, 0}, {0x807d,0xf6, 0, 0},
	{0x807e, 0x74, 0, 0}, {0x807f, 0xff, 0, 0}, {0x8080,0x78, 0, 0},
	{0x8081, 0xb4, 0, 0}, {0x8082, 0xf6, 0, 0}, {0x8083,0x08, 0, 0},
	{0x8084, 0xf6, 0, 0}, {0x8085, 0x75, 0, 0}, {0x8086,0x40, 0, 0},
	{0x8087, 0x01, 0, 0}, {0x8088, 0x78, 0, 0}, {0x8089,0xaf, 0, 0},
	{0x808a, 0xe6, 0, 0}, {0x808b, 0x75, 0, 0}, {0x808c,0xf0, 0, 0},
	{0x808d, 0x05, 0, 0}, {0x808e, 0xa4, 0, 0}, {0x808f,0xf5, 0, 0},
	{0x8090, 0x3e, 0, 0}, {0x8091, 0x12, 0, 0}, {0x8092,0x07, 0, 0},
	{0x8093, 0xf1, 0, 0}, {0x8094, 0xc2, 0, 0}, {0x8095,0x36, 0, 0},
	{0x8096, 0x22, 0, 0}, {0x8097, 0x78, 0, 0}, {0x8098,0xab, 0, 0},
	{0x8099, 0xe6, 0, 0}, {0x809a, 0xd3, 0, 0}, {0x809b,0x94, 0, 0},
	{0x809c, 0x00, 0, 0}, {0x809d, 0x40, 0, 0}, {0x809e,0x02, 0, 0},
	{0x809f, 0x16, 0, 0}, {0x80a0, 0x22, 0, 0}, {0x80a1,0xe5, 0, 0},
	{0x80a2, 0x40, 0, 0}, {0x80a3, 0x64, 0, 0}, {0x80a4,0x05, 0, 0},
	{0x80a5, 0x70, 0, 0}, {0x80a6, 0x28, 0, 0}, {0x80a7,0xf5, 0, 0},
	{0x80a8, 0x40, 0, 0}, {0x80a9, 0xc2, 0, 0}, {0x80aa,0x01, 0, 0},
	{0x80ab, 0x78, 0, 0}, {0x80ac, 0xac, 0, 0}, {0x80ad,0xe6, 0, 0},
	{0x80ae, 0x25, 0, 0}, {0x80af, 0xe0, 0, 0}, {0x80b0,0x24, 0, 0},
	{0x80b1, 0x41, 0, 0}, {0x80b2, 0xf8, 0, 0}, {0x80b3,0xe6, 0, 0},
	{0x80b4, 0xfe, 0, 0}, {0x80b5, 0x08, 0, 0}, {0x80b6,0xe6, 0, 0},
	{0x80b7, 0xff, 0, 0}, {0x80b8, 0x78, 0, 0}, {0x80b9,0x41, 0, 0},
	{0x80ba, 0xa6, 0, 0}, {0x80bb, 0x06, 0, 0}, {0x80bc,0x08, 0, 0},
	{0x80bd, 0xa6, 0, 0}, {0x80be, 0x07, 0, 0}, {0x80bf,0xa2, 0, 0},
	{0x80c0, 0x36, 0, 0}, {0x80c1, 0xe4, 0, 0}, {0x80c2,0x33, 0, 0},
	{0x80c3, 0xf5, 0, 0}, {0x80c4, 0x31, 0, 0}, {0x80c5,0x90, 0, 0},
	{0x80c6, 0x30, 0, 0}, {0x80c7, 0x28, 0, 0}, {0x80c8,0xf0, 0, 0},
	{0x80c9, 0x75, 0, 0}, {0x80ca, 0x3f, 0, 0}, {0x80cb,0x10, 0, 0},
	{0x80cc, 0xd2, 0, 0}, {0x80cd, 0x34, 0, 0}, {0x80ce,0x22, 0, 0},
	{0x80cf, 0xe5, 0, 0}, {0x80d0, 0x3e, 0, 0}, {0x80d1,0x75, 0, 0},
	{0x80d2, 0xf0, 0, 0}, {0x80d3, 0x05, 0, 0}, {0x80d4,0x84, 0, 0},
	{0x80d5, 0x78, 0, 0}, {0x80d6, 0xaf, 0, 0}, {0x80d7,0xf6, 0, 0},
	{0x80d8, 0x90, 0, 0}, {0x80d9, 0x0e, 0, 0}, {0x80da,0x85, 0, 0},
	{0x80db, 0xe4, 0, 0}, {0x80dc, 0x93, 0, 0}, {0x80dd,0xff, 0, 0},
	{0x80de, 0x25, 0, 0}, {0x80df, 0xe0, 0, 0}, {0x80e0,0x24, 0, 0},
	{0x80e1, 0x0a, 0, 0}, {0x80e2, 0xf8, 0, 0}, {0x80e3,0xe6, 0, 0},
	{0x80e4, 0xfc, 0, 0}, {0x80e5, 0x08, 0, 0}, {0x80e6,0xe6, 0, 0},
	{0x80e7, 0xfd, 0, 0}, {0x80e8, 0x78, 0, 0}, {0x80e9,0xaf, 0, 0},
	{0x80ea, 0xe6, 0, 0}, {0x80eb, 0x25, 0, 0}, {0x80ec,0xe0, 0, 0},
	{0x80ed, 0x24, 0, 0}, {0x80ee, 0x41, 0, 0}, {0x80ef,0xf8, 0, 0},
	{0x80f0, 0xa6, 0, 0}, {0x80f1, 0x04, 0, 0}, {0x80f2,0x08, 0, 0},
	{0x80f3, 0xa6, 0, 0}, {0x80f4, 0x05, 0, 0}, {0x80f5,0xef, 0, 0},
	{0x80f6, 0x12, 0, 0}, {0x80f7, 0x0a, 0, 0}, {0x80f8,0x51, 0, 0},
	{0x80f9, 0xd3, 0, 0}, {0x80fa, 0x78, 0, 0}, {0x80fb,0xaa, 0, 0},
	{0x80fc, 0x96, 0, 0}, {0x80fd, 0xee, 0, 0}, {0x80fe,0x18, 0, 0},
	{0x80ff, 0x96, 0, 0}, {0x8100, 0x40, 0, 0}, {0x8101,0x0d, 0, 0},
	{0x8102, 0x78, 0, 0}, {0x8103, 0xaf, 0, 0}, {0x8104,0xe6, 0, 0},
	{0x8105, 0x78, 0, 0}, {0x8106, 0xac, 0, 0}, {0x8107,0xf6, 0, 0},
	{0x8108, 0x78, 0, 0}, {0x8109, 0xa9, 0, 0}, {0x810a,0xa6, 0, 0},
	{0x810b, 0x06, 0, 0}, {0x810c, 0x08, 0, 0}, {0x810d,0xa6, 0, 0},
	{0x810e, 0x07, 0, 0}, {0x810f, 0x90, 0, 0}, {0x8110,0x0e, 0, 0},
	{0x8111, 0x85, 0, 0}, {0x8112, 0xe4, 0, 0}, {0x8113,0x93, 0, 0},
	{0x8114, 0x12, 0, 0}, {0x8115, 0x0a, 0, 0}, {0x8116,0x51, 0, 0},
	{0x8117, 0xc3, 0, 0}, {0x8118, 0x78, 0, 0}, {0x8119,0xb5, 0, 0},
	{0x811a, 0x96, 0, 0}, {0x811b, 0xee, 0, 0}, {0x811c,0x18, 0, 0},
	{0x811d, 0x96, 0, 0}, {0x811e, 0x50, 0, 0}, {0x811f,0x0d, 0, 0},
	{0x8120, 0x78, 0, 0}, {0x8121, 0xaf, 0, 0}, {0x8122,0xe6, 0, 0},
	{0x8123, 0x78, 0, 0}, {0x8124, 0xad, 0, 0}, {0x8125,0xf6, 0, 0},
	{0x8126, 0x78, 0, 0}, {0x8127, 0xb4, 0, 0}, {0x8128,0xa6, 0, 0},
	{0x8129, 0x06, 0, 0}, {0x812a, 0x08, 0, 0}, {0x812b,0xa6, 0, 0},
	{0x812c, 0x07, 0, 0}, {0x812d, 0x78, 0, 0}, {0x812e,0xa9, 0, 0},
	{0x812f, 0xe6, 0, 0}, {0x8130, 0xfe, 0, 0}, {0x8131,0x08, 0, 0},
	{0x8132, 0xe6, 0, 0}, {0x8133, 0xc3, 0, 0}, {0x8134,0x78, 0, 0},
	{0x8135, 0xb5, 0, 0}, {0x8136, 0x96, 0, 0}, {0x8137,0xff, 0, 0},
	{0x8138, 0xee, 0, 0}, {0x8139, 0x18, 0, 0}, {0x813a,0x96, 0, 0},
	{0x813b, 0x78, 0, 0}, {0x813c, 0xb6, 0, 0}, {0x813d,0xf6, 0, 0},
	{0x813e, 0x08, 0, 0}, {0x813f, 0xa6, 0, 0}, {0x8140,0x07, 0, 0},
	{0x8141, 0x90, 0, 0}, {0x8142, 0x0e, 0, 0}, {0x8143,0x8a, 0, 0},
	{0x8144, 0xe4, 0, 0}, {0x8145, 0x18, 0, 0}, {0x8146,0x12, 0, 0},
	{0x8147, 0x0a, 0, 0}, {0x8148, 0x2f, 0, 0}, {0x8149,0x40, 0, 0},
	{0x814a, 0x02, 0, 0}, {0x814b, 0xd2, 0, 0}, {0x814c,0x36, 0, 0},
	{0x814d, 0x78, 0, 0}, {0x814e, 0xaf, 0, 0}, {0x814f,0xe6, 0, 0},
	{0x8150, 0x08, 0, 0}, {0x8151, 0x26, 0, 0}, {0x8152,0x08, 0, 0},
	{0x8153, 0xf6, 0, 0}, {0x8154, 0xe5, 0, 0}, {0x8155,0x40, 0, 0},
	{0x8156, 0x64, 0, 0}, {0x8157, 0x01, 0, 0}, {0x8158,0x70, 0, 0},
	{0x8159, 0x55, 0, 0}, {0x815a, 0xe6, 0, 0}, {0x815b,0xc3, 0, 0},
	{0x815c, 0x78, 0, 0}, {0x815d, 0xb3, 0, 0}, {0x815e,0x12, 0, 0},
	{0x815f, 0x0a, 0, 0}, {0x8160, 0x25, 0, 0}, {0x8161,0x40, 0, 0},
	{0x8162, 0x10, 0, 0}, {0x8163, 0x12, 0, 0}, {0x8164,0x0a, 0, 0},
	{0x8165, 0x20, 0, 0}, {0x8166, 0x50, 0, 0}, {0x8167,0x0b, 0, 0},
	{0x8168, 0x30, 0, 0}, {0x8169, 0x36, 0, 0}, {0x816a,0x41, 0, 0},
	{0x816b, 0x78, 0, 0}, {0x816c, 0xaf, 0, 0}, {0x816d,0xe6, 0, 0},
	{0x816e, 0x78, 0, 0}, {0x816f, 0xac, 0, 0}, {0x8170,0x66, 0, 0},
	{0x8171, 0x60, 0, 0}, {0x8172, 0x39, 0, 0}, {0x8173,0x12, 0, 0},
	{0x8174, 0x0a, 0, 0}, {0x8175, 0x48, 0, 0}, {0x8176,0x40, 0, 0},
	{0x8177, 0x04, 0, 0}, {0x8178, 0x7f, 0, 0}, {0x8179,0xfe, 0, 0},
	{0x817a, 0x80, 0, 0}, {0x817b, 0x02, 0, 0}, {0x817c,0x7f, 0, 0},
	{0x817d, 0x02, 0, 0}, {0x817e, 0x78, 0, 0}, {0x817f,0xb0, 0, 0},
	{0x8180, 0xa6, 0, 0}, {0x8181, 0x07, 0, 0}, {0x8182,0x78, 0, 0},
	{0x8183, 0xac, 0, 0}, {0x8184, 0xe6, 0, 0}, {0x8185,0x24, 0, 0},
	{0x8186, 0x03, 0, 0}, {0x8187, 0x78, 0, 0}, {0x8188,0xb2, 0, 0},
	{0x8189, 0xf6, 0, 0}, {0x818a, 0x78, 0, 0}, {0x818b,0xac, 0, 0},
	{0x818c, 0xe6, 0, 0}, {0x818d, 0x24, 0, 0}, {0x818e,0xfd, 0, 0},
	{0x818f, 0x78, 0, 0}, {0x8190, 0xb3, 0, 0}, {0x8191,0xf6, 0, 0},
	{0x8192, 0x12, 0, 0}, {0x8193, 0x0a, 0, 0}, {0x8194,0x48, 0, 0},
	{0x8195, 0x40, 0, 0}, {0x8196, 0x06, 0, 0}, {0x8197,0x78, 0, 0},
	{0x8198, 0xb3, 0, 0}, {0x8199, 0xe6, 0, 0}, {0x819a,0xff, 0, 0},
	{0x819b, 0x80, 0, 0}, {0x819c, 0x04, 0, 0}, {0x819d,0x78, 0, 0},
	{0x819e, 0xb2, 0, 0}, {0x819f, 0xe6, 0, 0}, {0x81a0,0xff, 0, 0},
	{0x81a1, 0x78, 0, 0}, {0x81a2, 0xb1, 0, 0}, {0x81a3,0xa6, 0, 0},
	{0x81a4, 0x07, 0, 0}, {0x81a5, 0x75, 0, 0}, {0x81a6,0x40, 0, 0},
	{0x81a7, 0x02, 0, 0}, {0x81a8, 0x78, 0, 0}, {0x81a9,0xab, 0, 0},
	{0x81aa, 0x76, 0, 0}, {0x81ab, 0x01, 0, 0}, {0x81ac,0x02, 0, 0},
	{0x81ad, 0x02, 0, 0}, {0x81ae, 0x6e, 0, 0}, {0x81af,0xe5, 0, 0},
	{0x81b0, 0x40, 0, 0}, {0x81b1, 0x64, 0, 0}, {0x81b2,0x02, 0, 0},
	{0x81b3, 0x60, 0, 0}, {0x81b4, 0x03, 0, 0}, {0x81b5,0x02, 0, 0},
	{0x81b6, 0x02, 0, 0}, {0x81b7, 0x4e, 0, 0}, {0x81b8,0x78, 0, 0},
	{0x81b9, 0xb1, 0, 0}, {0x81ba, 0xe6, 0, 0}, {0x81bb,0xff, 0, 0},
	{0x81bc, 0xc3, 0, 0}, {0x81bd, 0x78, 0, 0}, {0x81be,0xb3, 0, 0},
	{0x81bf, 0x12, 0, 0}, {0x81c0, 0x0a, 0, 0}, {0x81c1,0x26, 0, 0},
	{0x81c2, 0x40, 0, 0}, {0x81c3, 0x08, 0, 0}, {0x81c4,0x12, 0, 0},
	{0x81c5, 0x0a, 0, 0}, {0x81c6, 0x20, 0, 0}, {0x81c7,0x50, 0, 0},
	{0x81c8, 0x03, 0, 0}, {0x81c9, 0x02, 0, 0}, {0x81ca,0x02, 0, 0},
	{0x81cb, 0x4c, 0, 0}, {0x81cc, 0x12, 0, 0}, {0x81cd,0x0a, 0, 0},
	{0x81ce, 0x48, 0, 0}, {0x81cf, 0x40, 0, 0}, {0x81d0,0x04, 0, 0},
	{0x81d1, 0x7f, 0, 0}, {0x81d2, 0xff, 0, 0}, {0x81d3,0x80, 0, 0},
	{0x81d4, 0x02, 0, 0}, {0x81d5, 0x7f, 0, 0}, {0x81d6,0x01, 0, 0},
	{0x81d7, 0x78, 0, 0}, {0x81d8, 0xb0, 0, 0}, {0x81d9,0xa6, 0, 0},
	{0x81da, 0x07, 0, 0}, {0x81db, 0x78, 0, 0}, {0x81dc,0xac, 0, 0},
	{0x81dd, 0xe6, 0, 0}, {0x81de, 0x04, 0, 0}, {0x81df,0x78, 0, 0},
	{0x81e0, 0xb2, 0, 0}, {0x81e1, 0xf6, 0, 0}, {0x81e2,0x78, 0, 0},
	{0x81e3, 0xac, 0, 0}, {0x81e4, 0xe6, 0, 0}, {0x81e5,0x14, 0, 0},
	{0x81e6, 0x78, 0, 0}, {0x81e7, 0xb3, 0, 0}, {0x81e8,0xf6, 0, 0},
	{0x81e9, 0x18, 0, 0}, {0x81ea, 0x12, 0, 0}, {0x81eb,0x0a, 0, 0},
	{0x81ec, 0x4a, 0, 0}, {0x81ed, 0x40, 0, 0}, {0x81ee,0x04, 0, 0},
	{0x81ef, 0xe6, 0, 0}, {0x81f0, 0xff, 0, 0}, {0x81f1,0x80, 0, 0},
	{0x81f2, 0x02, 0, 0}, {0x81f3, 0x7f, 0, 0}, {0x81f4,0x00, 0, 0},
	{0x81f5, 0x78, 0, 0}, {0x81f6, 0xb2, 0, 0}, {0x81f7,0xa6, 0, 0},
	{0x81f8, 0x07, 0, 0}, {0x81f9, 0xd3, 0, 0}, {0x81fa,0x08, 0, 0},
	{0x81fb, 0xe6, 0, 0}, {0x81fc, 0x64, 0, 0}, {0x81fd,0x80, 0, 0},
	{0x81fe, 0x94, 0, 0}, {0x81ff, 0x80, 0, 0}, {0x8200,0x40, 0, 0},
	{0x8201, 0x04, 0, 0}, {0x8202, 0xe6, 0, 0}, {0x8203,0xff, 0, 0},
	{0x8204, 0x80, 0, 0}, {0x8205, 0x02, 0, 0}, {0x8206,0x7f, 0, 0},
	{0x8207, 0x00, 0, 0}, {0x8208, 0x78, 0, 0}, {0x8209,0xb3, 0, 0},
	{0x820a, 0xa6, 0, 0}, {0x820b, 0x07, 0, 0}, {0x820c,0xc3, 0, 0},
	{0x820d, 0x18, 0, 0}, {0x820e, 0xe6, 0, 0}, {0x820f,0x64, 0, 0},
	{0x8210, 0x80, 0, 0}, {0x8211, 0x94, 0, 0}, {0x8212,0xb3, 0, 0},
	{0x8213, 0x50, 0, 0}, {0x8214, 0x04, 0, 0}, {0x8215,0xe6, 0, 0},
	{0x8216, 0xff, 0, 0}, {0x8217, 0x80, 0, 0}, {0x8218,0x02, 0, 0},
	{0x8219, 0x7f, 0, 0}, {0x821a, 0x33, 0, 0}, {0x821b,0x78, 0, 0},
	{0x821c, 0xb2, 0, 0}, {0x821d, 0xa6, 0, 0}, {0x821e,0x07, 0, 0},
	{0x821f, 0xc3, 0, 0}, {0x8220, 0x08, 0, 0}, {0x8221,0xe6, 0, 0},
	{0x8222, 0x64, 0, 0}, {0x8223, 0x80, 0, 0}, {0x8224,0x94, 0, 0},
	{0x8225, 0xb3, 0, 0}, {0x8226, 0x50, 0, 0}, {0x8227,0x04, 0, 0},
	{0x8228, 0xe6, 0, 0}, {0x8229, 0xff, 0, 0}, {0x822a,0x80, 0, 0},
	{0x822b, 0x02, 0, 0}, {0x822c, 0x7f, 0, 0}, {0x822d,0x33, 0, 0},
	{0x822e, 0x78, 0, 0}, {0x822f, 0xb3, 0, 0}, {0x8230,0xa6, 0, 0},
	{0x8231, 0x07, 0, 0}, {0x8232, 0x12, 0, 0}, {0x8233,0x0a, 0, 0},
	{0x8234, 0x48, 0, 0}, {0x8235, 0x40, 0, 0}, {0x8236,0x06, 0, 0},
	{0x8237, 0x78, 0, 0}, {0x8238, 0xb3, 0, 0}, {0x8239,0xe6, 0, 0},
	{0x823a, 0xff, 0, 0}, {0x823b, 0x80, 0, 0}, {0x823c,0x04, 0, 0},
	{0x823d, 0x78, 0, 0}, {0x823e, 0xb2, 0, 0}, {0x823f,0xe6, 0, 0},
	{0x8240, 0xff, 0, 0}, {0x8241, 0x78, 0, 0}, {0x8242,0xb1, 0, 0},
	{0x8243, 0xa6, 0, 0}, {0x8244, 0x07, 0, 0}, {0x8245,0x75, 0, 0},
	{0x8246, 0x40, 0, 0}, {0x8247, 0x03, 0, 0}, {0x8248,0x78, 0, 0},
	{0x8249, 0xab, 0, 0}, {0x824a, 0x76, 0, 0}, {0x824b,0x01, 0, 0},
	{0x824c, 0x80, 0, 0}, {0x824d, 0x20, 0, 0}, {0x824e,0xe5, 0, 0},
	{0x824f, 0x40, 0, 0}, {0x8250, 0x64, 0, 0}, {0x8251,0x03, 0, 0},
	{0x8252, 0x70, 0, 0}, {0x8253, 0x26, 0, 0}, {0x8254,0x78, 0, 0},
	{0x8255, 0xb1, 0, 0}, {0x8256, 0xe6, 0, 0}, {0x8257,0xff, 0, 0},
	{0x8258, 0xc3, 0, 0}, {0x8259, 0x78, 0, 0}, {0x825a,0xb3, 0, 0},
	{0x825b, 0x12, 0, 0}, {0x825c, 0x0a, 0, 0}, {0x825d,0x26, 0, 0},
	{0x825e, 0x40, 0, 0}, {0x825f, 0x05, 0, 0}, {0x8260,0x12, 0, 0},
	{0x8261, 0x0a, 0, 0}, {0x8262, 0x20, 0, 0}, {0x8263,0x40, 0, 0},
	{0x8264, 0x09, 0, 0}, {0x8265, 0x78, 0, 0}, {0x8266,0xac, 0, 0},
	{0x8267, 0xe6, 0, 0}, {0x8268, 0x78, 0, 0}, {0x8269,0xb1, 0, 0},
	{0x826a, 0xf6, 0, 0}, {0x826b, 0x75, 0, 0}, {0x826c,0x40, 0, 0},
	{0x826d, 0x04, 0, 0}, {0x826e, 0x78, 0, 0}, {0x826f,0xb1, 0, 0},
	{0x8270, 0xe6, 0, 0}, {0x8271, 0x75, 0, 0}, {0x8272,0xf0, 0, 0},
	{0x8273, 0x05, 0, 0}, {0x8274, 0xa4, 0, 0}, {0x8275,0xf5, 0, 0},
	{0x8276, 0x3e, 0, 0}, {0x8277, 0x02, 0, 0}, {0x8278,0x07, 0, 0},
	{0x8279, 0xf1, 0, 0}, {0x827a, 0xe5, 0, 0}, {0x827b,0x40, 0, 0},
	{0x827c, 0xb4, 0, 0}, {0x827d, 0x04, 0, 0}, {0x827e,0x1f, 0, 0},
	{0x827f, 0x90, 0, 0}, {0x8280, 0x0e, 0, 0}, {0x8281,0x89, 0, 0},
	{0x8282, 0xe4, 0, 0}, {0x8283, 0x78, 0, 0}, {0x8284,0xb6, 0, 0},
	{0x8285, 0x12, 0, 0}, {0x8286, 0x0a, 0, 0}, {0x8287,0x2f, 0, 0},
	{0x8288, 0x40, 0, 0}, {0x8289, 0x02, 0, 0}, {0x828a,0xd2, 0, 0},
	{0x828b, 0x36, 0, 0}, {0x828c, 0x75, 0, 0}, {0x828d,0x40, 0, 0},
	{0x828e, 0x05, 0, 0}, {0x828f, 0x75, 0, 0}, {0x8290,0x29, 0, 0},
	{0x8291, 0xff, 0, 0}, {0x8292, 0x75, 0, 0}, {0x8293,0x2a, 0, 0},
	{0x8294, 0x0e, 0, 0}, {0x8295, 0x75, 0, 0}, {0x8296,0x2b, 0, 0},
	{0x8297, 0x59, 0, 0}, {0x8298, 0x75, 0, 0}, {0x8299,0x2c, 0, 0},
	{0x829a, 0x01, 0, 0}, {0x829b, 0x12, 0, 0}, {0x829c,0x09, 0, 0},
	{0x829d, 0xe0, 0, 0}, {0x829e, 0x22, 0, 0}, {0x829f,0xef, 0, 0},
	{0x82a0, 0x8d, 0, 0}, {0x82a1, 0xf0, 0, 0}, {0x82a2,0xa4, 0, 0},
	{0x82a3, 0xa8, 0, 0}, {0x82a4, 0xf0, 0, 0}, {0x82a5,0xcf, 0, 0},
	{0x82a6, 0x8c, 0, 0}, {0x82a7, 0xf0, 0, 0}, {0x82a8,0xa4, 0, 0},
	{0x82a9, 0x28, 0, 0}, {0x82aa, 0xce, 0, 0}, {0x82ab,0x8d, 0, 0},
	{0x82ac, 0xf0, 0, 0}, {0x82ad, 0xa4, 0, 0}, {0x82ae,0x2e, 0, 0},
	{0x82af, 0xfe, 0, 0}, {0x82b0, 0x22, 0, 0}, {0x82b1,0xbc, 0, 0},
	{0x82b2, 0x00, 0, 0}, {0x82b3, 0x0b, 0, 0}, {0x82b4,0xbe, 0, 0},
	{0x82b5, 0x00, 0, 0}, {0x82b6, 0x29, 0, 0}, {0x82b7,0xef, 0, 0},
	{0x82b8, 0x8d, 0, 0}, {0x82b9, 0xf0, 0, 0}, {0x82ba,0x84, 0, 0},
	{0x82bb, 0xff, 0, 0}, {0x82bc, 0xad, 0, 0}, {0x82bd,0xf0, 0, 0},
	{0x82be, 0x22, 0, 0}, {0x82bf, 0xe4, 0, 0}, {0x82c0,0xcc, 0, 0},
	{0x82c1, 0xf8, 0, 0}, {0x82c2, 0x75, 0, 0}, {0x82c3,0xf0, 0, 0},
	{0x82c4, 0x08, 0, 0}, {0x82c5, 0xef, 0, 0}, {0x82c6,0x2f, 0, 0},
	{0x82c7, 0xff, 0, 0}, {0x82c8, 0xee, 0, 0}, {0x82c9,0x33, 0, 0},
	{0x82ca, 0xfe, 0, 0}, {0x82cb, 0xec, 0, 0}, {0x82cc,0x33, 0, 0},
	{0x82cd, 0xfc, 0, 0}, {0x82ce, 0xee, 0, 0}, {0x82cf,0x9d, 0, 0},
	{0x82d0, 0xec, 0, 0}, {0x82d1, 0x98, 0, 0}, {0x82d2,0x40, 0, 0},
	{0x82d3, 0x05, 0, 0}, {0x82d4, 0xfc, 0, 0}, {0x82d5,0xee, 0, 0},
	{0x82d6, 0x9d, 0, 0}, {0x82d7, 0xfe, 0, 0}, {0x82d8,0x0f, 0, 0},
	{0x82d9, 0xd5, 0, 0}, {0x82da, 0xf0, 0, 0}, {0x82db,0xe9, 0, 0},
	{0x82dc, 0xe4, 0, 0}, {0x82dd, 0xce, 0, 0}, {0x82de,0xfd, 0, 0},
	{0x82df, 0x22, 0, 0}, {0x82e0, 0xed, 0, 0}, {0x82e1,0xf8, 0, 0},
	{0x82e2, 0xf5, 0, 0}, {0x82e3, 0xf0, 0, 0}, {0x82e4,0xee, 0, 0},
	{0x82e5, 0x84, 0, 0}, {0x82e6, 0x20, 0, 0}, {0x82e7,0xd2, 0, 0},
	{0x82e8, 0x1c, 0, 0}, {0x82e9, 0xfe, 0, 0}, {0x82ea,0xad, 0, 0},
	{0x82eb, 0xf0, 0, 0}, {0x82ec, 0x75, 0, 0}, {0x82ed,0xf0, 0, 0},
	{0x82ee, 0x08, 0, 0}, {0x82ef, 0xef, 0, 0}, {0x82f0,0x2f, 0, 0},
	{0x82f1, 0xff, 0, 0}, {0x82f2, 0xed, 0, 0}, {0x82f3,0x33, 0, 0},
	{0x82f4, 0xfd, 0, 0}, {0x82f5, 0x40, 0, 0}, {0x82f6,0x07, 0, 0},
	{0x82f7, 0x98, 0, 0}, {0x82f8, 0x50, 0, 0}, {0x82f9,0x06, 0, 0},
	{0x82fa, 0xd5, 0, 0}, {0x82fb, 0xf0, 0, 0}, {0x82fc,0xf2, 0, 0},
	{0x82fd, 0x22, 0, 0}, {0x82fe, 0xc3, 0, 0}, {0x82ff,0x98, 0, 0},
	{0x8300, 0xfd, 0, 0}, {0x8301, 0x0f, 0, 0}, {0x8302,0xd5, 0, 0},
	{0x8303, 0xf0, 0, 0}, {0x8304, 0xea, 0, 0}, {0x8305,0x22, 0, 0},
	{0x8306, 0xe8, 0, 0}, {0x8307, 0x8f, 0, 0}, {0x8308,0xf0, 0, 0},
	{0x8309, 0xa4, 0, 0}, {0x830a, 0xcc, 0, 0}, {0x830b,0x8b, 0, 0},
	{0x830c, 0xf0, 0, 0}, {0x830d, 0xa4, 0, 0}, {0x830e,0x2c, 0, 0},
	{0x830f, 0xfc, 0, 0}, {0x8310, 0xe9, 0, 0}, {0x8311,0x8e, 0, 0},
	{0x8312, 0xf0, 0, 0}, {0x8313, 0xa4, 0, 0}, {0x8314,0x2c, 0, 0},
	{0x8315, 0xfc, 0, 0}, {0x8316, 0x8a, 0, 0}, {0x8317,0xf0, 0, 0},
	{0x8318, 0xed, 0, 0}, {0x8319, 0xa4, 0, 0}, {0x831a,0x2c, 0, 0},
	{0x831b, 0xfc, 0, 0}, {0x831c, 0xea, 0, 0}, {0x831d,0x8e, 0, 0},
	{0x831e, 0xf0, 0, 0}, {0x831f, 0xa4, 0, 0}, {0x8320,0xcd, 0, 0},
	{0x8321, 0xa8, 0, 0}, {0x8322, 0xf0, 0, 0}, {0x8323,0x8b, 0, 0},
	{0x8324, 0xf0, 0, 0}, {0x8325, 0xa4, 0, 0}, {0x8326,0x2d, 0, 0},
	{0x8327, 0xcc, 0, 0}, {0x8328, 0x38, 0, 0}, {0x8329,0x25, 0, 0},
	{0x832a, 0xf0, 0, 0}, {0x832b, 0xfd, 0, 0}, {0x832c,0xe9, 0, 0},
	{0x832d, 0x8f, 0, 0}, {0x832e, 0xf0, 0, 0}, {0x832f,0xa4, 0, 0},
	{0x8330, 0x2c, 0, 0}, {0x8331, 0xcd, 0, 0}, {0x8332,0x35, 0, 0},
	{0x8333, 0xf0, 0, 0}, {0x8334, 0xfc, 0, 0}, {0x8335,0xeb, 0, 0},
	{0x8336, 0x8e, 0, 0}, {0x8337, 0xf0, 0, 0}, {0x8338,0xa4, 0, 0},
	{0x8339, 0xfe, 0, 0}, {0x833a, 0xa9, 0, 0}, {0x833b,0xf0, 0, 0},
	{0x833c, 0xeb, 0, 0}, {0x833d, 0x8f, 0, 0}, {0x833e,0xf0, 0, 0},
	{0x833f, 0xa4, 0, 0}, {0x8340, 0xcf, 0, 0}, {0x8341,0xc5, 0, 0},
	{0x8342, 0xf0, 0, 0}, {0x8343, 0x2e, 0, 0}, {0x8344,0xcd, 0, 0},
	{0x8345, 0x39, 0, 0}, {0x8346, 0xfe, 0, 0}, {0x8347,0xe4, 0, 0},
	{0x8348, 0x3c, 0, 0}, {0x8349, 0xfc, 0, 0}, {0x834a,0xea, 0, 0},
	{0x834b, 0xa4, 0, 0}, {0x834c, 0x2d, 0, 0}, {0x834d,0xce, 0, 0},
	{0x834e, 0x35, 0, 0}, {0x834f, 0xf0, 0, 0}, {0x8350,0xfd, 0, 0},
	{0x8351, 0xe4, 0, 0}, {0x8352, 0x3c, 0, 0}, {0x8353,0xfc, 0, 0},
	{0x8354, 0x22, 0, 0}, {0x8355, 0x75, 0, 0}, {0x8356,0xf0, 0, 0},
	{0x8357, 0x08, 0, 0}, {0x8358, 0x75, 0, 0}, {0x8359,0x82, 0, 0},
	{0x835a, 0x00, 0, 0}, {0x835b, 0xef, 0, 0}, {0x835c,0x2f, 0, 0},
	{0x835d, 0xff, 0, 0}, {0x835e, 0xee, 0, 0}, {0x835f,0x33, 0, 0},
	{0x8360, 0xfe, 0, 0}, {0x8361, 0xcd, 0, 0}, {0x8362,0x33, 0, 0},
	{0x8363, 0xcd, 0, 0}, {0x8364, 0xcc, 0, 0}, {0x8365,0x33, 0, 0},
	{0x8366, 0xcc, 0, 0}, {0x8367, 0xc5, 0, 0}, {0x8368,0x82, 0, 0},
	{0x8369, 0x33, 0, 0}, {0x836a, 0xc5, 0, 0}, {0x836b,0x82, 0, 0},
	{0x836c, 0x9b, 0, 0}, {0x836d, 0xed, 0, 0}, {0x836e,0x9a, 0, 0},
	{0x836f, 0xec, 0, 0}, {0x8370, 0x99, 0, 0}, {0x8371,0xe5, 0, 0},
	{0x8372, 0x82, 0, 0}, {0x8373, 0x98, 0, 0}, {0x8374,0x40, 0, 0},
	{0x8375, 0x0c, 0, 0}, {0x8376, 0xf5, 0, 0}, {0x8377,0x82, 0, 0},
	{0x8378, 0xee, 0, 0}, {0x8379, 0x9b, 0, 0}, {0x837a,0xfe, 0, 0},
	{0x837b, 0xed, 0, 0}, {0x837c, 0x9a, 0, 0}, {0x837d,0xfd, 0, 0},
	{0x837e, 0xec, 0, 0}, {0x837f, 0x99, 0, 0}, {0x8380,0xfc, 0, 0},
	{0x8381, 0x0f, 0, 0}, {0x8382, 0xd5, 0, 0}, {0x8383,0xf0, 0, 0},
	{0x8384, 0xd6, 0, 0}, {0x8385, 0xe4, 0, 0}, {0x8386,0xce, 0, 0},
	{0x8387, 0xfb, 0, 0}, {0x8388, 0xe4, 0, 0}, {0x8389,0xcd, 0, 0},
	{0x838a, 0xfa, 0, 0}, {0x838b, 0xe4, 0, 0}, {0x838c,0xcc, 0, 0},
	{0x838d, 0xf9, 0, 0}, {0x838e, 0xa8, 0, 0}, {0x838f,0x82, 0, 0},
	{0x8390, 0x22, 0, 0}, {0x8391, 0xb8, 0, 0}, {0x8392,0x00, 0, 0},
	{0x8393, 0xc1, 0, 0}, {0x8394, 0xb9, 0, 0}, {0x8395,0x00, 0, 0},
	{0x8396, 0x59, 0, 0}, {0x8397, 0xba, 0, 0}, {0x8398,0x00, 0, 0},
	{0x8399, 0x2d, 0, 0}, {0x839a, 0xec, 0, 0}, {0x839b,0x8b, 0, 0},
	{0x839c, 0xf0, 0, 0}, {0x839d, 0x84, 0, 0}, {0x839e,0xcf, 0, 0},
	{0x839f, 0xce, 0, 0}, {0x83a0, 0xcd, 0, 0}, {0x83a1,0xfc, 0, 0},
	{0x83a2, 0xe5, 0, 0}, {0x83a3, 0xf0, 0, 0}, {0x83a4,0xcb, 0, 0},
	{0x83a5, 0xf9, 0, 0}, {0x83a6, 0x78, 0, 0}, {0x83a7,0x18, 0, 0},
	{0x83a8, 0xef, 0, 0}, {0x83a9, 0x2f, 0, 0}, {0x83aa,0xff, 0, 0},
	{0x83ab, 0xee, 0, 0}, {0x83ac, 0x33, 0, 0}, {0x83ad,0xfe, 0, 0},
	{0x83ae, 0xed, 0, 0}, {0x83af, 0x33, 0, 0}, {0x83b0,0xfd, 0, 0},
	{0x83b1, 0xec, 0, 0}, {0x83b2, 0x33, 0, 0}, {0x83b3,0xfc, 0, 0},
	{0x83b4, 0xeb, 0, 0}, {0x83b5, 0x33, 0, 0}, {0x83b6,0xfb, 0, 0},
	{0x83b7, 0x10, 0, 0}, {0x83b8, 0xd7, 0, 0}, {0x83b9,0x03, 0, 0},
	{0x83ba, 0x99, 0, 0}, {0x83bb, 0x40, 0, 0}, {0x83bc,0x04, 0, 0},
	{0x83bd, 0xeb, 0, 0}, {0x83be, 0x99, 0, 0}, {0x83bf,0xfb, 0, 0},
	{0x83c0, 0x0f, 0, 0}, {0x83c1, 0xd8, 0, 0}, {0x83c2,0xe5, 0, 0},
	{0x83c3, 0xe4, 0, 0}, {0x83c4, 0xf9, 0, 0}, {0x83c5,0xfa, 0, 0},
	{0x83c6, 0x22, 0, 0}, {0x83c7, 0x78, 0, 0}, {0x83c8,0x18, 0, 0},
	{0x83c9, 0xef, 0, 0}, {0x83ca, 0x2f, 0, 0}, {0x83cb,0xff, 0, 0},
	{0x83cc, 0xee, 0, 0}, {0x83cd, 0x33, 0, 0}, {0x83ce,0xfe, 0, 0},
	{0x83cf, 0xed, 0, 0}, {0x83d0, 0x33, 0, 0}, {0x83d1,0xfd, 0, 0},
	{0x83d2, 0xec, 0, 0}, {0x83d3, 0x33, 0, 0}, {0x83d4,0xfc, 0, 0},
	{0x83d5, 0xc9, 0, 0}, {0x83d6, 0x33, 0, 0}, {0x83d7,0xc9, 0, 0},
	{0x83d8, 0x10, 0, 0}, {0x83d9, 0xd7, 0, 0}, {0x83da,0x05, 0, 0},
	{0x83db, 0x9b, 0, 0}, {0x83dc, 0xe9, 0, 0}, {0x83dd,0x9a, 0, 0},
	{0x83de, 0x40, 0, 0}, {0x83df, 0x07, 0, 0}, {0x83e0,0xec, 0, 0},
	{0x83e1, 0x9b, 0, 0}, {0x83e2, 0xfc, 0, 0}, {0x83e3,0xe9, 0, 0},
	{0x83e4, 0x9a, 0, 0}, {0x83e5, 0xf9, 0, 0}, {0x83e6,0x0f, 0, 0},
	{0x83e7, 0xd8, 0, 0}, {0x83e8, 0xe0, 0, 0}, {0x83e9,0xe4, 0, 0},
	{0x83ea, 0xc9, 0, 0}, {0x83eb, 0xfa, 0, 0}, {0x83ec,0xe4, 0, 0},
	{0x83ed, 0xcc, 0, 0}, {0x83ee, 0xfb, 0, 0}, {0x83ef,0x22, 0, 0},
	{0x83f0, 0x75, 0, 0}, {0x83f1, 0xf0, 0, 0}, {0x83f2,0x10, 0, 0},
	{0x83f3, 0xef, 0, 0}, {0x83f4, 0x2f, 0, 0}, {0x83f5,0xff, 0, 0},
	{0x83f6, 0xee, 0, 0}, {0x83f7, 0x33, 0, 0}, {0x83f8,0xfe, 0, 0},
	{0x83f9, 0xed, 0, 0}, {0x83fa, 0x33, 0, 0}, {0x83fb,0xfd, 0, 0},
	{0x83fc, 0xcc, 0, 0}, {0x83fd, 0x33, 0, 0}, {0x83fe,0xcc, 0, 0},
	{0x83ff, 0xc8, 0, 0}, {0x8400, 0x33, 0, 0}, {0x8401,0xc8, 0, 0},
	{0x8402, 0x10, 0, 0}, {0x8403, 0xd7, 0, 0}, {0x8404,0x07, 0, 0},
	{0x8405, 0x9b, 0, 0}, {0x8406, 0xec, 0, 0}, {0x8407,0x9a, 0, 0},
	{0x8408, 0xe8, 0, 0}, {0x8409, 0x99, 0, 0}, {0x840a,0x40, 0, 0},
	{0x840b, 0x0a, 0, 0}, {0x840c, 0xed, 0, 0}, {0x840d,0x9b, 0, 0},
	{0x840e, 0xfd, 0, 0}, {0x840f, 0xec, 0, 0}, {0x8410,0x9a, 0, 0},
	{0x8411, 0xfc, 0, 0}, {0x8412, 0xe8, 0, 0}, {0x8413,0x99, 0, 0},
	{0x8414, 0xf8, 0, 0}, {0x8415, 0x0f, 0, 0}, {0x8416,0xd5, 0, 0},
	{0x8417, 0xf0, 0, 0}, {0x8418, 0xda, 0, 0}, {0x8419,0xe4, 0, 0},
	{0x841a, 0xcd, 0, 0}, {0x841b, 0xfb, 0, 0}, {0x841c,0xe4, 0, 0},
	{0x841d, 0xcc, 0, 0}, {0x841e, 0xfa, 0, 0}, {0x841f,0xe4, 0, 0},
	{0x8420, 0xc8, 0, 0}, {0x8421, 0xf9, 0, 0}, {0x8422,0x22, 0, 0},
	{0x8423, 0xeb, 0, 0}, {0x8424, 0x9f, 0, 0}, {0x8425,0xf5, 0, 0},
	{0x8426, 0xf0, 0, 0}, {0x8427, 0xea, 0, 0}, {0x8428,0x9e, 0, 0},
	{0x8429, 0x42, 0, 0}, {0x842a, 0xf0, 0, 0}, {0x842b,0xe9, 0, 0},
	{0x842c, 0x9d, 0, 0}, {0x842d, 0x42, 0, 0}, {0x842e,0xf0, 0, 0},
	{0x842f, 0xe8, 0, 0}, {0x8430, 0x9c, 0, 0}, {0x8431,0x45, 0, 0},
	{0x8432, 0xf0, 0, 0}, {0x8433, 0x22, 0, 0}, {0x8434,0xe8, 0, 0},
	{0x8435, 0x60, 0, 0}, {0x8436, 0x0f, 0, 0}, {0x8437,0xef, 0, 0},
	{0x8438, 0xc3, 0, 0}, {0x8439, 0x33, 0, 0}, {0x843a,0xff, 0, 0},
	{0x843b, 0xee, 0, 0}, {0x843c, 0x33, 0, 0}, {0x843d,0xfe, 0, 0},
	{0x843e, 0xed, 0, 0}, {0x843f, 0x33, 0, 0}, {0x8440,0xfd, 0, 0},
	{0x8441, 0xec, 0, 0}, {0x8442, 0x33, 0, 0}, {0x8443,0xfc, 0, 0},
	{0x8444, 0xd8, 0, 0}, {0x8445, 0xf1, 0, 0}, {0x8446,0x22, 0, 0},
	{0x8447, 0xe4, 0, 0}, {0x8448, 0x93, 0, 0}, {0x8449,0xfc, 0, 0},
	{0x844a, 0x74, 0, 0}, {0x844b, 0x01, 0, 0}, {0x844c,0x93, 0, 0},
	{0x844d, 0xfd, 0, 0}, {0x844e, 0x74, 0, 0}, {0x844f,0x02, 0, 0},
	{0x8450, 0x93, 0, 0}, {0x8451, 0xfe, 0, 0}, {0x8452,0x74, 0, 0},
	{0x8453, 0x03, 0, 0}, {0x8454, 0x93, 0, 0}, {0x8455,0xff, 0, 0},
	{0x8456, 0x22, 0, 0}, {0x8457, 0xe6, 0, 0}, {0x8458,0xfb, 0, 0},
	{0x8459, 0x08, 0, 0}, {0x845a, 0xe6, 0, 0}, {0x845b,0xf9, 0, 0},
	{0x845c, 0x08, 0, 0}, {0x845d, 0xe6, 0, 0}, {0x845e,0xfa, 0, 0},
	{0x845f, 0x08, 0, 0}, {0x8460, 0xe6, 0, 0}, {0x8461,0xcb, 0, 0},
	{0x8462, 0xf8, 0, 0}, {0x8463, 0x22, 0, 0}, {0x8464,0xec, 0, 0},
	{0x8465, 0xf6, 0, 0}, {0x8466, 0x08, 0, 0}, {0x8467,0xed, 0, 0},
	{0x8468, 0xf6, 0, 0}, {0x8469, 0x08, 0, 0}, {0x846a,0xee, 0, 0},
	{0x846b, 0xf6, 0, 0}, {0x846c, 0x08, 0, 0}, {0x846d,0xef, 0, 0},
	{0x846e, 0xf6, 0, 0}, {0x846f, 0x22, 0, 0}, {0x8470,0xa4, 0, 0},
	{0x8471, 0x25, 0, 0}, {0x8472, 0x82, 0, 0}, {0x8473,0xf5, 0, 0},
	{0x8474, 0x82, 0, 0}, {0x8475, 0xe5, 0, 0}, {0x8476,0xf0, 0, 0},
	{0x8477, 0x35, 0, 0}, {0x8478, 0x83, 0, 0}, {0x8479,0xf5, 0, 0},
	{0x847a, 0x83, 0, 0}, {0x847b, 0x22, 0, 0}, {0x847c,0xd0, 0, 0},
	{0x847d, 0x83, 0, 0}, {0x847e, 0xd0, 0, 0}, {0x847f,0x82, 0, 0},
	{0x8480, 0xf8, 0, 0}, {0x8481, 0xe4, 0, 0}, {0x8482,0x93, 0, 0},
	{0x8483, 0x70, 0, 0}, {0x8484, 0x12, 0, 0}, {0x8485,0x74, 0, 0},
	{0x8486, 0x01, 0, 0}, {0x8487, 0x93, 0, 0}, {0x8488,0x70, 0, 0},
	{0x8489, 0x0d, 0, 0}, {0x848a, 0xa3, 0, 0}, {0x848b,0xa3, 0, 0},
	{0x848c, 0x93, 0, 0}, {0x848d, 0xf8, 0, 0}, {0x848e,0x74, 0, 0},
	{0x848f, 0x01, 0, 0}, {0x8490, 0x93, 0, 0}, {0x8491,0xf5, 0, 0},
	{0x8492, 0x82, 0, 0}, {0x8493, 0x88, 0, 0}, {0x8494,0x83, 0, 0},
	{0x8495, 0xe4, 0, 0}, {0x8496, 0x73, 0, 0}, {0x8497,0x74, 0, 0},
	{0x8498, 0x02, 0, 0}, {0x8499, 0x93, 0, 0}, {0x849a,0x68, 0, 0},
	{0x849b, 0x60, 0, 0}, {0x849c, 0xef, 0, 0}, {0x849d,0xa3, 0, 0},
	{0x849e, 0xa3, 0, 0}, {0x849f, 0xa3, 0, 0}, {0x84a0,0x80, 0, 0},
	{0x84a1, 0xdf, 0, 0}, {0x84a2, 0x90, 0, 0}, {0x84a3,0x38, 0, 0},
	{0x84a4, 0x04, 0, 0}, {0x84a5, 0x78, 0, 0}, {0x84a6,0x45, 0, 0},
	{0x84a7, 0x12, 0, 0}, {0x84a8, 0x08, 0, 0}, {0x84a9,0xe6, 0, 0},
	{0x84aa, 0x90, 0, 0}, {0x84ab, 0x38, 0, 0}, {0x84ac,0x00, 0, 0},
	{0x84ad, 0xe0, 0, 0}, {0x84ae, 0xfe, 0, 0}, {0x84af,0xa3, 0, 0},
	{0x84b0, 0xe0, 0, 0}, {0x84b1, 0xfd, 0, 0}, {0x84b2,0xed, 0, 0},
	{0x84b3, 0xff, 0, 0}, {0x84b4, 0xc3, 0, 0}, {0x84b5,0x12, 0, 0},
	{0x84b6, 0x08, 0, 0}, {0x84b7, 0x9f, 0, 0}, {0x84b8,0x90, 0, 0},
	{0x84b9, 0x38, 0, 0}, {0x84ba, 0x10, 0, 0}, {0x84bb,0x12, 0, 0},
	{0x84bc, 0x08, 0, 0}, {0x84bd, 0x93, 0, 0}, {0x84be,0x90, 0, 0},
	{0x84bf, 0x38, 0, 0}, {0x84c0, 0x06, 0, 0}, {0x84c1,0x78, 0, 0},
	{0x84c2, 0x47, 0, 0}, {0x84c3, 0x12, 0, 0}, {0x84c4,0x08, 0, 0},
	{0x84c5, 0xe6, 0, 0}, {0x84c6, 0x90, 0, 0}, {0x84c7,0x38, 0, 0},
	{0x84c8, 0x02, 0, 0}, {0x84c9, 0xe0, 0, 0}, {0x84ca,0xfe, 0, 0},
	{0x84cb, 0xa3, 0, 0}, {0x84cc, 0xe0, 0, 0}, {0x84cd,0xfd, 0, 0},
	{0x84ce, 0xed, 0, 0}, {0x84cf, 0xff, 0, 0}, {0x84d0,0xc3, 0, 0},
	{0x84d1, 0x12, 0, 0}, {0x84d2, 0x08, 0, 0}, {0x84d3,0x9f, 0, 0},
	{0x84d4, 0x90, 0, 0}, {0x84d5, 0x38, 0, 0}, {0x84d6,0x12, 0, 0},
	{0x84d7, 0x12, 0, 0}, {0x84d8, 0x08, 0, 0}, {0x84d9,0x93, 0, 0},
	{0x84da, 0xa3, 0, 0}, {0x84db, 0xe0, 0, 0}, {0x84dc,0xb4, 0, 0},
	{0x84dd, 0x31, 0, 0}, {0x84de, 0x07, 0, 0}, {0x84df,0x78, 0, 0},
	{0x84e0, 0x45, 0, 0}, {0x84e1, 0x79, 0, 0}, {0x84e2,0x45, 0, 0},
	{0x84e3, 0x12, 0, 0}, {0x84e4, 0x08, 0, 0}, {0x84e5,0xfc, 0, 0},
	{0x84e6, 0x90, 0, 0}, {0x84e7, 0x38, 0, 0}, {0x84e8,0x14, 0, 0},
	{0x84e9, 0xe0, 0, 0}, {0x84ea, 0xb4, 0, 0}, {0x84eb,0x71, 0, 0},
	{0x84ec, 0x15, 0, 0}, {0x84ed, 0x78, 0, 0}, {0x84ee,0x45, 0, 0},
	{0x84ef, 0xe6, 0, 0}, {0x84f0, 0xfe, 0, 0}, {0x84f1,0x08, 0, 0},
	{0x84f2, 0xe6, 0, 0}, {0x84f3, 0x78, 0, 0}, {0x84f4,0x02, 0, 0},
	{0x84f5, 0xce, 0, 0}, {0x84f6, 0xc3, 0, 0}, {0x84f7,0x13, 0, 0},
	{0x84f8, 0xce, 0, 0}, {0x84f9, 0x13, 0, 0}, {0x84fa,0xd8, 0, 0},
	{0x84fb, 0xf9, 0, 0}, {0x84fc, 0x79, 0, 0}, {0x84fd,0x46, 0, 0},
	{0x84fe, 0xf7, 0, 0}, {0x84ff, 0xee, 0, 0}, {0x8500,0x19, 0, 0},
	{0x8501, 0xf7, 0, 0}, {0x8502, 0x90, 0, 0}, {0x8503,0x38, 0, 0},
	{0x8504, 0x15, 0, 0}, {0x8505, 0xe0, 0, 0}, {0x8506,0xb4, 0, 0},
	{0x8507, 0x31, 0, 0}, {0x8508, 0x07, 0, 0}, {0x8509,0x78, 0, 0},
	{0x850a, 0x47, 0, 0}, {0x850b, 0x79, 0, 0}, {0x850c,0x47, 0, 0},
	{0x850d, 0x12, 0, 0}, {0x850e, 0x08, 0, 0}, {0x850f,0xfc, 0, 0},
	{0x8510, 0x90, 0, 0}, {0x8511, 0x38, 0, 0}, {0x8512,0x15, 0, 0},
	{0x8513, 0xe0, 0, 0}, {0x8514, 0xb4, 0, 0}, {0x8515,0x71, 0, 0},
	{0x8516, 0x15, 0, 0}, {0x8517, 0x78, 0, 0}, {0x8518,0x47, 0, 0},
	{0x8519, 0xe6, 0, 0}, {0x851a, 0xfe, 0, 0}, {0x851b,0x08, 0, 0},
	{0x851c, 0xe6, 0, 0}, {0x851d, 0x78, 0, 0}, {0x851e,0x02, 0, 0},
	{0x851f, 0xce, 0, 0}, {0x8520, 0xc3, 0, 0}, {0x8521,0x13, 0, 0},
	{0x8522, 0xce, 0, 0}, {0x8523, 0x13, 0, 0}, {0x8524,0xd8, 0, 0},
	{0x8525, 0xf9, 0, 0}, {0x8526, 0x79, 0, 0}, {0x8527,0x48, 0, 0},
	{0x8528, 0xf7, 0, 0}, {0x8529, 0xee, 0, 0}, {0x852a,0x19, 0, 0},
	{0x852b, 0xf7, 0, 0}, {0x852c, 0x79, 0, 0}, {0x852d,0x45, 0, 0},
	{0x852e, 0x12, 0, 0}, {0x852f, 0x08, 0, 0}, {0x8530,0xce, 0, 0},
	{0x8531, 0x09, 0, 0}, {0x8532, 0x12, 0, 0}, {0x8533,0x08, 0, 0},
	{0x8534, 0xce, 0, 0}, {0x8535, 0xaf, 0, 0}, {0x8536,0x3a, 0, 0},
	{0x8537, 0x12, 0, 0}, {0x8538, 0x08, 0, 0}, {0x8539,0x84, 0, 0},
	{0x853a, 0x7d, 0, 0}, {0x853b, 0x50, 0, 0}, {0x853c,0x12, 0, 0},
	{0x853d, 0x02, 0, 0}, {0x853e, 0xb1, 0, 0}, {0x853f,0x78, 0, 0},
	{0x8540, 0x4d, 0, 0}, {0x8541, 0xa6, 0, 0}, {0x8542,0x06, 0, 0},
	{0x8543, 0x08, 0, 0}, {0x8544, 0xa6, 0, 0}, {0x8545,0x07, 0, 0},
	{0x8546, 0xaf, 0, 0}, {0x8547, 0x38, 0, 0}, {0x8548,0x12, 0, 0},
	{0x8549, 0x08, 0, 0}, {0x854a, 0x84, 0, 0}, {0x854b,0x7d, 0, 0},
	{0x854c, 0x50, 0, 0}, {0x854d, 0x12, 0, 0}, {0x854e,0x02, 0, 0},
	{0x854f, 0xb1, 0, 0}, {0x8550, 0x78, 0, 0}, {0x8551,0x49, 0, 0},
	{0x8552, 0xa6, 0, 0}, {0x8553, 0x06, 0, 0}, {0x8554,0x08, 0, 0},
	{0x8555, 0xa6, 0, 0}, {0x8556, 0x07, 0, 0}, {0x8557,0xaf, 0, 0},
	{0x8558, 0x3b, 0, 0}, {0x8559, 0x78, 0, 0}, {0x855a,0x47, 0, 0},
	{0x855b, 0x12, 0, 0}, {0x855c, 0x08, 0, 0}, {0x855d,0x86, 0, 0},
	{0x855e, 0x7d, 0, 0}, {0x855f, 0x3c, 0, 0}, {0x8560,0x12, 0, 0},
	{0x8561, 0x02, 0, 0}, {0x8562, 0xb1, 0, 0}, {0x8563,0x78, 0, 0},
	{0x8564, 0x4f, 0, 0}, {0x8565, 0xa6, 0, 0}, {0x8566,0x06, 0, 0},
	{0x8567, 0x08, 0, 0}, {0x8568, 0xa6, 0, 0}, {0x8569,0x07, 0, 0},
	{0x856a, 0xaf, 0, 0}, {0x856b, 0x39, 0, 0}, {0x856c,0x7e, 0, 0},
	{0x856d, 0x00, 0, 0}, {0x856e, 0x78, 0, 0}, {0x856f,0x47, 0, 0},
	{0x8570, 0x12, 0, 0}, {0x8571, 0x08, 0, 0}, {0x8572,0x88, 0, 0},
	{0x8573, 0x7d, 0, 0}, {0x8574, 0x3c, 0, 0}, {0x8575,0x12, 0, 0},
	{0x8576, 0x02, 0, 0}, {0x8577, 0xb1, 0, 0}, {0x8578,0x78, 0, 0},
	{0x8579, 0x4b, 0, 0}, {0x857a, 0xa6, 0, 0}, {0x857b,0x06, 0, 0},
	{0x857c, 0x08, 0, 0}, {0x857d, 0xa6, 0, 0}, {0x857e,0x07, 0, 0},
	{0x857f, 0xc3, 0, 0}, {0x8580, 0x78, 0, 0}, {0x8581,0x4e, 0, 0},
	{0x8582, 0xe6, 0, 0}, {0x8583, 0x94, 0, 0}, {0x8584,0x08, 0, 0},
	{0x8585, 0x18, 0, 0}, {0x8586, 0xe6, 0, 0}, {0x8587,0x94, 0, 0},
	{0x8588, 0x00, 0, 0}, {0x8589, 0x50, 0, 0}, {0x858a,0x05, 0, 0},
	{0x858b, 0x76, 0, 0}, {0x858c, 0x00, 0, 0}, {0x858d,0x08, 0, 0},
	{0x858e, 0x76, 0, 0}, {0x858f, 0x08, 0, 0}, {0x8590,0xc3, 0, 0},
	{0x8591, 0x78, 0, 0}, {0x8592, 0x50, 0, 0}, {0x8593,0xe6, 0, 0},
	{0x8594, 0x94, 0, 0}, {0x8595, 0x08, 0, 0}, {0x8596,0x18, 0, 0},
	{0x8597, 0xe6, 0, 0}, {0x8598, 0x94, 0, 0}, {0x8599,0x00, 0, 0},
	{0x859a, 0x50, 0, 0}, {0x859b, 0x05, 0, 0}, {0x859c,0x76, 0, 0},
	{0x859d, 0x00, 0, 0}, {0x859e, 0x08, 0, 0}, {0x859f,0x76, 0, 0},
	{0x85a0, 0x08, 0, 0}, {0x85a1, 0x78, 0, 0}, {0x85a2,0x4d, 0, 0},
	{0x85a3, 0x12, 0, 0}, {0x85a4, 0x08, 0, 0}, {0x85a5,0xbb, 0, 0},
	{0x85a6, 0xff, 0, 0}, {0x85a7, 0xd3, 0, 0}, {0x85a8,0x78, 0, 0},
	{0x85a9, 0x4a, 0, 0}, {0x85aa, 0xe6, 0, 0}, {0x85ab,0x9f, 0, 0},
	{0x85ac, 0x18, 0, 0}, {0x85ad, 0xe6, 0, 0}, {0x85ae,0x9e, 0, 0},
	{0x85af, 0x40, 0, 0}, {0x85b0, 0x0e, 0, 0}, {0x85b1,0x78, 0, 0},
	{0x85b2, 0x4d, 0, 0}, {0x85b3, 0xe6, 0, 0}, {0x85b4,0x13, 0, 0},
	{0x85b5, 0xfe, 0, 0}, {0x85b6, 0x08, 0, 0}, {0x85b7,0xe6, 0, 0},
	{0x85b8, 0x78, 0, 0}, {0x85b9, 0x4a, 0, 0}, {0x85ba,0x12, 0, 0},
	{0x85bb, 0x08, 0, 0}, {0x85bc, 0xf1, 0, 0}, {0x85bd,0x80, 0, 0},
	{0x85be, 0x04, 0, 0}, {0x85bf, 0x7e, 0, 0}, {0x85c0,0x00, 0, 0},
	{0x85c1, 0x7f, 0, 0}, {0x85c2, 0x00, 0, 0}, {0x85c3,0x78, 0, 0},
	{0x85c4, 0x51, 0, 0}, {0x85c5, 0x12, 0, 0}, {0x85c6,0x08, 0, 0},
	{0x85c7, 0xb3, 0, 0}, {0x85c8, 0xff, 0, 0}, {0x85c9,0xd3, 0, 0},
	{0x85ca, 0x78, 0, 0}, {0x85cb, 0x4c, 0, 0}, {0x85cc,0xe6, 0, 0},
	{0x85cd, 0x9f, 0, 0}, {0x85ce, 0x18, 0, 0}, {0x85cf,0xe6, 0, 0},
	{0x85d0, 0x9e, 0, 0}, {0x85d1, 0x40, 0, 0}, {0x85d2,0x0e, 0, 0},
	{0x85d3, 0x78, 0, 0}, {0x85d4, 0x4f, 0, 0}, {0x85d5,0xe6, 0, 0},
	{0x85d6, 0x13, 0, 0}, {0x85d7, 0xfe, 0, 0}, {0x85d8,0x08, 0, 0},
	{0x85d9, 0xe6, 0, 0}, {0x85da, 0x78, 0, 0}, {0x85db,0x4c, 0, 0},
	{0x85dc, 0x12, 0, 0}, {0x85dd, 0x08, 0, 0}, {0x85de,0xf1, 0, 0},
	{0x85df, 0x80, 0, 0}, {0x85e0, 0x04, 0, 0}, {0x85e1,0x7e, 0, 0},
	{0x85e2, 0x00, 0, 0}, {0x85e3, 0x7f, 0, 0}, {0x85e4,0x00, 0, 0},
	{0x85e5, 0xe4, 0, 0}, {0x85e6, 0xfc, 0, 0}, {0x85e7,0xfd, 0, 0},
	{0x85e8, 0x78, 0, 0}, {0x85e9, 0x55, 0, 0}, {0x85ea,0x12, 0, 0},
	{0x85eb, 0x04, 0, 0}, {0x85ec, 0x64, 0, 0}, {0x85ed,0x78, 0, 0},
	{0x85ee, 0x4d, 0, 0}, {0x85ef, 0x12, 0, 0}, {0x85f0,0x08, 0, 0},
	{0x85f1, 0xbb, 0, 0}, {0x85f2, 0x78, 0, 0}, {0x85f3,0x4a, 0, 0},
	{0x85f4, 0x26, 0, 0}, {0x85f5, 0xff, 0, 0}, {0x85f6,0xee, 0, 0},
	{0x85f7, 0x18, 0, 0}, {0x85f8, 0x36, 0, 0}, {0x85f9,0xfe, 0, 0},
	{0x85fa, 0x78, 0, 0}, {0x85fb, 0x59, 0, 0}, {0x85fc,0x12, 0, 0},
	{0x85fd, 0x08, 0, 0}, {0x85fe, 0xb3, 0, 0}, {0x85ff,0x78, 0, 0},
	{0x8600, 0x4c, 0, 0}, {0x8601, 0x26, 0, 0}, {0x8602,0xff, 0, 0},
	{0x8603, 0xee, 0, 0}, {0x8604, 0x18, 0, 0}, {0x8605,0x36, 0, 0},
	{0x8606, 0xfe, 0, 0}, {0x8607, 0xe4, 0, 0}, {0x8608,0xfc, 0, 0},
	{0x8609, 0xfd, 0, 0}, {0x860a, 0x78, 0, 0}, {0x860b,0x5d, 0, 0},
	{0x860c, 0x12, 0, 0}, {0x860d, 0x04, 0, 0}, {0x860e,0x64, 0, 0},
	{0x860f, 0x12, 0, 0}, {0x8610, 0x08, 0, 0}, {0x8611,0xc3, 0, 0},
	{0x8612, 0x78, 0, 0}, {0x8613, 0x59, 0, 0}, {0x8614,0x12, 0, 0},
	{0x8615, 0x04, 0, 0}, {0x8616, 0x57, 0, 0}, {0x8617,0xd3, 0, 0},
	{0x8618, 0x12, 0, 0}, {0x8619, 0x04, 0, 0}, {0x861a,0x23, 0, 0},
	{0x861b, 0x40, 0, 0}, {0x861c, 0x08, 0, 0}, {0x861d,0x12, 0, 0},
	{0x861e, 0x08, 0, 0}, {0x861f, 0xc3, 0, 0}, {0x8620,0x78, 0, 0},
	{0x8621, 0x59, 0, 0}, {0x8622, 0x12, 0, 0}, {0x8623,0x04, 0, 0},
	{0x8624, 0x64, 0, 0}, {0x8625, 0x78, 0, 0}, {0x8626,0x47, 0, 0},
	{0x8627, 0x12, 0, 0}, {0x8628, 0x08, 0, 0}, {0x8629,0xc5, 0, 0},
	{0x862a, 0x78, 0, 0}, {0x862b, 0x5d, 0, 0}, {0x862c,0x12, 0, 0},
	{0x862d, 0x04, 0, 0}, {0x862e, 0x57, 0, 0}, {0x862f,0xd3, 0, 0},
	{0x8630, 0x12, 0, 0}, {0x8631, 0x04, 0, 0}, {0x8632,0x23, 0, 0},
	{0x8633, 0x40, 0, 0}, {0x8634, 0x0a, 0, 0}, {0x8635,0x78, 0, 0},
	{0x8636, 0x47, 0, 0}, {0x8637, 0x12, 0, 0}, {0x8638,0x08, 0, 0},
	{0x8639, 0xc5, 0, 0}, {0x863a, 0x78, 0, 0}, {0x863b,0x5d, 0, 0},
	{0x863c, 0x12, 0, 0}, {0x863d, 0x04, 0, 0}, {0x863e,0x64, 0, 0},
	{0x863f, 0xe4, 0, 0}, {0x8640, 0xfd, 0, 0}, {0x8641,0x78, 0, 0},
	{0x8642, 0x54, 0, 0}, {0x8643, 0x12, 0, 0}, {0x8644,0x08, 0, 0},
	{0x8645, 0xde, 0, 0}, {0x8646, 0x24, 0, 0}, {0x8647,0x01, 0, 0},
	{0x8648, 0x12, 0, 0}, {0x8649, 0x08, 0, 0}, {0x864a,0xa7, 0, 0},
	{0x864b, 0x78, 0, 0}, {0x864c, 0x58, 0, 0}, {0x864d,0x12, 0, 0},
	{0x864e, 0x08, 0, 0}, {0x864f, 0xde, 0, 0}, {0x8650,0x24, 0, 0},
	{0x8651, 0x02, 0, 0}, {0x8652, 0x12, 0, 0}, {0x8653,0x08, 0, 0},
	{0x8654, 0xa7, 0, 0}, {0x8655, 0x78, 0, 0}, {0x8656,0x5c, 0, 0},
	{0x8657, 0x12, 0, 0}, {0x8658, 0x08, 0, 0}, {0x8659,0xde, 0, 0},
	{0x865a, 0x24, 0, 0}, {0x865b, 0x03, 0, 0}, {0x865c,0x12, 0, 0},
	{0x865d, 0x08, 0, 0}, {0x865e, 0xa7, 0, 0}, {0x865f,0x78, 0, 0},
	{0x8660, 0x60, 0, 0}, {0x8661, 0x12, 0, 0}, {0x8662,0x08, 0, 0},
	{0x8663, 0xde, 0, 0}, {0x8664, 0x24, 0, 0}, {0x8665,0x04, 0, 0},
	{0x8666, 0x12, 0, 0}, {0x8667, 0x08, 0, 0}, {0x8668,0xa7, 0, 0},
	{0x8669, 0x0d, 0, 0}, {0x866a, 0xbd, 0, 0}, {0x866b,0x05, 0, 0},
	{0x866c, 0xd4, 0, 0}, {0x866d, 0xc2, 0, 0}, {0x866e,0x0e, 0, 0},
	{0x866f, 0xc2, 0, 0}, {0x8670, 0x06, 0, 0}, {0x8671,0x22, 0, 0},
	{0x8672, 0x85, 0, 0}, {0x8673, 0x08, 0, 0}, {0x8674,0x36, 0, 0},
	{0x8675, 0x90, 0, 0}, {0x8676, 0x30, 0, 0}, {0x8677,0x24, 0, 0},
	{0x8678, 0xe0, 0, 0}, {0x8679, 0xf5, 0, 0}, {0x867a,0x32, 0, 0},
	{0x867b, 0xa3, 0, 0}, {0x867c, 0xe0, 0, 0}, {0x867d,0xf5, 0, 0},
	{0x867e, 0x33, 0, 0}, {0x867f, 0xa3, 0, 0}, {0x8680,0xe0, 0, 0},
	{0x8681, 0xf5, 0, 0}, {0x8682, 0x34, 0, 0}, {0x8683,0xa3, 0, 0},
	{0x8684, 0xe0, 0, 0}, {0x8685, 0xf5, 0, 0}, {0x8686,0x35, 0, 0},
	{0x8687, 0xa3, 0, 0}, {0x8688, 0xe0, 0, 0}, {0x8689,0xf5, 0, 0},
	{0x868a, 0x31, 0, 0}, {0x868b, 0xd2, 0, 0}, {0x868c,0x33, 0, 0},
	{0x868d, 0xe5, 0, 0}, {0x868e, 0x36, 0, 0}, {0x868f,0x12, 0, 0},
	{0x8690, 0x04, 0, 0}, {0x8691, 0x7c, 0, 0}, {0x8692,0x06, 0, 0},
	{0x8693, 0xc0, 0, 0}, {0x8694, 0x03, 0, 0}, {0x8695,0x06, 0, 0},
	{0x8696, 0xc4, 0, 0}, {0x8697, 0x04, 0, 0}, {0x8698,0x06, 0, 0},
	{0x8699, 0xca, 0, 0}, {0x869a, 0x07, 0, 0}, {0x869b,0x06, 0, 0},
	{0x869c, 0xd3, 0, 0}, {0x869d, 0x08, 0, 0}, {0x869e,0x06, 0, 0},
	{0x869f, 0xe3, 0, 0}, {0x86a0, 0x80, 0, 0}, {0x86a1,0x06, 0, 0},
	{0x86a2, 0xe6, 0, 0}, {0x86a3, 0x81, 0, 0}, {0x86a4,0x07, 0, 0},
	{0x86a5, 0x41, 0, 0}, {0x86a6, 0x8f, 0, 0}, {0x86a7,0x07, 0, 0},
	{0x86a8, 0x30, 0, 0}, {0x86a9, 0x90, 0, 0}, {0x86aa,0x07, 0, 0},
	{0x86ab, 0x41, 0, 0}, {0x86ac, 0x91, 0, 0}, {0x86ad,0x07, 0, 0},
	{0x86ae, 0x41, 0, 0}, {0x86af, 0x92, 0, 0}, {0x86b0,0x07, 0, 0},
	{0x86b1, 0x41, 0, 0}, {0x86b2, 0x93, 0, 0}, {0x86b3,0x07, 0, 0},
	{0x86b4, 0x41, 0, 0}, {0x86b5, 0x94, 0, 0}, {0x86b6,0x07, 0, 0},
	{0x86b7, 0x41, 0, 0}, {0x86b8, 0x98, 0, 0}, {0x86b9,0x07, 0, 0},
	{0x86ba, 0x3e, 0, 0}, {0x86bb, 0x9f, 0, 0}, {0x86bc,0x00, 0, 0},
	{0x86bd, 0x00, 0, 0}, {0x86be, 0x07, 0, 0}, {0x86bf,0x5c, 0, 0},
	{0x86c0, 0x12, 0, 0}, {0x86c1, 0x0a, 0, 0}, {0x86c2,0x8a, 0, 0},
	{0x86c3, 0x22, 0, 0}, {0x86c4, 0x12, 0, 0}, {0x86c5,0x0a, 0, 0},
	{0x86c6, 0x8a, 0, 0}, {0x86c7, 0xd2, 0, 0}, {0x86c8,0x03, 0, 0},
	{0x86c9, 0x22, 0, 0}, {0x86ca, 0xa2, 0, 0}, {0x86cb,0x36, 0, 0},
	{0x86cc, 0xe4, 0, 0}, {0x86cd, 0x33, 0, 0}, {0x86ce,0xf5, 0, 0},
	{0x86cf, 0x31, 0, 0}, {0x86d0, 0x02, 0, 0}, {0x86d1,0x07, 0, 0},
	{0x86d2, 0x41, 0, 0}, {0x86d3, 0xc2, 0, 0}, {0x86d4,0x01, 0, 0},
	{0x86d5, 0xc2, 0, 0}, {0x86d6, 0x02, 0, 0}, {0x86d7,0xc2, 0, 0},
	{0x86d8, 0x03, 0, 0}, {0x86d9, 0x12, 0, 0}, {0x86da,0x09, 0, 0},
	{0x86db, 0x06, 0, 0}, {0x86dc, 0x75, 0, 0}, {0x86dd,0x3f, 0, 0},
	{0x86de, 0x70, 0, 0}, {0x86df, 0xd2, 0, 0}, {0x86e0,0x34, 0, 0},
	{0x86e1, 0x80, 0, 0}, {0x86e2, 0x5e, 0, 0}, {0x86e3,0x02, 0, 0},
	{0x86e4, 0x0a, 0, 0}, {0x86e5, 0xd3, 0, 0}, {0x86e6,0x85, 0, 0},
	{0x86e7, 0x32, 0, 0}, {0x86e8, 0x38, 0, 0}, {0x86e9,0x85, 0, 0},
	{0x86ea, 0x33, 0, 0}, {0x86eb, 0x39, 0, 0}, {0x86ec,0xe5, 0, 0},
	{0x86ed, 0x3a, 0, 0}, {0x86ee, 0xc3, 0, 0}, {0x86ef,0x13, 0, 0},
	{0x86f0, 0xff, 0, 0}, {0x86f1, 0xe5, 0, 0}, {0x86f2,0x38, 0, 0},
	{0x86f3, 0xc3, 0, 0}, {0x86f4, 0x9f, 0, 0}, {0x86f5,0x50, 0, 0},
	{0x86f6, 0x02, 0, 0}, {0x86f7, 0x8f, 0, 0}, {0x86f8,0x38, 0, 0},
	{0x86f9, 0xe5, 0, 0}, {0x86fa, 0x3b, 0, 0}, {0x86fb,0xc3, 0, 0},
	{0x86fc, 0x13, 0, 0}, {0x86fd, 0xff, 0, 0}, {0x86fe,0xe5, 0, 0},
	{0x86ff, 0x39, 0, 0}, {0x8700, 0xc3, 0, 0}, {0x8701,0x9f, 0, 0},
	{0x8702, 0x50, 0, 0}, {0x8703, 0x02, 0, 0}, {0x8704,0x8f, 0, 0},
	{0x8705, 0x39, 0, 0}, {0x8706, 0xe5, 0, 0}, {0x8707,0x3a, 0, 0},
	{0x8708, 0xc3, 0, 0}, {0x8709, 0x13, 0, 0}, {0x870a,0xff, 0, 0},
	{0x870b, 0xfd, 0, 0}, {0x870c, 0xe5, 0, 0}, {0x870d,0x38, 0, 0},
	{0x870e, 0x90, 0, 0}, {0x870f, 0x0e, 0, 0}, {0x8710,0x7f, 0, 0},
	{0x8711, 0x12, 0, 0}, {0x8712, 0x0a, 0, 0}, {0x8713,0xa6, 0, 0},
	{0x8714, 0x40, 0, 0}, {0x8715, 0x04, 0, 0}, {0x8716,0xee, 0, 0},
	{0x8717, 0x9f, 0, 0}, {0x8718, 0xf5, 0, 0}, {0x8719,0x38, 0, 0},
	{0x871a, 0xe5, 0, 0}, {0x871b, 0x3b, 0, 0}, {0x871c,0xc3, 0, 0},
	{0x871d, 0x13, 0, 0}, {0x871e, 0xff, 0, 0}, {0x871f,0xfd, 0, 0},
	{0x8720, 0xe5, 0, 0}, {0x8721, 0x39, 0, 0}, {0x8722,0x90, 0, 0},
	{0x8723, 0x0e, 0, 0}, {0x8724, 0x80, 0, 0}, {0x8725,0x12, 0, 0},
	{0x8726, 0x0a, 0, 0}, {0x8727, 0xa6, 0, 0}, {0x8728,0x40, 0, 0},
	{0x8729, 0x14, 0, 0}, {0x872a, 0xee, 0, 0}, {0x872b,0x9f, 0, 0},
	{0x872c, 0xf5, 0, 0}, {0x872d, 0x39, 0, 0}, {0x872e,0x80, 0, 0},
	{0x872f, 0x0e, 0, 0}, {0x8730, 0x85, 0, 0}, {0x8731,0x35, 0, 0},
	{0x8732, 0x3b, 0, 0}, {0x8733, 0x85, 0, 0}, {0x8734,0x34, 0, 0},
	{0x8735, 0x3a, 0, 0}, {0x8736, 0x85, 0, 0}, {0x8737,0x33, 0, 0},
	{0x8738, 0x39, 0, 0}, {0x8739, 0x85, 0, 0}, {0x873a,0x32, 0, 0},
	{0x873b, 0x38, 0, 0}, {0x873c, 0x80, 0, 0}, {0x873d,0x03, 0, 0},
	{0x873e, 0x02, 0, 0}, {0x873f, 0x04, 0, 0}, {0x8740,0xa2, 0, 0},
	{0x8741, 0x90, 0, 0}, {0x8742, 0x30, 0, 0}, {0x8743,0x24, 0, 0},
	{0x8744, 0xe5, 0, 0}, {0x8745, 0x32, 0, 0}, {0x8746,0xf0, 0, 0},
	{0x8747, 0xa3, 0, 0}, {0x8748, 0xe5, 0, 0}, {0x8749,0x33, 0, 0},
	{0x874a, 0xf0, 0, 0}, {0x874b, 0xa3, 0, 0}, {0x874c,0xe5, 0, 0},
	{0x874d, 0x34, 0, 0}, {0x874e, 0xf0, 0, 0}, {0x874f,0xa3, 0, 0},
	{0x8750, 0xe5, 0, 0}, {0x8751, 0x35, 0, 0}, {0x8752,0xf0, 0, 0},
	{0x8753, 0xa3, 0, 0}, {0x8754, 0xe5, 0, 0}, {0x8755,0x31, 0, 0},
	{0x8756, 0xf0, 0, 0}, {0x8757, 0x90, 0, 0}, {0x8758,0x30, 0, 0},
	{0x8759, 0x23, 0, 0}, {0x875a, 0xe4, 0, 0}, {0x875b,0xf0, 0, 0},
	{0x875c, 0x22, 0, 0}, {0x875d, 0xc0, 0, 0}, {0x875e,0xe0, 0, 0},
	{0x875f, 0xc0, 0, 0}, {0x8760, 0x83, 0, 0}, {0x8761,0xc0, 0, 0},
	{0x8762, 0x82, 0, 0}, {0x8763, 0xc0, 0, 0}, {0x8764,0xd0, 0, 0},
	{0x8765, 0x90, 0, 0}, {0x8766, 0x3f, 0, 0}, {0x8767,0x0c, 0, 0},
	{0x8768, 0xe0, 0, 0}, {0x8769, 0xf5, 0, 0}, {0x876a,0x27, 0, 0},
	{0x876b, 0xe5, 0, 0}, {0x876c, 0x27, 0, 0}, {0x876d,0x30, 0, 0},
	{0x876e, 0xe3, 0, 0}, {0x876f, 0x42, 0, 0}, {0x8770,0x30, 0, 0},
	{0x8771, 0x35, 0, 0}, {0x8772, 0x34, 0, 0}, {0x8773,0x90, 0, 0},
	{0x8774, 0x60, 0, 0}, {0x8775, 0x19, 0, 0}, {0x8776,0xe0, 0, 0},
	{0x8777, 0xf5, 0, 0}, {0x8778, 0x0a, 0, 0}, {0x8779,0xa3, 0, 0},
	{0x877a, 0xe0, 0, 0}, {0x877b, 0xf5, 0, 0}, {0x877c,0x0b, 0, 0},
	{0x877d, 0x30, 0, 0}, {0x877e, 0x01, 0, 0}, {0x877f,0x06, 0, 0},
	{0x8780, 0x30, 0, 0}, {0x8781, 0x32, 0, 0}, {0x8782,0x03, 0, 0},
	{0x8783, 0xd3, 0, 0}, {0x8784, 0x80, 0, 0}, {0x8785,0x01, 0, 0},
	{0x8786, 0xc3, 0, 0}, {0x8787, 0x92, 0, 0}, {0x8788,0x09, 0, 0},
	{0x8789, 0x30, 0, 0}, {0x878a, 0x02, 0, 0}, {0x878b,0x06, 0, 0},
	{0x878c, 0x30, 0, 0}, {0x878d, 0x32, 0, 0}, {0x878e,0x03, 0, 0},
	{0x878f, 0xd3, 0, 0}, {0x8790, 0x80, 0, 0}, {0x8791,0x01, 0, 0},
	{0x8792, 0xc3, 0, 0}, {0x8793, 0x92, 0, 0}, {0x8794,0x0a, 0, 0},
	{0x8795, 0x30, 0, 0}, {0x8796, 0x32, 0, 0}, {0x8797,0x0c, 0, 0},
	{0x8798, 0x30, 0, 0}, {0x8799, 0x03, 0, 0}, {0x879a,0x09, 0, 0},
	{0x879b, 0x20, 0, 0}, {0x879c, 0x02, 0, 0}, {0x879d,0x06, 0, 0},
	{0x879e, 0x20, 0, 0}, {0x879f, 0x01, 0, 0}, {0x87a0,0x03, 0, 0},
	{0x87a1, 0xd3, 0, 0}, {0x87a2, 0x80, 0, 0}, {0x87a3,0x01, 0, 0},
	{0x87a4, 0xc3, 0, 0}, {0x87a5, 0x92, 0, 0}, {0x87a6,0x0b, 0, 0},
	{0x87a7, 0x90, 0, 0}, {0x87a8, 0x30, 0, 0}, {0x87a9,0x01, 0, 0},
	{0x87aa, 0xe0, 0, 0}, {0x87ab, 0x44, 0, 0}, {0x87ac,0x40, 0, 0},
	{0x87ad, 0xf0, 0, 0}, {0x87ae, 0xe0, 0, 0}, {0x87af,0x54, 0, 0},
	{0x87b0, 0xbf, 0, 0}, {0x87b1, 0xf0, 0, 0}, {0x87b2,0xe5, 0, 0},
	{0x87b3, 0x27, 0, 0}, {0x87b4, 0x30, 0, 0}, {0x87b5,0xe1, 0, 0},
	{0x87b6, 0x14, 0, 0}, {0x87b7, 0x30, 0, 0}, {0x87b8,0x33, 0, 0},
	{0x87b9, 0x11, 0, 0}, {0x87ba, 0x90, 0, 0}, {0x87bb,0x30, 0, 0},
	{0x87bc, 0x22, 0, 0}, {0x87bd, 0xe0, 0, 0}, {0x87be,0xf5, 0, 0},
	{0x87bf, 0x08, 0, 0}, {0x87c0, 0xe4, 0, 0}, {0x87c1,0xf0, 0, 0},
	{0x87c2, 0x30, 0, 0}, {0x87c3, 0x00, 0, 0}, {0x87c4,0x03, 0, 0},
	{0x87c5, 0xd3, 0, 0}, {0x87c6, 0x80, 0, 0}, {0x87c7,0x01, 0, 0},
	{0x87c8, 0xc3, 0, 0}, {0x87c9, 0x92, 0, 0}, {0x87ca,0x08, 0, 0},
	{0x87cb, 0xe5, 0, 0}, {0x87cc, 0x27, 0, 0}, {0x87cd,0x30, 0, 0},
	{0x87ce, 0xe5, 0, 0}, {0x87cf, 0x12, 0, 0}, {0x87d0,0x90, 0, 0},
	{0x87d1, 0x56, 0, 0}, {0x87d2, 0x90, 0, 0}, {0x87d3,0xe0, 0, 0},
	{0x87d4, 0xf5, 0, 0}, {0x87d5, 0x09, 0, 0}, {0x87d6,0x30, 0, 0},
	{0x87d7, 0x30, 0, 0}, {0x87d8, 0x09, 0, 0}, {0x87d9,0x30, 0, 0},
	{0x87da, 0x05, 0, 0}, {0x87db, 0x03, 0, 0}, {0x87dc,0xd3, 0, 0},
	{0x87dd, 0x80, 0, 0}, {0x87de, 0x01, 0, 0}, {0x87df,0xc3, 0, 0},
	{0x87e0, 0x92, 0, 0}, {0x87e1, 0x0d, 0, 0}, {0x87e2,0x90, 0, 0},
	{0x87e3, 0x3f, 0, 0}, {0x87e4, 0x0c, 0, 0}, {0x87e5,0xe5, 0, 0},
	{0x87e6, 0x27, 0, 0}, {0x87e7, 0xf0, 0, 0}, {0x87e8,0xd0, 0, 0},
	{0x87e9, 0xd0, 0, 0}, {0x87ea, 0xd0, 0, 0}, {0x87eb,0x82, 0, 0},
	{0x87ec, 0xd0, 0, 0}, {0x87ed, 0x83, 0, 0}, {0x87ee,0xd0, 0, 0},
	{0x87ef, 0xe0, 0, 0}, {0x87f0, 0x32, 0, 0}, {0x87f1,0x90, 0, 0},
	{0x87f2, 0x0e, 0, 0}, {0x87f3, 0x7d, 0, 0}, {0x87f4,0xe4, 0, 0},
	{0x87f5, 0x93, 0, 0}, {0x87f6, 0xfe, 0, 0}, {0x87f7,0x74, 0, 0},
	{0x87f8, 0x01, 0, 0}, {0x87f9, 0x93, 0, 0}, {0x87fa,0xff, 0, 0},
	{0x87fb, 0xc3, 0, 0}, {0x87fc, 0x90, 0, 0}, {0x87fd,0x0e, 0, 0},
	{0x87fe, 0x7b, 0, 0}, {0x87ff, 0x74, 0, 0}, {0x8800,0x01, 0, 0},
	{0x8801, 0x93, 0, 0}, {0x8802, 0x9f, 0, 0}, {0x8803,0xff, 0, 0},
	{0x8804, 0xe4, 0, 0}, {0x8805, 0x93, 0, 0}, {0x8806,0x9e, 0, 0},
	{0x8807, 0xfe, 0, 0}, {0x8808, 0xe4, 0, 0}, {0x8809,0x8f, 0, 0},
	{0x880a, 0x30, 0, 0}, {0x880b, 0x8e, 0, 0}, {0x880c,0x2f, 0, 0},
	{0x880d, 0xf5, 0, 0}, {0x880e, 0x2e, 0, 0}, {0x880f,0xf5, 0, 0},
	{0x8810, 0x2d, 0, 0}, {0x8811, 0xab, 0, 0}, {0x8812,0x30, 0, 0},
	{0x8813, 0xaa, 0, 0}, {0x8814, 0x2f, 0, 0}, {0x8815,0xa9, 0, 0},
	{0x8816, 0x2e, 0, 0}, {0x8817, 0xa8, 0, 0}, {0x8818,0x2d, 0, 0},
	{0x8819, 0xaf, 0, 0}, {0x881a, 0x3e, 0, 0}, {0x881b,0xfc, 0, 0},
	{0x881c, 0xfd, 0, 0}, {0x881d, 0xfe, 0, 0}, {0x881e,0x12, 0, 0},
	{0x881f, 0x03, 0, 0}, {0x8820, 0x06, 0, 0}, {0x8821,0x12, 0, 0},
	{0x8822, 0x0a, 0, 0}, {0x8823, 0xb8, 0, 0}, {0x8824,0xe4, 0, 0},
	{0x8825, 0x7b, 0, 0}, {0x8826, 0xff, 0, 0}, {0x8827,0xfa, 0, 0},
	{0x8828, 0xf9, 0, 0}, {0x8829, 0xf8, 0, 0}, {0x882a,0x12, 0, 0},
	{0x882b, 0x03, 0, 0}, {0x882c, 0x91, 0, 0}, {0x882d,0x12, 0, 0},
	{0x882e, 0x0a, 0, 0}, {0x882f, 0xb8, 0, 0}, {0x8830,0x90, 0, 0},
	{0x8831, 0x0e, 0, 0}, {0x8832, 0x69, 0, 0}, {0x8833,0xe4, 0, 0},
	{0x8834, 0x12, 0, 0}, {0x8835, 0x0a, 0, 0}, {0x8836,0xcd, 0, 0},
	{0x8837, 0x12, 0, 0}, {0x8838, 0x0a, 0, 0}, {0x8839,0xb8, 0, 0},
	{0x883a, 0xe4, 0, 0}, {0x883b, 0x85, 0, 0}, {0x883c,0x3d, 0, 0},
	{0x883d, 0x2c, 0, 0}, {0x883e, 0xf5, 0, 0}, {0x883f,0x2b, 0, 0},
	{0x8840, 0xf5, 0, 0}, {0x8841, 0x2a, 0, 0}, {0x8842,0xf5, 0, 0},
	{0x8843, 0x29, 0, 0}, {0x8844, 0xaf, 0, 0}, {0x8845,0x2c, 0, 0},
	{0x8846, 0xae, 0, 0}, {0x8847, 0x2b, 0, 0}, {0x8848,0xad, 0, 0},
	{0x8849, 0x2a, 0, 0}, {0x884a, 0xac, 0, 0}, {0x884b,0x29, 0, 0},
	{0x884c, 0xa3, 0, 0}, {0x884d, 0x12, 0, 0}, {0x884e,0x0a, 0, 0},
	{0x884f, 0xcd, 0, 0}, {0x8850, 0x8f, 0, 0}, {0x8851,0x2c, 0, 0},
	{0x8852, 0x8e, 0, 0}, {0x8853, 0x2b, 0, 0}, {0x8854,0x8d, 0, 0},
	{0x8855, 0x2a, 0, 0}, {0x8856, 0x8c, 0, 0}, {0x8857,0x29, 0, 0},
	{0x8858, 0xe5, 0, 0}, {0x8859, 0x30, 0, 0}, {0x885a,0x45, 0, 0},
	{0x885b, 0x2c, 0, 0}, {0x885c, 0xf5, 0, 0}, {0x885d,0x30, 0, 0},
	{0x885e, 0xe5, 0, 0}, {0x885f, 0x2f, 0, 0}, {0x8860,0x45, 0, 0},
	{0x8861, 0x2b, 0, 0}, {0x8862, 0xf5, 0, 0}, {0x8863,0x2f, 0, 0},
	{0x8864, 0xe5, 0, 0}, {0x8865, 0x2e, 0, 0}, {0x8866,0x45, 0, 0},
	{0x8867, 0x2a, 0, 0}, {0x8868, 0xf5, 0, 0}, {0x8869,0x2e, 0, 0},
	{0x886a, 0xe5, 0, 0}, {0x886b, 0x2d, 0, 0}, {0x886c,0x45, 0, 0},
	{0x886d, 0x29, 0, 0}, {0x886e, 0xf5, 0, 0}, {0x886f,0x2d, 0, 0},
	{0x8870, 0xe4, 0, 0}, {0x8871, 0xf5, 0, 0}, {0x8872,0x22, 0, 0},
	{0x8873, 0xf5, 0, 0}, {0x8874, 0x23, 0, 0}, {0x8875,0x85, 0, 0},
	{0x8876, 0x30, 0, 0}, {0x8877, 0x1e, 0, 0}, {0x8878,0x85, 0, 0},
	{0x8879, 0x2f, 0, 0}, {0x887a, 0x1d, 0, 0}, {0x887b,0x85, 0, 0},
	{0x887c, 0x2e, 0, 0}, {0x887d, 0x1c, 0, 0}, {0x887e,0x85, 0, 0},
	{0x887f, 0x2d, 0, 0}, {0x8880, 0x1b, 0, 0}, {0x8881,0x02, 0, 0},
	{0x8882, 0x0a, 0, 0}, {0x8883, 0x5c, 0, 0}, {0x8884,0x78, 0, 0},
	{0x8885, 0x45, 0, 0}, {0x8886, 0x7e, 0, 0}, {0x8887,0x00, 0, 0},
	{0x8888, 0xe6, 0, 0}, {0x8889, 0xfc, 0, 0}, {0x888a,0x08, 0, 0},
	{0x888b, 0xe6, 0, 0}, {0x888c, 0xfd, 0, 0}, {0x888d,0x12, 0, 0},
	{0x888e, 0x02, 0, 0}, {0x888f, 0x9f, 0, 0}, {0x8890,0x7c, 0, 0},
	{0x8891, 0x00, 0, 0}, {0x8892, 0x22, 0, 0}, {0x8893,0xe0, 0, 0},
	{0x8894, 0xa3, 0, 0}, {0x8895, 0xe0, 0, 0}, {0x8896,0x75, 0, 0},
	{0x8897, 0xf0, 0, 0}, {0x8898, 0x02, 0, 0}, {0x8899,0xa4, 0, 0},
	{0x889a, 0xff, 0, 0}, {0x889b, 0xae, 0, 0}, {0x889c,0xf0, 0, 0},
	{0x889d, 0xc3, 0, 0}, {0x889e, 0x08, 0, 0}, {0x889f,0xe6, 0, 0},
	{0x88a0, 0x9f, 0, 0}, {0x88a1, 0xf6, 0, 0}, {0x88a2,0x18, 0, 0},
	{0x88a3, 0xe6, 0, 0}, {0x88a4, 0x9e, 0, 0}, {0x88a5,0xf6, 0, 0},
	{0x88a6, 0x22, 0, 0}, {0x88a7, 0xff, 0, 0}, {0x88a8,0xe5, 0, 0},
	{0x88a9, 0xf0, 0, 0}, {0x88aa, 0x34, 0, 0}, {0x88ab,0x60, 0, 0},
	{0x88ac, 0x8f, 0, 0}, {0x88ad, 0x82, 0, 0}, {0x88ae,0xf5, 0, 0},
	{0x88af, 0x83, 0, 0}, {0x88b0, 0xec, 0, 0}, {0x88b1,0xf0, 0, 0},
	{0x88b2, 0x22, 0, 0}, {0x88b3, 0xe4, 0, 0}, {0x88b4,0xfc, 0, 0},
	{0x88b5, 0xfd, 0, 0}, {0x88b6, 0x12, 0, 0}, {0x88b7,0x04, 0, 0},
	{0x88b8, 0x64, 0, 0}, {0x88b9, 0x78, 0, 0}, {0x88ba,0x4f, 0, 0},
	{0x88bb, 0xe6, 0, 0}, {0x88bc, 0xc3, 0, 0}, {0x88bd,0x13, 0, 0},
	{0x88be, 0xfe, 0, 0}, {0x88bf, 0x08, 0, 0}, {0x88c0,0xe6, 0, 0},
	{0x88c1, 0x13, 0, 0}, {0x88c2, 0x22, 0, 0}, {0x88c3,0x78, 0, 0},
	{0x88c4, 0x45, 0, 0}, {0x88c5, 0xe6, 0, 0}, {0x88c6,0xfe, 0, 0},
	{0x88c7, 0x08, 0, 0}, {0x88c8, 0xe6, 0, 0}, {0x88c9,0xff, 0, 0},
	{0x88ca, 0xe4, 0, 0}, {0x88cb, 0xfc, 0, 0}, {0x88cc,0xfd, 0, 0},
	{0x88cd, 0x22, 0, 0}, {0x88ce, 0xe7, 0, 0}, {0x88cf,0xc4, 0, 0},
	{0x88d0, 0xf8, 0, 0}, {0x88d1, 0x54, 0, 0}, {0x88d2,0xf0, 0, 0},
	{0x88d3, 0xc8, 0, 0}, {0x88d4, 0x68, 0, 0}, {0x88d5,0xf7, 0, 0},
	{0x88d6, 0x09, 0, 0}, {0x88d7, 0xe7, 0, 0}, {0x88d8,0xc4, 0, 0},
	{0x88d9, 0x54, 0, 0}, {0x88da, 0x0f, 0, 0}, {0x88db,0x48, 0, 0},
	{0x88dc, 0xf7, 0, 0}, {0x88dd, 0x22, 0, 0}, {0x88de,0xe6, 0, 0},
	{0x88df, 0xfc, 0, 0}, {0x88e0, 0xed, 0, 0}, {0x88e1,0x75, 0, 0},
	{0x88e2, 0xf0, 0, 0}, {0x88e3, 0x04, 0, 0}, {0x88e4,0xa4, 0, 0},
	{0x88e5, 0x22, 0, 0}, {0x88e6, 0xe0, 0, 0}, {0x88e7,0xfe, 0, 0},
	{0x88e8, 0xa3, 0, 0}, {0x88e9, 0xe0, 0, 0}, {0x88ea,0xfd, 0, 0},
	{0x88eb, 0xee, 0, 0}, {0x88ec, 0xf6, 0, 0}, {0x88ed,0xed, 0, 0},
	{0x88ee, 0x08, 0, 0}, {0x88ef, 0xf6, 0, 0}, {0x88f0,0x22, 0, 0},
	{0x88f1, 0x13, 0, 0}, {0x88f2, 0xff, 0, 0}, {0x88f3,0xc3, 0, 0},
	{0x88f4, 0xe6, 0, 0}, {0x88f5, 0x9f, 0, 0}, {0x88f6,0xff, 0, 0},
	{0x88f7, 0x18, 0, 0}, {0x88f8, 0xe6, 0, 0}, {0x88f9,0x9e, 0, 0},
	{0x88fa, 0xfe, 0, 0}, {0x88fb, 0x22, 0, 0}, {0x88fc,0xe6, 0, 0},
	{0x88fd, 0xc3, 0, 0}, {0x88fe, 0x13, 0, 0}, {0x88ff,0xf7, 0, 0},
	{0x8900, 0x08, 0, 0}, {0x8901, 0xe6, 0, 0}, {0x8902,0x13, 0, 0},
	{0x8903, 0x09, 0, 0}, {0x8904, 0xf7, 0, 0}, {0x8905,0x22, 0, 0},
	{0x8906, 0xe4, 0, 0}, {0x8907, 0xf5, 0, 0}, {0x8908,0x3e, 0, 0},
	{0x8909, 0x90, 0, 0}, {0x890a, 0x0e, 0, 0}, {0x890b,0x77, 0, 0},
	{0x890c, 0x93, 0, 0}, {0x890d, 0xff, 0, 0}, {0x890e,0xe4, 0, 0},
	{0x890f, 0x8f, 0, 0}, {0x8910, 0x2c, 0, 0}, {0x8911,0xf5, 0, 0},
	{0x8912, 0x2b, 0, 0}, {0x8913, 0xf5, 0, 0}, {0x8914,0x2a, 0, 0},
	{0x8915, 0xf5, 0, 0}, {0x8916, 0x29, 0, 0}, {0x8917,0xaf, 0, 0},
	{0x8918, 0x2c, 0, 0}, {0x8919, 0xae, 0, 0}, {0x891a,0x2b, 0, 0},
	{0x891b, 0xad, 0, 0}, {0x891c, 0x2a, 0, 0}, {0x891d,0xac, 0, 0},
	{0x891e, 0x29, 0, 0}, {0x891f, 0x90, 0, 0}, {0x8920,0x0e, 0, 0},
	{0x8921, 0x6a, 0, 0}, {0x8922, 0x12, 0, 0}, {0x8923,0x0a, 0, 0},
	{0x8924, 0xcd, 0, 0}, {0x8925, 0x8f, 0, 0}, {0x8926,0x2c, 0, 0},
	{0x8927, 0x8e, 0, 0}, {0x8928, 0x2b, 0, 0}, {0x8929,0x8d, 0, 0},
	{0x892a, 0x2a, 0, 0}, {0x892b, 0x8c, 0, 0}, {0x892c,0x29, 0, 0},
	{0x892d, 0x90, 0, 0}, {0x892e, 0x0e, 0, 0}, {0x892f,0x72, 0, 0},
	{0x8930, 0x12, 0, 0}, {0x8931, 0x04, 0, 0}, {0x8932,0x47, 0, 0},
	{0x8933, 0xef, 0, 0}, {0x8934, 0x45, 0, 0}, {0x8935,0x2c, 0, 0},
	{0x8936, 0xf5, 0, 0}, {0x8937, 0x2c, 0, 0}, {0x8938,0xee, 0, 0},
	{0x8939, 0x45, 0, 0}, {0x893a, 0x2b, 0, 0}, {0x893b,0xf5, 0, 0},
	{0x893c, 0x2b, 0, 0}, {0x893d, 0xed, 0, 0}, {0x893e,0x45, 0, 0},
	{0x893f, 0x2a, 0, 0}, {0x8940, 0xf5, 0, 0}, {0x8941,0x2a, 0, 0},
	{0x8942, 0xec, 0, 0}, {0x8943, 0x45, 0, 0}, {0x8944,0x29, 0, 0},
	{0x8945, 0xf5, 0, 0}, {0x8946, 0x29, 0, 0}, {0x8947,0xe4, 0, 0},
	{0x8948, 0xf5, 0, 0}, {0x8949, 0x22, 0, 0}, {0x894a,0xf5, 0, 0},
	{0x894b, 0x23, 0, 0}, {0x894c, 0x85, 0, 0}, {0x894d,0x2c, 0, 0},
	{0x894e, 0x1e, 0, 0}, {0x894f, 0x85, 0, 0}, {0x8950,0x2b, 0, 0},
	{0x8951, 0x1d, 0, 0}, {0x8952, 0x85, 0, 0}, {0x8953,0x2a, 0, 0},
	{0x8954, 0x1c, 0, 0}, {0x8955, 0x85, 0, 0}, {0x8956,0x29, 0, 0},
	{0x8957, 0x1b, 0, 0}, {0x8958, 0x12, 0, 0}, {0x8959,0x0a, 0, 0},
	{0x895a, 0x5c, 0, 0}, {0x895b, 0xe4, 0, 0}, {0x895c,0xf5, 0, 0},
	{0x895d, 0x22, 0, 0}, {0x895e, 0xf5, 0, 0}, {0x895f,0x23, 0, 0},
	{0x8960, 0x90, 0, 0}, {0x8961, 0x0e, 0, 0}, {0x8962,0x72, 0, 0},
	{0x8963, 0x12, 0, 0}, {0x8964, 0x0a, 0, 0}, {0x8965,0xc1, 0, 0},
	{0x8966, 0x12, 0, 0}, {0x8967, 0x0a, 0, 0}, {0x8968,0x5c, 0, 0},
	{0x8969, 0xe4, 0, 0}, {0x896a, 0xf5, 0, 0}, {0x896b,0x22, 0, 0},
	{0x896c, 0xf5, 0, 0}, {0x896d, 0x23, 0, 0}, {0x896e,0x90, 0, 0},
	{0x896f, 0x0e, 0, 0}, {0x8970, 0x6e, 0, 0}, {0x8971,0x12, 0, 0},
	{0x8972, 0x0a, 0, 0}, {0x8973, 0xc1, 0, 0}, {0x8974,0x02, 0, 0},
	{0x8975, 0x0a, 0, 0}, {0x8976, 0x5c, 0, 0}, {0x8977,0x75, 0, 0},
	{0x8978, 0x89, 0, 0}, {0x8979, 0x03, 0, 0}, {0x897a,0x75, 0, 0},
	{0x897b, 0xa8, 0, 0}, {0x897c, 0x01, 0, 0}, {0x897d,0x75, 0, 0},
	{0x897e, 0xb8, 0, 0}, {0x897f, 0x04, 0, 0}, {0x8980,0x75, 0, 0},
	{0x8981, 0x29, 0, 0}, {0x8982, 0xff, 0, 0}, {0x8983,0x75, 0, 0},
	{0x8984, 0x2a, 0, 0}, {0x8985, 0x0e, 0, 0}, {0x8986,0x75, 0, 0},
	{0x8987, 0x2b, 0, 0}, {0x8988, 0x15, 0, 0}, {0x8989,0x75, 0, 0},
	{0x898a, 0x2c, 0, 0}, {0x898b, 0x0d, 0, 0}, {0x898c,0x12, 0, 0},
	{0x898d, 0x09, 0, 0}, {0x898e, 0xe0, 0, 0}, {0x898f,0x12, 0, 0},
	{0x8990, 0x00, 0, 0}, {0x8991, 0x09, 0, 0}, {0x8992,0x12, 0, 0},
	{0x8993, 0x0a, 0, 0}, {0x8994, 0xd3, 0, 0}, {0x8995,0x12, 0, 0},
	{0x8996, 0x00, 0, 0}, {0x8997, 0x06, 0, 0}, {0x8998,0xd2, 0, 0},
	{0x8999, 0x00, 0, 0}, {0x899a, 0xd2, 0, 0}, {0x899b,0x33, 0, 0},
	{0x899c, 0xd2, 0, 0}, {0x899d, 0xaf, 0, 0}, {0x899e,0x75, 0, 0},
	{0x899f, 0x29, 0, 0}, {0x89a0, 0xff, 0, 0}, {0x89a1,0x75, 0, 0},
	{0x89a2, 0x2a, 0, 0}, {0x89a3, 0x0e, 0, 0}, {0x89a4,0x75, 0, 0},
	{0x89a5, 0x2b, 0, 0}, {0x89a6, 0x49, 0, 0}, {0x89a7,0x75, 0, 0},
	{0x89a8, 0x2c, 0, 0}, {0x89a9, 0x03, 0, 0}, {0x89aa,0x12, 0, 0},
	{0x89ab, 0x09, 0, 0}, {0x89ac, 0xe0, 0, 0}, {0x89ad,0x30, 0, 0},
	{0x89ae, 0x08, 0, 0}, {0x89af, 0x09, 0, 0}, {0x89b0,0xc2, 0, 0},
	{0x89b1, 0x33, 0, 0}, {0x89b2, 0x12, 0, 0}, {0x89b3,0x06, 0, 0},
	{0x89b4, 0x72, 0, 0}, {0x89b5, 0xc2, 0, 0}, {0x89b6,0x08, 0, 0},
	{0x89b7, 0xd2, 0, 0}, {0x89b8, 0x33, 0, 0}, {0x89b9,0x30, 0, 0},
	{0x89ba, 0x09, 0, 0}, {0x89bb, 0x09, 0, 0}, {0x89bc,0xc2, 0, 0},
	{0x89bd, 0x35, 0, 0}, {0x89be, 0x12, 0, 0}, {0x89bf,0x00, 0, 0},
	{0x89c0, 0x0e, 0, 0}, {0x89c1, 0xc2, 0, 0}, {0x89c2,0x09, 0, 0},
	{0x89c3, 0xd2, 0, 0}, {0x89c4, 0x35, 0, 0}, {0x89c5,0x30, 0, 0},
	{0x89c6, 0x0e, 0, 0}, {0x89c7, 0x03, 0, 0}, {0x89c8,0x12, 0, 0},
	{0x89c9, 0x04, 0, 0}, {0x89ca, 0xa2, 0, 0}, {0x89cb,0x30, 0, 0},
	{0x89cc, 0x34, 0, 0}, {0x89cd, 0xdf, 0, 0}, {0x89ce,0x90, 0, 0},
	{0x89cf, 0x30, 0, 0}, {0x89d0, 0x29, 0, 0}, {0x89d1,0xe5, 0, 0},
	{0x89d2, 0x3f, 0, 0}, {0x89d3, 0xf0, 0, 0}, {0x89d4,0xb4, 0, 0},
	{0x89d5, 0x10, 0, 0}, {0x89d6, 0x05, 0, 0}, {0x89d7,0x90, 0, 0},
	{0x89d8, 0x30, 0, 0}, {0x89d9, 0x23, 0, 0}, {0x89da,0xe4, 0, 0},
	{0x89db, 0xf0, 0, 0}, {0x89dc, 0xc2, 0, 0}, {0x89dd,0x34, 0, 0},
	{0x89de, 0x80, 0, 0}, {0x89df, 0xcd, 0, 0}, {0x89e0,0xae, 0, 0},
	{0x89e1, 0x2a, 0, 0}, {0x89e2, 0xaf, 0, 0}, {0x89e3,0x2b, 0, 0},
	{0x89e4, 0xe4, 0, 0}, {0x89e5, 0xfd, 0, 0}, {0x89e6,0xed, 0, 0},
	{0x89e7, 0xc3, 0, 0}, {0x89e8, 0x95, 0, 0}, {0x89e9,0x2c, 0, 0},
	{0x89ea, 0x50, 0, 0}, {0x89eb, 0x33, 0, 0}, {0x89ec,0x12, 0, 0},
	{0x89ed, 0x0b, 0, 0}, {0x89ee, 0x1a, 0, 0}, {0x89ef,0xe4, 0, 0},
	{0x89f0, 0x93, 0, 0}, {0x89f1, 0xf5, 0, 0}, {0x89f2,0x2d, 0, 0},
	{0x89f3, 0x74, 0, 0}, {0x89f4, 0x01, 0, 0}, {0x89f5,0x93, 0, 0},
	{0x89f6, 0xf5, 0, 0}, {0x89f7, 0x2e, 0, 0}, {0x89f8,0x45, 0, 0},
	{0x89f9, 0x2d, 0, 0}, {0x89fa, 0x60, 0, 0}, {0x89fb,0x23, 0, 0},
	{0x89fc, 0x85, 0, 0}, {0x89fd, 0x2e, 0, 0}, {0x89fe,0x82, 0, 0},
	{0x89ff, 0x85, 0, 0}, {0x8a00, 0x2d, 0, 0}, {0x8a01,0x83, 0, 0},
	{0x8a02, 0xe0, 0, 0}, {0x8a03, 0xfc, 0, 0}, {0x8a04,0x12, 0, 0},
	{0x8a05, 0x0b, 0, 0}, {0x8a06, 0x1a, 0, 0}, {0x8a07,0x74, 0, 0},
	{0x8a08, 0x03, 0, 0}, {0x8a09, 0x93, 0, 0}, {0x8a0a,0x52, 0, 0},
	{0x8a0b, 0x04, 0, 0}, {0x8a0c, 0x12, 0, 0}, {0x8a0d,0x0b, 0, 0},
	{0x8a0e, 0x1a, 0, 0}, {0x8a0f, 0x74, 0, 0}, {0x8a10,0x02, 0, 0},
	{0x8a11, 0x93, 0, 0}, {0x8a12, 0x42, 0, 0}, {0x8a13,0x04, 0, 0},
	{0x8a14, 0x85, 0, 0}, {0x8a15, 0x2e, 0, 0}, {0x8a16,0x82, 0, 0},
	{0x8a17, 0x85, 0, 0}, {0x8a18, 0x2d, 0, 0}, {0x8a19,0x83, 0, 0},
	{0x8a1a, 0xec, 0, 0}, {0x8a1b, 0xf0, 0, 0}, {0x8a1c,0x0d, 0, 0},
	{0x8a1d, 0x80, 0, 0}, {0x8a1e, 0xc7, 0, 0}, {0x8a1f,0x22, 0, 0},
	{0x8a20, 0x78, 0, 0}, {0x8a21, 0xb1, 0, 0}, {0x8a22,0xe6, 0, 0},
	{0x8a23, 0xd3, 0, 0}, {0x8a24, 0x08, 0, 0}, {0x8a25,0xff, 0, 0},
	{0x8a26, 0xe6, 0, 0}, {0x8a27, 0x64, 0, 0}, {0x8a28,0x80, 0, 0},
	{0x8a29, 0xf8, 0, 0}, {0x8a2a, 0xef, 0, 0}, {0x8a2b,0x64, 0, 0},
	{0x8a2c, 0x80, 0, 0}, {0x8a2d, 0x98, 0, 0}, {0x8a2e,0x22, 0, 0},
	{0x8a2f, 0x93, 0, 0}, {0x8a30, 0xff, 0, 0}, {0x8a31,0x7e, 0, 0},
	{0x8a32, 0x00, 0, 0}, {0x8a33, 0xe6, 0, 0}, {0x8a34,0xfc, 0, 0},
	{0x8a35, 0x08, 0, 0}, {0x8a36, 0xe6, 0, 0}, {0x8a37,0xfd, 0, 0},
	{0x8a38, 0x12, 0, 0}, {0x8a39, 0x02, 0, 0}, {0x8a3a,0x9f, 0, 0},
	{0x8a3b, 0x78, 0, 0}, {0x8a3c, 0xb4, 0, 0}, {0x8a3d,0xe6, 0, 0},
	{0x8a3e, 0xfc, 0, 0}, {0x8a3f, 0x08, 0, 0}, {0x8a40,0xe6, 0, 0},
	{0x8a41, 0xfd, 0, 0}, {0x8a42, 0xd3, 0, 0}, {0x8a43,0xef, 0, 0},
	{0x8a44, 0x9d, 0, 0}, {0x8a45, 0xee, 0, 0}, {0x8a46,0x9c, 0, 0},
	{0x8a47, 0x22, 0, 0}, {0x8a48, 0x78, 0, 0}, {0x8a49,0xb0, 0, 0},
	{0x8a4a, 0xd3, 0, 0}, {0x8a4b, 0xe6, 0, 0}, {0x8a4c,0x64, 0, 0},
	{0x8a4d, 0x80, 0, 0}, {0x8a4e, 0x94, 0, 0}, {0x8a4f,0x80, 0, 0},
	{0x8a50, 0x22, 0, 0}, {0x8a51, 0x25, 0, 0}, {0x8a52,0xe0, 0, 0},
	{0x8a53, 0x24, 0, 0}, {0x8a54, 0x0a, 0, 0}, {0x8a55,0xf8, 0, 0},
	{0x8a56, 0xe6, 0, 0}, {0x8a57, 0xfe, 0, 0}, {0x8a58,0x08, 0, 0},
	{0x8a59, 0xe6, 0, 0}, {0x8a5a, 0xff, 0, 0}, {0x8a5b,0x22, 0, 0},
	{0x8a5c, 0xa2, 0, 0}, {0x8a5d, 0xaf, 0, 0}, {0x8a5e,0x92, 0, 0},
	{0x8a5f, 0x31, 0, 0}, {0x8a60, 0xc2, 0, 0}, {0x8a61,0xaf, 0, 0},
	{0x8a62, 0xe5, 0, 0}, {0x8a63, 0x23, 0, 0}, {0x8a64,0x45, 0, 0},
	{0x8a65, 0x22, 0, 0}, {0x8a66, 0x90, 0, 0}, {0x8a67,0x0e, 0, 0},
	{0x8a68, 0x5d, 0, 0}, {0x8a69, 0x60, 0, 0}, {0x8a6a,0x0b, 0, 0},
	{0x8a6b, 0x12, 0, 0}, {0x8a6c, 0x0b, 0, 0}, {0x8a6d,0x0f, 0, 0},
	{0x8a6e, 0xe0, 0, 0}, {0x8a6f, 0xf5, 0, 0}, {0x8a70,0x19, 0, 0},
	{0x8a71, 0xe0, 0, 0}, {0x8a72, 0xf5, 0, 0}, {0x8a73,0x1a, 0, 0},
	{0x8a74, 0x80, 0, 0}, {0x8a75, 0x0f, 0, 0}, {0x8a76,0x12, 0, 0},
	{0x8a77, 0x0b, 0, 0}, {0x8a78, 0x0f, 0, 0}, {0x8a79,0xe5, 0, 0},
	{0x8a7a, 0x1d, 0, 0}, {0x8a7b, 0xf0, 0, 0}, {0x8a7c,0x90, 0, 0},
	{0x8a7d, 0x0e, 0, 0}, {0x8a7e, 0x5f, 0, 0}, {0x8a7f,0x12, 0, 0},
	{0x8a80, 0x0b, 0, 0}, {0x8a81, 0x0f, 0, 0}, {0x8a82,0xe5, 0, 0},
	{0x8a83, 0x1e, 0, 0}, {0x8a84, 0xf0, 0, 0}, {0x8a85,0xa2, 0, 0},
	{0x8a86, 0x31, 0, 0}, {0x8a87, 0x92, 0, 0}, {0x8a88,0xaf, 0, 0},
	{0x8a89, 0x22, 0, 0}, {0x8a8a, 0xd2, 0, 0}, {0x8a8b,0x01, 0, 0},
	{0x8a8c, 0xc2, 0, 0}, {0x8a8d, 0x02, 0, 0}, {0x8a8e,0xe4, 0, 0},
	{0x8a8f, 0xf5, 0, 0}, {0x8a90, 0x40, 0, 0}, {0x8a91,0xf5, 0, 0},
	{0x8a92, 0x3f, 0, 0}, {0x8a93, 0xd2, 0, 0}, {0x8a94,0x34, 0, 0},
	{0x8a95, 0xd2, 0, 0}, {0x8a96, 0x32, 0, 0}, {0x8a97,0xd2, 0, 0},
	{0x8a98, 0x35, 0, 0}, {0x8a99, 0xd2, 0, 0}, {0x8a9a,0x01, 0, 0},
	{0x8a9b, 0xc2, 0, 0}, {0x8a9c, 0x02, 0, 0}, {0x8a9d,0xf5, 0, 0},
	{0x8a9e, 0x40, 0, 0}, {0x8a9f, 0xf5, 0, 0}, {0x8aa0,0x3f, 0, 0},
	{0x8aa1, 0xd2, 0, 0}, {0x8aa2, 0x34, 0, 0}, {0x8aa3,0xd2, 0, 0},
	{0x8aa4, 0x32, 0, 0}, {0x8aa5, 0x22, 0, 0}, {0x8aa6,0x2d, 0, 0},
	{0x8aa7, 0xfd, 0, 0}, {0x8aa8, 0xe4, 0, 0}, {0x8aa9,0x33, 0, 0},
	{0x8aaa, 0xfc, 0, 0}, {0x8aab, 0xe4, 0, 0}, {0x8aac,0x93, 0, 0},
	{0x8aad, 0xfe, 0, 0}, {0x8aae, 0xfb, 0, 0}, {0x8aaf,0xd3, 0, 0},
	{0x8ab0, 0xed, 0, 0}, {0x8ab1, 0x9b, 0, 0}, {0x8ab2,0x74, 0, 0},
	{0x8ab3, 0x80, 0, 0}, {0x8ab4, 0xf8, 0, 0}, {0x8ab5,0x6c, 0, 0},
	{0x8ab6, 0x98, 0, 0}, {0x8ab7, 0x22, 0, 0}, {0x8ab8,0x8f, 0, 0},
	{0x8ab9, 0x30, 0, 0}, {0x8aba, 0x8e, 0, 0}, {0x8abb,0x2f, 0, 0},
	{0x8abc, 0x8d, 0, 0}, {0x8abd, 0x2e, 0, 0}, {0x8abe,0x8c, 0, 0},
	{0x8abf, 0x2d, 0, 0}, {0x8ac0, 0x22, 0, 0}, {0x8ac1,0x12, 0, 0},
	{0x8ac2, 0x04, 0, 0}, {0x8ac3, 0x47, 0, 0}, {0x8ac4,0x8f, 0, 0},
	{0x8ac5, 0x1e, 0, 0}, {0x8ac6, 0x8e, 0, 0}, {0x8ac7,0x1d, 0, 0},
	{0x8ac8, 0x8d, 0, 0}, {0x8ac9, 0x1c, 0, 0}, {0x8aca,0x8c, 0, 0},
	{0x8acb, 0x1b, 0, 0}, {0x8acc, 0x22, 0, 0}, {0x8acd,0x93, 0, 0},
	{0x8ace, 0xf9, 0, 0}, {0x8acf, 0xf8, 0, 0}, {0x8ad0,0x02, 0, 0},
	{0x8ad1, 0x04, 0, 0}, {0x8ad2, 0x34, 0, 0}, {0x8ad3,0x90, 0, 0},
	{0x8ad4, 0x0e, 0, 0}, {0x8ad5, 0x81, 0, 0}, {0x8ad6,0x12, 0, 0},
	{0x8ad7, 0x04, 0, 0}, {0x8ad8, 0x47, 0, 0}, {0x8ad9,0x8f, 0, 0},
	{0x8ada, 0x3b, 0, 0}, {0x8adb, 0x8e, 0, 0}, {0x8adc,0x3a, 0, 0},
	{0x8add, 0x8d, 0, 0}, {0x8ade, 0x39, 0, 0}, {0x8adf,0x8c, 0, 0},
	{0x8ae0, 0x38, 0, 0}, {0x8ae1, 0xd2, 0, 0}, {0x8ae2,0x06, 0, 0},
	{0x8ae3, 0x30, 0, 0}, {0x8ae4, 0x06, 0, 0}, {0x8ae5,0x03, 0, 0},
	{0x8ae6, 0xd3, 0, 0}, {0x8ae7, 0x80, 0, 0}, {0x8ae8,0x01, 0, 0},
	{0x8ae9, 0xc3, 0, 0}, {0x8aea, 0x92, 0, 0}, {0x8aeb,0x0e, 0, 0},
	{0x8aec, 0x22, 0, 0}, {0x8aed, 0xc0, 0, 0}, {0x8aee,0xe0, 0, 0},
	{0x8aef, 0xc0, 0, 0}, {0x8af0, 0x83, 0, 0}, {0x8af1,0xc0, 0, 0},
	{0x8af2, 0x82, 0, 0}, {0x8af3, 0x90, 0, 0}, {0x8af4,0x3f, 0, 0},
	{0x8af5, 0x0d, 0, 0}, {0x8af6, 0xe0, 0, 0}, {0x8af7,0xf5, 0, 0},
	{0x8af8, 0x28, 0, 0}, {0x8af9, 0xe5, 0, 0}, {0x8afa,0x28, 0, 0},
	{0x8afb, 0xf0, 0, 0}, {0x8afc, 0xd0, 0, 0}, {0x8afd,0x82, 0, 0},
	{0x8afe, 0xd0, 0, 0}, {0x8aff, 0x83, 0, 0}, {0x8b00,0xd0, 0, 0},
	{0x8b01, 0xe0, 0, 0}, {0x8b02, 0x32, 0, 0}, {0x8b03,0x78, 0, 0},
	{0x8b04, 0x7f, 0, 0}, {0x8b05, 0xe4, 0, 0}, {0x8b06,0xf6, 0, 0},
	{0x8b07, 0xd8, 0, 0}, {0x8b08, 0xfd, 0, 0}, {0x8b09,0x75, 0, 0},
	{0x8b0a, 0x81, 0, 0}, {0x8b0b, 0xc0, 0, 0}, {0x8b0c,0x02, 0, 0},
	{0x8b0d, 0x09, 0, 0}, {0x8b0e, 0x77, 0, 0}, {0x8b0f,0xe4, 0, 0},
	{0x8b10, 0x93, 0, 0}, {0x8b11, 0xfe, 0, 0}, {0x8b12,0x74, 0, 0},
	{0x8b13, 0x01, 0, 0}, {0x8b14, 0x93, 0, 0}, {0x8b15,0xf5, 0, 0},
	{0x8b16, 0x82, 0, 0}, {0x8b17, 0x8e, 0, 0}, {0x8b18,0x83, 0, 0},
	{0x8b19, 0x22, 0, 0}, {0x8b1a, 0x8f, 0, 0}, {0x8b1b,0x82, 0, 0},
	{0x8b1c, 0x8e, 0, 0}, {0x8b1d, 0x83, 0, 0}, {0x8b1e,0x75, 0, 0},
	{0x8b1f, 0xf0, 0, 0}, {0x8b20, 0x04, 0, 0}, {0x8b21,0xed, 0, 0},
	{0x8b22, 0x02, 0, 0}, {0x8b23, 0x04, 0, 0}, {0x8b24,0x70, 0, 0},
	{0x8b25, 0x00, 0, 0}, {0x8b26, 0x00, 0, 0}, {0x8b27,0x00, 0, 0},
	{0x8b28, 0x00, 0, 0}, {0x8b29, 0x00, 0, 0}, {0x8b2a,0x00, 0, 0},
	{0x8b2b, 0x00, 0, 0}, {0x8b2c, 0x00, 0, 0}, {0x8b2d,0x00, 0, 0},
	{0x8b2e, 0x00, 0, 0}, {0x8b2f, 0x00, 0, 0}, {0x8b30,0x00, 0, 0},
	{0x8b31, 0x00, 0, 0}, {0x8b32, 0x00, 0, 0}, {0x8b33,0x00, 0, 0},
	{0x8b34, 0x00, 0, 0}, {0x8b35, 0x00, 0, 0}, {0x8b36,0x00, 0, 0},
	{0x8b37, 0x00, 0, 0}, {0x8b38, 0x00, 0, 0}, {0x8b39,0x00, 0, 0},
	{0x8b3a, 0x00, 0, 0}, {0x8b3b, 0x00, 0, 0}, {0x8b3c,0x00, 0, 0},
	{0x8b3d, 0x00, 0, 0}, {0x8b3e, 0x00, 0, 0}, {0x8b3f,0x00, 0, 0},
	{0x8b40, 0x00, 0, 0}, {0x8b41, 0x00, 0, 0}, {0x8b42,0x00, 0, 0},
	{0x8b43, 0x00, 0, 0}, {0x8b44, 0x00, 0, 0}, {0x8b45,0x00, 0, 0},
	{0x8b46, 0x00, 0, 0}, {0x8b47, 0x00, 0, 0}, {0x8b48,0x00, 0, 0},
	{0x8b49, 0x00, 0, 0}, {0x8b4a, 0x00, 0, 0}, {0x8b4b,0x00, 0, 0},
	{0x8b4c, 0x00, 0, 0}, {0x8b4d, 0x00, 0, 0}, {0x8b4e,0x00, 0, 0},
	{0x8b4f, 0x00, 0, 0}, {0x8b50, 0x00, 0, 0}, {0x8b51,0x00, 0, 0},
	{0x8b52, 0x00, 0, 0}, {0x8b53, 0x00, 0, 0}, {0x8b54,0x00, 0, 0},
	{0x8b55, 0x00, 0, 0}, {0x8b56, 0x00, 0, 0}, {0x8b57,0x00, 0, 0},
	{0x8b58, 0x00, 0, 0}, {0x8b59, 0x00, 0, 0}, {0x8b5a,0x00, 0, 0},
	{0x8b5b, 0x00, 0, 0}, {0x8b5c, 0x00, 0, 0}, {0x8b5d,0x00, 0, 0},
	{0x8b5e, 0x00, 0, 0}, {0x8b5f, 0x00, 0, 0}, {0x8b60,0x00, 0, 0},
	{0x8b61, 0x00, 0, 0}, {0x8b62, 0x00, 0, 0}, {0x8b63,0x00, 0, 0},
	{0x8b64, 0x00, 0, 0}, {0x8b65, 0x00, 0, 0}, {0x8b66,0x00, 0, 0},
	{0x8b67, 0x00, 0, 0}, {0x8b68, 0x00, 0, 0}, {0x8b69,0x00, 0, 0},
	{0x8b6a, 0x00, 0, 0}, {0x8b6b, 0x00, 0, 0}, {0x8b6c,0x00, 0, 0},
	{0x8b6d, 0x00, 0, 0}, {0x8b6e, 0x00, 0, 0}, {0x8b6f,0x00, 0, 0},
	{0x8b70, 0x00, 0, 0}, {0x8b71, 0x00, 0, 0}, {0x8b72,0x00, 0, 0},
	{0x8b73, 0x00, 0, 0}, {0x8b74, 0x00, 0, 0}, {0x8b75,0x00, 0, 0},
	{0x8b76, 0x00, 0, 0}, {0x8b77, 0x00, 0, 0}, {0x8b78,0x00, 0, 0},
	{0x8b79, 0x00, 0, 0}, {0x8b7a, 0x00, 0, 0}, {0x8b7b,0x00, 0, 0},
	{0x8b7c, 0x00, 0, 0}, {0x8b7d, 0x00, 0, 0}, {0x8b7e,0x00, 0, 0},
	{0x8b7f, 0x00, 0, 0}, {0x8b80, 0x00, 0, 0}, {0x8b81,0x00, 0, 0},
	{0x8b82, 0x00, 0, 0}, {0x8b83, 0x00, 0, 0}, {0x8b84,0x00, 0, 0},
	{0x8b85, 0x00, 0, 0}, {0x8b86, 0x00, 0, 0}, {0x8b87,0x00, 0, 0},
	{0x8b88, 0x00, 0, 0}, {0x8b89, 0x00, 0, 0}, {0x8b8a,0x00, 0, 0},
	{0x8b8b, 0x00, 0, 0}, {0x8b8c, 0x00, 0, 0}, {0x8b8d,0x00, 0, 0},
	{0x8b8e, 0x00, 0, 0}, {0x8b8f, 0x00, 0, 0}, {0x8b90,0x00, 0, 0},
	{0x8b91, 0x00, 0, 0}, {0x8b92, 0x00, 0, 0}, {0x8b93,0x00, 0, 0},
	{0x8b94, 0x00, 0, 0}, {0x8b95, 0x00, 0, 0}, {0x8b96,0x00, 0, 0},
	{0x8b97, 0x00, 0, 0}, {0x8b98, 0x00, 0, 0}, {0x8b99,0x00, 0, 0},
	{0x8b9a, 0x00, 0, 0}, {0x8b9b, 0x00, 0, 0}, {0x8b9c,0x00, 0, 0},
	{0x8b9d, 0x00, 0, 0}, {0x8b9e, 0x00, 0, 0}, {0x8b9f,0x00, 0, 0},
	{0x8ba0, 0x00, 0, 0}, {0x8ba1, 0x00, 0, 0}, {0x8ba2,0x00, 0, 0},
	{0x8ba3, 0x00, 0, 0}, {0x8ba4, 0x00, 0, 0}, {0x8ba5,0x00, 0, 0},
	{0x8ba6, 0x00, 0, 0}, {0x8ba7, 0x00, 0, 0}, {0x8ba8,0x00, 0, 0},
	{0x8ba9, 0x00, 0, 0}, {0x8baa, 0x00, 0, 0}, {0x8bab,0x00, 0, 0},
	{0x8bac, 0x00, 0, 0}, {0x8bad, 0x00, 0, 0}, {0x8bae,0x00, 0, 0},
	{0x8baf, 0x00, 0, 0}, {0x8bb0, 0x00, 0, 0}, {0x8bb1,0x00, 0, 0},
	{0x8bb2, 0x00, 0, 0}, {0x8bb3, 0x00, 0, 0}, {0x8bb4,0x00, 0, 0},
	{0x8bb5, 0x00, 0, 0}, {0x8bb6, 0x00, 0, 0}, {0x8bb7,0x00, 0, 0},
	{0x8bb8, 0x00, 0, 0}, {0x8bb9, 0x00, 0, 0}, {0x8bba,0x00, 0, 0},
	{0x8bbb, 0x00, 0, 0}, {0x8bbc, 0x00, 0, 0}, {0x8bbd,0x00, 0, 0},
	{0x8bbe, 0x00, 0, 0}, {0x8bbf, 0x00, 0, 0}, {0x8bc0,0x00, 0, 0},
	{0x8bc1, 0x00, 0, 0}, {0x8bc2, 0x00, 0, 0}, {0x8bc3,0x00, 0, 0},
	{0x8bc4, 0x00, 0, 0}, {0x8bc5, 0x00, 0, 0}, {0x8bc6,0x00, 0, 0},
	{0x8bc7, 0x00, 0, 0}, {0x8bc8, 0x00, 0, 0}, {0x8bc9,0x00, 0, 0},
	{0x8bca, 0x00, 0, 0}, {0x8bcb, 0x00, 0, 0}, {0x8bcc,0x00, 0, 0},
	{0x8bcd, 0x00, 0, 0}, {0x8bce, 0x00, 0, 0}, {0x8bcf,0x00, 0, 0},
	{0x8bd0, 0x00, 0, 0}, {0x8bd1, 0x00, 0, 0}, {0x8bd2,0x00, 0, 0},
	{0x8bd3, 0x00, 0, 0}, {0x8bd4, 0x00, 0, 0}, {0x8bd5,0x00, 0, 0},
	{0x8bd6, 0x00, 0, 0}, {0x8bd7, 0x00, 0, 0}, {0x8bd8,0x00, 0, 0},
	{0x8bd9, 0x00, 0, 0}, {0x8bda, 0x00, 0, 0}, {0x8bdb,0x00, 0, 0},
	{0x8bdc, 0x00, 0, 0}, {0x8bdd, 0x00, 0, 0}, {0x8bde,0x00, 0, 0},
	{0x8bdf, 0x00, 0, 0}, {0x8be0, 0x00, 0, 0}, {0x8be1,0x00, 0, 0},
	{0x8be2, 0x00, 0, 0}, {0x8be3, 0x00, 0, 0}, {0x8be4,0x00, 0, 0},
	{0x8be5, 0x00, 0, 0}, {0x8be6, 0x00, 0, 0}, {0x8be7,0x00, 0, 0},
	{0x8be8, 0x00, 0, 0}, {0x8be9, 0x00, 0, 0}, {0x8bea,0x00, 0, 0},
	{0x8beb, 0x00, 0, 0}, {0x8bec, 0x00, 0, 0}, {0x8bed,0x00, 0, 0},
	{0x8bee, 0x00, 0, 0}, {0x8bef, 0x00, 0, 0}, {0x8bf0,0x00, 0, 0},
	{0x8bf1, 0x00, 0, 0}, {0x8bf2, 0x00, 0, 0}, {0x8bf3,0x00, 0, 0},
	{0x8bf4, 0x00, 0, 0}, {0x8bf5, 0x00, 0, 0}, {0x8bf6,0x00, 0, 0},
	{0x8bf7, 0x00, 0, 0}, {0x8bf8, 0x00, 0, 0}, {0x8bf9,0x00, 0, 0},
	{0x8bfa, 0x00, 0, 0}, {0x8bfb, 0x00, 0, 0}, {0x8bfc,0x00, 0, 0},
	{0x8bfd, 0x00, 0, 0}, {0x8bfe, 0x00, 0, 0}, {0x8bff,0x00, 0, 0},
	{0x8c00, 0x00, 0, 0}, {0x8c01, 0x00, 0, 0}, {0x8c02,0x00, 0, 0},
	{0x8c03, 0x00, 0, 0}, {0x8c04, 0x00, 0, 0}, {0x8c05,0x00, 0, 0},
	{0x8c06, 0x00, 0, 0}, {0x8c07, 0x00, 0, 0}, {0x8c08,0x00, 0, 0},
	{0x8c09, 0x00, 0, 0}, {0x8c0a, 0x00, 0, 0}, {0x8c0b,0x00, 0, 0},
	{0x8c0c, 0x00, 0, 0}, {0x8c0d, 0x00, 0, 0}, {0x8c0e,0x00, 0, 0},
	{0x8c0f, 0x00, 0, 0}, {0x8c10, 0x00, 0, 0}, {0x8c11,0x00, 0, 0},
	{0x8c12, 0x00, 0, 0}, {0x8c13, 0x00, 0, 0}, {0x8c14,0x00, 0, 0},
	{0x8c15, 0x00, 0, 0}, {0x8c16, 0x00, 0, 0}, {0x8c17,0x00, 0, 0},
	{0x8c18, 0x00, 0, 0}, {0x8c19, 0x00, 0, 0}, {0x8c1a,0x00, 0, 0},
	{0x8c1b, 0x00, 0, 0}, {0x8c1c, 0x00, 0, 0}, {0x8c1d,0x00, 0, 0},
	{0x8c1e, 0x00, 0, 0}, {0x8c1f, 0x00, 0, 0}, {0x8c20,0x00, 0, 0},
	{0x8c21, 0x00, 0, 0}, {0x8c22, 0x00, 0, 0}, {0x8c23,0x00, 0, 0},
	{0x8c24, 0x00, 0, 0}, {0x8c25, 0x00, 0, 0}, {0x8c26,0x00, 0, 0},
	{0x8c27, 0x00, 0, 0}, {0x8c28, 0x00, 0, 0}, {0x8c29,0x00, 0, 0},
	{0x8c2a, 0x00, 0, 0}, {0x8c2b, 0x00, 0, 0}, {0x8c2c,0x00, 0, 0},
	{0x8c2d, 0x00, 0, 0}, {0x8c2e, 0x00, 0, 0}, {0x8c2f,0x00, 0, 0},
	{0x8c30, 0x00, 0, 0}, {0x8c31, 0x00, 0, 0}, {0x8c32,0x00, 0, 0},
	{0x8c33, 0x00, 0, 0}, {0x8c34, 0x00, 0, 0}, {0x8c35,0x00, 0, 0},
	{0x8c36, 0x00, 0, 0}, {0x8c37, 0x00, 0, 0}, {0x8c38,0x00, 0, 0},
	{0x8c39, 0x00, 0, 0}, {0x8c3a, 0x00, 0, 0}, {0x8c3b,0x00, 0, 0},
	{0x8c3c, 0x00, 0, 0}, {0x8c3d, 0x00, 0, 0}, {0x8c3e,0x00, 0, 0},
	{0x8c3f, 0x00, 0, 0}, {0x8c40, 0x00, 0, 0}, {0x8c41,0x00, 0, 0},
	{0x8c42, 0x00, 0, 0}, {0x8c43, 0x00, 0, 0}, {0x8c44,0x00, 0, 0},
	{0x8c45, 0x00, 0, 0}, {0x8c46, 0x00, 0, 0}, {0x8c47,0x00, 0, 0},
	{0x8c48, 0x00, 0, 0}, {0x8c49, 0x00, 0, 0}, {0x8c4a,0x00, 0, 0},
	{0x8c4b, 0x00, 0, 0}, {0x8c4c, 0x00, 0, 0}, {0x8c4d,0x00, 0, 0},
	{0x8c4e, 0x00, 0, 0}, {0x8c4f, 0x00, 0, 0}, {0x8c50,0x00, 0, 0},
	{0x8c51, 0x00, 0, 0}, {0x8c52, 0x00, 0, 0}, {0x8c53,0x00, 0, 0},
	{0x8c54, 0x00, 0, 0}, {0x8c55, 0x00, 0, 0}, {0x8c56,0x00, 0, 0},
	{0x8c57, 0x00, 0, 0}, {0x8c58, 0x00, 0, 0}, {0x8c59,0x00, 0, 0},
	{0x8c5a, 0x00, 0, 0}, {0x8c5b, 0x00, 0, 0}, {0x8c5c,0x00, 0, 0},
	{0x8c5d, 0x00, 0, 0}, {0x8c5e, 0x00, 0, 0}, {0x8c5f,0x00, 0, 0},
	{0x8c60, 0x00, 0, 0}, {0x8c61, 0x00, 0, 0}, {0x8c62,0x00, 0, 0},
	{0x8c63, 0x00, 0, 0}, {0x8c64, 0x00, 0, 0}, {0x8c65,0x00, 0, 0},
	{0x8c66, 0x00, 0, 0}, {0x8c67, 0x00, 0, 0}, {0x8c68,0x00, 0, 0},
	{0x8c69, 0x00, 0, 0}, {0x8c6a, 0x00, 0, 0}, {0x8c6b,0x00, 0, 0},
	{0x8c6c, 0x00, 0, 0}, {0x8c6d, 0x00, 0, 0}, {0x8c6e,0x00, 0, 0},
	{0x8c6f, 0x00, 0, 0}, {0x8c70, 0x00, 0, 0}, {0x8c71,0x00, 0, 0},
	{0x8c72, 0x00, 0, 0}, {0x8c73, 0x00, 0, 0}, {0x8c74,0x00, 0, 0},
	{0x8c75, 0x00, 0, 0}, {0x8c76, 0x00, 0, 0}, {0x8c77,0x00, 0, 0},
	{0x8c78, 0x00, 0, 0}, {0x8c79, 0x00, 0, 0}, {0x8c7a,0x00, 0, 0},
	{0x8c7b, 0x00, 0, 0}, {0x8c7c, 0x00, 0, 0}, {0x8c7d,0x00, 0, 0},
	{0x8c7e, 0x00, 0, 0}, {0x8c7f, 0x00, 0, 0}, {0x8c80,0x00, 0, 0},
	{0x8c81, 0x00, 0, 0}, {0x8c82, 0x00, 0, 0}, {0x8c83,0x00, 0, 0},
	{0x8c84, 0x00, 0, 0}, {0x8c85, 0x00, 0, 0}, {0x8c86,0x00, 0, 0},
	{0x8c87, 0x00, 0, 0}, {0x8c88, 0x00, 0, 0}, {0x8c89,0x00, 0, 0},
	{0x8c8a, 0x00, 0, 0}, {0x8c8b, 0x00, 0, 0}, {0x8c8c,0x00, 0, 0},
	{0x8c8d, 0x00, 0, 0}, {0x8c8e, 0x00, 0, 0}, {0x8c8f,0x00, 0, 0},
	{0x8c90, 0x00, 0, 0}, {0x8c91, 0x00, 0, 0}, {0x8c92,0x00, 0, 0},
	{0x8c93, 0x00, 0, 0}, {0x8c94, 0x00, 0, 0}, {0x8c95,0x00, 0, 0},
	{0x8c96, 0x00, 0, 0}, {0x8c97, 0x00, 0, 0}, {0x8c98,0x00, 0, 0},
	{0x8c99, 0x00, 0, 0}, {0x8c9a, 0x00, 0, 0}, {0x8c9b,0x00, 0, 0},
	{0x8c9c, 0x00, 0, 0}, {0x8c9d, 0x00, 0, 0}, {0x8c9e,0x00, 0, 0},
	{0x8c9f, 0x00, 0, 0}, {0x8ca0, 0x00, 0, 0}, {0x8ca1,0x00, 0, 0},
	{0x8ca2, 0x00, 0, 0}, {0x8ca3, 0x00, 0, 0}, {0x8ca4,0x00, 0, 0},
	{0x8ca5, 0x00, 0, 0}, {0x8ca6, 0x00, 0, 0}, {0x8ca7,0x00, 0, 0},
	{0x8ca8, 0x00, 0, 0}, {0x8ca9, 0x00, 0, 0}, {0x8caa,0x00, 0, 0},
	{0x8cab, 0x00, 0, 0}, {0x8cac, 0x00, 0, 0}, {0x8cad,0x00, 0, 0},
	{0x8cae, 0x00, 0, 0}, {0x8caf, 0x00, 0, 0}, {0x8cb0,0x00, 0, 0},
	{0x8cb1, 0x00, 0, 0}, {0x8cb2, 0x00, 0, 0}, {0x8cb3,0x00, 0, 0},
	{0x8cb4, 0x00, 0, 0}, {0x8cb5, 0x00, 0, 0}, {0x8cb6,0x00, 0, 0},
	{0x8cb7, 0x00, 0, 0}, {0x8cb8, 0x00, 0, 0}, {0x8cb9,0x00, 0, 0},
	{0x8cba, 0x00, 0, 0}, {0x8cbb, 0x00, 0, 0}, {0x8cbc,0x00, 0, 0},
	{0x8cbd, 0x00, 0, 0}, {0x8cbe, 0x00, 0, 0}, {0x8cbf,0x00, 0, 0},
	{0x8cc0, 0x00, 0, 0}, {0x8cc1, 0x00, 0, 0}, {0x8cc2,0x00, 0, 0},
	{0x8cc3, 0x00, 0, 0}, {0x8cc4, 0x00, 0, 0}, {0x8cc5,0x00, 0, 0},
	{0x8cc6, 0x00, 0, 0}, {0x8cc7, 0x00, 0, 0}, {0x8cc8,0x00, 0, 0},
	{0x8cc9, 0x00, 0, 0}, {0x8cca, 0x00, 0, 0}, {0x8ccb,0x00, 0, 0},
	{0x8ccc, 0x00, 0, 0}, {0x8ccd, 0x00, 0, 0}, {0x8cce,0x00, 0, 0},
	{0x8ccf, 0x00, 0, 0}, {0x8cd0, 0x00, 0, 0}, {0x8cd1,0x00, 0, 0},
	{0x8cd2, 0x00, 0, 0}, {0x8cd3, 0x00, 0, 0}, {0x8cd4,0x00, 0, 0},
	{0x8cd5, 0x00, 0, 0}, {0x8cd6, 0x00, 0, 0}, {0x8cd7,0x00, 0, 0},
	{0x8cd8, 0x00, 0, 0}, {0x8cd9, 0x00, 0, 0}, {0x8cda,0x00, 0, 0},
	{0x8cdb, 0x00, 0, 0}, {0x8cdc, 0x00, 0, 0}, {0x8cdd,0x00, 0, 0},
	{0x8cde, 0x00, 0, 0}, {0x8cdf, 0x00, 0, 0}, {0x8ce0,0x00, 0, 0},
	{0x8ce1, 0x00, 0, 0}, {0x8ce2, 0x00, 0, 0}, {0x8ce3,0x00, 0, 0},
	{0x8ce4, 0x00, 0, 0}, {0x8ce5, 0x00, 0, 0}, {0x8ce6,0x00, 0, 0},
	{0x8ce7, 0x00, 0, 0}, {0x8ce8, 0x00, 0, 0}, {0x8ce9,0x00, 0, 0},
	{0x8cea, 0x00, 0, 0}, {0x8ceb, 0x00, 0, 0}, {0x8cec,0x00, 0, 0},
	{0x8ced, 0x00, 0, 0}, {0x8cee, 0x00, 0, 0}, {0x8cef,0x00, 0, 0},
	{0x8cf0, 0x00, 0, 0}, {0x8cf1, 0x00, 0, 0}, {0x8cf2,0x00, 0, 0},
	{0x8cf3, 0x00, 0, 0}, {0x8cf4, 0x00, 0, 0}, {0x8cf5,0x00, 0, 0},
	{0x8cf6, 0x00, 0, 0}, {0x8cf7, 0x00, 0, 0}, {0x8cf8,0x00, 0, 0},
	{0x8cf9, 0x00, 0, 0}, {0x8cfa, 0x00, 0, 0}, {0x8cfb,0x00, 0, 0},
	{0x8cfc, 0x00, 0, 0}, {0x8cfd, 0x00, 0, 0}, {0x8cfe,0x00, 0, 0},
	{0x8cff, 0x00, 0, 0}, {0x8d00, 0x00, 0, 0}, {0x8d01,0x00, 0, 0},
	{0x8d02, 0x00, 0, 0}, {0x8d03, 0x00, 0, 0}, {0x8d04,0x00, 0, 0},
	{0x8d05, 0x00, 0, 0}, {0x8d06, 0x00, 0, 0}, {0x8d07,0x00, 0, 0},
	{0x8d08, 0x00, 0, 0}, {0x8d09, 0x00, 0, 0}, {0x8d0a,0x00, 0, 0},
	{0x8d0b, 0x00, 0, 0}, {0x8d0c, 0x00, 0, 0}, {0x8d0d,0x00, 0, 0},
	{0x8d0e, 0x00, 0, 0}, {0x8d0f, 0x00, 0, 0}, {0x8d10,0x00, 0, 0},
	{0x8d11, 0x00, 0, 0}, {0x8d12, 0x00, 0, 0}, {0x8d13,0x00, 0, 0},
	{0x8d14, 0x00, 0, 0}, {0x8d15, 0x00, 0, 0}, {0x8d16,0x00, 0, 0},
	{0x8d17, 0x00, 0, 0}, {0x8d18, 0x00, 0, 0}, {0x8d19,0x00, 0, 0},
	{0x8d1a, 0x00, 0, 0}, {0x8d1b, 0x00, 0, 0}, {0x8d1c,0x00, 0, 0},
	{0x8d1d, 0x00, 0, 0}, {0x8d1e, 0x00, 0, 0}, {0x8d1f,0x00, 0, 0},
	{0x8d20, 0x00, 0, 0}, {0x8d21, 0x00, 0, 0}, {0x8d22,0x00, 0, 0},
	{0x8d23, 0x00, 0, 0}, {0x8d24, 0x00, 0, 0}, {0x8d25,0x00, 0, 0},
	{0x8d26, 0x00, 0, 0}, {0x8d27, 0x00, 0, 0}, {0x8d28,0x00, 0, 0},
	{0x8d29, 0x00, 0, 0}, {0x8d2a, 0x00, 0, 0}, {0x8d2b,0x00, 0, 0},
	{0x8d2c, 0x00, 0, 0}, {0x8d2d, 0x00, 0, 0}, {0x8d2e,0x00, 0, 0},
	{0x8d2f, 0x00, 0, 0}, {0x8d30, 0x00, 0, 0}, {0x8d31,0x00, 0, 0},
	{0x8d32, 0x00, 0, 0}, {0x8d33, 0x00, 0, 0}, {0x8d34,0x00, 0, 0},
	{0x8d35, 0x00, 0, 0}, {0x8d36, 0x00, 0, 0}, {0x8d37,0x00, 0, 0},
	{0x8d38, 0x00, 0, 0}, {0x8d39, 0x00, 0, 0}, {0x8d3a,0x00, 0, 0},
	{0x8d3b, 0x00, 0, 0}, {0x8d3c, 0x00, 0, 0}, {0x8d3d,0x00, 0, 0},
	{0x8d3e, 0x00, 0, 0}, {0x8d3f, 0x00, 0, 0}, {0x8d40,0x00, 0, 0},
	{0x8d41, 0x00, 0, 0}, {0x8d42, 0x00, 0, 0}, {0x8d43,0x00, 0, 0},
	{0x8d44, 0x00, 0, 0}, {0x8d45, 0x00, 0, 0}, {0x8d46,0x00, 0, 0},
	{0x8d47, 0x00, 0, 0}, {0x8d48, 0x00, 0, 0}, {0x8d49,0x00, 0, 0},
	{0x8d4a, 0x00, 0, 0}, {0x8d4b, 0x00, 0, 0}, {0x8d4c,0x00, 0, 0},
	{0x8d4d, 0x00, 0, 0}, {0x8d4e, 0x00, 0, 0}, {0x8d4f,0x00, 0, 0},
	{0x8d50, 0x00, 0, 0}, {0x8d51, 0x00, 0, 0}, {0x8d52,0x00, 0, 0},
	{0x8d53, 0x00, 0, 0}, {0x8d54, 0x00, 0, 0}, {0x8d55,0x00, 0, 0},
	{0x8d56, 0x00, 0, 0}, {0x8d57, 0x00, 0, 0}, {0x8d58,0x00, 0, 0},
	{0x8d59, 0x00, 0, 0}, {0x8d5a, 0x00, 0, 0}, {0x8d5b,0x00, 0, 0},
	{0x8d5c, 0x00, 0, 0}, {0x8d5d, 0x00, 0, 0}, {0x8d5e,0x00, 0, 0},
	{0x8d5f, 0x00, 0, 0}, {0x8d60, 0x00, 0, 0}, {0x8d61,0x00, 0, 0},
	{0x8d62, 0x00, 0, 0}, {0x8d63, 0x00, 0, 0}, {0x8d64,0x00, 0, 0},
	{0x8d65, 0x00, 0, 0}, {0x8d66, 0x00, 0, 0}, {0x8d67,0x00, 0, 0},
	{0x8d68, 0x00, 0, 0}, {0x8d69, 0x00, 0, 0}, {0x8d6a,0x00, 0, 0},
	{0x8d6b, 0x00, 0, 0}, {0x8d6c, 0x00, 0, 0}, {0x8d6d,0x00, 0, 0},
	{0x8d6e, 0x00, 0, 0}, {0x8d6f, 0x00, 0, 0}, {0x8d70,0x00, 0, 0},
	{0x8d71, 0x00, 0, 0}, {0x8d72, 0x00, 0, 0}, {0x8d73,0x00, 0, 0},
	{0x8d74, 0x00, 0, 0}, {0x8d75, 0x00, 0, 0}, {0x8d76,0x00, 0, 0},
	{0x8d77, 0x00, 0, 0}, {0x8d78, 0x00, 0, 0}, {0x8d79,0x00, 0, 0},
	{0x8d7a, 0x00, 0, 0}, {0x8d7b, 0x00, 0, 0}, {0x8d7c,0x00, 0, 0},
	{0x8d7d, 0x00, 0, 0}, {0x8d7e, 0x00, 0, 0}, {0x8d7f,0x00, 0, 0},
	{0x8d80, 0x00, 0, 0}, {0x8d81, 0x00, 0, 0}, {0x8d82,0x00, 0, 0},
	{0x8d83, 0x00, 0, 0}, {0x8d84, 0x00, 0, 0}, {0x8d85,0x00, 0, 0},
	{0x8d86, 0x00, 0, 0}, {0x8d87, 0x00, 0, 0}, {0x8d88,0x00, 0, 0},
	{0x8d89, 0x00, 0, 0}, {0x8d8a, 0x00, 0, 0}, {0x8d8b,0x00, 0, 0},
	{0x8d8c, 0x00, 0, 0}, {0x8d8d, 0x00, 0, 0}, {0x8d8e,0x00, 0, 0},
	{0x8d8f, 0x00, 0, 0}, {0x8d90, 0x00, 0, 0}, {0x8d91,0x00, 0, 0},
	{0x8d92, 0x00, 0, 0}, {0x8d93, 0x00, 0, 0}, {0x8d94,0x00, 0, 0},
	{0x8d95, 0x00, 0, 0}, {0x8d96, 0x00, 0, 0}, {0x8d97,0x00, 0, 0},
	{0x8d98, 0x00, 0, 0}, {0x8d99, 0x00, 0, 0}, {0x8d9a,0x00, 0, 0},
	{0x8d9b, 0x00, 0, 0}, {0x8d9c, 0x00, 0, 0}, {0x8d9d,0x00, 0, 0},
	{0x8d9e, 0x00, 0, 0}, {0x8d9f, 0x00, 0, 0}, {0x8da0,0x00, 0, 0},
	{0x8da1, 0x00, 0, 0}, {0x8da2, 0x00, 0, 0}, {0x8da3,0x00, 0, 0},
	{0x8da4, 0x00, 0, 0}, {0x8da5, 0x00, 0, 0}, {0x8da6,0x00, 0, 0},
	{0x8da7, 0x00, 0, 0}, {0x8da8, 0x00, 0, 0}, {0x8da9,0x00, 0, 0},
	{0x8daa, 0x00, 0, 0}, {0x8dab, 0x00, 0, 0}, {0x8dac,0x00, 0, 0},
	{0x8dad, 0x00, 0, 0}, {0x8dae, 0x00, 0, 0}, {0x8daf,0x00, 0, 0},
	{0x8db0, 0x00, 0, 0}, {0x8db1, 0x00, 0, 0}, {0x8db2,0x00, 0, 0},
	{0x8db3, 0x00, 0, 0}, {0x8db4, 0x00, 0, 0}, {0x8db5,0x00, 0, 0},
	{0x8db6, 0x00, 0, 0}, {0x8db7, 0x00, 0, 0}, {0x8db8,0x00, 0, 0},
	{0x8db9, 0x00, 0, 0}, {0x8dba, 0x00, 0, 0}, {0x8dbb,0x00, 0, 0},
	{0x8dbc, 0x00, 0, 0}, {0x8dbd, 0x00, 0, 0}, {0x8dbe,0x00, 0, 0},
	{0x8dbf, 0x00, 0, 0}, {0x8dc0, 0x00, 0, 0}, {0x8dc1,0x00, 0, 0},
	{0x8dc2, 0x00, 0, 0}, {0x8dc3, 0x00, 0, 0}, {0x8dc4,0x00, 0, 0},
	{0x8dc5, 0x00, 0, 0}, {0x8dc6, 0x00, 0, 0}, {0x8dc7,0x00, 0, 0},
	{0x8dc8, 0x00, 0, 0}, {0x8dc9, 0x00, 0, 0}, {0x8dca,0x00, 0, 0},
	{0x8dcb, 0x00, 0, 0}, {0x8dcc, 0x00, 0, 0}, {0x8dcd,0x00, 0, 0},
	{0x8dce, 0x00, 0, 0}, {0x8dcf, 0x00, 0, 0}, {0x8dd0,0x00, 0, 0},
	{0x8dd1, 0x00, 0, 0}, {0x8dd2, 0x00, 0, 0}, {0x8dd3,0x00, 0, 0},
	{0x8dd4, 0x00, 0, 0}, {0x8dd5, 0x00, 0, 0}, {0x8dd6,0x00, 0, 0},
	{0x8dd7, 0x00, 0, 0}, {0x8dd8, 0x00, 0, 0}, {0x8dd9,0x00, 0, 0},
	{0x8dda, 0x00, 0, 0}, {0x8ddb, 0x00, 0, 0}, {0x8ddc,0x00, 0, 0},
	{0x8ddd, 0x00, 0, 0}, {0x8dde, 0x00, 0, 0}, {0x8ddf,0x00, 0, 0},
	{0x8de0, 0x00, 0, 0}, {0x8de1, 0x00, 0, 0}, {0x8de2,0x00, 0, 0},
	{0x8de3, 0x00, 0, 0}, {0x8de4, 0x00, 0, 0}, {0x8de5,0x00, 0, 0},
	{0x8de6, 0x00, 0, 0}, {0x8de7, 0x00, 0, 0}, {0x8de8,0x00, 0, 0},
	{0x8de9, 0x00, 0, 0}, {0x8dea, 0x00, 0, 0}, {0x8deb,0x00, 0, 0},
	{0x8dec, 0x00, 0, 0}, {0x8ded, 0x00, 0, 0}, {0x8dee,0x00, 0, 0},
	{0x8def, 0x00, 0, 0}, {0x8df0, 0x00, 0, 0}, {0x8df1,0x00, 0, 0},
	{0x8df2, 0x00, 0, 0}, {0x8df3, 0x00, 0, 0}, {0x8df4,0x00, 0, 0},
	{0x8df5, 0x00, 0, 0}, {0x8df6, 0x00, 0, 0}, {0x8df7,0x00, 0, 0},
	{0x8df8, 0x00, 0, 0}, {0x8df9, 0x00, 0, 0}, {0x8dfa,0x00, 0, 0},
	{0x8dfb, 0x00, 0, 0}, {0x8dfc, 0x00, 0, 0}, {0x8dfd,0x00, 0, 0},
	{0x8dfe, 0x00, 0, 0}, {0x8dff, 0x00, 0, 0}, {0x8e00,0x11, 0, 0},
	{0x8e01, 0x03, 0, 0}, {0x8e02, 0x21, 0, 0}, {0x8e03,0x14, 0, 0},
	{0x8e04, 0x31, 0, 0}, {0x8e05, 0x31, 0, 0}, {0x8e06,0x4f, 0, 0},
	{0x8e07, 0x56, 0, 0}, {0x8e08, 0x54, 0, 0}, {0x8e09,0x20, 0, 0},
	{0x8e0a, 0x20, 0, 0}, {0x8e0b, 0x20, 0, 0}, {0x8e0c,0x20, 0, 0},
	{0x8e0d, 0x20, 0, 0}, {0x8e0e, 0x20, 0, 0}, {0x8e0f,0x00, 0, 0},
	{0x8e10, 0x10, 0, 0}, {0x8e11, 0x00, 0, 0}, {0x8e12,0x56, 0, 0},
	{0x8e13, 0x40, 0, 0}, {0x8e14, 0x1a, 0, 0}, {0x8e15,0x30, 0, 0},
	{0x8e16, 0x29, 0, 0}, {0x8e17, 0x7e, 0, 0}, {0x8e18,0x00, 0, 0},
	{0x8e19, 0x30, 0, 0}, {0x8e1a, 0x04, 0, 0}, {0x8e1b,0x20, 0, 0},
	{0x8e1c, 0xdf, 0, 0}, {0x8e1d, 0x30, 0, 0}, {0x8e1e,0x05, 0, 0},
	{0x8e1f, 0x40, 0, 0}, {0x8e20, 0xbf, 0, 0}, {0x8e21,0x50, 0, 0},
	{0x8e22, 0x25, 0, 0}, {0x8e23, 0x04, 0, 0}, {0x8e24,0xfb, 0, 0},
	{0x8e25, 0x50, 0, 0}, {0x8e26, 0x03, 0, 0}, {0x8e27,0x00, 0, 0},
	{0x8e28, 0xfd, 0, 0}, {0x8e29, 0x50, 0, 0}, {0x8e2a,0x27, 0, 0},
	{0x8e2b, 0x01, 0, 0}, {0x8e2c, 0xfe, 0, 0}, {0x8e2d,0x60, 0, 0},
	{0x8e2e, 0x00, 0, 0}, {0x8e2f, 0x11, 0, 0}, {0x8e30,0x00, 0, 0},
	{0x8e31, 0x3f, 0, 0}, {0x8e32, 0x05, 0, 0}, {0x8e33,0x30, 0, 0},
	{0x8e34, 0x00, 0, 0}, {0x8e35, 0x3f, 0, 0}, {0x8e36,0x06, 0, 0},
	{0x8e37, 0x22, 0, 0}, {0x8e38, 0x00, 0, 0}, {0x8e39,0x3f, 0, 0},
	{0x8e3a, 0x01, 0, 0}, {0x8e3b, 0x29, 0, 0}, {0x8e3c,0x00, 0, 0},
	{0x8e3d, 0x3f, 0, 0}, {0x8e3e, 0x02, 0, 0}, {0x8e3f,0x00, 0, 0},
	{0x8e40, 0x00, 0, 0}, {0x8e41, 0x36, 0, 0}, {0x8e42,0x06, 0, 0},
	{0x8e43, 0x07, 0, 0}, {0x8e44, 0x00, 0, 0}, {0x8e45,0x3f, 0, 0},
	{0x8e46, 0x0b, 0, 0}, {0x8e47, 0x0f, 0, 0}, {0x8e48,0xf0, 0, 0},
	{0x8e49, 0x30, 0, 0}, {0x8e4a, 0x01, 0, 0}, {0x8e4b,0x40, 0, 0},
	{0x8e4c, 0xbf, 0, 0}, {0x8e4d, 0x30, 0, 0}, {0x8e4e,0x01, 0, 0},
	{0x8e4f, 0x00, 0, 0}, {0x8e50, 0xbf, 0, 0}, {0x8e51,0x30, 0, 0},
	{0x8e52, 0x29, 0, 0}, {0x8e53, 0x70, 0, 0}, {0x8e54,0x00, 0, 0},
	{0x8e55, 0x3a, 0, 0}, {0x8e56, 0x00, 0, 0}, {0x8e57,0x01, 0, 0},
	{0x8e58, 0xfe, 0, 0}, {0x8e59, 0x3a, 0, 0}, {0x8e5a,0x00, 0, 0},
	{0x8e5b, 0x00, 0, 0}, {0x8e5c, 0xfe, 0, 0}, {0x8e5d,0x36, 0, 0},
	{0x8e5e, 0x03, 0, 0}, {0x8e5f, 0x36, 0, 0}, {0x8e60,0x02, 0, 0},
	{0x8e61, 0x41, 0, 0}, {0x8e62, 0x44, 0, 0}, {0x8e63,0x58, 0, 0},
	{0x8e64, 0x20, 0, 0}, {0x8e65, 0x18, 0, 0}, {0x8e66,0x10, 0, 0},
	{0x8e67, 0x0a, 0, 0}, {0x8e68, 0x04, 0, 0}, {0x8e69,0x04, 0, 0},
	{0x8e6a, 0x00, 0, 0}, {0x8e6b, 0x03, 0, 0}, {0x8e6c,0xff, 0, 0},
	{0x8e6d, 0x64, 0, 0}, {0x8e6e, 0x00, 0, 0}, {0x8e6f,0x00, 0, 0},
	{0x8e70, 0x80, 0, 0}, {0x8e71, 0x00, 0, 0}, {0x8e72,0x00, 0, 0},
	{0x8e73, 0x00, 0, 0}, {0x8e74, 0x00, 0, 0}, {0x8e75,0x00, 0, 0},
	{0x8e76, 0x00, 0, 0}, {0x8e77, 0x02, 0, 0}, {0x8e78,0x04, 0, 0},
	{0x8e79, 0x06, 0, 0}, {0x8e7a, 0x00, 0, 0}, {0x8e7b,0x03, 0, 0},
	{0x8e7c, 0x98, 0, 0}, {0x8e7d, 0x00, 0, 0}, {0x8e7e,0xcc, 0, 0},
	{0x8e7f, 0x50, 0, 0}, {0x8e80, 0x3c, 0, 0}, {0x8e81,0x28, 0, 0},
	{0x8e82, 0x1e, 0, 0}, {0x8e83, 0x10, 0, 0}, {0x8e84,0x10, 0, 0},
	{0x8e85, 0x00, 0, 0}, {0x8e86, 0x00, 0, 0}, {0x8e87,0x00, 0, 0},
	{0x8e88, 0x6e, 0, 0}, {0x8e89, 0x05, 0, 0}, {0x8e8a,0x05, 0, 0},
	{0x8e8b, 0x00, 0, 0}, {0x8e8c, 0xa5, 0, 0}, {0x8e8d,0x5a, 0, 0},

	/* un-documented registers */
	{0x3022, 0x00, 0, 0}, {0x3023, 0x00, 0, 0}, {0x3024,0x00, 0, 0},
	{0x3025, 0x00, 0, 0}, {0x3026, 0x00, 0, 0}, {0x3027,0x00, 0, 0},
	{0x3028, 0x00, 0, 0}, {0x3029, 0xff, 0, 0}
};
// temp


static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,
			    enum ov5640_mode mode, enum ov5640_mode orig_mode)
{
	......................................................................................................
	if (mode == ov5640_mode_INIT) {													// only for sensor init
		// temp
		pr_debug("Func ov5640_init_mode -> if (mode == ov5640_mode_INIT)\n");
		// temp
		pModeSetting = ov5640_init_setting_30fps_VGA;
		ArySize = ARRAY_SIZE(ov5640_init_setting_30fps_VGA);

		ov5640_data.pix.width = 640;
		ov5640_data.pix.height = 480;
		retval = ov5640_download_firmware(pModeSetting, ArySize);
		if (retval < 0)
			goto err;

		// temp
		retval = ov5640_download_autofocus();
		if (retval < 0) {
			pr_err("%s: error downloading autofocus firmware\n", __func__);
			goto err;
		}

		trigger_auto_focus();
		// temp

		pModeSetting = ov5640_setting_30fps_VGA_640_480;
		ArySize = ARRAY_SIZE(ov5640_setting_30fps_VGA_640_480);
	......................................................................................................


static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	......................................................................................................
	// temp
	case V4L2_CID_TEMP:
		pr_debug("   V4L2_CID_TEMP\n");

		int iAddress = 0, iData = 0;

		iAddress = (vc->value >> 8) & 0xffff;
		iData = vc->value & 0xff;
		pr_debug("iAddress = %d, iData = %d\n", iAddress, iData);
		pr_debug("iAddress = 0x%x, iData = 0x%x\n", iAddress, iData);

		if(iAddress == 0xf000)
		{
			#if 0
			switch(iData)
			{
				case 1:
					ov5640_auto_focus_start();
					break;
				case 2:
					ov5640_set_idle_mode();
					break;
			}
			#else
			pr_debug("Stepping to position: %d\n", iData);

			if(iData < 0 || iData > 255)
			{
				retval = -EPERM;
				return retval;
			}

			ov5640_write_reg(CMD_PARA3, 0);
			ov5640_write_reg(CMD_PARA4, iData);
			retval1 = ov5640_write_reg(CMD_ACK, 0x01);
			retval2 = ov5640_write_reg(CMD_MAIN, 0x1a);
			if(retval1 != 0 || retval2 != 0) {
				pr_err("%s:error stepping to 0x%02x: %d/%d\n",
				       __func__, iData, retval1, retval2);
				retval = -EPERM;
			} else {
				pr_debug("step successful\n");
				retval = 0;
			}
			#endif
		}
		else
			ov5640_write_reg(iAddress, iData);
		break;
	// temp
	......................................................................................................


static int ov5640_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	......................................................................................................
	// temp
	#if 0
	pr_info("Upload Auto-focus firmware");
	firmware_regs = ov5640_af_firmware;
	for (i = 0; i < ARRAY_SIZE(ov5640_af_firmware); ++i, ++firmware_regs) {
		retval = ov5640_write_reg(firmware_regs->u16RegAddr,
					  firmware_regs->u8Val);
		if (retval < 0)
			break;
	}
	#elif 0
	pr_info("Upload Auto-focus firmware");
	firmware_regs = ov5642_af_firmware;
	for (i = 0; i < ARRAY_SIZE(ov5642_af_firmware); ++i, ++firmware_regs) {
		retval = ov5640_write_reg(firmware_regs->u16RegAddr,
					  firmware_regs->u8Val);
		if (retval < 0)
			break;
	}
	#endif
	// temp
	......................................................................................................




[71+1]i.MX6( Boundary Devices )

1-3.Android Getting Started Guide
1.	Ubuntu Xenial(16.04) install
	cf)	Virtual box 의 vdi 이미지파일 크기는 200GB 정도 되야 함
		Note that you need a lot of space, Google says “at least 100GB of free disk space for a checkout, 150GB for a single build”.
2.	Build 환경 설정 및 전체Build
	1)	~$ sudo apt-get install openjdk-8-jdk
		~$ sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip
	
	2)	~$ sudo apt-get install uuid uuid-dev lzop gperf liblz-dev liblzo2-2 liblzo2-dev u-boot-tools flex mtd-utils android-tools-fsutils bc
	
	3)	~/$ mkdir bin
		~/$ cd bin
		~/$ mkdir repo
		~/$ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo > ~/bin/repo
		~/$ chmod a+x ~/bin/repo
		~/$ export PATH=~/bin:$PATH
		
	4)	~/$ ssh-keygen -t rsa -b 4096 -C "git@linode.boundarydevices.com" -> 입력 후 엔터
				Enter file in which to save ~ -> 엔터
				Enter passphrase ~ -> 비밀번호 입력
			~/.ssh 폴더에 id_rsa.pub 파일이 생성되며
				본 파일을 인터넷 https://boundarydevices.com/private-git-access/ 사이트에서 첨부파일로 송부 합(내 이름/수신받고자 하는 내 메일 주소 함께 입력)
				곧바로 boundary devices로 부터 메일 받았다는 확인 메일 오며, 이 후 24시간 안에 최종 git download 가능 허가 메일이 다시 옮
				이후, 아래 명령 실행 가능
				
		~/$ ssh git@linode.boundarydevices.com 본 명령에서 에러 발생하면,	cf) 본 명령 실행하지 않아도 됨
		~/$ ssh -vvv git@linode.boundarydevices.com 명령을 다시 실햄 함,	cf) 본 명령 실행하지 않아도 됨
		
	5)	~/$ export PATH=~/bin:$PATH
		~/$ mkdir myandroid
		~/$ cd myandroid
		~/myandroid$ repo init -u git://github.com/boundarydevices/android-manifest.git -b boundary-imx-n7.1.1_1.0.0-ga
		~/myandroid$ repo sync
			->	정상적으로 4시간 정도 다운 받으면 아래 문구가 나오고서 종료 됨
				boundary server에서 다운 받은 총 용량은 -> 87GBytes나 된다.
				................................................................................
				파일을 가져옵니다: 100% (44431/44431), 완료.져옵니다:  12% (5394/44431)   
				파일을 가져옵니다: 100% (63/63), 완료. 을 가져옵니다:  22% (14/63)   
				파일을 가져옵니다: 100% (1756/1756), 완료.
				파일을 가져옵니다: 100% (8053/8053), 완료.
				파일을 가져옵니다: 100% (544/544), 완료.  가져옵니다:  28% (154/544)   
				파일을 가져옵니다: 100% (15774/15774), 완료.져옵니다:  24% (3861/15774)   
				파일을 가져옵니다: 100% (19/19), 완료.
				Syncing work tree: 100% (499/499), done.  

	6)	AOSP build
		~/myandroid$ source build/envsetup.sh
		~/myandroid$ lunch		->	17입력 후 엔터(17. nitrogen6x-eng)
			... choose nitrogen6x / nit6xlite / nitrogen6sx from the list of boards
			A couple of things to note on the available targets:
			-	nitrogen6x is meant for Nitrogen6X, Nitrogen6_Max, BDSL-i.MX6, Nitrogen6_SOM, Nitrogen_SOMv2 (starting with l511)
			-	nit6xlite is only meant for Nitrogen6Lite
			-	nitrogen6sx is only meant for Nit6_SoloX (starting with l511)
			-	-eng is the development configuration with additional debugging tools, root access via console/adb and more logs
			-	-user is suited for production as it provides only limited access to the device just like a stock Android phone

		~/myandroid$ make 2>&1 | tee build.out
			A full build will take upwards of 3 hours, but incremental builds are pretty speedy if you’re changing things.

		cf) build 중 아래 에러가 발생하면 VirtualBox 메모리를 8G로 올려주고 아래 JACK SERVER 메모리 오류 해결 방법을 실행(기존 메모리 셋팅 : 3.5G)
		    FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp
		    Java heap space
		    Try increasing heap size with java option '-Xmx<size>'
		    Warning: This may have produced partial or corrupted output.
		    ninja: build stopped: subcommand failed.
		    build/core/ninja.mk:146: recipe for target 'ninja_wrapper' failed
		    make: *** [ninja_wrapper] Error 1
		cf) JACK SERVER 메모리 오류 해결 방법
		    $ cd /home/krh/myandroid
		    $ export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m"
		    $ out/host/linux-x86/bin/jack-admin kill-server
		    $ out/host/linux-x86/bin/jack-admin start-server

		정상적으로 Build가 끝나면 아래와 같은 message가 출력된 다음 마침
		[ 99% 24893/24895] host StaticLib: libaudioutils_32 (out/host/linux-x86/obj32/STATIC_LIBRARIES/libaudioutils_intermediates/libaudioutils.a)
		[ 99% 24894/24895] Export includes file:  -- out/host/linux-x86/obj32/EXECUTABLES/primitives_tests_intermediates/export_includes
		[100% 24895/24895] host Executable: primitives_tests_32 (out/host/linux-x86/obj32/EXECUTABLES/primitives_tests_intermediates/primitives_tests32)
		
		#### make completed successfully (03:45:16 (hh:mm:ss)) ####
		
		krh@krh-VirtualBox:~/myandroid$ 

	7)	In order to flash the newly created Android image into a SD Card, you can use our mksdcard.sh script:
		~/myandroid$ sudo ./device/boundary/mksdcard.sh /dev/sdX nitrogen6x
			-> cf)	sdX에서 X는 정말 X가 아닌 SD Card 위치를 뜻함, ls /dev/sd* 명령으로 확인할 수 있으며 보통 SD Card는 sdb 로 인식 됨
3.	U-Boot v2018.07 for i.MX platforms
	1)	Getting the source code
		First, clone our U-Boot git repository. This is the branch you’ll need to compile and install to work with the new kernel.
		~$ mkdir u-boot-imx6
		~$ git clone https://github.com/boundarydevices/u-boot-imx6 -b boundary-v2018.07
			->	본 명령을 실행하면 BoundaryDevices server로 부터 u-boot-imx6 관련 파일등이 u-boot-imx6 폴더에 복사 됨
			->	정상적으로 다운 받으면 아래 message가 출력 됨
				'u-boot-imx6'에 복제합니다...
				remote: Enumerating objects: 609715, done.
				remote: Total 609715 (delta 0), reused 0 (delta 0), pack-reused 609715
				오브젝트를 받는 중: 100% (609715/609715), 140.27 MiB | 9.57 MiB/s, 완료.
				델타를 알아내는 중: 100% (495536/495536), 완료.
				연결을 확인하는 중입니다... 완료.
		~$ cd u-boot-imx6
	2)	Choosing the proper defconfig
		Here you’ll need to find and make the relevant defconfig for your board.
		If you have the board running U-Boot already, you can type the following to see which defconfig you should build.
		=> printenv uboot_defconfig			->	nitrogen6_max board RS232 Console에 연결시킨 다음 본 명령을 실행시키니 아래와 같은 설정이 출력 됨
		uboot_defconfig=nitrogen6_max

		~/u-boot-imx6$ find configs/ -name "nit*defconfig"	->	Build 환경에서 본 명령 실행하니 아래와 같은 설정이 표시 됨
		configs/nitrogen6_max_dl4g_defconfig
		configs/nitrogen6_vm1g_defconfig
		configs/nitrogen6_vm_defconfig
		configs/nitrogen6_som2_s1g_defconfig
		configs/nitrogen6sx_defconfig
		configs/nitrogen6qp_som2_4g_defconfig
		configs/nitrogen6_lum_dl1_defconfig
		configs/nit6xlite_defconfig
		configs/nitrogen6q_som2_2g_defconfig
		configs/nitrogen6s_defconfig
		configs/nitrogen6qp_max_defconfig
		configs/nitrogen6_scm_defconfig
		configs/nitrogen6q_som2_1g_defconfig
		configs/nitrogen6_som2_s512m_defconfig
		configs/nitrogen8m_3g_defconfig
		configs/nit6xlite1g_defconfig
		configs/nitrogen6_max_defconfig
		configs/nitrogen6q_som2_4g_defconfig
		configs/nitrogen6dl2g_defconfig
		configs/nitrogen51_e_512m_defconfig
		configs/nitrogen51_e_rev0_256m_defconfig
		configs/nitrogen6_max_dl2g_defconfig
		configs/nitrogen8m_defconfig
		configs/nitrogen6q_defconfig
		configs/nitrogen6_som2_dl1g_defconfig
		configs/nitrogen6_max_4gr0_defconfig
		configs/nitrogen51_vm_256m_defconfig
		configs/nitrogen8m_4g_defconfig
		configs/nitrogen6s1g_defconfig
		configs/nitrogen51_e_rev0_512m_defconfig
		configs/nitrogen6q2g_defconfig
		configs/nitrogen6dl_defconfig
		configs/nitrogen51_e_256m_defconfig
		configs/nitrogen7_defconfig
		configs/nitrogen6_vm-pt1g_defconfig
		configs/nitrogen6q_fl_defconfig
		configs/nitrogen51_vm_512m_defconfig

	3)	Building for i.MX6/7
		Now compile that defconfig. For 32-bit platforms, we’ll use nitrogen6q_defconfig as an example.

		~/u-boot-imx6$ sudo apt-get install crossbuild-essential-armhf
		~/u-boot-imx6$ export ARCH=arm
		~/u-boot-imx6$ export CROSS_COMPILE=arm-linux-gnueabihf-
//		~/u-boot-imx6$ make nitrogen6q_defconfig
		~/u-boot-imx6$ make nitrogen6_max_defconfig		->	상기 2)번에서 => printenv uboot_defconfig -> uboot_defconfig=nitrogen6_max 가 표시되었기 때문에 nitrogen6_max_defconfig으로 설정함
		~/u-boot-imx6$ make -j2
		
		정상적으로 Build 하면 아래와 같은 message가 출력 됨
		  LD      u-boot
		  OBJCOPY u-boot-nodtb.bin
		  OBJCOPY u-boot.srec
		  SYM     u-boot.sym
		  COPY    u-boot.bin
		  CFGS    u-boot.cfgout
		  MKIMAGE u-boot.imx
		  CFGCHK  u-boot.cfg
		
		#### make completed successfully (25 seconds) ####

	4)	Flashing procedure
		가)	아래 방법은 이미 u-boot-imx6 이미지가 Board 상에 저장되어 있는 상태에서 script를 이용하여 SD Card에 저장되어 있는 신규 u-boot-imx6를 Upgrade 하는 것임
		You can use the copy_upgrade.sh script to copy the bootable binary and the upgrade script to the root folder of your media (SD Card / USB / SATA drive).
		~/u-boot-imx6/$ ./copy_upgrade.sh <mount_path>/		->	SD Card가 복사하고자 하는 target이라면 ex) ~/u-boot-imx6/$ ./copy_upgrade.sh /dev/sdb/
		
		Plug your media to the platform, power up the board and interrupt u-boot to run the commands below (via the serial terminal).
		Hit any key to stop autoboot:  0
		=> run upgradeu
		This will run the upgrade.scr script and look for a file u-boot.${uboot_defconfig} and burn it.		->	{uboot_defconfig}은 상기 2)번 uboot_defconfig=nitrogen6_max을 뜻함

		At this point it might be worth while to clear your environment variables after the first reboot.
		This will set you up with the default environment variables and no more.
		Hit any key to stop autoboot:  0 
		=> env default -a
		=> savee
		Then as a final note, if you’ve somehow managed to brick your board through this process and need help. Well, we already wrote a blog post here about that topic.

		나)	Loading u-boot.bin unsing JTAG on imx6q-sabresd board
		For loading u-boot using JTAG, follow the below steps--
		1. Download DDR stress test tool v.2.52 from NXP website.
		2. Boot your board into serial mode, by turning all boot switches off
		3. Now connect USB cable from USB OTG port to desktop/Laptop on which you will be running DDR stress test tool.
		4. For information on using DDR stress test tool refer to documentation.
		5. Once board is detected in DDR stress test tool, use appropriate inc script in the tool and click on download. After successful downloading of script , DDR will be initialised.
		6. Now connect JTAG cable , and load u-boot.bin image using load_image command from JTAG to appropriate address, for imx6q sabresd board it is 0x17800000.
		7. Once image is downloaded successfully, you can resume from same address using resume command like
		resume 0x178000000
		 
		For custom boards, you can use xls provided by NXP to generate inc file for custom board which can be used for loading into DDR stress test tool to initalise DDR.
		I am using Arm olimex JTAG debugger for debugging.
		
		다)	How to Use Trace32 to Run U-boot in the i.MX6Q SABRE Platform
		The document in attachment describes how to learn System Boot Flow of Linux by code using Trace32.
		The hardware platform is i.MX6Q SABRE and the software in PC is Trace32.
		 
		Contents
		1. Introduction
		2. Hardware Connection
		3. Serial Connection Setup
		4. U-boot Directory Setup
		5. Trace32 Installation & U-boot Debugging
		Original Attachment has been moved to: attach_onecore_eboot.cmm.zip
		
		라)	
		JTAG(Joint Test Action Group)
		 - 임베디드 시스템 개발 초기에는 부트로더 자체가 없으므로 이를 임베디드 시스템 플래시 메모리에 넣어주기 위한 방법이 필요 -> JTAG 인터페이스 사용
		 - JTAG은 하드웨어 디버깅을 목적으로 프로세서의 모든 외부 핀에 대해 데이터를 넣거나 외부 핀의 데이터를 읽어 들일 수 있는 기능을 제공 
		 - 보통은 5개의 신호를 사용하며 , 이중 TDI(test data in), TDO(test data out) , TCK(test clock input)이 주요 신호이다, 임베디드 시스템 개발 초기에 하드웨어 디버깅을 하거나 부트로더 전송에 주로 사용.
		
		JTAG 사용법
		 - 먼저 임베디드 시스템의 JTAG 커넥터와 호스트  PC의 프린터 포트를 JTAG  시리얼 케이블로 연결
		 - 다음 호스트 PC에서 부트로더 전송 기능을 하는 명령어에 전송할 부트로더 파일명을 입력
		ex) Jfashs-Xscale u-boot.bin  여기서 Jflash-Xscale이 JTAG를 통한 부트로더 전송 명령, u-boot.bin 이 전송 할 부트로더 파일명이다.




1-2.Permission denied 에러 해결 방법
cf) 아래 명령 실행하면 부팅 이후 Boundary device terminal window 에서 ifconfig 명령도 Permission denied 에러 발생하던 것이 사라짐
-> U-Boot:
=> setenv selinux permissive
=> saveenv


1-1.Request of datasheet
I have purchased your product and please send me the data such as the schematic soon.
1. Nit6Q_MAX(NITROGEN6-MAX_REV4 03-21-2016)
   -> Request : Schematic & 3D STEP
2. Nit6X_5MP_MIPI
   -> Request : Schematic
3. Nit6X_5MP
   -> Request : Schematic
4. Nit6X_ANDROID
   -> Request : Schematic
5. DB_SABER_LITE_DISPLAY 800X480(Nit6X_800x480 Interface board)
   -> Request : Schematic
*** All of the above items are required.
No matter how long I wait, I can not reply and send it again.


1.	Android 7.x (Nougat) -> myandroid(System development) 용량 -> 87GBytes
		Android Getting Started Guide -> boundary server에서 아래 명령으로 다운 받은 총 용량은 -> 87GBytes나 된다.
		cf)	~/myandroid$ repo init -u git://github.com/boundarydevices/android-manifest.git -b boundary-imx-n7.1.1_1.0.0-ga
				~/myandroid$ repo sync
				->	정상적으로 4시간 정도 다운 받으면 아래 문구가 나오고서 종료 됨
						................................................................................
						파일을 가져옵니다: 100% (44431/44431), 완료.져옵니다:  12% (5394/44431)   
						파일을 가져옵니다: 100% (63/63), 완료. 을 가져옵니다:  22% (14/63)   
						파일을 가져옵니다: 100% (1756/1756), 완료.
						파일을 가져옵니다: 100% (8053/8053), 완료.
						파일을 가져옵니다: 100% (544/544), 완료.  가져옵니다:  28% (154/544)   
						파일을 가져옵니다: 100% (15774/15774), 완료.져옵니다:  24% (3861/15774)   
						파일을 가져옵니다: 100% (19/19), 완료.
						Syncing work tree: 100% (499/499), done.  


2-1.dd 명령을 사용해서 SD card 이미지 내용 수정
	1)	SD CARD Reader를 사용해서 읽어 들임(ex, /dev/sdb 등이 생성)
	2)	자동으로 mounting된 폴더(ex, /media/krh/root)에 test.txt 파일 복사 
	3)	$ sudo dd if=/dev/sdb of=/media/krh/sdcard_backup.img bs=1M					->	본 명령 사용해서 /dev/sdb 에 있는 파티션 등이 포함된 이미지를 sdcard_backup.img 파일로 백업
	4)	$ fdisk -l sdcard_backup.img																			  ->	본 명령을 사용해서 제대로 Backup 되었는지 확인
	5)	이제 만들어진 이미지를 SD card에 dd로 write를 한 후에 확인을 해보아도 되나
			(ex,
			$ sudo umount /media/krh/boot
			$ sudo umount /media/krh/recovery
			$ sudo umount /media/krh/system
			$	sudo dd if=/media/krh/sdcard_backup.img of=/dev/sdb bs=1M
			)

			loop device로 마운트 하여 확인할 수 있다.
			$ sudo losetup -Pf --show sdcard_backup.img
				/dev/loop0																												->	바로 위 명령을 실행하면 본 명령이 표시됨, /dev에 loop0 디바이스가 생성된 것임
			$ ls -l /dev/loop0*
				brw-rw---- 1 root disk   7, 0 10월 25 18:32 /dev/loop0
				brw-rw---- 1 root disk 259, 0 10월 25 18:32 /dev/loop0p1
				brw-rw---- 1 root disk 259, 1 10월 25 18:32 /dev/loop0p2

				위와 같이 하면 loop 디바이스를 이용하여 이미지를 attach 할 수 있다. 즉, ls 를 해보면 위처럼 loop0으로 시작하는 디바이스가 생성된다. 
				loop0은 이미지, loop0p1은 첫번째 파티션, loop0p2는 두번째 파티션이다.

				첫번째 파티션을 마운트 해서 확인해 본다.

				$ sudo mount -t ext4 /dev/loop0p1 /media/krh/test
				$ ls /media/krh/test/
					lost+found  test.txt
				$ cat test/test.txt
					Hello, World!

				아까 복사한 test.txt 파일이 정상적으로 들어가 있음.


2.	U-Boot upgrade
Flashing procedure
	Now you’ll have a u-boot.imx file compiled. Rename the u-boot.imx file to u-boot.{uboot_defconfig} (see below), then move that and the 6x_upgrade script to the root folder of your media(SD Card / USB / SATA drive).
	1.	1)	https://boundarydevices.com/u-boot-v2017-03/ 에서 u-boot.nitrogen6_max 파일을 다운 받음
			~/u-boot-imx6/$ cp u-boot.imx /dev/sdd1/u-boot.nitrogen6q
Gary Bisson
October 19, 2016 at 8:14 am
Hi,
The message is clear, it can’t mount the partition since it’s ext4 and not ext2. So please use one of the following options:
1- use the USB recovery procedure to boot a proper U-Boot first
https://boundarydevice.wpengine.com/unbricking-nitrogen6x-sabre-lite-i-mx6-board/
2- or copy 6x_upgrade and u-boot. to a FAT32 device (either USB stick or sdcard)
Regards,
Gary

Hi all,
I’m trying to unbrick my i.MX6q Sabre Lite board.
Connecting the board to the host PC with by USB, and turning the switches to USB OTG on the board, then powering up or reseting the board.
But when entring the command : lsub
I have no entry named Freescale semiconductor Inc !!!
How can I force the board to run up on USB OTG recovery mode ?
Thanks in advance for your answers
Best regards

=> setenv uboot_defconfig nitrogen6_max
=> run upgradeu
AHCI 0001.0300 32 slots 1 ports 3 Gbps 0x1 impl SATA mode
flags: ncq stag pm led clo only pmp pio slum part
No port device detected!
** Bad device size - sata 0 **
AHCI 0001.0300 32 slots 1 ports 3 Gbps 0x1 impl SATA mode
flags: ncq stag pm led clo only pmp pio slum part
No port device detected!
** Bad device sata 1 **
switch to partitions #0, OK
mmc0 is current device
3626 bytes read in 11 ms (321.3 KiB/s)
## Executing script at 10008000
SF: Detected sst25vf016b with page size 256 Bytes, erase size 4 KiB, total 2 MiB
probed SPI ROM
check U-Boot
** File not found u-boot.nitrogen6_max **
File u-boot.nitrogen6_max not found on SD card
timeout irqstat=10000
timeout irqstat=10000
switch to partitions #0, OK
mmc1(part 0) is current device
** No partition table - mmc 1 **
USB is stopped. Please issue 'usb start' first.
** Bad device usb 0 **
USB is stopped. Please issue 'usb start' first.
** Bad device usb 1 **
=>
	2.	cp u-boot.nitrogen6_max /media/krh/boot/
	상기, "2-1.dd 명령을 사용해서 SD card 이미지 내용 수정" 방법을 참고해서
			/media/krh/boot/에 6x_upgrade 파일과 u-boot.nitrogen6_max 파일 복사
			cf)	6x_upgrade 파일은 이미 /media/krh/boot/에 있기 때문에 실행하지 않아도 됨
	3.	보드에 SD card 뽑고서 재부팅 -> 부팅 카운트 동작에서 엔터키를 쳐서 부팅 모드로 들어감
			U-Boot > setenv uboot_defconfig nitrogen6_max
			U-Boot > run upgradeu
			U-Boot > env default -a
			U-Boot > savee


  cf) 상기 3항 실행 전/후 Boot 설정 사항
U-Boot 2015.07-15072-g45cfc85 (Jan 28 2016 - 17:41:33 -0700), Build: jenkins-uboot_v2015.07-30

CPU:   Freescale i.MX6Q rev1.2 996 MHz (running at 792 MHz)
Reset cause: POR
Board: Nitrogen6_max
I2C:   ready
DRAM:  3.8 GiB
MMC:   FSL_SDHC: 0, FSL_SDHC: 1
SF: Detected SST25VF016B with page size 256 Bytes, erase size 4 KiB, total 2 MiB
auto-detected panel CLAA-WVGA
Display: lcd:CLAA-WVGA (800x480)
In:    serial
Out:   serial
Err:   serial
Net:   using phy at 6
FEC [PRIME], usb_ether
Error: usb_ether address not set.

Hit any key to stop autoboot:  0
=> print
baudrate=115200
board=nitrogen6_max
bootcmd=for dtype in ${bootdevs}; do if itest.s "xusb" == "x${dtype}" ; then usb start ;fi; for disk in 0 1 ; do ${dtype} dev ${disk} ;load ${dtype} ${disk}:1 10008000 /6x_bootscript&& source 10008000 ; done ; done; setenv stdout serial,vga ; echo ; echo 6x_bootscript not found ; echo ; echo serial console at 115200, 8N1 ; echo ; echo details at http://boundarydevices.com/6q_bootscript ; setenv stdout serial; if sata init && sata dev 0; then setenv stdout serial,vga; echo expose SATA drive over USB; ums 0 sata 0;fi ;for disk in 1 0 ; do if mmc dev ${disk} ; then setenv stdout serial,vga; echo expose MMC ${disk} over USB; ums 0 mmc ${disk}; fi ;done;
bootdelay=3
bootdevs=mmc sata usb
clearenv=if sf probe || sf probe || sf probe 1 ; then sf erase 0xc0000 0x2000 && echo restored environment to factory default ; fi
cmd_hdmi=fdt set fb_hdmi status disabled
cmd_lcd=fdt set fb_lcd status okay;fdt set fb_lcd interface_pix_fmt RGB666;fdt set lcd default_ifmt RGB666;fdt set fb_lcd mode_str CLAA-WVGA;
cmd_lvds=fdt set fb_lvds status disabled
cmd_lvds2=fdt set fb_lvds2 status disabled
console=ttymxc1
cpu=6Q
ethact=FEC
ethaddr=00:19:b8:03:96:64
ethprime=FEC
fdt_addr=0x13000000
fdt_high=0xffffffff
initrd_high=0xffffffff
loadaddr=0x12000000
loadsplash=if sf probe ; then sf read ${splashimage} c2000 ${splashsize} ; fi
uboot_defconfig=nitrogen6_max
upgradeu=for dtype in ${bootdevs}; do for disk in 0 1 ; do ${dtype} dev ${disk} ;load ${dtype} ${disk}:1 10008000 /6x_upgrade && source 10008000 ; done ; done
usbnet_devaddr=00:19:b8:00:00:02
usbnet_hostaddr=00:19:b8:00:00:01
usbrecover=setenv ethact usb_ether; setenv ipaddr 10.0.0.2; setenv netmask 255.255.255.0; setenv serverip 10.0.0.1; setenv bootargs console=ttymxc1,115200; tftpboot 10800000 10.0.0.1:uImage-${board}-recovery&& tftpboot 12800000 10.0.0.1:uramdisk-${board}-recovery.img && bootm 10800000 12800000

Environment size: 1963/8188 bytes
=> setenv uboot_defconfig nitrogen6_max
=> run upgradeu
switch to partitions #0, OK
mmc0 is current device
3626 bytes read in 32 ms (110.4 KiB/s)
## Executing script at 10008000
SF: Detected SST25VF016B with page size 256 Bytes, erase size 4 KiB, total 2 MiB
probed SPI ROM
check U-Boot
0 bytes read in 79 ms (0 Bytes/s)
read 0 bytes from SD card
device 0 offset 0x400, size 0x0
SF: 0 bytes @ 0x400 Read: ERROR
Error reading boot loader from EEPROM
switch to partitions #0, OK
mmc1(part 0) is current device
** No partition table - mmc 1 **
AHCI 0001.0300 32 slots 1 ports 3 Gbps 0x1 impl SATA mode
flags: ncq stag pm led clo only pmp pio slum part
No port device detected!
** Bad device size - sata 0 **

SATA device 1: unknown device
** Bad device sata 1 **
USB is stopped. Please issue 'usb start' first.
** Bad device usb 0 **
USB is stopped. Please issue 'usb start' first.
** Bad device usb 1 **
=> print
a_qspi1=12000000
a_qspi2=12400000
a_script=12000000
a_uImage1=12000400
a_uImage2=12400400
baudrate=115200
board=nitrogen6_max
bootcmd=for dtype in ${bootdevs}; do if itest.s "xusb" == "x${dtype}" ; then usb start ;fi; for disk in 0 1 ; do ${dtype} dev ${disk} ;load ${dtype} ${disk}:1 10008000 /6x_bootscript&& source 10008000 ; done ; done; setenv stdout serial,vga ; echo ; echo 6x_bootscript not found ; echo ; echo serial console at 115200, 8N1 ; echo ; echo details at http://boundarydevices.com/6q_bootscript ; setenv stdout serial; if sata init && sata dev 0; then setenv stdout serial,vga; echo expose SATA drive over USB; ums 0 sata 0;fi ;for disk in 1 0 ; do if mmc dev ${disk} ; then setenv stdout serial,vga; echo expose MMC ${disk} over USB; ums 0 mmc ${disk}; fi ;done;
bootdelay=3
bootdevs=mmc sata usb
clearenv=if sf probe || sf probe || sf probe 1 ; then sf erase 0xc0000 0x2000 && echo restored environment to factory default ; fi
cmd_hdmi=fdt set fb_hdmi status disabled
cmd_lcd=fdt set fb_lcd status okay;fdt set fb_lcd interface_pix_fmt RGB666;fdt set lcd default_ifmt RGB666;fdt set fb_lcd mode_str CLAA-WVGA;
cmd_lvds=fdt set fb_lvds status disabled
cmd_lvds2=fdt set fb_lvds2 status disabled
console=ttymxc1
cpu=6Q
ethact=FEC
ethaddr=00:19:b8:03:96:64
ethprime=FEC
fdt_addr=0x13000000
fdt_high=0xffffffff
filesize=0
initrd_high=0xffffffff
loadaddr=0x12000000
loadsplash=if sf probe ; then sf read ${splashimage} c2000 ${splashsize} ; fi
stdout=serial,vga
uboot_defconfig=nitrogen6_max
upgradeu=for dtype in ${bootdevs}; do for disk in 0 1 ; do ${dtype} dev ${disk} ;load ${dtype} ${disk}:1 10008000 /6x_upgrade && source 10008000 ; done ; done
usbnet_devaddr=00:19:b8:00:00:02
usbnet_hostaddr=00:19:b8:00:00:01
usbrecover=setenv ethact usb_ether; setenv ipaddr 10.0.0.2; setenv netmask 255.255.255.0; setenv serverip 10.0.0.1; setenv bootargs console=ttymxc1,115200; tftpboot 10800000 10.0.0.1:uImage-${board}-recovery&& tftpboot 12800000 10.0.0.1:uramdisk-${board}-recovery.img && bootm 10800000 12800000

Environment size: 2096/8188 bytes
=>

	cf)	6x_upgrade
			The above procedure will flash the U-Boot from the SD card to the NOR flash. 
			The fact that you always are in download mode means that you erased the NOR flash at some point.

	cf)	How can I read SD card on ubuntu? [closed]
			check your partitions inside
			# cat /proc/partitions

			If you have there something like
			# cat /proc/partitions | grep sdb
			   8        0  234431064 sdb
			   8        1     524288 sdb1

			cf)	# mount -> mount 되어 있는 현황을 알 수 있다. ex) sdb1이 어떤 폴더와 연결되어 있는지 알 수 있음

			You can try to mount sdb1
			# sudo mkdir /media/sdb1
			# chmod 777 /media/sdb1
			# sudo mount /dev/sdb1 /media/sdb1


3.	mmc0 / mmc1
Sorry but I don’t understand the issue. Do you want to flash the image in SDCard or eMMC?
 In U-Boot, it always goes like this:
? mmc 0 == sdcard
? mmc 1 == emmc

Both options are working by default, you can see in the boot_targets variable that mmc0 has the 1st priority over mmc1.


4.  open camera / opencamera in boundary devices
1)  opencamerasrc_v_1_43_3 -> net.sourceforge.opencamera.test(androidTest) -> MainActivityTest
	-> public void testTakePhotoHDRPhotoStamp() throws InterruptedException
	-> public void testTakePhotoExpo() throws InterruptedException
		본 method를 실행하면 화면이 점점 밝아지는 기능이 구현 됨
		하지만 화면이 점점 밝아지는 것은 노출계수를 수동으로 조절해서 밝아지는 것이 아닌 아래 2)에서 설명하는 원인으로 밝아지는 것임
		본 경우는 촬영하면서 밝아지는 것은 아니지만 ov5640_init_mode 함수가 자동으로 반복 동작하면서 화면이 밝아짐
    cf) 테스트 실행 방법 : Android Studio -> 상단 testTakePhotoHDRPhotoStamp 함수 선택 -> 오른쪽 마우스 -> Run 'testTakePhotoHDRPhotoStamp()'
		cf) 이렇게 일부 기능만 실행시키면 halt되는 에러 발생할 경우 있으며
			이때는 정상적으로 open camera 전체 기능으로 실행 시킨 다음 상기 일부 기능을 실행시키면 halt 에러 제거 됨
    
2)	open camera app 실행시에만 ov5640_mipi camera로 셋팅 후 촬영 버튼을 누를 때 마다 시 화면이 점점 밝아지는 현상 나타남
	이 경우 Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\ov5640_mipi.c 파일 내부의 ov5640_init_mode 함수가 촬영 버튼 누를 때 마다 실행됨
	
	cf)	open camera app & ov5642 camera로 촬영 시에는 나타나지 않음
	cf)	기본 camera app에서는 ov5640_mipi, ov5642 카메라 모두 촬영해도 이런 현상 일어나지 않음
		하지만, 본 경우에도 Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\ov5640_mipi.c 파일 내부의 ov5640_init_mode 함수가 촬영 버튼 누를 때 마다 실행됨
	->	최종 결론
		본 현상이 일어나는 원인은 ov5640_init_mode -> ov5640_change_mode_exposure_calc가 실행되면서 발생하는 것으로
		static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,enum ov5640_mode mode, enum ov5640_mode orig_mode) 매개인수 중
		mode 값이 제대로 대입되지 않아서 발생하는 것임
		cf)	카메라 해상도를 1280x720 or 1024x768 등으로 설정하면 본 현상 일어나지 않고 2592x1944 로 설정한 경우만 본 현상 일어남

Use Camera2 API - If selected, this enables support for the Camera2 API that was introduced in Android 5. 
Turning this option on or off will cause Open Camera to restart.
This enables some new features (including manual ISO/exposure, manual focus, HDR, exposure bracketing).
Note that not all Android 5 devices have full support for the Camera2 API 
(Open Camera will only show this option if all cameras report either "LIMITED" or "FULL" support for the API; "LEGACY" devices are not supported). 
Also note that even if devices support Camera2 API, many devices have extremely poor support, 
leading to bugs such as poor flash behaviour, or video recording not working. 
These are not necessarily bugs in Open Camera, but problems with manufacturer support for Camera2 API. If you have problems with flash behaviour, 
try the "Use alternative flash method" setting under "Photo Settings". Please see here for more details on device compatibility.

hardware/imx/mx6/libcamera2/

Alex
July 30, 2013 at 3:02 am
Hi
Regrading Camera Hal version 2 in Android 4.2.2 , how we can set parameters like white balance , Effects etc.
Preview ,Capture[Still] , Video Recording is fine
Board : Sabre Lite , Camera Interface : MIPI CSI2 , Camera Hal :hardware/imx/mx6/libcamera2
Please let me know your valuable inputs and thoughts , Experience

Post
Author
Reply

ericn
July 30, 2013 at 8:27 am
Hi Alex,
We’ll be doing auto-focus for the OV5640 very soon, but I’m not sure about the other parameters.
If you’re in a hurry and want professional help, the folks at e-con Systems have all of this for embedded Linux. I’m not sure about Android bindings though.

3)	기존 Freescale i.mx6 카메라 device driver 단 중 중요 사항
->	~\i.mx6\software\Android\###중요소스 에 저장되어 있음
->	~\IP\Ubuntu_backup\Ubuntu-amd64 에 저장되어 있음
가)	Y:\root\myandroid\hardware\imx\mx6\libcamera2\Ov5640Mipi.cpp
나)	Y:\root\myandroid\kernel_imx\drivers\media\video\mxc\capture\ov5640_mipi.c


5-1.AOSP build(Total build)
Initialize the environment with the envsetup.sh script.
~/myandroid$ source build/envsetup.sh

cf) This script gives you access to a new set of commands targeted for AOSP development.
    Below are detailed the most useful ones (in our opinion).
- croot: Changes directory to the top of the tree (useful when you get lost in frameworks/base)
- mm: Builds all of the modules in the current directory
- mmm: Builds all of the modules in the supplied directories
- cgrep: Greps on all local C/C++ files
- jgrep: Greps on all local Java files
- resgrep: Greps on all local res/*.xml files                     // */

The next step is to choose the target board and build:
~/myandroid$ lunch					// 17입력하고 Enter key 누름
... choose nitrogen6x / nit6xlite / nitrogen6sx from the list of boards
A couple of things to note on the available targets:
- nitrogen6x is meant for Nitrogen6X, Nitrogen6_Max, BDSL-i.MX6, Nitrogen6_SOM, Nitrogen_SOMv2 (starting with l511)
- nit6xlite is only meant for Nitrogen6Lite
- nitrogen6sx is only meant for Nit6_SoloX (starting with l511)
- eng is the development configuration with additional debugging tools, root access via console/adb and more logs
- user is suited for production as it provides only limited access to the device just like a stock Android phone

~/myandroid$ make 2>&1 | tee build.out
A full build will take upwards of 3 hours, but incremental builds are pretty speedy if you’re changing things.
cf) build 중 아래 에러가 발생하면 VirtualBox 메모리를 8G로 올려주고 아래 JACK SERVER 메모리 오류 해결 방법을 실행(기존 메모리 셋팅 : 3.5G)
    FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp
    Java heap space
    Try increasing heap size with java option '-Xmx<size>'
    Warning: This may have produced partial or corrupted output.
    ninja: build stopped: subcommand failed.
    build/core/ninja.mk:146: recipe for target 'ninja_wrapper' failed
    make: *** [ninja_wrapper] Error 1
cf) JACK SERVER 메모리 오류 해결 방법
    $ cd /home/krh/myandroid
    $ export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4096m"
    $ out/host/linux-x86/bin/jack-admin kill-server
    $ out/host/linux-x86/bin/jack-admin start-server


In order to flash the newly created Android image into a SD Card, you can use our mksdcard.sh script:
~/myandroid$ sudo ./device/boundary/mksdcard.sh /dev/sdX nitrogen6x

If you wish to create an .img file, you can use our mkimage.sh script at your own risk (using loop devices, please check it out):
~/myandroid$ sudo ./device/boundary/mkimage.sh \
        <name_of_image> <size_in_MiB> <target_name>

For instance, here is our we create the .img.gz file for Nitrogen6sx:
~/myandroid$ sudo ./device/boundary/mkimage.sh \
        m601-nitrogen6sx-20160726.img 3600 nitrogen6sx
~/myandroid$ gzip m601-nitrogen6sx-20160726.img


5.  Kernel build
cf)	커널 옵션을 변경하고 싶으면 아래 명령 실행해서 수정 한 다음 아래 "6.  Boot image" 명령을 실행시켜서 build 하자
	$ cd ~/myandroid
	~/myandroid$ rm kernel_imx/.config			->	본 명령은 실행하지 말자 실행하면 수정한 커널 옵션이 모두 지워짐
	$ source build/envsetup.sh
	$ lunch
	~/myandroid$ export CROSS_COMPILE=$PWD/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-
	~/myandroid$ export ARCH=arm
	~/myandroid$ cd kernel_imx
	$ make menuconfig
cf)	본 명령(export CROSS_COMPILE=$PWD/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin/arm-eabi-)은 사용하지 말자
	이유, arm-eabi-4.8 버전 문제(6.  Boot image 에서는 4.9버전 사용하는 것 같음)로 인해서 에러 발생하는 것 같음
	->	kernel option 변경의 경우도 그냥 "6.  Boot image" 명령을 사용하자
cf)	본 명령은 정말 kernel option(make menuconfig)과 관련된 사항 만 build 시켜주는 명령이며
	/myandroid/kernel_imx/drivers/media/platform/mxc/capture 등의 kernel_imx 내부의 함수를 build 시켜줄려면 아래 "6.  Boot image" 명령을 실행시켜줘야 함

Modifications made to the kernel are not automatically picked up if it has been built once already. 
In order to force the build of the kernel, you need to delete the kernel .config file. 
Note that the kernel Makefile will detect which objects need to be re-compile.
~/myandroid$ rm kernel_imx/.config

If you wish to re-build the kernel and only the kernel, you can set the toolchain path and build it as follows:
* For Lollipop and earlier versions:
~/myandroid$ export CROSS_COMPILE=$PWD/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
~/myandroid$ export ARCH=arm
~/myandroid$ cd kernel_imx
~/myandroid/kernel_imx$ make nitrogen6x_defconfig
~/myandroid/kernel_imx$ make uImage LOADADDR=0x10008000 dtbs -j8
~/myandroid/kernel_imx$ adb push arch/arm/boot/uImage /boot/
~/myandroid/kernel_imx$ adb push arch/arm/boot/dts/imx6q-nitrogen6x.dtb /boot/

* For Marshmallow and newer versions:
~/myandroid$ export CROSS_COMPILE=$PWD/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin/arm-eabi-
~/myandroid$ export ARCH=arm
~/myandroid$ cd kernel_imx
~/myandroid/kernel_imx$ make boundary_defconfig
~/myandroid/kernel_imx$ make zImage dtbs -j8
~/myandroid/kernel_imx$ adb push arch/arm/boot/zImage /boot/
~/myandroid/kernel_imx$ adb push arch/arm/boot/dts/imx6q-nitrogen6x.dtb /boot/

cf) make zImage dtbs -j8 명령으로 compile 도중 "Cannot use CONFIG_CC_STACKPROTECTOR_STRONG: -fstack-protector-strong not supported by compiler" 에러 발생 시 해결 방법
$ scripts/config --disable CC_STACKPROTECTOR_STRONG
명령을 실행하면 됨
  cf) Gary Bisson
  August 11, 2016 at 2:41 pm
  Hi Ed,
  Here is the explanation of this option:
  https://lwn.net/Articles/584225/
  We added the CONFIG_CC_STACKPROTECTOR_STRONG to our config. This stack protector option is available starting with GCC4.9, I didn’t realize that Trusty was still using 4.8.
  For now, please remove this STACKPROTECTOR option from the defconfig. In the meantime I’ll circle back with the time to know whether or not we remove it.
  Also, if you use the latest Ubuntu image, it requires to build the the galcore driver separately as a module to match the latest libraries available.
  https://github.com/Freescale/kernel-module-imx-gpu-viv
  Regards,
  Gary


6.  Boot image
If your latest modifications only affect kernel, ramdisk or bootscript, 
you do not need to start a full build but use the bootimage target instead.
//~/myandroid$ make bootimage
cf)	전체 소스에서 일부분만 다시 빌드(X:\root\myandroid\kernel_imx 내부의 kernel image Rebuild)
# Boot image for SABRE-SD board
$ cd ~/myandroid
$ source build/envsetup.sh
$ lunch
$ make bootimage			->	boot.img 이미지 내부에 kernel image도 포함되어 있으며
								본, 명령을 실행하면 X:\root\myandroid\out\target\product\sabresd_6dq\ 폴더 내부의 boot.img & uImage 이미지를 rebuild 시킴
###							->	cf)	본 명령을 실행해도 Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture 내부 파일 등의 수정 사항을 rebuild 하지 못하는 경우
###								아래와 같이 명령을 실행시키면 제대로 rebuild 시켜 줌
###								$ cd ~/myandroid
###								$ source build/envsetup.sh
###								$ lunch			// 17입력하고 Enter key 누름
###								~/myandroid$ export CROSS_COMPILE=$PWD/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-
###								~/myandroid$ export ARCH=arm
###								~/myandroid$ cd kernel_imx
###								~/myandroid/kernel_imx$ make clean			// 본 명령을 수행해도 Y:\myandroid\kernel_imx\.config 파일이 지워지지는 않음(파일 내용 유지)
																			// 본 명령을 수행하면 Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture 폴더 내부 object files 등이 모두 지워짐(단, 소스 코드는 지워지지 않음)
###								~/myandroid/kernel_ims$ cd ..
###								~/myandroid$ make bootimage
								cf)	make clean
									@echo  'Cleaning targets:'
									@echo  '  clean		  - Remove most generated files but keep the config and'
									@echo  '                    enough build support to build external modules'
									@echo  '  mrproper	  - Remove all generated files + config + various backup files'
									@echo  '  distclean	  - mrproper + remove editor backup and patch files'

cf)1  $ make bootimage
   2  - repackage boot image without rebuilding dependencies
   3  $ make bootimage-nodeps

This will only update the components under the boot/ output folder which then can be updated as follows as an example:
~/myandroid$ adb push $OUT/boot/imx6q-nitrogen6x.dtb /boot
~/myandroid$ adb push $OUT/boot/zImage /boot
~/myandroid$ adb push $OUT/boot/6x_bootscript /boot
~/myandroid$ adb push $OUT/boot/uramdisk.img /boot
cf)	$OUT -> Y:\myandroid\out\target\product\nitrogen6x

Those modifications require a reboot in order to take effect:
~/myandroid$ adb reboot


7.  Specific package build
$ cd ~/myandroid
$ source build/envsetup.sh
$ lunch				// 17입력하고 Enter key 누름

If on the other hand the modification only affect a specific package, you can rebuild only that latter by issuing:
~/myandroid$ mmm hardware/libhardware_legacy/
ex)									 mmm ./hardware/imx/libcamera3							->	hardware 수정 시 실행
									 mmm ./frameworks/av/services/camera/libcameraservice	->	frameworks 수정 시 실행

You can even force the rebuild in case the Android.mk doesn’t see any obvious change that require re-building:
~/myandroid$ mmm -B hardware/libhardware_legacy/

	마지막으로
	[taehyo@build-desktop:/android]# make snod												->	이곳에서도 본 명령을 꼭 수행해줘야지 수정 사항이 적용 된다.


###8.	Nitrogen6-MAX, Camera setParameters change routine

//Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1
// LCD Window 일부분을 눌러서 AutoFocus 기능이 수행되도록 한 경우 routine
08-09 03:07:51.579 2081-2081/net.sourceforge.opencamera D/CameraController1: autoFocus
08-09 03:07:51.579 237-513/? V/Camera2Client: autoFocus: Camera 0
08-09 03:07:51.607 237-2161/? V/Camera3-Device: insertTriggers: tag = 65545
    insertTriggers: Mixed in trigger afTrigger, value 2
    insertTriggers: tag = 65569
    insertTriggers: parent->mDeviceVersion = 768
    insertTriggers: Mixed in trigger afTriggerId, value 4
    prepareHalRequests: Request settings are NEW
    prepareHalRequests: Request (frame num 23068) had AF trigger 0x2
08-09 03:07:51.607 237-345/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000007, frameNumber = 23066, burstId = 0, partialResultCount = 0
08-09 03:07:51.608 237-345/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 23066 from InFlightMap
08-09 03:07:51.610 237-345/? V/Camera3-Device: Camera 0: notifyShutter: Shutter fired for frame 23067 (id 10000007) at 2589580082308
08-09 03:07:51.610 237-345/? V/Camera2Client: notifyShutter: Shutter notification for request id 10000007 at time 2589580082308
08-09 03:07:51.610 237-345/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000007, frameNumber = 23067, burstId = 0, partialResultCount = 0
    insertResultLocked: result requestId = 10000007, frameNumber = 23067, burstId = 0
08-09 03:07:51.623 237-2161/? V/Camera3-Device: prepareHalRequests: registered in flight requestId = 10000009, frameNumber = 23068, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-09 03:07:51.623 237-2161/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:23068 Settings:0xa4c7e000
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-09 03:07:51.623 237-513/? V/Camera3-Device: triggerAutofocus: Triggering autofocus, id 5
08-09 03:07:51.624 2081-2081/net.sourceforge.opencamera D/Preview: autofocus started, count now: 2
08-09 03:07:51.679 237-2161/? V/Camera3-Device: insertTriggers: tag = 65545
    insertTriggers: Mixed in trigger afTrigger, value 1
    insertTriggers: tag = 65569
08-09 03:07:51.680 237-2161/? V/Camera3-Device: insertTriggers: parent->mDeviceVersion = 768
    insertTriggers: Mixed in trigger afTriggerId, value 5
    prepareHalRequests: Request settings are NEW
    prepareHalRequests: Request (frame num 23069) had AF trigger 0x1
08-09 03:07:51.681 237-345/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000007, frameNumber = 23067, burstId = 0, partialResultCount = 0
08-09 03:07:51.682 237-345/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 23067 from InFlightMap
08-09 03:07:51.682 237-345/? V/FslCameraHAL: processSettings: AF region: x 888 y 963
08-09 03:07:51.685 237-345/? V/FslCameraHAL: trigger: 2 afMode 1 afTriggerId 4
08-09 03:07:51.685 237-345/? V/Camera3-Device: Camera 0: notifyShutter: Shutter fired for frame 23068 (id 10000009) at 2589653566641
08-09 03:07:51.686 237-345/? V/Camera2Client: notifyShutter: Shutter notification for request id 10000009 at time 2589653566641
08-09 03:07:51.686 237-345/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 23068, burstId = 0, partialResultCount = 0
    insertResultLocked: result requestId = 10000009, frameNumber = 23068, burstId = 0
08-09 03:07:51.686 237-2162/? V/Camera2Client: notifyAutoFocus: Autofocus state now 0, last trigger 4
08-09 03:07:51.692 237-2161/? V/Camera3-Device: prepareHalRequests: registered in flight requestId = 10000009, frameNumber = 23069, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-09 03:07:51.692 237-2161/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:23069 Settings:0xa4c7e000
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-09 03:07:51.752 237-2161/? V/Camera3-Device: prepareHalRequests: Request settings are NEW
08-09 03:07:51.753 237-345/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 23068, burstId = 0, partialResultCount = 0
    removeInFlightRequestIfReadyLocked: removed frame 23068 from InFlightMap
08-09 03:07:51.753 237-345/? V/FslCameraHAL: processSettings: AF region: x 888 y 963
08-09 03:07:51.756 237-345/? V/FslCameraHAL: trigger: 1 afMode 1 afTriggerId 5
    virtual unsigned char Ov5640Mipi::doAutoFocus(unsigned char): mode = 1
//Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1Routine1

//Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2
// Exposure compensation 을 변경한 경우 수행되는 routine

08-08 01:07:08.524 1686-1686/net.sourceforge.opencamera D/CameraController1: getParameters
08-08 01:07:08.524 236-236/? V/Camera2Client: getParameters: Camera 0
08-08 01:07:08.526 1686-1686/net.sourceforge.opencamera D/CameraController1: change exposure from 1 to 0
    setCameraParameters
08-08 01:07:08.526 236-1588/? V/Camera2Client: setParameters: Camera 0
08-08 01:07:08.527 236-1588/? V/Camera2-Parameters: set: Preview FPS value is used from 'range'
    set: Preview FPS range (10, 30)
    Picture size has not been overridden. Skip checking
    Array aspect: 1.333333, still aspect: 1.333333
    Horiz crop factor: 1.000000, vert crop fact: 1.000000
    Current still picture FOV: 56.595833 x 43.977539 deg
08-08 01:07:08.527 236-1588/? V/Camera2Client: updateRequests: Camera 0: state = 3
08-08 01:07:08.528 236-1588/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 0
08-08 01:07:08.528 236-1588/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-08 01:07:08.528 236-1588/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 0
08-08 01:07:08.528 236-1588/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-08 01:07:08.528 236-1588/? V/Camera2Client: startPreviewL: state == 3, restart = 1
08-08 01:07:08.528 236-1588/? V/Camera2-StreamingProcessor: startStream: Camera 0: type = 1
08-08 01:07:08.528 236-1588/? E/Camera3-Device: setStreamingRequest: In Camera3Device::setStreamingRequest
08-08 01:07:08.528 236-1588/? V/Camera3-Device: convertMetadataListToRequestListLocked: requestId = 10000010
    unpauseForNewRequests: RequestThread: Going active
    Camera 0: Capture request 10000010 enqueued
08-08 01:07:08.529 1686-1686/net.sourceforge.opencamera D/CameraController1: done
08-08 01:07:08.530 1686-1686/net.sourceforge.opencamera D/Preview: showToast: Exposure compensation 0 EV
    reuse last toast: android.widget.Toast@7a9181e
08-08 01:07:08.587 236-1733/? V/Camera3-Device: insertTriggers: Mixed in trigger afTrigger, value 2
    insertTriggers: Mixed in trigger afTriggerId, value 5
    prepareHalRequests: Request settings are NEW
    prepareHalRequests: Request (frame num 396) had AF trigger 0x2
//Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2Routine2

//Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3
============== Nitrogen6-MAX Device driver, 실제 AutoFocus 동작이 처리되는 routine  ================

CameraController1.java
	public void autoFocus(final CameraController.AutoFocusCallback cb, boolean capture_follows_autofocus_hint) {
	.......................................................................................
        try {
        	camera.autoFocus(camera_cb);
        }
	.......................................................................................

Y:\myandroid\frameworks\av\services\camera\libcameraservice\api1\Camera2Client.cpp
status_t Camera2Client::autoFocus() {
    ATRACE_CALL();
    Mutex::Autolock icl(mBinderSerializationLock);
    ALOGV("%s: Camera %d", __FUNCTION__, mCameraId);
    status_t res;
    if ( (res = checkPid(__FUNCTION__) ) != OK) return res;

    int triggerId;
    bool notifyImmediately = false;
    bool notifySuccess = false;
    {
        SharedParameters::Lock l(mParameters);
        if (l.mParameters.state < Parameters::PREVIEW) {
            ALOGE("%s: Camera %d: Call autoFocus when preview is inactive (state = %d).",
                    __FUNCTION__, mCameraId, l.mParameters.state);
            return INVALID_OPERATION;
        }

        /**
          * If the camera does not support auto-focus, it is a no-op and
          * onAutoFocus(boolean, Camera) callback will be called immediately
          * with a fake value of success set to true.
          *
          * Similarly, if focus mode is set to INFINITY, there's no reason to
          * bother the HAL.
          */
        if (l.mParameters.focusMode == Parameters::FOCUS_MODE_FIXED ||
                l.mParameters.focusMode == Parameters::FOCUS_MODE_INFINITY) {
            notifyImmediately = true;
            notifySuccess = true;
        }
        /**
         * If we're in CAF mode, and AF has already been locked, just fire back
         * the callback right away; the HAL would not send a notification since
         * no state change would happen on a AF trigger.
         */
        if ( (l.mParameters.focusMode == Parameters::FOCUS_MODE_CONTINUOUS_PICTURE ||
                l.mParameters.focusMode == Parameters::FOCUS_MODE_CONTINUOUS_VIDEO) &&
                l.mParameters.focusState == ANDROID_CONTROL_AF_STATE_FOCUSED_LOCKED ) {
            notifyImmediately = true;
            notifySuccess = true;
        }
        /**
         * Send immediate notification back to client
         */
        if (notifyImmediately) {
            SharedCameraCallbacks::Lock l(mSharedCameraCallbacks);
            if (l.mRemoteCallback != 0) {
                l.mRemoteCallback->notifyCallback(CAMERA_MSG_FOCUS,
                        notifySuccess ? 1 : 0, 0);
            }
            return OK;
        }
        /**
         * Handle quirk mode for AF in scene modes
         */
        if (l.mParameters.quirks.triggerAfWithAuto &&
                l.mParameters.sceneMode != ANDROID_CONTROL_SCENE_MODE_DISABLED &&
                l.mParameters.focusMode != Parameters::FOCUS_MODE_AUTO &&
                !l.mParameters.focusingAreas[0].isEmpty()) {
            ALOGV("%s: Quirk: Switching from focusMode %d to AUTO",
                    __FUNCTION__, l.mParameters.focusMode);
            l.mParameters.shadowFocusMode = l.mParameters.focusMode;
            l.mParameters.focusMode = Parameters::FOCUS_MODE_AUTO;
            updateRequests(l.mParameters);
        }

        l.mParameters.currentAfTriggerId = ++l.mParameters.afTriggerCounter;
        triggerId = l.mParameters.currentAfTriggerId;
    }
    ATRACE_ASYNC_BEGIN(kAutofocusLabel, triggerId);

    syncWithDevice();

    mDevice->triggerAutofocus(triggerId);

    return OK;
}

Y:\myandroid\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp
status_t Camera3Device::triggerAutofocus(uint32_t id) {
    ATRACE_CALL();
    Mutex::Autolock il(mInterfaceLock);

    ALOGV("%s: Triggering autofocus, id %d", __FUNCTION__, id);
    // Mix-in this trigger into the next request and only the next request.
    RequestTrigger trigger[] = {
        {
            ANDROID_CONTROL_AF_TRIGGER,
            ANDROID_CONTROL_AF_TRIGGER_START
        },
        {
            ANDROID_CONTROL_AF_TRIGGER_ID,
            static_cast<int32_t>(id)
        }
    };

    return mRequestThread->queueTrigger(trigger,
                                        sizeof(trigger)/sizeof(trigger[0]));
}

Y:\myandroid\hardware\imx\libcamera3\Camera.cpp
//do advanced character set.
int32_t Camera::processSettings(sp<Metadata> settings, uint32_t frame)
{
	.......................................................................................
		// temp, LCD 화면을 누르면 이곳 까지 실행됨 확인
        // process trigger type
        ALOGV("trigger: %d afMode %d afTriggerId %d", trigger, afMode, m3aState.afTriggerId);
        switch (trigger) {
            case ANDROID_CONTROL_AF_TRIGGER_CANCEL:
                // in case of continuous focus, cancel means to stop manual focus only
                if ((afMode == ANDROID_CONTROL_AF_MODE_CONTINUOUS_VIDEO) ||
                    (afMode == ANDROID_CONTROL_AF_MODE_CONTINUOUS_PICTURE))
                    m3aState.afState = doAutoFocus(afMode);
                break;
            case ANDROID_CONTROL_AF_TRIGGER_START:
                m3aState.afState = doAutoFocus(afMode);
                break;
	.......................................................................................

Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.cpp
uint8_t Ov5640Mipi::doAutoFocus(uint8_t mode)
{
    struct v4l2_control c;
    uint8_t ret = ANDROID_CONTROL_AF_STATE_INACTIVE;
    int result;

    int32_t fd = open(mDevPath, O_RDWR);
    if (fd < 0) {
        ALOGE("couldn't open device %s", mDevPath);
        return ret;
    }

	// temp, Camera 동작 중 LCD 화면을 터치하면 이곳 까지 듣어와서 처리 함
	ALOGV("%s: mode = %d", __func__, mode);
	// temp

    switch (mode) {
    case ANDROID_CONTROL_AF_MODE_AUTO:
    case ANDROID_CONTROL_AF_MODE_MACRO:
        ret = ANDROID_CONTROL_AF_STATE_ACTIVE_SCAN;
        c.id = V4L2_CID_AUTO_FOCUS_START;
        break;
    case ANDROID_CONTROL_AF_MODE_CONTINUOUS_VIDEO:
    case ANDROID_CONTROL_AF_MODE_CONTINUOUS_PICTURE:
        ret = ANDROID_CONTROL_AF_STATE_PASSIVE_SCAN;
        c.id = V4L2_CID_FOCUS_AUTO;
        c.value = 1;
        break;
    case ANDROID_CONTROL_AF_MODE_OFF:
    default:
        ret = ANDROID_CONTROL_AF_STATE_INACTIVE;
        c.id = V4L2_CID_AUTO_FOCUS_STOP;
    }
    result = ioctl(fd, VIDIOC_S_CTRL, &c);
    if (result != 0) {
        ALOGE("ioctl error: %d", result);
        ret = ANDROID_CONTROL_AF_STATE_INACTIVE;
    }

    close(fd);

    return ret;
}

Y:\myandroid\kernel_imx\drivers\media\v4l2-core\v4l2-ioctl.c
static long __video_do_ioctl(struct file *file,
		unsigned int cmd, void *arg)
{
	.......................................................................................
	if (v4l2_is_known_ioctl(cmd)) {
		info = &v4l2_ioctls[_IOC_NR(cmd)];
	.......................................................................................

static struct v4l2_ioctl_info v4l2_ioctls[] = {
	.......................................................................................
	IOCTL_INFO_FNC(VIDIOC_S_CTRL, v4l_s_ctrl, v4l_print_control, INFO_FL_PRIO | INFO_FL_CTRL),
	.......................................................................................

static int v4l_s_ctrl(const struct v4l2_ioctl_ops *ops,
				struct file *file, void *fh, void *arg)
{
	struct video_device *vfd = video_devdata(file);
	struct v4l2_control *p = arg;
	struct v4l2_fh *vfh =
		test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;
	struct v4l2_ext_controls ctrls;
	struct v4l2_ext_control ctrl;

	if (vfh && vfh->ctrl_handler)
		return v4l2_s_ctrl(vfh, vfh->ctrl_handler, p);
	if (vfd->ctrl_handler)
		return v4l2_s_ctrl(NULL, vfd->ctrl_handler, p);
	if (ops->vidioc_s_ctrl)
		return ops->vidioc_s_ctrl(file, fh, p);
	if (ops->vidioc_s_ext_ctrls == NULL)
		return -ENOTTY;

	ctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);
	ctrls.count = 1;
	ctrls.controls = &ctrl;
	ctrl.id = p->id;
	ctrl.value = p->value;
	if (check_ext_ctrls(&ctrls, 1))
		return ops->vidioc_s_ext_ctrls(file, fh, &ctrls);
	return -EINVAL;
}

Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\mxc_v4l2_capture.c
/*!
 * V4L2 - set_control function
 *          V4L2_CID_PRIVATE_BASE is the extention for IPU preprocessing.
 *          0 for normal operation
 *          1 for vertical flip
 *          2 for horizontal flip
 *          3 for horizontal and vertical flip
 *          4 for 90 degree rotation
 * @param cam         structure cam_data *
 *
 * @param c           structure v4l2_control *
 *
 * @return  status    0 success, EINVAL failed
 */
static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
{
	.......................................................................................
	case V4L2_CID_FOCUS_AUTO:
	case V4L2_CID_AUTO_WHITE_BALANCE:
	case V4L2_CID_DO_WHITE_BALANCE:
	case V4L2_CID_COLORFX:
		if (cam->sensor)
			ret = vidioc_int_s_ctrl(cam->sensor, c);
		else {
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;
	.......................................................................................

Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\ov5640_mipi.c
/*!
 * ioctl_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
 * @s: pointer to standard V4L2 device structure
 * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
 *
 * If the requested control is supported, sets the control's current
 * value in HW (and updates the video_control[] array).  Otherwise,
 * returns -EINVAL if the control is not supported.
 */
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	.......................................................................................
	case V4L2_CID_FOCUS_AUTO:			// ??0094860??= 0x009a090c = 0x009a0000 | 0x900 +12 
		retval = ov5640_af_set_auto(!!vc->value);
		break;
	.......................................................................................

static int ov5640_af_set_auto(int enable)
{
	int ret = 0;

	if (enable)
		ret = ov5640_af_set_mode(V4L2_CID_FOCUS_AUTO);
	else
		ret = ov5640_af_set_mode(V4L2_CID_AUTO_FOCUS_STOP);

	return ret;
}

static int ov5640_af_set_mode(int mode)
{
	int err = 0;

	switch (mode) {
	case V4L2_CID_AUTO_FOCUS_START:
		/* start single focus */
		err = ov5640_write_reg(OV5640_REG_AF_MODE,
				       OV5640_AF_MODE_SINGLE);
		focus_range = V4L2_AUTO_FOCUS_RANGE_NORMAL;
		break;
	case V4L2_CID_FOCUS_AUTO:
		/* start continuous focus */
		err = ov5640_write_reg(OV5640_REG_AF_MODE,
				       OV5640_AF_MODE_CONTINUOUS);
		focus_range = V4L2_AUTO_FOCUS_RANGE_NORMAL;
		break;
	case V4L2_CID_3A_LOCK:
		/* pause focus */
		err = ov5640_write_reg(OV5640_REG_AF_MODE,
				       OV5640_AF_MODE_PAUSE);
		break;
	case V4L2_CID_AUTO_FOCUS_STOP:
		/* release focus to infinity */
		err = ov5640_write_reg(OV5640_REG_AF_MODE,
				       OV5640_AF_MODE_RELEASE);
		break;
	default:
		pr_err("Invalid mode: %d\n", mode);
		return -EINVAL;
	}

	if (err) {
		pr_err("Setting focus mode failed!\n");
		return err;
	}

	focus_mode = mode;

	return 0;
}

//Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3Routine3


/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.	하기, //fix2fix2 ~ //fix2fix2은 BoundaryDevice(Nitrogen6-MAX) Device driver 단에서
	setParameter(Exposure compensation 조절 명령 등) 명령이 처리될 수 있도록 수정한 사항을 기술하고 있음
	cf)	하기와 같이 수정하면 정말로 노출계수가 조절 됨

 * S4.2. Auto-exposure settings and result entries:
 *
 *  Main metadata entries:
 *
 *   ANDROID_CONTROL_AE_MODE: Control for selecting the current auto-exposure
 *       mode. Set by the framework in the request settings.
 *
 *     AE_MODE_OFF: Autoexposure is disabled; the user controls exposure, gain,
 *         frame duration, and flash.
 *
 *     AE_MODE_ON: Standard autoexposure, with flash control disabled. User may
 *         set flash to fire or to torch mode.
 *
 *     AE_MODE_ON_AUTO_FLASH: Standard autoexposure, with flash on at HAL's
 *         discretion for precapture and still capture. User control of flash
 *         disabled.
 *
 *     AE_MODE_ON_ALWAYS_FLASH: Standard autoexposure, with flash always fired
 *         for capture, and at HAL's discretion for precapture.. User control of
 *         flash disabled.
 *
 *     AE_MODE_ON_AUTO_FLASH_REDEYE: Standard autoexposure, with flash on at
 *         HAL's discretion for precapture and still capture. Use a flash burst
 *         at end of precapture sequence to reduce redeye in the final
 *         picture. User control of flash disabled.
 *
 *   ANDROID_CONTROL_AE_STATE: Dynamic metadata describing the current AE
 *       algorithm state, reported by the HAL in the result metadata.
 *
 *     AE_STATE_INACTIVE: Initial AE state after mode switch. When the device is
 *         opened, it must start in this state.
 *
 *     AE_STATE_SEARCHING: AE is not converged to a good value, and is adjusting
 *         exposure parameters.
 *
 *     AE_STATE_CONVERGED: AE has found good exposure values for the current
 *         scene, and the exposure parameters are not changing. HAL may
 *         spontaneously leave this state to search for better solution.
 *
 *     AE_STATE_LOCKED: AE has been locked with the AE_LOCK control. Exposure
 *         values are not changing.
 *
 *     AE_STATE_FLASH_REQUIRED: The HAL has converged exposure, but believes
 *         flash is required for a sufficiently bright picture. Used for
 *         determining if a zero-shutter-lag frame can be used.
 *
 *     AE_STATE_PRECAPTURE: The HAL is in the middle of a precapture
 *         sequence. Depending on AE mode, this mode may involve firing the
 *         flash for metering, or a burst of flash pulses for redeye reduction.
 *
 *   ANDROID_CONTROL_AE_PRECAPTURE_TRIGGER: Control for starting a metering
 *       sequence before capturing a high-quality image. Set by the framework in
 *       the request settings.
 *
 *      PRECAPTURE_TRIGGER_IDLE: No current trigger.
 *
 *      PRECAPTURE_TRIGGER_START: Start a precapture sequence. The HAL should
 *         use the subsequent requests to measure good exposure/white balance
 *         for an upcoming high-resolution capture.
 *
 *  Additional metadata entries:
 *
 *   ANDROID_CONTROL_AE_LOCK: Control for locking AE controls to their current
 *       values
 *
 *   ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION: Control for adjusting AE
 *       algorithm target brightness point.
 *
 *   ANDROID_CONTROL_AE_TARGET_FPS_RANGE: Control for selecting the target frame
 *       rate range for the AE algorithm. The AE routine cannot change the frame
 *       rate to be outside these bounds.
 *
 *   ANDROID_CONTROL_AE_REGIONS: Control for selecting the regions of the FOV
 *       that should be used to determine good exposure levels. This applies to
 *       all AE modes besides OFF.


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

//fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2

Y:\myandroid\hardware\imx\libcamera3\Camera.cpp
//do advanced character set.
int32_t Camera::processSettings(sp<Metadata> settings, uint32_t frame)
{
	.......................................................................................
	// temp, manual exposure
	int32_t ae_data = 0;
	static int32_t ae_data_backup = 0;

	entry = settings->find(ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION);
    if (entry.count > 0) {
        // ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION
//		ALOGI("ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION");

		ae_data = entry.data.i32[0];
		ALOGV("%s: ae_data = %d", __FUNCTION__, ae_data);

		/*	ae_data가 ae_data_backup 아닌 경우만 노출 계수를 변경해 주고 
			곧바로 변경한 노출계수를 ae_data_backup에 저장시켜서 이후 노출계수 값을 변경하지 않은 경우는 본 노출계수 변경 함수가 실행되지 않도록 함 */
		if(ae_data != ae_data_backup)
		{
			manualExposure(ae_data);
			ae_data_backup = ae_data;
		}
    }
	// temp
	.......................................................................................


Y:\myandroid\hardware\imx\libcamera3\Camera.h
class Camera : public camera_info, public SensorData
{
	.......................................................................................
protected:
	.......................................................................................
	// temp, manual exposure
	virtual uint8_t manualExposure(int32_t ae_data) {
        return ANDROID_CONTROL_AE_STATE_INACTIVE;
    }
	// temp
	.......................................................................................


Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.h
class Ov5640Mipi : public Camera
{
public:
    Ov5640Mipi(int32_t id, int32_t facing, int32_t orientation, char* path);
    ~Ov5640Mipi();

    virtual status_t initSensorStaticData();

    virtual uint8_t doAutoFocus(uint8_t mode);
    virtual uint8_t getAutoFocusStatus(uint8_t mode);
    virtual void    setAutoFocusRegion(int x, int y);

	// temp, manual exposure
	virtual uint8_t manualExposure(int32_t ae_data);
	// temp


Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.cpp
// temp, manual exposure
uint8_t Ov5640Mipi::manualExposure(int32_t ae_data)
{
    struct v4l2_control c;
    uint8_t ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    int result;

    int32_t fd = open(mDevPath, O_RDWR);
    if (fd < 0) {
        ALOGE("couldn't open device %s", mDevPath);
        return ret;
    }

	ALOGV("%s: ae_data = %d", __func__, ae_data);

    ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    c.id = V4L2_CID_EXPOSURE;
	c.value = ae_data;
 
    result = ioctl(fd, VIDIOC_S_CTRL, &c);
    if (result != 0) {
        ALOGE("ioctl error: %d", result);
        ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    }

    close(fd);

    return ret;
}
// temp


Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\ov5640_mipi.c
static int AE_low, AE_high, AE_Target = 52;
// temp, manual exposure
#define MANUAL_EXPOSURE_DEFAULT_DATA	0
static int iManualExposureData = MANUAL_EXPOSURE_DEFAULT_DATA;
// temp

/*!
 * ioctl_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
 * @s: pointer to standard V4L2 device structure
 * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
 *
 * If the requested control is supported, sets the control's current
 * value in HW (and updates the video_control[] array).  Otherwise,
 * returns -EINVAL if the control is not supported.
 */
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
{
	.......................................................................................
	case V4L2_CID_FOCUS_AUTO:			// ??0094860??= 0x009a090c = 0x009a0000 | 0x900 +12 
//		retval = ov5640_af_set_auto(!!vc->value);
		// temp
		retval = ov5640_af_set_auto(vc->value);
		// temp
		break;
	.......................................................................................
	case V4L2_CID_EXPOSURE:
		// temp, manual exposure
		pr_debug("In ov5640_mipi:ioctl_s_ctrl->V4L2_CID_EXPOSURE:vc->value = %d\n", vc->value);
		iManualExposureData = vc->value;
		retval = OV5640_set_manual_exposure_target(iManualExposureData);
		// temp
		break;
	.......................................................................................

// temp, manual exposure
static int OV5640_set_manual_exposure_target(int target)
{
	/*	
		4.6.2 manual exposure control
		To manually change exposure value, you must first set both 0x3503[0], where 0x3503[0] enables manual exposure
		control. In auto exposure mode, the extra exposure values (larger than 1 frame) in registers 0x350C/0x350D
		automatically change. In manual exposure mode, these registers will not automatically change. The manually set
		exposure in registers 0x3500~0x3502 must be less than the maximum exposure value in {0x380E, 0x380F} +
		{0x350C,0x350D}. The exposure value in registers 0x3500~0x3502 is in units of line*16 - the low 4 bits (0x3502[3:0]) is
		the fraction of line, the maximum value in {0x380E + 0x380F} + {0x350C, 0x350D} is in unit of line. If the manually set
		exposure value is less than one pre-defined frame period (e.g., 1/15 second in 15fps), there is no need to change
		0x380E/0x380F. If the exposure value needs to be set beyond the pre-defined frame period; in other words, if the frame
		period needs to be extended to extend exposure time, then the maximum frame value in 0x380E/0x380F needs to be
		set first, then the exposure can be set in registers 0x3500~0x3502 accordingly.

		14.1 Shutter
		The shutter of OV5642 controls exposure time. The unit of shutter is line period.
		Shutter value has limitation for each output resolution. The limitation is stored in 2 registers,
		reg0x350c, reg0x350d
		Maxlines = reg0x350c<<8 + reg0x350d
		The shutter value are stored in 3 registers, reg0x3500, reg0x3501,reg3502 .
		Shutter = reg0x3500<<12+ reg0x3501<<4+reg3502>>4;

		4.6.4 manual gain control
		To manually change gain, first set register bit 0x3503[1] to enable manual control, then change the values in
		0x350A/0x350B for the manual gain. The OV5640 has a maximum of 64x gain.
		cf)	4.6.3 auto gain control (AGC)
			Unlike prolonging integration time, increasing gain will amplify both signal and noise. Thus, AGC usually starts after AEC
			is full. However, in cases where adjacent AEC step changes are too large (>1/16), AGC steps should be inserted in
			between; otherwise, the integration time will keep switching between two adjacent steps and the image flickers.

		참고)
			address		register name		default value	R/W		description
			0x3503 		AEC PK MANUAL 		0x00 			RW		AEC Manual Mode Control
																		Bit[1]: AGC manual
																			0: Auto enable
																			1: Manual enable
																		Bit[0]: AEC manual
																			0: Auto enable
																			1: Manual enable
			0x3500 		AEC PK EXPOSURE 	0x00 			RW 		Exposure Output,						cf)	Shutter value, Manual exposure mode일 경우 본 값을 조절해서 노출계수 조절
																		Bit[3:0]: Exposure [19:16]
			0x3501 		AEC PK EXPOSURE 	0x02 			RW 		Exposure Output,						cf)	Shutter value, Manual exposure mode일 경우 본 값을 조절해서 노출계수 조절
																		Bit[7:0]: Exposure [15:8]
			0x3502 		AEC PK EXPOSURE 	0x00 			RW		Exposure Output							cf)	Shutter value, Manual exposure mode일 경우 본 값을 조절해서 노출계수 조절
																		Bit[7:0]: Exposure [7:0]
																			Lower four bits are a fraction of a	line;
																			they should be 0 since OV5640 does not support
			0x350C 		AEC PK VTS 			0x00 			RW 		AEC VTS Output
																		Bit[7:0]: VTS[15:8]					cf)	Auto exposure mode에서는 주변환경에 따라서 자동으로 변경되지만
																												Manual exposure mode에서는 자동으로 변경되지 않고 Shutter value의 Limitation 값으로 사용 됨
			0x350D 		AEC PK VTS 			0x00 			RW 		AEC VTS Output							cf)	Auto exposure mode에서는 주변환경에 따라서 자동으로 변경되지만
																												Manual exposure mode에서는 자동으로 변경되지 않고 Shutter value의 Limitation 값으로 사용 됨
																		Bit[7:0]: VTS[7:0]

			0x380E 		TIMING VTS 			0x07 			RW 		Bit[7:0]: Total vertical size[15:8]		cf)	maximum frame value		
			0x380F 		TIMING VTS 			0xB0 			RW 		Bit[7:0]: Total vertical size[7:0]		cf)	maximum frame value

			0x350A 		AEC PK REAL GAIN 	0x00 			RW		Real Gain								cf)	본 Gain값을 높이면 이미지는 확실하게 밝아지기는 하나 Noise도 엄청 증가하기 때문에 default 부근 값으로 설정 함
																	Bit[7:2]: Debug mode
																	Bit[1:0]: Real gain[9:8]
			0x350B 		AEC PK REAL GAIN 	0x10 			RW 		Real Gain								cf)	본 Gain값을 높이면 이미지는 확실하게 밝아지기는 하나 Noise도 엄청 증가하기 때문에 default 부근 값으로 설정 함
																	Bit[7:0]: Real gain[7:0]

		예제)
			OV5640_set_shutter(target);에서의 target 값을 0~1800으로 설정하고
			ov5640_write_reg(0x350c, 5);
			ov5640_write_reg(0x380e, 10);					// 설정값을 5로 하면 본 0x350c & 0x380e register값을 수정하지 않은 노출영상과 비슷한 결과를 출력하며
															// 설정값을 10으로 하면 본 0x350c & 0x380e register값을 수정하지 않은 영상 보다 노출 정도가 2배 정도 증가된 영상이 출력됨
															// 설정값 10이상 부터는 10으로 설정한 경우 대비 별다른 차이점이 없음
			으로 설정하니 기존 보다 더 노출계수 효과가 늘어 났다.

		예제)
			아래와 같이 설정해서 iShutterData 값을 변경하니 실제 카메라 화면이 완전 어두운 상태에서 화면이 상당히 하얗게 Saturation 되는 화면 까지
			iShutterData 값에 따라서 모두 차이 나게 변화됨(ex, iShutterData = 2500 -> 3000 으로 변경시에도 노출 화면 변화 됨)
			하지만, 화면 refresh가 1초 정도 delay 간격으로 굼뜨게 변함
			하지만, 이는 Device driver/프로그램 문제가 아닌 워낙 shutter speed를 장시간으로 설정했기 때문에 나타나는 현상 임
			cf)	아래와 같이 manual로 노출계수를 변경하고서 1024x768 해상도에서 촬영하면 변경한 노출계수로 카메라 촬영이 가능하지만
				1920x1080 해상도에서 촬영하면 default 노출계수로 변경된 이미지로 촬영 됨
				또한 포커스가 맞춰진 상태에서 촬영하면 아래 변경된 노출계수로 촬영이 되지만 포커스가 제대로 맞춰지지 않은 상태에서 촬영하면 default 노출계수로 변경된 영상으로 촬영되는 것 같다.
			
			ov5640_write_reg(0x3503, 0x07);			// Manual AGC, Manual AEC
		//	ov5640_write_reg(0x3500, 0xff);			// 아래 OV5640_set_shutter 함수에서 처리
		//	ov5640_write_reg(0x3501, 0xff);
		//	ov5640_write_reg(0x3502, 0xff);
			ov5640_write_reg(0x350c, 0xff);			// Shutter limitation 값이므로 최대로 설정
			ov5640_write_reg(0x350d, 0xff);			// Shutter limitation 값이므로 최대로 설정
			ov5640_write_reg(0x380e, 0x20);			// maximum frame value 값이므로 최대로 설정, 0x380e/0x380f 값을 모두 0xff로 설정하면 iShutterData값을 변화시켜도 계속 어두운 카메라 상태 유지
			ov5640_write_reg(0x380f, 0xff);			// maximum frame value 값이므로 최대로 설정

			switch(target)
			{
				case -3:
					iShutterData = 0;				// 완전 어두운 화면
					break;
				case -2:
					iShutterData = 500;
					break;
				case -1:
					iShutterData = 1000;
					break;
				case 0:
					iShutterData = 1500;
					break;
				case 1:
					iShutterData = 2000;
					break;
				case 2:
					iShutterData = 2500;
					break;
				case 3:
					iShutterData = 3000;			// 하얗게 saturation 된 화면
					break;
				default:
					iShutterData = 0;
					break;
			}

			pr_debug("%s(mipi):target = %d, iShutterData = %d\n", __func__, target, iShutterData);

			OV5640_set_shutter(iShutterData);	
	*/

	/*
		AWB(Auto White Balance)
		의미)	Auto White Balance란 카메라 촬영 시 반사된 빛의 색감을 중립적으로 잡아, 색 균형을 조절해서
			흰색을 흰색으로 보이게 하는 것임.
			사람의 눈은 색 항상성을 가지고 있어 광원에 관계 없이 물체가 가지는 고유한 색을 인식하는 기능이 있습니다.			
			그래서 광원이 바뀌더라도 흰색을 항상 흰색으로 느끼게 됨 이를 카메라가 해 주는 것임
			cf)	사람의 눈이 아닌 카메라가 피사체를 보고 이를 LCD에 표시해 주기 때문에 White Balance를
				사람이 하는 것이 아닌 카메라가 해줘야 함
			cf)	하얀색 조명아래 흰 종이만 흰색으로 아는 것이 아닌, 노란색 조명아래 흰 종이도 흰색으로 느낌
			cf)	AWB란 입사된 광원의 색 온도와 상관없이 색차 성분의 백터의 평균치가 화이트라고 가정을 하고
				세 개 평균치를 화이트로 이동하는 것을 의미합니다.
				일단 들어온 영상의 색차 신호를 가지고 색차 평균을 산출하고
				이것을 원점으로 수렴시키려고 보정하는 것이 White Balance 알고리즘의 기본 내용입니다.
		참고)
			address 	register name		default value	R/W 	description
			0x5001 		ISP CONTROL 01		0x01 			RW		ISP Control 01
																	Bit[7]: Special Digital Effects (SDE) enable
																		0: Disable
																		1: Enable
																	Bit[5]: Scaling enable,	본 Scaling은 Zoom in/out과 연관되어 있는 것이며
																		ov5640_downsize_mode(SUBSAMPLING/SCALING)를 뜻하는 것 아님
																		오히려, ov5640_downsize_mode(SUBSAMPLING/SCALING)은 0x3821(Bit[0]: Horizontal binning enable)과 연관되어 있음
																		0: Disable
																		1: Enable
																	Bit[2]: UV average enable
																		0: Disable
																		1: Enable
																	Bit[1]: Color matrix enable
																		0: Disable
																		1: Enable
																	Bit[0]: Auto white balance (AWB) enable
																		0: Disable
																		1: Enable
			0x5193 		AWB CONTROL 19 		0xF0 			RW 		Bit[7:0]: Red limit

		7.4 AWB gain control [0x3400 ~ 0x3406]

			address		register name		default	value	R/W		description
			0x3400 		AWB R GAIN 			0x04 			RW 		Bit[3:0]: AWB R gain[11:8]
			0x3401 		AWB R GAIN 			0x00 			RW 		Bit[7:0]: AWB R gain[7:0]
			0x3402 		AWB G GAIN 			0x04 			RW 		Bit[3:0]: AWB G gain[11:8]
			0x3403 		AWB G GAIN 			0x00 			RW 		Bit[7:0]: AWB G gain[7:0]
			0x3404 		AWB B GAIN 			0x04 			RW 		Bit[3:0]: AWB B gain[11:8]
			0x3405 		AWB B GAIN 			0x00 			RW 		Bit[7:0]: AWB B gain[7:0]
			0x3406 		AWB MANUAL CONTROL	0x00 			RW		Bit[7:1]: Debug mode
																	Bit[0]: AWB gain manual enable
																		0: Auto
																		1: Manual
	*/

	/*
		5.2 lens correction (LENC)			->	0x5000	->	Bit[7]: LENC correction enable
			cf)	본, lens correction (LENC) 기능을 Disable 시키면 확실하게 가운데는 밝고 외곽으로 갈 수록(원형으로 퍼지는 방향) 어두워지는 이미지로 변한다.

		5.5 defect pixel cancellation (DPC)	->	0x5000	->	Bit[2]: Black pixel cancellation enable / Bit[1]: White pixel cancellation enable
		Due to processes and other reasons, pixel defects in the sensor array will occur. Thus, these bad or wounded pixels will
		generate wrong color values. The main purpose of Defect Pixel Cancellation (DPC) function is to remove the effect
		caused by these bad or wounded pixels. Also, some special functions are available for those pixels located at the image
		boundary. To remove the defect pixel effect correctly, the proper threshold should first be determined.
			cf)	본 기능은 이미 static struct reg_value ov5640_init_setting_30fps_VGA[] 에서 Enable 되어 있음
			
			address		register name		default	value	R/W		description
			0x5000 		ISP CONTROL 00 		0x06 			RW		ISP Control 00
																	Bit[7]: LENC correction enable
																		0: Disable
																		1: Enable
																	Bit[5]: RAW gamma enable
																		0: Disable
																		1: Enable
																	Bit[2]: Black pixel cancellation enable
																		0: Disable
																		1: Enable
																	Bit[1]: White pixel cancellation enable
																		0: Disable
																		1: Enable
																	Bit[0]: Color interpolation (CIP) enable
																		0: Disable
																		1: Enable
	*/

	/*
		Sharpness
			address		register name			default value	R/W		description
			0x5308 		CIP CTRL 				0x25 			RW		Bit[7]: Debug mode
																		Bit[6]: CIP edge MT manual enable
																		Bit[4]: CIP DNS manual enable
																		Bit[2:0]: CIP threshold for BR sharpen
			0x5302 		CIP SHARPENMT OFFSET1 	0x18 			RW		CIP Sharpen MT Offset1
																		(Y edge mt manual setting when 0x5308[6]=1)

		예제1)
			Sharpness OFF(확실하게 이미지 부드러워짐)
			Write_i2c(0x5308 ,0x65);
			Write_i2c(0x5302 ,0x00);
			
		예제2)
			Sharpness MAX(확실하게 이미지 날카로워짐)
			Write_i2c(0x5308 ,0x65);
			Write_i2c(0x5302 ,0xff);

		예제3) 이미지가 기본 셋팅(Write_i2c(0x5308 ,0x25)) 보다 부드러워지기는 하지만 예제1) 보다는 부드러운/뭉개짐이 약간 약함
			Write_i2c(0x5308 ,0x00);

###		예제4) 예제1)과 부드러움/뭉개짐/색상 등 모든 사항에서 거의 동일한 이미지를 보이지만 DNS(De-Noise) 기능도 ON으로 설정된
			 예제이기 때문에 본 설정으로 이미지 sharpness 셋팅을 취하자(어두운 곳에서 Noise를 보다 잘 제거해 줄 수도 있기 때문)	
			Sharpness OFF & DNS(De-noise) manual enable(확실하게 이미지 부드러워짐)
			Write_i2c(0x5308 ,0x75);
			Write_i2c(0x5302 ,0x00);
	*/

	/*	
		측정용으로 사용한 OV7725 Camera setting
		unsigned char OV7725_initialData[][2]=
		{
		//unsigned char data=0;
		{0x00, 0x00}, {0x01, 0x4b}, {0x02, 0x40}, {0x03, 0x45}, {0x04, 0x00}, {0x05, 0x79}, {0x06, 0x78}, {0x07, 0x79},	//0x00번지 GAIN[7:0]의 값의 변경은 AEC[7:0]을 변경시킨 것과 유사한 결과를 나타내지만 너무 변화폭이 크기 때문에 사용 곤란
		//{0x08, 0x00},  //AEC[15:8]
		{0x09, 0x00}, {0x0a, 0x77}, {0x0b, 0x21}, {0x0c, 0xd0}, {0x0d, 0x41}, {0x0e, 0x79}, {0x0f, 0xc5}, //{0x10, 0x7e},    //AEC[7:0],	0x0D(COM4[7:6])의 값을 0x41 -> 0xc1로 바꾸면 카메라 이미지를 고속으로 찍을 수 있음(빠르게 지나가는 피사체도 찍을 수 있음, 그런데 이 경우 이미지가 어두워지게 됨, cf) 0x11(CLKRC[5:0])의 값도 0x00으로 함께 바꾸면 이미지에 가로줄 노이즈가 발생함)
		{0x11, 0x01}, {0x12, 0x02},   // 0x00 --> YUV422 format(LCD Color Preview),      0x02 -->GRB422(현,사용중 모드),								0x11(CLKRC[5:0])의 값을 0x01 -> 0x00으로 바꾸면 카메라 이미지를 고속으로 찍을 수 있음(빠르게 지나가는 피사체도 찍을 수 있음, 그런데 이 경우 이미지가 어두워지게 됨)
		{0x13, 0x88}, //AWB off, AGC off, AEC off  :0x88        default: 0x8f
		{0x14, 0x91}, {0x15, 0x00}, {0x16, 0x00}, {0x17, 0x22}, {0x18, 0xa4}, {0x19, 0x07}, {0x1a, 0xf0}, {0x1b, 0x40},
		{0x1c, 0x7f}, {0x1d, 0xa2}, {0x1e, 0x00}, {0x1f, 0x0a}, {0x20, 0x10}, {0x21, 0x00}, {0x22, 0x3f}, {0x23, 0x07},
		{0x24, 0x30}, {0x25, 0xd0}, {0x26, 0x91}, {0x27, 0x00}, {0x28, 0x00}, {0x29, 0xa0}, {0x2a, 0x00}, {0x2b, 0x00},
		{0x2c, 0xf0}, {0x2d, 0x00}, {0x2e, 0x00}, {0x2f, 0x42}, {0x30, 0x78}, {0x31, 0x68}, {0x32, 0x00}, {0x33, 0x00},
		{0x34, 0x00}, {0x35, 0x80}, {0x36, 0x80}, {0x37, 0x81}, {0x38, 0x80}, {0x39, 0x6c}, {0x3a, 0x88}, {0x3b, 0xa0},
		{0x3c, 0xa4}, {0x3d, 0x03}, {0x3e, 0xe2}, {0x3f, 0x1f}, {0x40, 0xe8}, {0x41, 0x00}, {0x42, 0x7f}, {0x43, 0x80},
	//	{0x44, 0x80}, {0x45, 0x80}, {0x46, 0x05}, //LC_CTR[0]: 0:disable lens correction., 1:enable lens correction.(현,Lens correction 사용; Lens shade 카메라 자체적으로도 on)
		// fix, Multi 에서는 카메라자체 Lens shade 기능 OFF 시킴, 이유 : 카메라자체 Lens shade 기능을 ON 하면 오히려 이미지 중심부 둘레의 왜곡이(그림자 현상)  더 심해지기 때문
		{0x44, 0x80}, {0x45, 0x80}, {0x46, 0x04}, //LC_CTR[0]: 0:disable lens correction., 1:enable lens correction.(현,Lens correction 사용; Lens shade 카메라 자체적으로도 on)
		// fix
		{0x47, 0x24}, {0x48, 0x1d}, {0x49, 0x47}, {0x4a, 0x1f}, {0x4b, 0x50}, {0x4c, 0x54}, {0x4d, 0x09}, {0x4e, 0xef},
		{0x4f, 0x10}, {0x50, 0x60}, {0x51, 0x00}, {0x52, 0x00}, {0x53, 0x24}, {0x54, 0x7a}, {0x55, 0xfc}, {0x56, 0xfc},
		{0x57, 0xfc}, {0x58, 0xfc}, {0x59, 0xfc}, {0x5a, 0xfc}, {0x5b, 0xfc}, {0x5c, 0xfc}, {0x5d, 0xfc}, {0x5e, 0xfc},
		{0x5f, 0xfc}, {0x60, 0x00}, {0x61, 0x05}, {0x62, 0xff}, {0x63, 0xe0}, {0x64, 0xff}, {0x65, 0x20}, {0x66, 0x00},	// DSP_Ctrl1[1][0]:Black/White defect auto correction ON하면 오히려 기준스트립측정CV 1.3 -> 1.7로 더 나빠짐, DSP_Ctrl1[6][5]:UV adjust/SDE ON하면 오히려 기준스트립측정CV 1.3 -> 1.6로 더 나빠짐
		{0x67, 0x48}, {0x68, 0x00}, {0x69, 0x5c}, {0x6a, 0x11}, {0x6b, 0xaa}, {0x6c, 0x01}, {0x6d, 0x50}, {0x6e, 0x80},
		{0x6f, 0x80}, {0x70, 0x0f}, {0x71, 0x00}, {0x72, 0x00}, {0x73, 0x0f}, {0x74, 0x0f}, {0x75, 0xff}, {0x76, 0x00},
		{0x77, 0x10}, {0x78, 0x10}, {0x79, 0x70}, {0x7a, 0x70}, {0x7b, 0xf0}, {0x7c, 0xf0}, {0x7d, 0xf0}, {0x7e, 0x0c},
		{0x7f, 0x16}, {0x80, 0x2a}, {0x81, 0x4e}, {0x82, 0x61}, {0x83, 0x6f}, {0x84, 0x7b}, {0x85, 0x86}, {0x86, 0x8e},
	//	{0x87, 0x97}, {0x88, 0xa4}, {0x89, 0xaf}, {0x8a, 0xc5}, {0x8b, 0xd7}, {0x8c, 0xe8}, {0x8d, 0x20}, {0x8e, 0x00},  
		// fix, De-noise(0x8e)을 0x00 -> 0x05로 변경하니 Camera capture image도 훨씬 부드러워지고 측정편차 CV도 0.82 -> 0.76으로 7.3% 좋아짐(cf. De-noise성능체크)
		{0x87, 0x97}, {0x88, 0xa4}, {0x89, 0xaf}, {0x8a, 0xc5}, {0x8b, 0xd7}, {0x8c, 0xe8}, {0x8d, 0x20}, {0x8e, 0x05}, 
		// fix
	//	{0x8f, 0x01}, {0x90, 0x05}, {0x91, 0x01}, {0x92, 0x03}, {0x93, 0x00}, {0x94, 0xb0}, {0x95, 0x9d}, {0x96, 0x0f}, 
		// fix, EDGE0(0x8f)을 0x01 -> 0x00으로 변경하니 Camera capture image도 훨씬 부드러워지고 JIG Total(JIG1,JIG3,JIG4,JIG5,JIG6) 측정편차 CV도 1.4638-> 1.334로 0.129 만큼 좋아짐(cf. JIG별 측정값 CV 분석 및 향상방안 모색.xls)
		{0x8f, 0x00}, {0x90, 0x05}, {0x91, 0x01}, {0x92, 0x03}, {0x93, 0x00}, {0x94, 0xb0}, {0x95, 0x9d}, {0x96, 0x0f},
		// fix
		{0x97, 0x18}, {0x98, 0x7f}, {0x99, 0x91}, {0x9a, 0x1e}, {0x9b, 0x08}, {0x9c, 0x20}, {0x9d, 0x00}, {0x9e, 0x81}, 
		{0x9f, 0xfa}, {0xa0, 0x02}, {0xa1, 0x50}, {0xa2, 0x40}, {0xa3, 0x06}, {0xa4, 0x00}, {0xa5, 0x00}, {0xa6, 0x00}, //  Gray scale image output :0x20(현, Gray scale 사용하지 않음)                
		{0xa7, 0x40}, {0xa8, 0x40}, {0xa9, 0x7b}, {0xaa, 0x21}, {0xab, 0x05}, {0xac, 0x9f},

		{0x08, 0x00},	//AEC[15:8]
		{0x10, 8}	//AEC[7:0]
		};
	*/ 

	/*
		측정용으로 사용한 OV7725 Camera 성능 향상 방법
		1)	AEC 값이 작을 수록(AEC 값이 작기 때문에 LED구동저항R101의 값을 작게 해서 광량을 증가 시켜야 함)
			동일조건에 Capture할때마다 측정값이 변하는 폭이 작음
			따라서, AEC의 값이 작을 수록 좋지만 무한정 작게 하면 LED구동저항R101의 값을 0ohm에 가깝게 해서 
			LED가 아주 밝게 해줘야지만 피사체를 볼 수 있기 때문에 LED 광량이 너무 밝아지는 문제점 있음

		2)	AEC 노출시간을 기존 14 -> 10으로 변경(노출시간을 줄여 온도에 따라서 LED광량이 변하는 영향을 덜 받게 함)하니 측정값이 1시간 동안 증가하는 폭이 줄어듦
			CV : 0.44 -> 0.20(고농도), Bias : 1.03 -> 0.42(고농도)으로 측정값 증가 폭이 줄어 듦

		3)	현, 부팅시 부터 카메라 모듈에 계속 전원이 투입되고 있으며
			혹시 카메라에 전원을 계속 투입하고 있는 것 때문에 측정값이 계속 증가하는 것 아닌가 생각하고
			측정이미지를 찍는 순간에만 카메라에 전원을 투입하는 방식으로 H/W를 변경하고 측정한 결과
			측정값이 증가하는 현상을 줄이는데 효과 있음 확인 함
			CV : 0.62 -> 0.44(고농도), Bias : 1.93 -> 1.03(고농도)으로 측정값 증가 폭이 줄어 듦
	*/

	int iShutterData = 0;
	u8 u8Temp = 0, u8Temp2 = 0;

	/*	AEC/AGC manual 설정	-------------------------------------------------------	*/
	ov5640_write_reg(0x3503, 0x07);			// Manual AGC, Manual AEC
//	ov5640_write_reg(0x3500, 0xff);			// 아래 OV5640_set_shutter 함수에서 처리
//	ov5640_write_reg(0x3501, 0xff);
//	ov5640_write_reg(0x3502, 0xff);
	ov5640_write_reg(0x350c, 0xff);			// Shutter limitation 값이므로 최대로 설정
	ov5640_write_reg(0x350d, 0xff);			// Shutter limitation 값이므로 최대로 설정
//	ov5640_write_reg(0x380e, 0x20);			// maximum frame value 값이므로 최대로 설정, 일반광측정, 0x380e/0x380f 값을 모두 0xff로 설정하면 iShutterData값을 변화시켜도 계속 컴컴한 preview 상태 유지
	// temp, 형광측정
	ov5640_write_reg(0x380e, 0x78); 		// maximum frame value 값이므로 최대로 설정, = 120, cf) 128 이상 설정하면 컴컴한 preview 상태 유지
	// temp
	ov5640_write_reg(0x380f, 0xff);			// maximum frame value 값이므로 최대로 설정

	ov5640_write_reg(0x350a, 0x00);			// Bit[1:0]: Real gain[9:8], default 설정값
	ov5640_write_reg(0x350b, 0x5a);			// Bit[7:0]: Real gain[7:0], i.mx6 board manual exposure 설정 시 default 값 = 0x10
	/*	---------------------------------------------------------------------------	*/

	/*	Special Digital Effects (SDE) Disable & Auto white balance (AWB) Enable & AWB gain manual
		-	Auto white balance (AWB) 를 Disable시키면 R/G/B가 보이기는 하지만 녹색으로 많이 saturation된 R/G/B 색상으로 보이며
			이에, 0x3402값을 최소로 해서 녹색값을 줄이려해도 아예, 변화를 줄 수 없음
			cf)	AWB gain manual으로 설정하고 0x3400 에서 0x3405 값을 변경시켜 R/G/B Gain 정도를 변화시키려 해도 전혀 변화를 줄 수 없음
		-	Auto white balance (AWB) Enable 시킨 경우는 R/G/B 고유의 색상이 제대로 표현되며
			cf)	AWB gain manual으로 설정하고 0x3400 에서 0x3405 값을 변경시켜 R/G/B Gain 정도를 변화시키면 정상적으로 각각의 Gain값이 변화된 이미지를 볼 수 있음
			cf)	Auto white balance (AWB) Enable 상태에서 조명을 Green으로 하고 AWB gain auto/manual(0x3406)을 AWB gain manual으로 설정시켰을 때는
				흰색 색상이 Green 색상으로 saturation되어서 연두색으로 보이다가 AWB gain auto으로 설정하면 연두색이 흰색으로 변화됨
				->	이는 Auto white balance (AWB) Enable 으로 설정되어 있어도 Auto white auto/manual(0x3406)값에 따라서
					Auto white balance (AWB) 기능이 동작되고 안되고 설정시킬 수 있다는 것을 뜻함
		->	결론
			Auto white balance (AWB) Enable 로 설정시키고(R/G/B값을 제대로 촬영하기 위해)
			그 대신 AWB gain auto/manual(0x3406)을 AWB gain manual로 설정시켜서
			Auto white balance (AWB)가 자동으로 동작되어 피사체에 따라서 R/G/B 색상(Gain값)이 변화되는 기능은 Disable 시키자.	*/
	ov5640_read_reg(0x5001, &u8Temp);
	// Special Digital Effects (SDE) Disable
	u8Temp2 = u8Temp & ~(0x80);				// ~(1000 0000) = 0111 1111
	// Auto white balance (AWB) Enable
	u8Temp2 = u8Temp2 | 0x01;				// 0000 0001

	ov5640_write_reg(0x5001, u8Temp2);
	pr_debug("%s(mipi):ov5640_read_reg(0x5001) = 0x%x, ov5640_write_reg(0x5001) = 0x%x\n", __func__, u8Temp, u8Temp2);

	ov5640_write_reg(0x3406, 0x01);			// AWB gain manual
	ov5640_write_reg(0x5193, 0xf0);			// AWB CONTROL 19, Red limit, 0x70(default) -> 0xf0

	#if 0
	ov5640_write_reg(0x3400, 0x07);			// Bit[3:0]: AWB R gain[11:8]
	ov5640_write_reg(0x3401, 0x32);			// Bit[7:0]: AWB R gain[7:0]
	ov5640_write_reg(0x3402, 0x04);			// Bit[3:0]: AWB G gain[11:8]
	ov5640_write_reg(0x3403, 0x00);			// Bit[7:0]: AWB G gain[7:0]
	ov5640_write_reg(0x3404, 0x05);			// Bit[3:0]: AWB B gain[11:8]
	ov5640_write_reg(0x3405, 0x36);			// Bit[7:0]: AWB B gain[7:0]
	#else
	ov5640_write_reg(0x3400, g_stCameraRegister.add3400);			// Bit[3:0]: AWB R gain[11:8]
	ov5640_write_reg(0x3401, g_stCameraRegister.add3401);			// Bit[7:0]: AWB R gain[7:0]
	ov5640_write_reg(0x3402, g_stCameraRegister.add3402);			// Bit[3:0]: AWB G gain[11:8]
	ov5640_write_reg(0x3403, g_stCameraRegister.add3403);			// Bit[7:0]: AWB G gain[7:0]
	ov5640_write_reg(0x3404, g_stCameraRegister.add3404);			// Bit[3:0]: AWB B gain[11:8]
	ov5640_write_reg(0x3405, g_stCameraRegister.add3405);			// Bit[7:0]: AWB B gain[7:0]
	#endif
	/*	--------------------------------------------------------------------------- */

	/*	Sharpness OFF & DNS(De-noise) manual enable(확실하게 이미지 부드러워짐)	------------	*/
	ov5640_write_reg(0x5308 ,0x75);
	ov5640_write_reg(0x5302 ,0x00);
	/*	--------------------------------------------------------------------------- */

	#if 0		// 일반광측정
	switch(target)
	{
		case -3:
			iShutterData = 0;				// 완전 어두운 화면
			break;
		case -2:
			iShutterData = 500;				// 일반광원으로 볼 수 있는 shutter speed
			break;
		case -1:
			iShutterData = 1000;
			break;
		case 0:
			iShutterData = 2000;
			break;
		case 1:
			iShutterData = 3000;
			break;
		case 2:
			iShutterData = 4000;
			break;
		case 3:
			iShutterData = 5000;			// 하얗게 saturation 된 화면
			break;
		default:
			iShutterData = 0;
			break;
	}
	#else
	// temp, 형광측정
	switch(target)
	{
		case -3:
			iShutterData = 0;				// 완전 어두운 화면
			break;
		case -2:
			iShutterData = 500;				// 일반광원으로 볼 수 있는 shutter speed
			break;
		case -1:
			iShutterData = 10000;
			break;
		case 0:
			iShutterData = 23000;
			break;
		case 1:
			iShutterData = 36000;
			break;
		case 2:
			iShutterData = 50000;
			break;
		case 3:
			iShutterData = 65535;			// 0xffff, 최대 shutter speed
			break;
		default:
			iShutterData = 0;
			break;
	}
	// temp
	#endif
	
	pr_debug("%s(mipi):target = %d, iShutterData = %d\n", __func__, target, iShutterData);

	OV5640_set_shutter(iShutterData);

	return 0;
}
// temp

static int OV5640_set_shutter(int shutter)
{
	 /* write shutter, in number of line period */
	 int temp;

	 // temp, manual exposure
	 pr_debug("%s(mipi):shutter = %d\n", __func__, shutter);
	 // temp
	.......................................................................................

static int ov5640_init_mode(enum ov5640_frame_rate frame_rate,
			    enum ov5640_mode mode, enum ov5640_mode orig_mode)
{
	.......................................................................................
//	else if ((dn_mode == SUBSAMPLING && orig_dn_mode == SCALING) ||
//			(dn_mode == SCALING && orig_dn_mode == SUBSAMPLING))
	// temp
	/*	mode가 ov5640_mode_INIT 이 아니면
		ov5640_change_mode_exposure_calc 함수가 아닌
		ov5640_change_mode_direct 함수가 실행되도록 함
		이유)	ov5640_change_mode_exposure_calc / ov5640_change_mode_direct 함수의 차이는
			해당 frame_rate와 mode에 대한 카메라 레지스터를 ov5640_download_firmware 함수로 카메라에 다운로드 시키는 사항은 동일하며
			차이점은 ov5640_change_mode_exposure_calc 함수가 ov5640_downsize_mode 가 기존과 신규가 다른 경우에 한해서
			해당 frame_rate와 mode에 대한 카메라 shutter speed와 gain을 계산해서 shutter speed와 gain을 재 설정해 주는 부분만 다름
			->	따라서, 본 ov5640_mipi.c 에서는 manual AEC/AGC/AWB로만 사용할 것이기 때문에 ov5640_change_mode_exposure_calc 함수는 사용할
				필요가 없고 대신 ov5640_change_mode_direct 함수를 사용하면 되는 것임	*/
	else if (false)
	// temp
	{
		/* change between subsampling and scaling
		 * go through exposure calucation */

		// temp
		/* Open camera -> 2592x1944 & 1920x1080 해상도 모두 -> 카메라 촬영을 실시하면 본 루틴으로 들어 와서 하기 명령을 실행 함
		   이유)	두 모두 다 ov5640_mode_info_data -> dn_mode 설정이 default 640x480의 dn_mode 설정인 SUBSAMPLING 이 아닌 SCALING으로 설정되어 있기 때문
		   		cf) 상기 두 모두 이외의 다른 모드는 ov5640_mode_info_data -> dn_mode 설정이 default 640x480의 dn_mode 설정인 SUBSAMPLING 와 동일한 SUBSAMPLING으로 설정되어 있음
		   		cf)	image size under 1280 * 960 are SUBSAMPLING, image size upper 1280 * 960 are SCALING 으로 설정되며 영상압축을 위해 sampling 하는 방법 같다.	*/
		printk("%s() in ov5640_change_mode_exposure_calc() frame_rate = %d, mode = %d\n",
		       __func__, frame_rate, mode);
		// temp
		retval = ov5640_change_mode_exposure_calc(frame_rate, mode);
	}
	else
	{
		/* change inside subsampling or scaling
		 * download firmware directly */

		// temp
		printk("%s() in ov5640_change_mode_direct() frame_rate = %d, mode = %d\n",
		       __func__, frame_rate, mode);
		// temp
		retval = ov5640_change_mode_direct(frame_rate, mode);
	}

	if (retval < 0)
		goto err;

//	OV5640_set_AE_target(AE_Target);
	// temp, manual exposure
	OV5640_set_manual_exposure_target(iManualExposureData);
	// temp
	.......................................................................................

static int ov5640_change_mode_direct(enum ov5640_frame_rate frame_rate,
				enum ov5640_mode mode)
{
	.......................................................................................
	/* turn off AE/AG */
	// temp, manual exposure, ov5640_mipi 는 manual AEC/AGC 로 사용하기 때문에
//	OV5640_turn_on_AE_AG(0);
	// temp
	.......................................................................................
	/* turn on AE/AG */
	// temp, manual exposure, ov5640_mipi 는 manual AEC/AGC 로 사용하기 때문에
//	OV5640_turn_on_AE_AG(1);
	// temp
	.......................................................................................


Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.cpp
/*	본 함수는 NITROGEN6-MAX Board 전원 초기 투입시에만 한번 실행하고 그 이후 카메라 app을 실행해도 실행되지 않음	*/
status_t Ov5640Mipi::initSensorStaticData()
{
	.......................................................................................
    i = 0;
	#if 0
    mTargetFpsRange[i++] = 10;
    mTargetFpsRange[i++] = 30;
    mTargetFpsRange[i++] = 30;
    mTargetFpsRange[i++] = 30;
	#elif 0
	// temp
	/*	사진Capture소요시간 : 총2.44sec,
		LCD Preview 이미지 보다 저장된 Capture 이미지가 50% 정도 어두워 보임	*/
	mTargetFpsRange[i++] = 10;
	mTargetFpsRange[i++] = 15;
	mTargetFpsRange[i++] = 23;
	mTargetFpsRange[i++] = 30;
	#elif 0
	/*	1.	1024x768 해상도
			1)	사진Capture소요시간 : ?
			2)	LCD Preview 이미지와 저장된 Capture 이미지 밝기와 색상 거의 동일하며
			3)	LCD Preview 이미지는 밝기는 mTargetFpsRange[i++] = 10/30/30/30 과 동일
			4)	저장된 Capture 이미지 밝기는 mTargetFpsRange[i++] = 10/30/30/30 보다 50% 밝음
		2.	2592x1944 해상도
			1)	사진Capture소요시간 : ?
			2)	LCD Preview 이미지 보다 저장된 Capture 이미지의 밝기가 50% 어둡고 색상은 녹색으로 많이 saturation됨
			3)	LCD Preview 이미지는 밝기는 mTargetFpsRange[i++] = 10/30/30/30 과 동일
			4)	저장된 Capture 이미지 밝기는 mTargetFpsRange[i++] = 10/30/30/30와 동일하게 어두움	*/
	mTargetFpsRange[i++] = 10;
	mTargetFpsRange[i++] = 15;
	mTargetFpsRange[i++] = 10;
	mTargetFpsRange[i++] = 15;
	#else
	/*	1.	1024x768 해상도
			1)	사진Capture소요시간 : ?
			2)	LCD Preview 이미지와 저장된 Capture 이미지 밝기와 색상 거의 동일하며
			3)	LCD Preview 이미지는 밝기는 mTargetFpsRange[i++] = 10/30/30/30 과 동일
			4)	저장된 Capture 이미지 밝기는 mTargetFpsRange[i++] = 10/30/30/30 보다 50% 밝음
		2.	2592x1944 해상도
			1)	사진Capture소요시간 : ?
			2)	LCD Preview 이미지 보다 저장된 Capture 이미지의 밝기가 30% 어둡고 색상은 녹색으로 약간 saturation됨
			3)	LCD Preview 이미지는 밝기는 mTargetFpsRange[i++] = 10/30/30/30 과 동일
			4)	저장된 Capture 이미지 밝기는 mTargetFpsRange[i++] = 10/30/30/30 보다 30% 밝음	
		3.	아래와 같이 설정하면 Android studio Logcat message가 아래와 같이 카메라 해상도에 관계없이 출력 됨(1024x768, 2592x1944 카메라 해상도에 관계 없이)
			V/Camera2-Parameters: set: Preview FPS value is used from 'range'
    		set: Preview FPS range (23, 30)
		cf)	// We'll set the target FPS range for still captures to be as wide
			// as possible to give the HAL maximum latitude for exposure selection
			camera_metadata_ro_entry_t availableFpsRanges =
				staticInfo(ANDROID_CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES, 2);
			if (availableFpsRanges.count < 2 || availableFpsRanges.count % 2 != 0) {
				return NO_INIT;
			}	*/
	mTargetFpsRange[i++] = 10;
	mTargetFpsRange[i++] = 15;
	mTargetFpsRange[i++] = 23;
	mTargetFpsRange[i++] = 30;
	// temp
	#endif
	.......................................................................................


//fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2fix2


/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
1.	하기, //fix3fix3 ~ //fix3fix3은 BoundaryDevice(Nitrogen6-MAX) Device driver 단에서
	카메라 레지스터를 직접 제어할 수 있도록 수정한 사항을 기술하고 있음
	cf)	하기와 같이 수정하면 정말로 카메라 레지스터가 직접 제어 됨

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

//fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3

D:\Program\SJ\SW\Window\AndroidStudio\OpenCamera_old1\app\src\main\java\net\sourceforge\opencamera\MainActivity.java
	public void clickedExposure(View view)
	{
		if( MyDebug.LOG )
			Log.d(TAG, "clickedExposure");
		this.closePopup();
		SeekBar seek_bar = ((SeekBar)findViewById(R.id.seekbar));
		int visibility = seek_bar.getVisibility();

		// temp, regwrite
		if(true)
		{
			final EditText edittext = (EditText) findViewById(R.id.editText1);
			stAddress = edittext.getText();
			final EditText edittext2 = (EditText) findViewById(R.id.editText2);
			stData = edittext2.getText();
			String stTemp1 = "", stTemp2 = "";

			if((stAddress.equals(null) == false) && (stData.equals(null) == false))
			{
				stTemp1 = stAddress.toString();
				stTemp2 = stData.toString();

				if((stTemp1.equals("") == false) && (stTemp2.equals("") == false))
				{
					if( MyDebug.LOG )
						Log.d(TAG, "Start of preview.RegWrite");

					preview.RegWrite(Integer.parseInt(stTemp1), Integer.parseInt(stTemp2));

					// initialize
					stAddress.clear();
					stData.clear();

					return;
				}
			}
		}
		// temp
	.......................................................................................

D:\Program\SJ\SW\Window\AndroidStudio\OpenCamera_old1\app\src\main\java\net\sourceforge\opencamera\Preview.java
    // temp, regwrite
    void RegWrite(int address, int data) {
/*		location = new Location(LocationManager.GPS_PROVIDER);

		if((camera_controller != null) && (location != null))
		{
			Log.d(TAG, "In RegWrite, address = " + address + "data = " + data);

//			location.setProvider("hohoho");
			location.setLatitude(address);
			location.setLongitude(data);

			camera_controller.setLocationInfo(location);

		}	*/
        // temp
        camera_controller.setRegWrite(address, data);
        // temp
    }
    // temp


D:\Program\SJ\SW\Window\AndroidStudio\OpenCamera_old1\app\src\main\java\net\sourceforge\opencamera\CameraController.java
	// temp, regwrite
	void setRegWrite(int address, int data)
	{
		// temp
		/*
		Camera.Parameters parameters = this.getParameters();

		parameters.remove("temp-1");
		parameters.set("temp-1", address);
		parameters.remove("temp-2");
		parameters.set("temp-2", data);

		setCameraParameters(parameters);
		*/
		// temp

		// temp
		if(false)
		{
			Camera.Parameters parameters = this.getParameters();

			int new_exposure = 0;
			new_exposure = (address << 8) + data;			// ex) address = 1234(=0x04D2), data = 56(=0x38) -> (address << 8) + data -> 0x04D238(=315960)

			// temp
//			Log.d(TAG, "Before of camera parameter: " + parameters.flatten());
			// temp

			int current_exposure = parameters.getExposureCompensation();

			parameters.setExposureCompensation(new_exposure);
			setCameraParameters(parameters);

			int new_exposure2 = parameters.getExposureCompensation();

			if (MyDebug.LOG)
				Log.d(TAG, "change exposure from " + current_exposure + " to " + new_exposure2);

			// temp
//			Log.d(TAG, "After of camera parameter: " + parameters.flatten());
			// temp
		}
		else
		{
			Camera.Parameters parameters = this.getParameters();

			int address_data = 0;
			address_data = (address << 8) + data;			// ex) address = 1234(=0x04D2), data = 56(=0x38) -> (address << 8) + data -> 0x04D238(=315960)

			// temp
			Log.d(TAG, "Before of camera parameter: " + parameters.flatten());
			// temp

			parameters.remove("temp-1");
			parameters.set("temp-1", address_data);

			setCameraParameters(parameters);

			// temp
			Log.d(TAG, "After of camera parameter: " + parameters.flatten());
			// temp
			
			/* ex)
			08-30 02:13:33.794 1884-1884/net.sourceforge.opencamera D/CameraController: 
			    Before of camera parameter: 
			video-size=1920x1080;preferred-preview-size-for-video=1920x1080;preview-size-values=1920x1080,320x240,720x480,720x576,1280x720,640x480,176x144,1024x768;video-size-values=1920x1080,320x240,720x480,720x576,1280x720,640x480,176x144,1024x768;preview-format=yuv420sp;preview-format-values=yuv420sp,yuv420p;preview-fps-range-values=(10000,30000),(30000,30000);preview-frame-rate-values=30;picture-size-values=640x480,320x240,720x480,720x576,1280x720,1920x1080,2592x1944,1024x768;picture-format=jpeg;picture-format-values=jpeg;jpeg-thumbnail-width=160;jpeg-thumbnail-height=120;jpeg-thumbnail-size-values=96x96,160x120,0x0;jpeg-thumbnail-quality=90;rotation=0;whitebalance=auto;whitebalance-values=auto;effect=none;effect-values=none;antibanding=auto;antibanding-values=auto;focus-mode-values=auto,continuous-picture,continuous-video;max-num-focus-areas=1;focal-length=3.37;exposure-compensation=0;
			temp-1=0;
			max-exposure-compensation=3;min-exposure-compensation=-3;exposure-compensation-step=1;auto-exposure-lock=false;auto-exposure-lock-supported=true;auto-whitebalance-lock=false;auto-whitebalance-lock-supported=true;max-num-metering-areas=1;zoom=0;max-zoom=99;zoom-ratios=100,103,106,109,112,115,118,121,124,127,130,133,136,139,142,145,148,151,154,157,160,163,166,169,172,175,178,181,184,187,190,193,196,199,203,206,209,212,215,218,221,224,227,230,233,236,239,242,245,248,251,254,257,260,263,266,269,272,275,278,281,284,287,290,293,296,299,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399;zoom-supported=true;smooth-zoom-supported=false;focus-distances=Infinity,Infinity,Infinity;max-num-detected-faces-hw=0;max-num-detected-faces-sw=0;video-frame-format=android-opaque;video-snapshot-supported=true;video-stabilization=false;video-stabilization-supported=false;jpeg-quality=90;focus-mode=auto;picture-size=1024x768;preview-size=640x480;recording-hint=false;focus-areas=(-498,1,-398,101,1000);metering-areas=(-498,1,-398,101,1000);preview-frame-rate=30;preview-fps-range=10000,30000;horizontal-view-angle=56.5958;vertical-view-angle=43.9775
			    setCameraParameters

			08-30 02:13:33.799 1884-1884/net.sourceforge.opencamera D/CameraController: done
			    After of camera parameter: 
			video-size=1920x1080;preferred-preview-size-for-video=1920x1080;preview-size-values=1920x1080,320x240,720x480,720x576,1280x720,640x480,176x144,1024x768;video-size-values=1920x1080,320x240,720x480,720x576,1280x720,640x480,176x144,1024x768;preview-format=yuv420sp;preview-format-values=yuv420sp,yuv420p;preview-fps-range-values=(10000,30000),(30000,30000);preview-frame-rate-values=30;picture-size-values=640x480,320x240,720x480,720x576,1280x720,1920x1080,2592x1944,1024x768;picture-format=jpeg;picture-format-values=jpeg;jpeg-thumbnail-width=160;jpeg-thumbnail-height=120;jpeg-thumbnail-size-values=96x96,160x120,0x0;jpeg-thumbnail-quality=90;rotation=0;whitebalance=auto;whitebalance-values=auto;effect=none;effect-values=none;antibanding=auto;antibanding-values=auto;focus-mode-values=auto,continuous-picture,continuous-video;max-num-focus-areas=1;focal-length=3.37;exposure-compensation=0;
			max-exposure-compensation=3;min-exposure-compensation=-3;exposure-compensation-step=1;auto-exposure-lock=false;auto-exposure-lock-supported=true;auto-whitebalance-lock=false;auto-whitebalance-lock-supported=true;max-num-metering-areas=1;zoom=0;max-zoom=99;zoom-ratios=100,103,106,109,112,115,118,121,124,127,130,133,136,139,142,145,148,151,154,157,160,163,166,169,172,175,178,181,184,187,190,193,196,199,203,206,209,212,215,218,221,224,227,230,233,236,239,242,245,248,251,254,257,260,263,266,269,272,275,278,281,284,287,290,293,296,299,303,306,309,312,315,318,321,324,327,330,333,336,339,342,345,348,351,354,357,360,363,366,369,372,375,378,381,384,387,390,393,396,399;zoom-supported=true;smooth-zoom-supported=false;focus-distances=Infinity,Infinity,Infinity;max-num-detected-faces-hw=0;max-num-detected-faces-sw=0;video-frame-format=android-opaque;video-snapshot-supported=true;video-stabilization=false;video-stabilization-supported=false;jpeg-quality=90;focus-mode=auto;picture-size=1024x768;preview-size=640x480;recording-hint=false;focus-areas=(-498,1,-398,101,1000);metering-areas=(-498,1,-398,101,1000);preview-frame-rate=30;preview-fps-range=10000,30000;horizontal-view-angle=56.5958;vertical-view-angle=43.9775;
			temp-1=0	*/
		}
		// temp
	}
	// temp


X:\root\myandroid\frameworks\base\core\java\android\hardware\Camera.java
    public class Parameters {
	......................................................................................................
		// temp, regwrite
		private static final String KEY_TEMP_1 = "temp-1";		// Camera register write
        private static final String KEY_TEMP_2 = "temp-2";		// Reserve command
		// temp
	......................................................................................................


X:\root\myandroid\frameworks\av\camera\CameraParameters.cpp
namespace android {
	......................................................................................................
// temp, regwrite
const char CameraParameters::KEY_TEMP_1[] = "temp-1";		// Camera register write
const char CameraParameters::KEY_TEMP_2[] = "temp-2";		// Reserve command
// temp
	......................................................................................................


X:\root\myandroid\frameworks\av\include\camera\CameraParameters.h
class CameraParameters
{
	......................................................................................................
    // temp, regwrite
    static const char KEY_TEMP_1[];
    // Temporary value 1
    static const char KEY_TEMP_2[];
    // Temporary value 2
    // temp
	......................................................................................................


Y:\myandroid\kernel_imx\include\uapi\linux\v4l2-controls.h
///* last CID + 1 */
//#define V4L2_CID_LASTP1                         (V4L2_CID_BASE+43)
// temp, regwrite
#define V4L2_CID_TEMP					(V4L2_CID_BASE+43)

/* last CID + 1 */
#define V4L2_CID_LASTP1					(V4L2_CID_BASE+44)
// temp


Y:\myandroid\bionic\libc\kernel\uapi\linux\v4l2-controls.h
//#define V4L2_CID_LASTP1 (V4L2_CID_BASE + 43)
// temp, regwrite
#define V4L2_CID_TEMP (V4L2_CID_BASE + 43)
#define V4L2_CID_LASTP1 (V4L2_CID_BASE + 44)
// temp


Y:\myandroid\system\media\camera\include\system\camera_metadata_tags.h
/**
 * Main enum for defining camera metadata tags.  New entries must always go
 * before the section _END tag to preserve existing enumeration values.  In
 * addition, the name and type of the tag needs to be added to
 * system/media/camera/src/camera_metadata_tag_info.c
 */
typedef enum camera_metadata_tag {
	......................................................................................................
    // temp, regwrite
    ANDROID_CONTROL_REG_WRITE,		                  // int32        | public
    // temp
    ANDROID_CONTROL_END,
	......................................................................................................


Y:\myandroid\system\media\camera\src\camera_metadata_tag_info.c
static tag_info_t android_control[ANDROID_CONTROL_END -
        ANDROID_CONTROL_START] = {
	......................................................................................................
    // temp, regwrite
	[ ANDROID_CONTROL_REG_WRITE - ANDROID_CONTROL_START ] =
    { "RegWrite",                      TYPE_INT32   },
    // temp
};

int camera_metadata_enum_snprint(uint32_t tag,
                                 uint32_t value,
                                 char *dst,
                                 size_t size) {
	......................................................................................................

		// temp, regwrite
        case ANDROID_CONTROL_REG_WRITE: {
            break;
        }
		// temp
	......................................................................................................


Y:\myandroid\hardware\imx\libcamera3\Metadata.cpp
void Metadata::createSettingTemplate(Metadata& base, Camera& camera,
                                     int request_template)
{
	......................................................................................................
    static const int32_t aeExpCompensation = 0;
    base.addInt32(ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION, 1, &aeExpCompensation);

	// temp, regwrite
    static const int32_t regWriteData = 0;
    base.addInt32(ANDROID_CONTROL_REG_WRITE, 1, &regWriteData);
	// temp
	......................................................................................................


Y:\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\Parameters.cpp
status_t Parameters::updateRequest(CameraMetadata *request) const {
	......................................................................................................
    res = request->update(ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION,
            &exposureCompensation, 1);		// exposureCompensation 값을 ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION 위치에 복사 시키는 명령
	// temp, 확인 결과, camera app에서 Exposure compensation 조절하면 이곳까지 제대로 변경 사항 적용 됨 확인
	ALOGE("%s: exposureCompensation(request->update) = %d", __FUNCTION__,
							exposureCompensation);
	// temp
    if (res != OK) return res;

	// temp, regwrite
	res = request->update(ANDROID_CONTROL_REG_WRITE,
            &regWriteData, 1);
	// 확인 결과, camera app에서 RegWrite 수행하면 이곳까지 제대로 변경 사항 적용 됨 확인
	ALOGE("%s: regWriteData(request->update) = %d", __FUNCTION__,
							regWriteData);
    if (res != OK) return res;
	// temp
	......................................................................................................


Y:\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\Parameters.h
struct Parameters {
	......................................................................................................
    int32_t exposureCompensation;
	// temp, regwrite
	int32_t regWriteData;
	// temp
	......................................................................................................


Y:\myandroid\frameworks\av\services\camera\libcameraservice\api1\client2\Parameters.cpp
status_t Parameters::initialize(const CameraMetadata *info, int deviceVersion) {
	......................................................................................................
    exposureCompensation = 0;
    params.set(CameraParameters::KEY_EXPOSURE_COMPENSATION,
                exposureCompensation);
	......................................................................................................
	// temp, regwrite
	regWriteData = 0;
    params.set(CameraParameters::KEY_TEMP_1,
                regWriteData);
	// temp
	......................................................................................................

status_t Parameters::set(const String8& paramString) {
	......................................................................................................
    // EXPOSURE_COMPENSATION
    validatedParams.exposureCompensation =
        newParams.getInt(CameraParameters::KEY_EXPOSURE_COMPENSATION);
    camera_metadata_ro_entry_t exposureCompensationRange =
        staticInfo(ANDROID_CONTROL_AE_COMPENSATION_RANGE);
	#if 1
	if ((validatedParams.exposureCompensation <
            exposureCompensationRange.data.i32[0]) ||
        (validatedParams.exposureCompensation >
            exposureCompensationRange.data.i32[1])) {
        ALOGE("%s: Requested exposure compensation index is out of bounds: %d",
                __FUNCTION__, validatedParams.exposureCompensation);
        return BAD_VALUE;
    }
    #else
    // temp, regwrite
	if ((validatedParams.exposureCompensation <
				exposureCompensationRange.data.i32[0]) ||
			(validatedParams.exposureCompensation >
				0xffffff)) {						// address_max = 0xffff, data_max = 0xff
			ALOGE("%s: Requested exposure compensation index is out of bounds: %d",
					__FUNCTION__, validatedParams.exposureCompensation);
			return BAD_VALUE;
	}
	// temp
	#endif

	// temp, regwrite
	// KEY_TEMP_1, Camera register write
    validatedParams.regWriteData =
        newParams.getInt(CameraParameters::KEY_TEMP_1);
	if (validatedParams.regWriteData >
				0xffffff) {						// address_max = 0xffff, data_max = 0xff
			ALOGE("%s: Requested regWriteData is out of bounds: %d",
					__FUNCTION__, validatedParams.regWriteData);
			return BAD_VALUE;
	}
	// temp
	......................................................................................................


Y:\myandroid\hardware\imx\libcamera3\Camera.h
class Camera : public camera_info, public SensorData
	......................................................................................................
	// temp, manual exposure
	virtual uint8_t manualExposure(int32_t ae_data) {
        return ANDROID_CONTROL_AE_STATE_INACTIVE;
    }
	// temp

	// temp, regwrite
	virtual uint8_t registerWrite(int32_t reg_data) {
        return ANDROID_CONTROL_AE_STATE_INACTIVE;
    }
	// temp
	......................................................................................................


Y:\myandroid\hardware\imx\libcamera3\Camera.cpp
//do advanced character set.
int32_t Camera::processSettings(sp<Metadata> settings, uint32_t frame)
	......................................................................................................
	// temp, manual exposure	
	int32_t ae_data = 0;
	static int32_t ae_data_backup = 0;

	entry = settings->find(ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION);
    if (entry.count > 0) {
        // ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION
//		ALOGI("ANDROID_CONTROL_AE_EXPOSURE_COMPENSATION");

		ae_data = entry.data.i32[0];
		ALOGV("%s: ae_data = %d", __FUNCTION__, ae_data);

		/*	ae_data가 ae_data_backup 아닌 경우만 노출 계수를 변경해 주고 
			곧바로 변경한 노출계수를 ae_data_backup에 저장시켜서 이후 노출계수 값을 변경하지 않은 경우는 본 노출계수 변경 함수가 실행되지 않도록 함 */
		if(ae_data != ae_data_backup)
		{
			manualExposure(ae_data);
			ae_data_backup = ae_data;
		}
    }
	// temp

	// temp, regwrite	
	int32_t reg_data = 0;
	static int32_t reg_data_backup = 0;

	entry = settings->find(ANDROID_CONTROL_REG_WRITE);
    if (entry.count > 0) {
        // ANDROID_CONTROL_REG_WRITE
//		ALOGI("ANDROID_CONTROL_REG_WRITE");

		reg_data = entry.data.i32[0];
		ALOGV("%s: reg_data = %d, reg_data_backup = %d", __FUNCTION__, reg_data, reg_data_backup);

		/*	reg_data가 reg_data_backup 아닌 경우만 카메라 레지스터 명령을 실행하고 
			마지막 실행한 카메라 레지스트 데이터를 reg_data_backup에 저장시켜서 이후 카메라 레지스터 데이터를 변경하지 않은 경우는 본 카메라 레지스터 명령이 실행되지 않도록 함 */
		/*	Dummy regwrite
			iAddress = 0, iData = 0 인 경우는 ov5640_write_reg 명령이 실행되지 않음(static int OV5640_set_register_write_target(int target)
			cf) 동일한 ov5640_write_reg 명령을 연속으로 수행해야 하는 경우는 아래와 같이 처리해야만 함
				이유) Camera::processSettings 처리 루틴에서 동일한 레지스터 데이터가 아닌 경우만 regwrite 명령이 수행되도록 하기 때문
				1)	정상적으로 ov5640_write_reg 명령이 실행되도록 하고
				2)	iAddress = 0, iData = 0 으로 설정시켜서 Dummy regwrite 명령을 실행시키고
				3)	다시 상기 1)번과 동일한 명령을 실행시키면 됨
			cf)	Open camera, app을 껏다가 켜도 이곳 reg_data_backup 값은 초기화 되지 않고 보존되어 있기 때문에
				한번 카메라 레지스터 명령을 실행시켜서 reg_data_backup 값이 변경된 경우 Open camera, app 껏다가 킨 경우
				아래 registerWrite(reg_data); 명령이 -> registerWrite(0); 자동으로 원하지 않게 한번 실행되는 현상 있음	*/
		if(reg_data != reg_data_backup)
		{
			registerWrite(reg_data);
			reg_data_backup = reg_data;
		}
    }
	// temp
	......................................................................................................


Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.h
class Ov5640Mipi : public Camera
	......................................................................................................
	// temp, manual exposure
	virtual uint8_t manualExposure(int32_t ae_data);
	// temp

	// temp, regwrite
	virtual uint8_t registerWrite(int32_t reg_data);
	// temp
	......................................................................................................


Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.cpp
// temp, manual exposure
uint8_t Ov5640Mipi::manualExposure(int32_t ae_data)
{
    struct v4l2_control c;
    uint8_t ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    int result;

    int32_t fd = open(mDevPath, O_RDWR);
    if (fd < 0) {
        ALOGE("couldn't open device %s", mDevPath);
        return ret;
    }

	ALOGV("%s: ae_data = %d", __func__, ae_data);

    ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    c.id = V4L2_CID_EXPOSURE;
	c.value = ae_data;
 
    result = ioctl(fd, VIDIOC_S_CTRL, &c);
    if (result != 0) {
        ALOGE("ioctl error: %d", result);
        ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    }

    close(fd);

    return ret;
}
// temp

// temp, regwrite
uint8_t Ov5640Mipi::registerWrite(int32_t reg_data)
{
    struct v4l2_control c;
    uint8_t ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    int result;

    int32_t fd = open(mDevPath, O_RDWR);
    if (fd < 0) {
        ALOGE("couldn't open device %s", mDevPath);
        return ret;
    }

	ALOGV("%s: reg_data = %d", __func__, reg_data);

    ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    c.id = V4L2_CID_TEMP;
	c.value = reg_data;
 
    result = ioctl(fd, VIDIOC_S_CTRL, &c);
    if (result != 0) {
        ALOGE("ioctl error: %d", result);
        ret = ANDROID_CONTROL_AE_STATE_INACTIVE;
    }

    close(fd);

    return ret;
}
// temp


Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\mxc_v4l2_capture.c
static int mxc_v4l2_s_ctrl(cam_data *cam, struct v4l2_control *c)
{
	......................................................................................................
	case V4L2_CID_EXPOSURE:
		if (cam->sensor) {
			cam->ae_mode = c->value;
			ret = vidioc_int_s_ctrl(cam->sensor, c);
		} else {
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;

	// temp, regwrite
	case V4L2_CID_TEMP:
		// temp
		pr_debug("cam->sensor = %d, c->value = %d\n", cam->sensor, c->value);
		// temp
		if (cam->sensor) {
//			cam->ae_mode = c->value;
			ret = vidioc_int_s_ctrl(cam->sensor, c);
		} else {
			pr_err("ERROR: v4l2 capture: slave not found!\n");
			ret = -ENODEV;
		}
		break;
	// temp
	......................................................................................................


Y:\myandroid\kernel_imx\drivers\media\platform\mxc\capture\ov5640_mipi.c
static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
	......................................................................................................
	case V4L2_CID_EXPOSURE:			// ((V4L2_CTRL_CLASS_USER | 0x900)+17) = ((0x00980000 | 0x900)+17) = 9963793
		// temp, manual exposure
		pr_debug("In ov5640_mipi:ioctl_s_ctrl->V4L2_CID_EXPOSURE:vc->value = %d\n", vc->value);
		iManualExposureData = vc->value;
		retval = OV5640_set_manual_exposure_target(iManualExposureData);
		// temp
		break;
	// temp, regwrite
	case V4L2_CID_TEMP:				// ((V4L2_CTRL_CLASS_USER | 0x900)+43) = ((0x00980000 | 0x900)+43) = 9963819?
		pr_debug("In ov5640_mipi:ioctl_s_ctrl->V4L2_CID_TEMP:vc->value = %d\n", vc->value);
		retval = OV5640_set_register_write_target(vc->value);
		break;	
	// temp
	......................................................................................................

static __init int ov5640_init(void)
{
	u8 err;

	// temp, regwrite
	printk("<1>ov5640_init of ov5640_mipi.c\n");

	// Initial
	g_stCameraRegister.add3400 = 0x07;
	g_stCameraRegister.add3401 = 0x32;
	g_stCameraRegister.add3402 = 0x04;
	g_stCameraRegister.add3403 = 0x00;
	g_stCameraRegister.add3404 = 0x05;
	g_stCameraRegister.add3405 = 0x36;
	// temp
	......................................................................................................

// temp, regwrite
typedef struct
{
	unsigned char add3400;	// address 0x3400 data
	unsigned char add3401;
	unsigned char add3402;
	unsigned char add3403;
	unsigned char add3404;
	unsigned char add3405;
} CAMERA_REG_DATA;

CAMERA_REG_DATA g_stCameraRegister = {0};
// temp

static int OV5640_set_manual_exposure_target(int target)
{
	......................................................................................................
	#if 0
	ov5640_write_reg(0x3400, 0x07);			// Bit[3:0]: AWB R gain[11:8]
	ov5640_write_reg(0x3401, 0x32);			// Bit[7:0]: AWB R gain[7:0]
	ov5640_write_reg(0x3402, 0x04);			// Bit[3:0]: AWB G gain[11:8]
	ov5640_write_reg(0x3403, 0x00);			// Bit[7:0]: AWB G gain[7:0]
	ov5640_write_reg(0x3404, 0x05);			// Bit[3:0]: AWB B gain[11:8]
	ov5640_write_reg(0x3405, 0x36);			// Bit[7:0]: AWB B gain[7:0]
	#else
	ov5640_write_reg(0x3400, g_stCameraRegister.add3400);			// Bit[3:0]: AWB R gain[11:8]
	ov5640_write_reg(0x3401, g_stCameraRegister.add3401);			// Bit[7:0]: AWB R gain[7:0]
	ov5640_write_reg(0x3402, g_stCameraRegister.add3402);			// Bit[3:0]: AWB G gain[11:8]
	ov5640_write_reg(0x3403, g_stCameraRegister.add3403);			// Bit[7:0]: AWB G gain[7:0]
	ov5640_write_reg(0x3404, g_stCameraRegister.add3404);			// Bit[3:0]: AWB B gain[11:8]
	ov5640_write_reg(0x3405, g_stCameraRegister.add3405);			// Bit[7:0]: AWB B gain[7:0]
	#endif
	......................................................................................................

// temp, regwrite
static int OV5640_set_register_write_target(int target)
{
	int iAddress = 0;
	unsigned char iData = 0;
	
	iAddress = (target >> 8) & 0xffff;
	iData = target & 0xff;

	pr_debug("%s(mipi):iAddress = %d, iData = %d\n", __func__, iAddress, iData);
	pr_debug("%s(mipi):iAddress = 0x%x, iData = 0x%x\n", __func__, iAddress, iData);

	/*	Dummy regwrite
		iAddress = 0, iData = 0 인 경우는 ov5640_write_reg 명령이 실행되지 않음
		cf)	동일한 ov5640_write_reg 명령을 연속으로 수행해야 하는 경우는 아래와 같이 처리해야만 함
			이유)	Camera::processSettings 처리 루틴에서 동일한 레지스터 데이터가 아닌 경우만 regwrite 명령이 수행되도록 하기 때문
			1)	정상적으로 ov5640_write_reg 명령이 실행되도록 하고
			2)	iAddress = 0, iData = 0 으로 설정시켜서 Dummy regwrite 명령을 실행시키고
			3)	다시 상기 1)번과 동일한 명령을 실행시키면 됨	*/
	if(((0 < iAddress) && (iAddress <= 0xffff))
		&& ((0 <= iData) && (iData <= 0xff)))
	{
		ov5640_write_reg(iAddress, iData);
		pr_info("%s: register write OK!\n", __func__);

		switch(iAddress)
		{
			case 0x3400:
				g_stCameraRegister.add3400 = iData;
				break;
			case 0x3401:
				g_stCameraRegister.add3401 = iData;
				break;
			case 0x3402:
				g_stCameraRegister.add3402 = iData;
				break;
			case 0x3403:
				g_stCameraRegister.add3403 = iData;
				break;
			case 0x3404:
				g_stCameraRegister.add3404 = iData;
				break;
			case 0x3405:
				g_stCameraRegister.add3405 = iData;
				break;
		}		
	}
	else
	{
		pr_info("%s: register write FAIL!\n", __func__);
	}

	return 0;
}
// temp


//fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3fix3


//Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4
============== Nitrogen6-MAX Device driver, 실제 카메라 캡쳐/촬영 버튼을 누르면 실행되는 Routine  ================

1-1.핵심 사항
	카메라(1024 x 768 해상도) 캡쳐/촬영 버튼을 누르면 카메라 해상도를
	1)	Width * Height 1024 x 768 format NV12, fps: 15으로 설정해서 해당 해상도로 캡쳐한 다음
	2)	Width * Height 640 x 480 format NV12, fps: 15으로 다시 복귀해서 LCD Preview 화면을 보여 주는 것으로 보임
	cf)	참고로, 카메라 해상도가 1920 x 1080 인 경우는 아래와 같음
		1)	Width * Height 1920 x 1080 format NV12, fps: 15으로 설정해서 해당 해상도로 캡쳐한 다음
		2)	Width * Height 1280 x 720 format NV12, fps: 15으로 다시 복귀해서 LCD Preview 화면을 보여 주는 것으로 보임
		08-24 03:39:12.638 236-319/? I/FslCameraHAL: virtual int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
	    virtual int32_t USPStream::onDeviceConfigureLocked()
	    virtual int32_t MMAPStream::onDeviceConfigureLocked()
	    Width * Height 1920 x 1080 format NV12, fps: 15
		08-24 03:39:13.259 236-319/? I/FslCameraHAL: virtual int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
	    virtual int32_t USPStream::onDeviceConfigureLocked()
	    virtual int32_t MMAPStream::onDeviceConfigureLocked()
	    Width * Height 1280 x 720 format NV12, fps: 15


1.	전체 Routine(Android studio Logcat 정보)
08-24 02:53:41.470 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:37 Settings:0x0
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:41.733 1484-1484/net.sourceforge.opencamera D/MainActivity: clickedTakePhoto
    takePicture
    close popup
08-24 02:53:41.733 1484-1484/net.sourceforge.opencamera D/Preview: takePicturePressed
    startCameraPreview
08-24 02:53:41.734 1484-1484/net.sourceforge.opencamera D/Preview: setPreviewPaused: false
    showGUI: true
08-24 02:53:41.735 1484-1484/net.sourceforge.opencamera D/Preview: n_burst: 1
    takePicture
    removing location data from parameters...
08-24 02:53:41.736 236-511/? V/Camera2Client: getParameters: Camera 0
08-24 02:53:41.736 235-262/? I/audio_hw_primary: start_output_stream_primary... -1427282624, device 2
08-24 02:53:41.737 1484-1484/net.sourceforge.opencamera D/CameraController: setCameraParameters
08-24 02:53:41.738 236-839/? V/Camera2Client: setParameters: Camera 0
08-24 02:53:41.738 236-839/? V/Camera2-Parameters: set: Preview FPS value is used from 'range'
    set: Preview FPS range (10, 30)
08-24 02:53:41.739 236-839/? V/Camera2-Parameters: Picture size has not been overridden. Skip checking
    Array aspect: 1.333333, still aspect: 1.333333
    Horiz crop factor: 1.000000, vert crop fact: 1.000000
    Current still picture FOV: 56.595833 x 43.977539 deg
08-24 02:53:41.739 235-262/? W/audio_hw_primary: card 0, port 0 device 0x2
    rate 44100, channel 2 period_size 0xc0
08-24 02:53:41.739 236-839/? V/Camera2Client: updateRequests: Camera 0: state = 3
08-24 02:53:41.740 236-839/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:41.740 236-839/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:41.740 236-839/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:41.740 236-839/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:41.740 236-839/? V/Camera2Client: startPreviewL: state == 3, restart = 1
08-24 02:53:41.740 236-839/? V/Camera2-StreamingProcessor: startStream: Camera 0: type = 1
08-24 02:53:41.741 236-839/? E/Camera3-Device: setStreamingRequest: In Camera3Device::setStreamingRequest
08-24 02:53:41.741 236-839/? V/Camera3-Device: convertMetadataListToRequestListLocked: requestId = 10000008
    unpauseForNewRequests: RequestThread: Going active
    Camera 0: Capture request 10000008 enqueued
08-24 02:53:41.741 1484-1484/net.sourceforge.opencamera D/CameraController: done
08-24 02:53:41.741 1484-1484/net.sourceforge.opencamera D/Preview: showGUI: false
08-24 02:53:41.743 1484-1484/net.sourceforge.opencamera D/MainActivity: close popup
08-24 02:53:41.743 1484-1484/net.sourceforge.opencamera D/Preview: focus_value is focus_mode_manual
    takePictureWhenFocused
    focus_value is focus_mode_manual
    focus_success is 1
    remaining_burst_photos: 0
08-24 02:53:41.765 1484-1484/net.sourceforge.opencamera D/Preview: getImageVideoRotation() from current_rotation 0
    getImageVideoRotation() returns current_rotation 0
08-24 02:53:41.765 236-511/? V/Camera2Client: getParameters: Camera 0
08-24 02:53:41.767 1484-1484/net.sourceforge.opencamera D/CameraController: setCameraParameters
08-24 02:53:41.767 236-839/? V/Camera2Client: setParameters: Camera 0
08-24 02:53:41.767 236-839/? V/Camera2-Parameters: set: Preview FPS value is used from 'range'
    set: Preview FPS range (10, 30)
08-24 02:53:41.768 236-839/? V/Camera2-Parameters: Picture size has not been overridden. Skip checking
    Array aspect: 1.333333, still aspect: 1.333333
    Horiz crop factor: 1.000000, vert crop fact: 1.000000
    Current still picture FOV: 56.595833 x 43.977539 deg
08-24 02:53:41.768 236-839/? V/Camera2Client: updateRequests: Camera 0: state = 3
08-24 02:53:41.768 236-839/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:41.768 236-839/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:41.768 236-839/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:41.768 236-839/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
08-24 02:53:41.769 236-839/? V/Camera2-Parameters: Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:41.769 236-839/? V/Camera2Client: startPreviewL: state == 3, restart = 1
08-24 02:53:41.769 236-839/? V/Camera2-StreamingProcessor: startStream: Camera 0: type = 1
08-24 02:53:41.769 236-839/? E/Camera3-Device: setStreamingRequest: In Camera3Device::setStreamingRequest
08-24 02:53:41.769 236-839/? V/Camera3-Device: convertMetadataListToRequestListLocked: requestId = 10000009
    unpauseForNewRequests: RequestThread: Going active
    Camera 0: Capture request 10000009 enqueued
08-24 02:53:41.769 1484-1484/net.sourceforge.opencamera D/CameraController: done
08-24 02:53:41.769 1484-1484/net.sourceforge.opencamera D/Preview: enable_sound? true
08-24 02:53:41.770 236-236/? V/Camera2Client: sendCommand: Camera 0: Command 4 (1, 0)
08-24 02:53:41.770 1484-1484/net.sourceforge.opencamera D/Preview: about to call takePicture
08-24 02:53:41.772 236-511/? V/Camera2Client: commandStopFaceDetectionL: Camera 0: Stopping face detection
    takePicture: Camera 0: Starting picture capture
08-24 02:53:42.074 236-1518/? V/Camera3-Device: prepareHalRequests: Request settings are NEW
08-24 02:53:42.076 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000007, frameNumber = 36, burstId = 0, partialResultCount = 0
08-24 02:53:42.078 236-319/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 36 from InFlightMap
08-24 02:53:42.078 236-319/? V/FslCameraHAL: processSettings: ae_data = 1
08-24 02:53:42.080 236-319/? V/Camera3-Device: Camera 0: notifyShutter: Shutter fired for frame 37 (id 10000007) at 291049974700
08-24 02:53:42.080 236-319/? V/Camera2Client: notifyShutter: Shutter notification for request id 10000007 at time 291049974700
08-24 02:53:42.080 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000007, frameNumber = 37, burstId = 0, partialResultCount = 0
08-24 02:53:42.081 236-319/? V/Camera3-Device: insertResultLocked: result requestId = 10000007, frameNumber = 37, burstId = 0
08-24 02:53:42.096 236-1518/? V/Camera3-Device: prepareHalRequests: registered in flight requestId = 10000009, frameNumber = 38, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-24 02:53:42.096 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:38 Settings:0xa9756900
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:42.097 236-1520/? V/Camera3-Device: createDefaultRequest: for template 2
08-24 02:53:42.098 236-1520/? I/FslCameraHAL: const camera_metadata_t *Camera::constructDefaultRequestSettings(int32_t):0: type=2
08-24 02:53:42.098 1484-1484/net.sourceforge.opencamera D/Preview: takePicture exit
08-24 02:53:42.098 1484-1484/net.sourceforge.opencamera E/Preview: End of takePicture()
08-24 02:53:42.098 236-1520/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:42.098 236-1520/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
08-24 02:53:42.099 236-1520/? V/Camera2-Parameters: Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:42.099 236-1520/? V/Camera3-Device: triggerPrecaptureMetering: Triggering precapture metering, id 1
08-24 02:53:42.160 235-261/? W/audio_hw_primary: ret -32, pcm write 768 error start error: hw 0x0 app 0x0 avail 0x0
    : Unknown error -32
08-24 02:53:42.195 235-262/? W/AudioFlinger: write blocked for 375 msecs, 5 delayed writes, thread 0xaa983e80
08-24 02:53:42.698 236-1518/? V/Camera3-Device: insertTriggers: tag = 65542
    insertTriggers: Mixed in trigger aePrecaptureTrigger, value 1
08-24 02:53:42.699 236-1518/? V/Camera3-Device: insertTriggers: tag = 65566
    insertTriggers: parent->mDeviceVersion = 768
    insertTriggers: Mixed in trigger aePrecaptureId, value 1
    prepareHalRequests: Request settings are NEW
08-24 02:53:42.699 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000007, frameNumber = 37, burstId = 0, partialResultCount = 0
08-24 02:53:42.700 236-319/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 37 from InFlightMap
08-24 02:53:42.701 236-319/? V/FslCameraHAL: processSettings: ae_data = 1
08-24 02:53:42.703 236-319/? V/Camera3-Device: Camera 0: notifyShutter: Shutter fired for frame 38 (id 10000009) at 291672345367
08-24 02:53:42.703 236-319/? V/Camera2Client: notifyShutter: Shutter notification for request id 10000009 at time 291672345367
08-24 02:53:42.703 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 38, burstId = 0, partialResultCount = 0
08-24 02:53:42.704 236-319/? V/Camera3-Device: insertResultLocked: result requestId = 10000009, frameNumber = 38, burstId = 0
08-24 02:53:42.704 236-1518/? V/Camera3-Device: prepareHalRequests: registered in flight requestId = 10000009, frameNumber = 39, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-24 02:53:42.705 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:39 Settings:0xa14ff000
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:43.101 236-1520/? W/Camera2-CaptureSequencer: Timed out waiting for precapture start
08-24 02:53:43.101 236-1520/? V/Camera3-Device: Camera 0: Clearing repeating request
    convertMetadataListToRequestListLocked: requestId = 30000000
    unpauseForNewRequests: RequestThread: Going active
    Camera 0: Capture request 30000000 enqueued
08-24 02:53:43.322 236-1518/? V/Camera3-Device: prepareHalRequests: Request settings are NEW
08-24 02:53:43.323 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 38, burstId = 0, partialResultCount = 0
08-24 02:53:43.325 236-319/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 38 from InFlightMap
08-24 02:53:43.325 236-319/? I/FslCameraHAL: ae precature trigger
08-24 02:53:43.325 236-319/? V/FslCameraHAL: processSettings: ae_data = 1
08-24 02:53:43.327 236-319/? V/Camera3-Device: Camera 0: notifyShutter: Shutter fired for frame 39 (id 10000009) at 292296734033
08-24 02:53:43.327 236-319/? V/Camera2Client: notifyShutter: Shutter notification for request id 10000009 at time 292296734033
08-24 02:53:43.327 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 39, burstId = 0, partialResultCount = 0
08-24 02:53:43.328 236-319/? V/Camera3-Device: insertResultLocked: result requestId = 10000009, frameNumber = 39, burstId = 0
08-24 02:53:43.328 236-1519/? V/Camera2Client: notifyAutoExposure: Autoexposure state now 2, last trigger 1
08-24 02:53:43.330 236-1518/? V/Camera3-Device: prepareHalRequests: registered in flight requestId = 30000000, frameNumber = 40, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-24 02:53:43.330 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:40 Settings:0x9deec000
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:43.946 236-1518/? I/FslCameraHAL: int32_t VideoStream::configure(sp<Stream>): w:640, h:480, sensor format:0x103, stream format:0x103, fps:15, num:3
08-24 02:53:43.947 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 39, burstId = 0, partialResultCount = 0
08-24 02:53:43.948 236-319/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 39 from InFlightMap
08-24 02:53:43.996 236-1518/? V/Camera3-Device: waitForNextRequestLocked: RequestThread: Going idle
08-24 02:53:44.439 236-319/? I/FslCameraHAL: freeBufferToIon buffer num:3
08-24 02:53:44.440 236-319/? I/FslCameraHAL: virtual int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
    virtual int32_t USPStream::onDeviceConfigureLocked()
    virtual int32_t MMAPStream::onDeviceConfigureLocked()
    Width * Height 1024 x 768 format NV12, fps: 15
08-24 02:53:44.669 236-319/? I/FslCameraHAL: allocateBufferFromIon buffer num:2
08-24 02:53:44.680 236-319/? I/FslCameraHAL: phyalloc ptr:0x0xa08eb000, phy:0x34900000, ionSize:1183744
08-24 02:53:44.691 236-319/? I/FslCameraHAL: phyalloc ptr:0x0xa07ca000, phy:0x34b00000, ionSize:1183744
08-24 02:53:44.692 236-319/? I/FslCameraHAL: virtual int32_t USPStream::onDeviceStartLocked() VIDIOC_QBUF phy:0x34900000
    virtual int32_t USPStream::onDeviceStartLocked() VIDIOC_QBUF phy:0x34b00000
08-24 02:53:44.692 236-319/? V/FslCameraHAL: processSettings: ae_data = 1
08-24 02:53:44.693 236-319/? V/Camera3-Device: Camera 0: notifyShutter: Shutter fired for frame 40 (id 30000000) at 293663517700
08-24 02:53:44.694 236-319/? V/Camera2Client: notifyShutter: Shutter notification for request id 30000000 at time 293663517700
08-24 02:53:44.694 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 30000000, frameNumber = 40, burstId = 0, partialResultCount = 0
    insertResultLocked: result requestId = 30000000, frameNumber = 40, burstId = 0
08-24 02:53:44.695 243-651/? D/NuPlayerDriver: seekTo(0xb3d0c840) 0 ms at state 4
    notifyListener_l(0xb3d0c840), (7, 0, 0), loop setting(0, 0)
08-24 02:53:44.696 243-1511/? I/GenericSource: start
08-24 02:53:44.699 243-270/? D/NuPlayerDriver: start(0xb3d0c840), state is 4, eos is 0
08-24 02:53:44.700 236-1519/? V/Camera2Client: notifyAutoExposure: Autoexposure state now 0, last trigger 1
08-24 02:53:44.706 1484-1484/net.sourceforge.opencamera D/CameraController: shutterCallback.onShutter()
08-24 02:53:44.711 243-1511/? D/NuPlayerDriver: notifyListener_l(0xb3d0c840), (4, 0, 0), loop setting(0, 0)
08-24 02:53:44.714 243-1541/? I/MediaPlayerService: MediaPlayerService::getOMX
08-24 02:53:44.714 243-1541/? I/OMXClient: MuxOMX ctor
08-24 02:53:44.715 240-844/? I/OMXMaster: makeComponentInstance(OMX.google.vorbis.decoder) in mediacodec process
08-24 02:53:44.719 240-252/? E/OMXNodeInstance: setConfig(f0003d:google.vorbis.decoder, ConfigPriority(0x6f800002)) ERROR: Undefined(0x80001001)
08-24 02:53:44.719 243-1541/? I/ACodec: codec does not support config priority (err -2147483648)
08-24 02:53:44.721 243-1541/? I/MediaCodec: MediaCodec will operate in async mode
08-24 02:53:44.741 243-1539/? D/AudioTrack: Client defaulted notificationFrames to 8071 for frameCount 24215
08-24 02:53:44.743 243-1511/? D/NuPlayerDriver: notifyListener_l(0xb3d0c840), (6, 0, 0), loop setting(0, 0)
08-24 02:53:44.763 243-1539/? W/AudioTrack: getTimestamp() location moved from kernel to server
08-24 02:53:44.768 243-1540/? I/NuPlayerDecoder: [audio] saw output EOS
08-24 02:53:44.792 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 30000000, frameNumber = 40, burstId = 0, partialResultCount = 0
08-24 02:53:44.793 236-319/? E/FslCameraHAL: getGpsCoordinates: error reading jpeg Coordinates tag
    getGpsTimeStamp: error reading jpeg TimeStamp tag
    getGpsProcessingMethod: error reading jpeg ProcessingMethod tag
08-24 02:53:44.793 236-319/? I/FslCameraHAL: int32_t Stream::processJpegBuffer(StreamBuffer &, sp<Metadata>) srcStream->mWidth:1024, srcStream->mHeight:768, v4l2Width:1024, v4l2Height:768
08-24 02:53:44.808 236-319/? E/vpu-lib: chmod failed
08-24 02:53:44.812 236-319/? I/vpu-lib: Product Info: i.MX6Q/D/S
08-24 02:53:44.812 236-319/? I/FslCameraHAL: vpu lib version : major.minor.rel=5.4.36 
    vpu fw version : major.minor.rel_rcode=3.1.1_r46075 
08-24 02:53:44.814 236-319/? I/vpu-lib: <gpu> alloc handle: 0xa14fa930, paddr: 0x2ef94000, vaddr: 0xa4494000
    <gpu> alloc handle: 0xa14fa920, paddr: 0x2ea1b000, vaddr: 0xa3f1b000
08-24 02:53:44.815 236-319/? I/vpu-lib: <gpu> alloc handle: 0xa16b9060, paddr: 0x2f116000, vaddr: 0xa4616000
08-24 02:53:44.817 236-319/? I/vpu-lib: <gpu> alloc handle: 0xa16b90a0, paddr: 0x2f268000, vaddr: 0xa4768000
08-24 02:53:44.818 236-319/? I/vpu-lib: <gpu> alloc handle: 0xa16b90c0, paddr: 0x2f3ba000, vaddr: 0xa48ba000
08-24 02:53:44.823 236-319/? I/vpu-lib: <gpu> free handle: 0xa14fa920, paddr: 0x2ea1b000, vaddr: 0xa3f1b000
08-24 02:53:44.824 236-319/? I/vpu-lib: <gpu> free handle: 0xa14fa930, paddr: 0x2ef94000, vaddr: 0xa4494000
    <gpu> free handle: 0xa16b9060, paddr: 0x2f116000, vaddr: 0xa4616000
    <gpu> free handle: 0xa16b90a0, paddr: 0x2f268000, vaddr: 0xa4768000
    <gpu> free handle: 0xa16b90c0, paddr: 0x2f3ba000, vaddr: 0xa48ba000
08-24 02:53:44.825 236-319/? I/FslCameraHAL: insertExifThumbnailImage. ReplaceThumbnail(). ret=1
08-24 02:53:44.826 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 30000000, frameNumber = 40, burstId = 0, partialResultCount = 0
    removeInFlightRequestIfReadyLocked: removed frame 40 from InFlightMap
08-24 02:53:44.826 236-1517/? V/Camera3-Device: notifyStatus: Camera 0: Now idle
08-24 02:53:44.839 236-1520/? V/Camera3-Device: waitUntilDrainedLocked: Camera 0: Waiting until idle
08-24 02:53:44.841 1484-1484/net.sourceforge.opencamera D/Preview: onPictureTaken
08-24 02:53:44.846 1484-1484/net.sourceforge.opencamera D/MainActivity: getOutputMediaFile returns: /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg
08-24 02:53:44.847 1484-1484/net.sourceforge.opencamera D/Preview: save to: /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg
08-24 02:53:44.851 1484-1484/net.sourceforge.opencamera D/Preview: onPictureTaken saved photo
08-24 02:53:44.851 1484-1484/net.sourceforge.opencamera D/MainActivity: broadcastFile
08-24 02:53:44.860 1484-1484/net.sourceforge.opencamera D/Preview: pause_preview? false
    startCameraPreview
    starting the camera preview
    setRecordingHint: false
08-24 02:53:44.861 236-839/? V/Camera2Client: getParameters: Camera 0
08-24 02:53:44.862 1484-1484/net.sourceforge.opencamera D/CameraController: setCameraParameters
08-24 02:53:44.863 236-236/? V/Camera2Client: setParameters: Camera 0
08-24 02:53:44.863 236-236/? V/Camera2-Parameters: set: Preview FPS value is used from 'range'
    set: Preview FPS range (10, 30)
    Picture size has not been overridden. Skip checking
    Array aspect: 1.333333, still aspect: 1.333333
    Horiz crop factor: 1.000000, vert crop fact: 1.000000
    Current still picture FOV: 56.595833 x 43.977539 deg
08-24 02:53:44.864 236-236/? V/Camera2Client: updateRequests: Camera 0: state = 1
08-24 02:53:44.864 236-236/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:44.864 236-236/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:44.864 236-236/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:44.864 236-236/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:44.864 1484-1484/net.sourceforge.opencamera D/CameraController: done
08-24 02:53:44.865 236-511/? V/Camera2Client: startPreview: E
    startPreviewL: state == 1, restart = 0
08-24 02:53:44.865 236-511/? E/Camera2-Parameters: updateRequest: exposureCompensation(request->update) = 1
08-24 02:53:44.865 236-511/? V/Camera2-Parameters: Zoom maxDigital=4.000000, increment=0.030303, ratio=1.000000, previewWidth=640, previewHeight=480, activeWidth=2592, activeHeight=1944
    Crop region calculated (x=0,y=0,w=2592.000000,h=1944.000000) for zoom=0
08-24 02:53:44.865 236-511/? V/Camera2-StreamingProcessor: startStream: Camera 0: type = 1
08-24 02:53:44.865 236-511/? E/Camera3-Device: setStreamingRequest: In Camera3Device::setStreamingRequest
08-24 02:53:44.865 236-511/? V/Camera3-Device: convertMetadataListToRequestListLocked: requestId = 10000010
    unpauseForNewRequests: RequestThread: Going active
08-24 02:53:44.865 236-1518/? V/Camera3-Device: prepareHalRequests: Request settings are NEW
08-24 02:53:44.865 236-1517/? V/Camera3-Device: notifyStatus: Camera 0: Now active
08-24 02:53:44.865 236-511/? V/Camera3-Device: Camera 0: Capture request 10000010 enqueued
08-24 02:53:44.866 236-1518/? V/Camera3-Device: prepareHalRequests: registered in flight requestId = 10000010, frameNumber = 41, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-24 02:53:44.866 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:41 Settings:0xa0da7a00
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:44.866 236-1518/? I/FslCameraHAL: int32_t VideoStream::configure(sp<Stream>): w:1024, h:768, sensor format:0x103, stream format:0x103, fps:15, num:2
08-24 02:53:44.866 236-1518/? V/Camera3-Device: prepareHalRequests: Request settings are REUSED
    prepareHalRequests: registered in flight requestId = 10000010, frameNumber = 42, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-24 02:53:44.866 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:42 Settings:0x0
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:44.867 1484-1484/net.sourceforge.opencamera D/Preview: time after starting camera preview: 6
    setPreviewPaused: false
    showGUI: true
08-24 02:53:44.868 1484-1484/net.sourceforge.opencamera D/Preview: showGUI: true
08-24 02:53:44.869 1484-1484/net.sourceforge.opencamera D/Preview: onPictureTaken started preview
08-24 02:53:44.906 990-1544/android.process.media I/ExifInterface_JNI: Raw image not detected
08-24 02:53:44.933 236-319/? I/FslCameraHAL: freeBufferToIon buffer num:2
08-24 02:53:44.934 236-319/? I/FslCameraHAL: virtual int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
    virtual int32_t USPStream::onDeviceConfigureLocked()
    virtual int32_t MMAPStream::onDeviceConfigureLocked()
    Width * Height 640 x 480 format NV12, fps: 15
08-24 02:53:44.936 1484-1496/net.sourceforge.opencamera D/ExternalStorage: Scanned /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg:
    -> uri=content://media/external/images/media/86
    
    --------- beginning of system
08-24 02:53:44.945 514-1258/system_process W/ActivityManager: android.hardware.action.NEW_PICTURE no longer allowed; dropping from u0a54
08-24 02:53:44.965 1484-1496/net.sourceforge.opencamera D/MainActivity: file_path: /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg
    file_name: IMG_20180824_025344.jpg
    mime_type: image/jpeg


2.	핵심 일부분 Routine(Android studio Logcat 정보)
08-24 02:53:43.946 236-1518/? I/FslCameraHAL: int32_t VideoStream::configure(sp<Stream>): w:640, h:480, sensor format:0x103, stream format:0x103, fps:15, num:3
08-24 02:53:43.947 236-319/? V/Camera3-Device: processCaptureResult: got InFlightRequest requestId = 10000009, frameNumber = 39, burstId = 0, partialResultCount = 0
08-24 02:53:43.948 236-319/? V/Camera3-Device: removeInFlightRequestIfReadyLocked: removed frame 39 from InFlightMap
08-24 02:53:43.996 236-1518/? V/Camera3-Device: waitForNextRequestLocked: RequestThread: Going idle
08-24 02:53:44.439 236-319/? I/FslCameraHAL: freeBufferToIon buffer num:3
08-24 02:53:44.440 236-319/? I/FslCameraHAL: virtual int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
    virtual int32_t USPStream::onDeviceConfigureLocked()
    virtual int32_t MMAPStream::onDeviceConfigureLocked()
    Width * Height 1024 x 768 format NV12, fps: 15
......................................................................................................................................
08-24 02:53:44.841 1484-1484/net.sourceforge.opencamera D/Preview: onPictureTaken
08-24 02:53:44.846 1484-1484/net.sourceforge.opencamera D/MainActivity: getOutputMediaFile returns: /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg
08-24 02:53:44.847 1484-1484/net.sourceforge.opencamera D/Preview: save to: /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg
08-24 02:53:44.851 1484-1484/net.sourceforge.opencamera D/Preview: onPictureTaken saved photo
08-24 02:53:44.851 1484-1484/net.sourceforge.opencamera D/MainActivity: broadcastFile
08-24 02:53:44.860 1484-1484/net.sourceforge.opencamera D/Preview: pause_preview? false
    startCameraPreview
    starting the camera preview
    setRecordingHint: false
......................................................................................................................................
08-24 02:53:44.866 236-1518/? I/FslCameraHAL: int32_t VideoStream::configure(sp<Stream>): w:1024, h:768, sensor format:0x103, stream format:0x103, fps:15, num:2
08-24 02:53:44.866 236-1518/? V/Camera3-Device: prepareHalRequests: Request settings are REUSED
    prepareHalRequests: registered in flight requestId = 10000010, frameNumber = 42, burstId = 0.
    threadLoop: 3161: submitting 1 requests in a batch.
08-24 02:53:44.866 236-1518/? V/FslCameraHAL: int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Request Frame:42 Settings:0x0
    int32_t Camera::processCaptureRequest(camera3_capture_request_t *):0: Capturing new frame.
08-24 02:53:44.867 1484-1484/net.sourceforge.opencamera D/Preview: time after starting camera preview: 6
    setPreviewPaused: false
    showGUI: true
08-24 02:53:44.868 1484-1484/net.sourceforge.opencamera D/Preview: showGUI: true
08-24 02:53:44.869 1484-1484/net.sourceforge.opencamera D/Preview: onPictureTaken started preview
08-24 02:53:44.906 990-1544/android.process.media I/ExifInterface_JNI: Raw image not detected
08-24 02:53:44.933 236-319/? I/FslCameraHAL: freeBufferToIon buffer num:2
08-24 02:53:44.934 236-319/? I/FslCameraHAL: virtual int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
    virtual int32_t USPStream::onDeviceConfigureLocked()
    virtual int32_t MMAPStream::onDeviceConfigureLocked()
    Width * Height 640 x 480 format NV12, fps: 15
08-24 02:53:44.936 1484-1496/net.sourceforge.opencamera D/ExternalStorage: Scanned /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg:
    -> uri=content://media/external/images/media/86
    
    --------- beginning of system
08-24 02:53:44.945 514-1258/system_process W/ActivityManager: android.hardware.action.NEW_PICTURE no longer allowed; dropping from u0a54
08-24 02:53:44.965 1484-1496/net.sourceforge.opencamera D/MainActivity: file_path: /storage/emulated/0/DCIM/OpenCamera/IMG_20180824_025344.jpg
    file_name: IMG_20180824_025344.jpg
    mime_type: image/jpeg


3.	상단 "Width * Height 2592 x 1944 format NV12, fps: 15" 문구는 아래 과정을 통해서 출력되는 문구 임

Y:\myandroid\hardware\imx\libcamera3\Ov5640Mipi.cpp
// configure device.
int32_t Ov5640Mipi::OvStream::onDeviceConfigureLocked()
{
    ALOGI("%s", __func__);
    int32_t ret = 0;
    if (mDev <= 0) {
        ALOGE("%s invalid fd handle", __func__);
        return BAD_VALUE;
    }

    int32_t input = 1;
    ret = ioctl(mDev, VIDIOC_S_INPUT, &input);
    if (ret < 0) {
        ALOGE("%s VIDIOC_S_INPUT Failed: %s", __func__, strerror(errno));
        return ret;
    }

    return USPStream::onDeviceConfigureLocked();
}

// configure device.
int32_t USPStream::onDeviceConfigureLocked()
{
    ALOGI("%s", __func__);
    int32_t ret = 0;
    if (mDev <= 0) {
        ALOGE("%s invalid fd handle", __func__);
        return BAD_VALUE;
    }

    return MMAPStream::onDeviceConfigureLocked();
}

// configure device.
int32_t MMAPStream::onDeviceConfigureLocked()
{
    ALOGI("%s", __func__);
    int32_t ret = 0;
    if (mDev <= 0) {
        ALOGE("%s invalid fd handle", __func__);
        return BAD_VALUE;
    }

    int32_t fps = mFps;
    int32_t vformat;
    vformat = convertPixelFormatToV4L2Format(mFormat);

    if ((mWidth > 1920) || (mHeight > 1080)) {
        fps = 15;
    }

    ALOGI("Width * Height %d x %d format %c%c%c%c, fps: %d",
          mWidth, mHeight, vformat&0xFF, (vformat>>8)&0xFF,
          (vformat>>16)&0xFF, (vformat>>24)&0xFF, fps);

    struct v4l2_streamparm param;
    memset(&param, 0, sizeof(param));
    param.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    param.parm.capture.timeperframe.numerator   = 1;
    param.parm.capture.timeperframe.denominator = fps;
    param.parm.capture.capturemode = mCamera->getCaptureMode(mWidth, mHeight);
    ret = ioctl(mDev, VIDIOC_S_PARM, &param);
    if (ret < 0) {
        ALOGE("%s: VIDIOC_S_PARM Failed: %s", __func__, strerror(errno));
        return ret;
    }

    struct v4l2_format fmt;
    memset(&fmt, 0, sizeof(fmt));
    fmt.type                 = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    fmt.fmt.pix.width        = mWidth & 0xFFFFFFF8;
    fmt.fmt.pix.height       = mHeight & 0xFFFFFFF8;
    fmt.fmt.pix.pixelformat  = vformat;
    fmt.fmt.pix.priv         = 0;
    fmt.fmt.pix.sizeimage    = 0;
    fmt.fmt.pix.bytesperline = 0;

    // Special stride alignment for YU12
    if (vformat == v4l2_fourcc('Y', 'U', '1', '2')){
        // Goolge define the the stride and c_stride for YUV420 format
        // y_size = stride * height
        // c_stride = ALIGN(stride/2, 16)
        // c_size = c_stride * height/2
        // size = y_size + c_size * 2
        // cr_offset = y_size
        // cb_offset = y_size + c_size
        // int stride = (width+15)/16*16;
        // int c_stride = (stride/2+16)/16*16;
        // y_size = stride * height
        // c_stride = ALIGN(stride/2, 16)
        // c_size = c_stride * height/2
        // size = y_size + c_size * 2
        // cr_offset = y_size
        // cb_offset = y_size + c_size

        // GPU and IPU take below stride calculation
        // GPU has the Y stride to be 32 alignment, and UV stride to be
        // 16 alignment.
        // IPU have the Y stride to be 2x of the UV stride alignment
        int32_t stride = (mWidth+31)/32*32;
        int32_t c_stride = (stride/2+15)/16*16;
        fmt.fmt.pix.bytesperline = stride;
        fmt.fmt.pix.sizeimage    = stride*mHeight+c_stride * mHeight;
        ALOGI("Special handling for YV12 on Stride %d, size %d",
            fmt.fmt.pix.bytesperline,
            fmt.fmt.pix.sizeimage);
    }

    ret = ioctl(mDev, VIDIOC_S_FMT, &fmt);
    if (ret < 0) {
        ALOGE("%s: VIDIOC_S_FMT Failed: %s", __func__, strerror(errno));
        return ret;
    }

    return 0;
}















//Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4Routine4

[72]	간이 RFID Writing(2K, NESSLAB)
	1)	Windows7에서 동작시키기
		EXAX_HF_15693.exe, EXAX_HF_15693__________.exe 실행파일을 번갈아 가면서 실행시킨 다음
		EXAX_HF_15693__________.exe 실행 시키면 정상적으로 동작되는 것 같다.




[73]	Adobe Reader 검색기능 사용 시 "클립보드로 복사하는 과정에서 오류가 있습니다." 오류 발생 문제 해결
	1)	기본설정 -> 페이지표시 -> [ ]페이지 캐시 사용(P) 항목을 체크 해제




[74]	형광측정
	1-1)형광측정 원리
		빛을 흡수하여 들뜬 분자는 어떻게 되는가? 
		분자가 자외선이나 가시광선을 흡수하게 되면 바닥 상태에 있는 전자가 높은 에너지 상태로 들뜨게 된다. 흡수한 빛 에너지가,  
		결합에너지나 구조 변화를 일어나게 하는데 필요한 에너지 보다 크다면, 일부 분자는 분해되거나(광분해) 구조 변화(광이성질화)��� 일으키게 된다. 
		그렇지 않다면,  분자는 흡수된 빛 에너지를 보통  열에너지로 내어놓으면서 다시 바닥 상태로 되돌아 ��다. 그러나 어떤 분자들은 빛을 내면서 바닥 상태로 되돌아 가는데, 이를 형광이라 한다. 
		형광은 흡수된 빛 에너지 보다 약간 적은 에너지의 빛으로 나온다. 즉, 형광의 파장은 흡수된 빛의 파장보다 약간 길다. 

		빛을 흡수한 분자에서 일어나는 분자내 및 분자간 과정. 작은 파란색 원은 들뜬 분자의 낮은 에너지 상태의 빈 자리이다.
		분자의 진동 상태 때문에 형광 에너지는 흡광 에너지보다 적고, 따라서 흡수한 빛 보다 긴 파장에서 형광이 나온다.

	1)	Photo bleaching
		->	Life technologies 사이트에서 해당 형광다이의 스펙 중에서
			Photostability in buffer 와 Photostability in antifade 가 Photo bleaching에 어느 정도 강한지 나타내는 지표임
			이유)	Photostability in buffer 항목에 마우스를 가져다 대면 하기와 같은 설명이 나옮
					:	Relative measure of the percentage of initial fluorescence intensity remaining following 30 seconds of continuous illumination 
						using a 40x/1.4NA objective and a 100-watt Hg-arc lamp as the light source with samples mounted in phosphate buffer
					Photostability in antifade 항목에 마우스를 가져다 대면 하기와 같은 설명이 나옮
					:	Relative measure of the percentage of initial fluorescence intensity remaining following 30 seconds of continuous illumination
						using a 40x/1.4NA objective and a 100-watt Hg-arc lamp as the light source with samples mounted in ProLong® Gold or SlowFade® Gold antifade reagent
			
형광물질은 익사이테이션이 되면, 구조가 변합니다. 원래 구조로 돌아오면서 빛을 내는 것이지요. 지속적으로 익사이테이션 시켜주면,
1) 물질내 새로운 공유결합등이 생겨나서 원래 구조로 돌아올 수 없게 되거나,
2) 다른 물질과 반응하여 원래 구조로 돌아올 수 없게 되거나,
3) phototoxicity등으로 인해서 형광구조나 해당 세포가 파괴되거나,
하기 때문인 것으로 정리됩니다. 예를 들어서 EGFP가 100개 있다. 한번 익사이테이션 시키면, 98개만 돌아오고....다시 97개....하는 식으로 특정 pool 의 밝기는 지속적으로 감소하게 됩니다. 
EGFP는 매우 안정적인 형광단백질로, 일반적으로 20마이크론 두께의 EGFP 레이블된 세포내의 특정 영역을 블리칭 시킬때, 일반 이미징 광도보다 50~100 배 정도의 세기로 몇 마이크론 직경을 쪼여줍니다. 
(영역과 시간, 세기등의 세세한 옵션은 대부분의 콘포칼 프로그램에서 조정할 수 있습니다.) 옆에서 봐도 눈이 시릴 정도의 세기라고 생각하시면 됩니다. 
따라서 일반적인 이미징에서 블리칭은 사실 큰 문제가 아니며, two-photon과 다양한 형광단백질들이 일반적인 최근에는, 오히려 지속적인 excitation에 의한 phototoxicity가 
이미징 주로 하는 사람들에게는 더 큰 문제입니다. 밝기가 제대로 안 나올 경우에는 흔히들 더 강력한 프로모터를 사용하는데, 이때에는 오히려 toxicity 가 증가할 수도 있으니, 
일단 한번 시도해보는 것이 최선이라고 생각합니다. 많은 생물학 실험들이 그렇듯이, 명확하게 숫자로 예측 불가능한 상황이 대부분이기 때문이죠.
다만, 샘플은 언제나 블랙박스에 보관하셔야하고, 이미징시에도 최소한의 광선 아래에서 하셔야 합니다. 카메라 필터등을 써서 EGFP excitation range (488 나노미터)를 벗어나는 환경을 구현해 줍니다. 
빨간 셀로판을 겹겹이 싼 박스에 보관한다던지 하는 식으로요.
셀을 키우는 과정에서의 노출은 큰 문제가 안될꺼 같습니다. 안정적인 암세포 라인이라면, 생쥐내에서도 지속적으로 분열하겠고, 지속적으로 새로운 EGFP들이 만들어질 테니까요. 
오히려 일반적인 이미징 시스템으로 누드 마우스 조직을 뚫고 들어가서 어느정도까지 자세하게 관찰이 가능할까?....하는게 문제가 될꺼 같습니다. 만약에 사진 찍어보신 데이타가 
있으시면 한번 보고 싶네요. 높은 해상력이 필요하지 않을 경우에는 상관없겠죠. 요즈음 여러가지 희한한 것들이 많이 나와있으니....그런데, 전체 쥐의 크기로 보았을때에 굉장히 많이 들어가야할 꺼 같습니다.
누드 마우스는 아니었지만 누군가가 살아있는 쥐의 뇌속의 뉴런 이미징을 시냅스 스파인 하나하나가 보일 정도의 고해상도로 하는 것을 직접 본 적이 있는데, 
해골을 열어서 코닥에서 파는 빨간색 카메라 필터로 (넘버 29) 로 두개골에 창문을 내어주더군요.
이미징은 미국에서 별도의 전공과정이 있을 정도로 큰 분야이고, 최근에 매우 발전하고 있습니다. 인터넷이나 저널을 찾아보시면 보다 자세하고 유용한 정보를 더 많이 얻으실 수 있을 껍니다.
그럼, 건투를 빕니다.

형광물질은 시간이 지남에 따라 자체 형광성질을 잃게 된다. 이러한 현상을 Photobleaching 이라고 하는데 이 현상은 레이저 세기에 영향을 받게 된다. 
그런데 살아있는 세포를 이용하여 Real Time Imaging을 하고자 할 때에는 그 관찰시간이 수 시간 이상 걸리는 경우도 있다. 
따라서 현상을 지속적으로 관찰하고자 한다면 Photobleaching을 최소화 하는 것이 중요하다. 

굽신) 형광 염색시에 형광의 지속시간 늘이기.. 
오쿤 (2011-09-15 21:20)질문보기 
답변보기 
Alexa Fluor® 594 phalloidin 을 이용해서 f-actin을 염색하고 확인하고 있습니다.
문제가 되는 현상은 형광 현미경으로 관찰시에 형광이 급속도로 bleaching이 됩니다.
3D 샘플의 전체적인 표면 이미지가 필요해서 세포를 3D 지지체에 배양 후 현미경을 통해 찍고 있는데
고 배율에서 여러장을 찍어서 전체 샘플의 형태를 나타내고자 하는데요.
고배율에서 여러장을 찍는 동안 형광이 급속히 사라져서 5장~6장 정도의 이미지 밖에 
얻지를 못하고 있습니다. mount 용액을 이용해서도 해보았는데 효과가 없습니다.
약 20분 정도 후에는 형광이 급격히 약해지는 데요 
혹시 이러한 형광의 약해짐을 막을 수 있는 방법은 없습니까?
과정은 간단히

1% BSA/PBS로 블럭킹하고 1:10 으로 희석된 phalloidin/PBS를 1시간동안 반응 시킨 후에
PBS로 5분간 3번 씻고 hochest 33258로 핵을 염색하고 PBS로 5분간 3회 세척하였습니다.
염색 직후는 문제가 없는데 관찰 중에 급격히 형광이 사라져서 원하는 이미지를 얻기가
너무 힘드네요.  
 
susemi94 (2011-09-15 22:46)질문보기 
답변보기 
  답변추천1    
  어떤 브랜드 제품을 써보셨는지 모르겠네요..
같은 Molecular Probe 제품중에 ProLong® Gold Antifade Reagent 라는 제품이 있습니다..
Alexa Fluor® 594 의 경우 92%까지 Resistance of dye to photobleaching 되니 참고하시고.
자세한 문의는 공식대리점인 케이디알에 해보세요..
 
빅토리아 (2011-09-16 09:16)질문보기 
답변보기 
  답변추천0     
  비밀번호    
음.. probes를 변경하실 수 있을 것 같은데요..
최근에 제가 사용해 보았던 제품들  한번 참고해보세요.
기존 probes에 비해 2-3일 이상씩은 최소한 유지되는 것 같습니다.
---> long term probes로 변경
    http://tools.invitrogen.com/content/sfs/manuals/mp10582.pdf

FRAP 실험
FRAP은 Fluorescence recovery after photobleaching의 약자이며, 그대로 해석하면 표백 후 형광 회복 정도로 유동성을 알 수 있다는 것입니다.
그림 순서대로 진행하는 실험입니다.
막단백질에 형광뮬질로 표시한다 -> 일부분에 강력한 레이저를 쏴서 표백시킨다 -> 기다린다 -> 표백된 부분이 분산되어서 회복되어 보임!!!
만약 세포막이 유동적이지 않다면 표백된 부분이 회복되지 않고 그 부분은 계속 표백되어있겠죠. 그러나 그래프를 보면 알 수 있듯이 회복됩니다.
이 회복 속도로 막단백질이 어느 속도로 이동하는지도 유추할 수 있습니다.
 
FLIP : Fluorescence Loss in Photobleaching, Photobleaching 형광손실

1. 형광과 전기화학을 이용한 바이오칩 기술 
바이오칩이란 유리 같은 고체 기질 위에 많은 종류의 DNA나 protein 같은 바이오 물질을 고밀도로 집적시켜 붙여놓은 것이다. 
이때 DNA를 집적시켜 놓으면 DNA 칩, protein을 집적시켜 놓으면 protein 칩이라 명명된다. 이들 바이오칩에 사용되는 검출 방법으로는 크게 형광을 이용한 방법과 전기적 신호를 이용한 방법이 있다.
형광을 이용한 방법은 Cy3 나 Cy5 와 같은 유기 형광염료를 검출하고자 하는 DNA나 protein에 표지시켜 형광 스캐너나 형광 현미경을 이용하여 염료의 형광 신호를 검출한다. 
일반적인 형광 검출법은 다양한 파장대의 형광을 낼 수 있는 유기 염료들이 존재하여 원하는 파장대의 염료를 사용하는 것이 가능하며, 형광 검출기들이 보편화되어 있어 그 사용이 용이하다. 
그리고 다른 검출법들에 비해 비교적 높은 sensitivity를 보인다. 하지만 일반 유기 염료들의 거의 대부분은 빛에 의한 photo bleaching 현상을 보이기 때문에 장시간 빛에 노출시킬 수 없으며, 
심지어 몇 분간의 노출로 인하여 형광을 내지 못하는 염료들도 있다. 따라서 유기 염료들을 대체할 수 있는 여러 후보물질들에 대한 연구가 진행되고 있으며, 
그 중 하나로 quantum dot이 현재 사용되고 있다. ( http://www.qdots.com)
Quantum dot은 유기 염료와 달리 photo bleaching 현상이 없으며, quantum yield가 유기 염료보다 훨씬 좋기 때문에 더 강한 형광 신호를 낼 수 있다. 
이러한 quantum dot은 또한 크기에 따라 다양한 파장대의 형광을 낼 수 있기 때문에 유기 염료의 대체품으로 고려되고 있다. 하지만 quantum dot은 다양한 이점에도 불구하고 유기 염료와 마찬가지로 
검출하고자 하는 바이오 물질에 우선적으로 표지되어야 하는 단점이 있다. 이 경우 추가적인 비용, 시간, 노동이 필요하며, 또한 검출 물질에 결합된 이들 형광 물질들은 
어떤 경우 바이오칩 표면의 탐침 분자들과 검출 물질들 간의 상호 작용을 방해하여 잘못된 결과를 보여준다. 따라서 이런 표지 문제에 관한 해결책으로서 molecular beacon이나 전기적 신호들이 이용되고 있다.
Molecular beacon은 검출 DNA와 결합할 수 있는 loop 부분과 고리를 만들 수 있는 stem 부분으로 구성되며, 각 stem의 끝 부분에는 형광을 낼 수 있는 fluorophore와 
그것의 형광을 소멸시킬 수 있는 quencher가 달려있다. 따라서 검출 DNA가 없을 경우 molecular beacon 양 말단의 fluorophore와 quencher간의 짧은 거리로 인해 형광신호가 나타나지 않지만 
검출 DNA가 있는 경우 molecular beacon의 loop는 검출 DNA와 결합하게 되고 따라서 fluorophore와 quencher 사이의 거리는 멀어지게 되어 형광을 나타낸다.

	2)	형광Dye + 형광Filter
		가)	형광다이 spec이 하기와 같은 경우는
			Goat polyclonal secondary antibody
			Anti-Mouse IgG Flamma 488		->	488은 LED 파장을 뜻하는 것임
			-	Absorption : 496nm
			-	Emission : 519nm
		나)	형광필터는 하기 필터를 사용하는 것이 맞음
			Semrock
			FF01-520/35-25 Filter	->	본 filter의 정확한 명칭은 Bandpass Filter 임(편광필터 아님)
			-	Transmission Band 1 : Tavg > 93% 502.5 - 537.5nm
			-	Center Wavelength 1 : 520nm
			-	Guaranteed Minimum Bandwidth 1 : 35nm
			-	Size : 25mm(Diameter) x 3.5mm(Thickness)
		다)	Bandpass filter , Polarization filter(편광필터)
			a)	Bandpass filter
				광원 중에 일정한 영역 파장대의 광원만 받아 들일 때 사용
			b)	Polarization filter(편광필터)
				광원 중 수직/수평 방향의 빛만 통과시키는 필터로
				반사되는 빛은 산란이 되어 광원의 파동방향이 변경되게 되며 이에
				만약 반사되는 빛의 파동 방향과 편광필터의 편광 판이 서로 평행이면 100% 빛이 통과되게 되고
				만약 반사되는 빛의 파동 방향과 편광필터의 편광 판이 서로 수직이며 감소되거나 삭제되어 빛이 통과되게 됨
				따라서, 장착된 편광필터를 회전시킬 때 마다 어떨 때는 피사체가 또렷하게 보이고 어떨 때는 피사체가 산란이 되어 보일 수 있음
		라)	형광측정을 위한 Bandpass filter
			케이오에스, Semrock 필터, 010-5494-0122, 임용환 과장
			-	FF01-485/20-25	x 2개
			-	FF01-520/35-25	x 1개
			-	FF01-529/24-25	x 1개
			-	FF01-640/14-25	x 1개
			-	FF01-680/22-25	x 1개
			
			케이오에스, Semrock 필터 재고 현황
			484nm
			FF01-470/22-25 ?/ ?(459~481nm)
			FF01-494/20-25 ?/ ?(484~504nm)
			FF01-482/35-25 ?/ ?(465~499nm) / Unmounted type
			
			521nm
			FF01-520/35-25? /? (503~537nm)
			FF01-529/28-50 ?/? (515~543nm) / 50mm size
			FF01-536/40-25? /? (516~556nm)
			FF01-538/40-25 ?/ ?(518~558nm) / Unmounted type
			
			555nm
			FF01-556/20-25? /? (546~566nm)
			FF01-536/40-25? /? (516~556nm)
			
			580nm
			FF01-575/25-25? /? (563~588nm)
			FF01-580/23-25? /? (569~592nm)

			Semrock	Cy5.5 A Filter Set
			This filter set is ideal for use with Cy5.5™ and Alexa Fluor™ 680, as well as other deep-red/near-infrared fluorophores. 
			The longer excitation and emission wavelengths of these fluorophores enable deeper tissue penetration. The superb brightne
			구성품
			- FF02-655/40-25 : 655-20nm ~ 655+20nm = 635nm ~ 675nm
			- FF01-716/40-25 : 716-20nm ~ 716+20nm = 696nm ~ 735nm
			- FF685-Di02-25x36 : 685nm이하에서는 반사 & 685nm이상에서는 통과
			
			BrightLine Basic™ single-band filter set, optimized for Cy5 and other like fluorophores
			This filter set is ideal for use with Cy5 and other fluorophores. This hard-coated filter set is the best value on the market, 
			delivering substantially higher brightness and contrast than the comparable premium soft-coated filter sets.
			구성품
			- FF01-630/38-25 : 630-19nm ~ 630+19nm = 611nm ~ 649nm
			- FF01-694/44-25 : 694-22nm ~ 694+22nm = 672nm ~ 716nm
			- FF655-Di01-25x36 : 655nm이하에서는 반사 & 655nm이상에서는 통과

			
			cf)	바디텍에서 사용하는 Bandpass filter
			-	D640/20 X-ww	->	630 ~ 650nm
			-	D680/30 M		->	665 ~ 695nm
			cf)	2013년 05월 10일 바디텍(i-chroma)제품의 경우 Bandpass filter
			-	Laser부 D640/20 X-ww bandpass filter 사용하지 않고
			-	수신부 681DF26 bandpass filter만 사용 함	->	668 ~ 694nm
			
			cf)	MSO4104(1GHz, Oscilloscope)
				MSO70404C(4GHz, Oscilloscope)
				
				7elec, 070-7561-0684
				MSO5204B(2GHz, Oscilloscope)
				MSO5104B(1GHz, Oscilloscope)
				
			cf)	S1P-Fluorcein (Excitatuib 484nm/Emission 521nm)
				S1P-TAMRA (Excitatuib 555nm/Emission 580nm)
			
			

	3)	Fluorescence 가 Luminescence 보다 강도가 더 높은 이유

가)	Chemiluminescence 화학발광 실제 실험 결과
	MITSUBISHI PASTFAST Cartridge에 있는 ALP-conjugated antibody와 Chemiluminescent substrate(CDP-Star with Spphire II)를 서로 섞어서
	화학발광시킨 결과(암실에서 측정)
	A)	약 15초 정도 결과 후에 아주 약한 뿌연 발광이 일어 났고(약간 푸른 빛)
	B)	이렇게 아주 미세한 빛이 20초 정도 나오다가 완전히 빛이 소멸 됨을 확인 함
	cf)	이성환 연구원 얘기
		실제 Chemiluminescence 화학발광을 측정해 보았으며
		상기와 같이 Chemiluminescence 화학발광은 아주 미세한 빛이 1분 안으로만 발색하며
		이를 CCD Camera의 Bulb mode를 이용해서 측정하면 아주 미세한 빛이 증폭되어서 볼 수 있다고 함
		->	내가 측정했고 생각했던 방식과 동일함 확인 됨


두 단어를 우리말로 번역하면 이해가 좀 더 쉬우실 겁니다.
아시다시피 fluorescence는 형광이란 말이고, luminescence는 발광이란 말이죠.
즉 형광은 그 자체로 빛을 발하지 않습니다. 다만 형광물질에 광선이 쬐여지면 그 광선을 고유한 빛깔 형태의 광선으로 다시 방사하게 되는데, 
그때 보여지는 빛을 형광이라 합니다. 예를 들어 실험에서 많이 쓰는 GFP의 경우, 그 protein 자체가 빛을 발광하진 않습니다. 
다만 UV가 쬐여졌을 때 쬐여진 UV와 전혀 다른 파장영역 (눈에 보이니까 가시광선대가 되겠죠)의 빛으로 다시 방사되어 초록색으로 보이게 됩니다. 
반면에 luminescence는 발광이란 의미이기에 그 자체가 곧 빛을 발하는 경우죠. 즉 바로 우리가 눈으로 인식할 수 있는 경우입니다 
(때에 따라선 그 강도가 너무 약해서 잘 안보일수도 있어요). western blotting 실험 해보셨죠? 
그때 암실에서 film을 넣기 전 HRP와 ECL(enhanced chemiluminescence) sol.을 섞어서 반응시키죠. 
이때 luminescence가 발생합니다. 이 빛에 의해 film이 타게 되는 거죠. 간혹 signal이 강한 경우에 이 luminescence가 바로 눈에 보이기도 한답니다. 발광이니까...
도움이 되셨길 바랍니다. 
  
앞서 말씀하신 분이 아주 잘 설명을 해 주셨는데요. 

그렇기 때문에 ELISA 분석기에 따라서 Fluresence를 잡을 수 있는 기기와 luminescence를 잡을 수 있는 기기등으로 구분이 됩니다. 
물론 두가지를 모두 분석해 주는 기기도 있구요. 
특히나 luminescence의 경우에는 발광이다 보니 well이 좁은 분석 plate를 사용하거나 투명한 재질을 사용하면 옆 well에 영향을 주어 값이 정확하지 않은 경우들도 발생합니다. 
하여 불투명한 재질을 사용하거나 luminescence용 plate를 사용하여 그런 간섭을 줄여주기도 합니다. 
또한 Flu~의 경우에는 각각의 형광을 분석하기 위하여 각종 필터들이 필요합니다. 
그렇기 때문에 어떠한 파장값을 읽고 어떠한 파장값을 조사해 주느냐에 따른 필터들이 많이 필요합니다. 
사용하시는 시약이나 발색시약에 따라서 필터들이 다르게 설정이 되니까 이를 잘 확인하시고 분석하세요. 
 
간단하게 말씀드려서 fluorescence는 어떤 물질이 빛을 흡수한 후에 특정 파장의 빛을 방출하는 경우이고 luminescence는 외부의 빛을 흡수 하던지 
화학 반응에 의한 것이던지 스스로 특정 파장의 빛을 방출하는 경우입니다.
luminescence가 더 광의의 의미가 되는 것이죠.
만일 luciferase에 의해 특정 파장의 빛이 발산될 때에는 기본적으로 화학 반응에 의한 것이니 이를 fluorescence라고는 할 수 없습니다.
하지만 fluorescence는 luminescence의 일종이라 볼 수도 있죠.
 
15D 화학발광
* 분석화학에 화학발광(chemiluminescence)의 응용 → 비교적 최근
* 화학발광을 하는 화학반응의 수가 적음
 → ∴ 비교적 적은 화학종에만 화학발광법 응용 
 → 그러나, 화학발광을 하는 화합물들은 우리 주위의 중요한 물질들
* 높은 선택성, 단순성, 및 매우 큰 감도로 인해 최근 이용 급증

15D-1 화학발광 현상
* 화학반응에 의하여 전자적으로 들뜬 화학종이 생성 → 화학발광
 → ㉠ 바닥상태로 되돌아가면서 빛을 방출 또는 
     ㉡ 에너지가 다른 화학종으로 전이된 후 방출
* 화학발광 반응은 여러 생화학계에서 나타남 → 생체발광(bioluminescence)
 → 반딧불, 바다 팬지(pansy), 어떤 해파리, 박테리아, 원생동물 및 갑각류 등   
 → 여러 자연 생체발광의 화학적 성질은 완전히 알려져 있지 않다
* 100여년 전, 몇 가지 간단한 유기 화합물도 화학발광을 할 수 있음을 발견 
 → 화학발광을 내는 화합물의 가장 간단한 형태의 반응
           A + B → C* + D           C* → C + hν
  → C*: C 화학종의 들뜬 상태 
  → 화학발광 스펙트럼은 반응 생성물 C의 것
 → 대부분의 화학발광 반응은 이 식에 의해 제시된 것보다 훨씬 더 복잡
* 화학발광의 경우, 복사선의 세기  ICL(초당 방출되는 광자수)는 ㉠ 화학 반응속도(dC/dt) 그리고 
   ㉡ 화학발광의 양자 수득률 ΦCL(반응 분자당 방출되는 광자수)에 따라 달라진다.
 → 화학발광 양자 수득률 ΦCL은 들뜬 양자 수득률 ΦEX(반응 분자당 들뜬 상태수)와 
     방출 양자 수득률 ΦEM(들뜬 상태당 광자수)의 곱과 같다
                        ICL =  ΦCL(dC/dt) = ΦEXΦEM(dC/dt) 
 → 분석에 유용한 화학발광계는 보통 약 0.01∼0.2의 ΦCL 값을 갖는다. 

15D-2 화학발광의 측정
* 화학발광 측정을 하기 위한 기기장치는 매우 간단하다.
 → 적절한 반응용기와 광전증배관 만으로 구성
 → 보통, 파장 선택장치는 필요하지 않음
  → 복사선이 생기는 것은 오직 분석물과 시약사이의 화학반응이기 때문
* 화학발광 광도계 시판
* 화학발광 실험에서 나오는 전형적인 신호
 → 시약과 분석물을 혼합한 후에 시간의 함수로서 빠르게 극대를 나타냄
 → 그 다음에 신호는 다소 지수함수적으로 감소 
그림 15-11

* 정량분석을 할 경우, 신호는 ㉠ 일정한 시간동안 적분하고, ㉡ 똑같은 방법으로 처리하여 얻은 
   표준물과 비교
 → 면적 대신, 봉우리 높이를 이용하기도 함
 → 신호와 농도사이의 선형 관계가 105∼106 크기의 농도 범위에 걸쳐 성립

15D-3 화학발광의 분석적 응용
* 화학발광법은 일반적으로 매우 감도가 좋다.
 → 약한 빛살도 잡음없이 쉽게 검출 가능 
 → 게다가, 필터 또는 단색화장치에 의한 빛의 감소는 피할 수 있음
 → 실제로, 검출한계는 검출기 감도가 아니라 오히려 시약 순도에 의해 결정
* 전형적인 검출한계: ppb(또는 때때로 이 이하)∼ppm 범위
* 전형적인 정밀도는 현재의 문헌으로는 판정하기 어렵다

	4)	형광측정기
		가)	주)고마바이오텍, Luminex 200
			a)	Green(532nm) / Red Laser(635nm) 로 동시 측정
			b)	Non-magnetic bead, Magnetic bead 모두 사용 가능
			c)	Protein, DNA, RNA 등 다양한 물질 분석에 적용할 수 있습니다	
			d)	동작원리
				각각의 well에 들어가 있는 A,B,C,D,E,F,G,H 등의 각각의 성분을 측정할 수 있는 장비로
				well에 들어 있는 아주 많은 입자를 수직방향으로 조금씩(1개씩) 떨어뜨리며 이때 각각의 입자를
				Green / Red Laser로 조사하면서 나오는 광량을 PMT를 가지고 측정해서
				각각의 well에 들어가 있는 A,B,C,D,E,F,G,H 등의 조성을 분석 함
			e)	사양
				Luminex 200 Specification
				Software					xPONENT 3.1
				Optic						Lasers / APDs / PMTs
				Hardware					Flow Cytometry based
				Bead Compatibility			Magnetic and non-Magnetic
				Multiplex Capacity			100
				Read Time					~ 40 mins / 96 well plate
				Applications				Protein / Nucleic Acid
				Dynamic Range				3.5 logs
				Microtiter Plate			96 well
				Footprint including PC		80.0 cm (32”)
				(linear bench space)
				Weight (Analyzer)			49 kg (113 lbs)

	5)	Digital Optic, PRIME측정기를 가지고 형광측정 테스트
		가)	형광Dye는 Alexa647 사용
			-	Laser에서 나오는 빛 걸러주는 Bandpass filter 사용하지 않음
			-	D680(?)		->	665 ~ 695nm	->	수신부Bandpass filter를 본 사양으로 사용한 것인지 확실하지 않음

		나)	형광측정기 광학 모듈은 아래와 같은 구조로 구성되어 있으며
			형광측정기 광학 모듈 구현 순서는
			a)	6에서 나온 Laser광원은
###				Laser 뒷단 볼록렌즈 역할
					본 볼록렌즈로 Laser광원을 좀더 모아주지 않으면
					membrane을 Laser광원이 한 지점만 비춰주는 것이 아닌 넓은 영역을 비춰주게 되며
					이렇게 되면 PhotoDiode에서 광원을 한 지점만 수신하는 것이 아닌 넓은 영역을 수신하게 되어서
					측정파형이 형광Dye가 있는 지점만 Peak로 측정하는 것이 아닌 실제는 Background가 없는데 Background가 있는 것 처럼 측정파형이 생성되는 심각한 문제 발생 함.
					따라서, Sliding & Photodiode 수신 방식의 경우는 꼭 본 볼록렌즈를 사용해서 광원을 모아줘야 함
				
			b)	5번 Dichroic Mirror의 특성으로 인해서 광원이 90 방향으로 꺽여서(반사되어서) 7번으로 향함
				cf)	본 잠망경 거울은 640nm 파장 이하의 광원은 반사시켜주고 640nm 파장 이상의 광원은 통과시켜주는 거울임
					cf,	카메라에서 적목현상을 제거시켜주는 적외선Filter
					cf,	Dichroic Mirror 특성
						ex)	Long pass Dichroic Mirror 특성	:	<650nm 이하 파장의 빛은 반사시켜주고 >650nm 이상 파장의 빛은 통과시켜 줌
						ex)	Short pass Dichroic Mirror 특성	:	>650nm 이상 파장의 빛은 반사시켜주고 <650nm 이하 파장의 빛은 통과시켜 줌
				cf)	일반 거울을 본 잠망경 위치에 설치하면 640nm의 광원을 조금도 반사시켜 주지 못함
				cf)	붉은색 셀로판테이프를 본 잠망경 위치에 설치하면 640nm의 광원을 조금도 반사시켜 주지 못함
			c)	7번 오목렌즈에서는 광원을 한 점으로 집중시켜서(모아서) 8번 피사체로 Focusing 해줌
			d)	8번 피사체에서는 Focusing된 광원으로 인해 형광반응이 일어나며 이에 반응된 680nm(?) 광원이 방출 됨(형광band)
			e)	8번 피사체에서 방출된 빛은 7번 볼록렌즈를 거쳐서 형상이 확대되어 5번으로 향하며
			f)	5번 에서는 Dichroic Mirror의 특성으로 인해 680nm(?)의 형광 광원을 그대로 통과시켜 4번으로 향하게 함
			g)	4번 에서는 680nm(?)파장의 빛만 3번으로 통과시켜주며
			h)	3번 에서는 오목렌즈로 인해 빛이 한점으로 모이도록 해서 2번으로 향하게 해줌
			i)	2번 에서는 일직선틈 형상의 Slit으로 인해 빛의 일부만 통과되도록 함
			j)	1번 에서는 최종적으로 받은 형광 광원을 전기 신호로 변경시켜 줌
			
			형광측정기 광학 모듈 구조
					1.	PhotoDiode
					2.	Slit
					3.	오목렌즈(4번으로 부터 올라오는 빛을 모아줌)
					4.	680nm bandpass filter(?, 확실하지 않음)
6.	640nm Laser		5.	Dichroic Mirror(45도각도)		5+1우측암실공간	
						cf)	본, Dichroic Mirror가 640nm 파장의 Bandpass filter 역할까지 해주는 것임
							이유는, 만약 650nm 경계스펙의 Dichroic Mirror를 사용한다면
							650nm 파장 이하의 빛은 90도로 반사시켜서 아래 7번으로 보내주고
							650nm 파장 이상의 빛은 그대로 통과시켜서 5+1좌측암실공간으로 가서 빛이 소멸되기 때문에
							결론적으로 아래 7번으로 가는 빛은 650nm이하의 빛만 내려가는 것임
						cf)	바디텍 제품의 경우도 Laser광원이 수신부로 들어가는 현상 동일하게 발생하고 있음
							참고로, Dichroic Mirror는 방향성이 있지는 않음 뒤집어서 달아도 수신부로 들어가는 현상은 동일하게 발생
							cf)	뒤집어 달아도 성능 상의 큰 문제는 없지만 원칙은 코팅면이(유리면 아님) 빛이 반사되어 들어가는 부분과 맞닿아 있어야 함
							cf)	형광필터 방향 구분 방법, 코팅면/유리면 구별 방법은 Mirror의 두께면(측면)을 정면으로 본 상태에서 대각선으로 보면(두께면 앞단/좌측끝에서 두께면 뒤단/우측끝)
								코팅면은 빛이 대부분 반사되어 흰색(유리)살이 보이지 않고 유리면의 경우는 빛의 반사가 적어서 흰색(유리)살이 보임
							cf)	모든 Bandpass Filter & Dichroic Mirror 제품의 설치 방향은 코팅면이 빛이 들어가는 부분이고 유리면이 빛이 나오는 부분임
							cf)	참고로 본 테스트에서 사용한 바디텍 제품은 Laser광원부에 D640/20 X-ww bandpass filter도 장착되어 있지 않은 제품이었음
					7.	오목렌즈(빛을 모아줌)
					8.	피사체(형광Dye)

		다)	Digital Optic, PRIME측정기 Laser 광원이 수신부로 들어가는 문제 원인 파악 및 입증
			1.	테스트결과 :
				#1번미터기를 기준으로 기준카트리지(인쇄)로 #18번미터기를 Calibration한 다음
				형광Dye카트리지로 측정하면 Y절편이 1250 정도 높아지는 결과를(#18(Default) 얻으며 이로 인해서 측정값이 왜곡되는 결과를 얻음
			   1) 원인 : 어떤 경우에도 Laser광원이 수신부로 들어가면 안되지만 현, 광학설계 잘못으로 수신부로 들어가기 때문에 발생하는 것임
			      cf) 형광Dye카트리지의 경우 바탕색이 흰색이기 때문에 Laser광원의 잡광이 수신부로 더 많이 들어 감
			      cf) 회색 바탕의 기준카트리지가 남색 바탕의 기준카트리지 보다 본 문제점을 어느 정도 더 많이 보상해 주기 때문에 회색 바탕의 기준카트리지 사용 함
			   2) 근거자료
			      가) 기존 미터기의 경우, 육안으로도 Laser광원이 수신부로 들어가는 현상 확인 할 수 있으며
			      나) 실험적으로도 본 가설이 맞음 확인 완료
			           a) 기존 미터기 수신부에 기존Bandpassfilter가 아닌 716/40nm Bandpassfilter를 장착시키면
			           b) 기존과는 다른 육안으로도 Laser광원이 수신부로 들어가지 않고
			              실제 형광Dye카트리지를 사용해서 측정해도 그림과 같이(#18(수신부716Bandpassfilter로변경) Y절편이 높아지는 현상 발생하지 않음
			      다) 따라서, 기존 미터기의 경우 Laser광원이 수신부로 들어가는 정도가 미터기 마다 다른 문제점이 있기 때문에
			          인쇄된 기준카트리지로 Calibration을 진행해도 실제 리얼검체를(형광Dye카트리지와 특성 유사) 사용해서 측정하면
			          그림과 같이 측정 파형의 Y절편값이 미터기마다 다른 현상이 발생하고 이로 인해서 미터기 마다 측정값 편차가 더 발생하는 것임
			2.	PRIME측정기에 합당한 형광 Filter set
				Semrock, BrightLine Basic™ single-band filter set, optimized for Cy5 and other like fluorophores 세트와 스펙 동일
				1)	Laser 출력부 뒷단 Bandpass filter
					FF01-630/38-25		:	11.95mm 지름 원
				2)	Dichroic Mirror
					FF655-Di01-25x36	:	14.95mm X 11.95mm 직사각형
				3)	PhotoDiode 수신부 앞단 Bandpass filter
					FF01-694/44-25		:	12.50mm 지름 원

				cf)	단가(저렴) 고려한 스펙(사이즈의 경우 소수점 자리수로 내려갈수록 사이즈 가공 단가가 ex,2배($100 -> $200)로 올라가기 때문에
					왠만하면 소수점까지 내려가지 않게 가공하는 것이 좋음)
				1)	Laser 출력부 뒷단 Bandpass filter
					FF01-630/38-12.0(Bandpass filter) : 12mm 지름 원 X 2개(Unhoused / Unmounted)
				2)	Dichroic Mirror
					FF655-Di01-15x12(Dichroic Mirror) : 15mm X 12mm 직사각형 X 2개(Unhoused / Unmounted)
				3)	PhotoDiode 수신부 앞단 Bandpass filter
					FF01-694/44-12(Bandpass filter) : 12mm 지름 원 X 2개(Unhoused / Unmounted)
					
				아주중요)Laser 처럼 광원의 세기가 아주 강한 경우는
					상기 FF01-630/38-25 Bandpass filter를 Laser 뒷단에 설치했다고 해서 무 자르듯 파형을 잘라주지는 못함
					Direct 직사광선으로 Laser 광원을 FF01-630/38-25 Bandpass filter를 통과시키는 경우 거의 50%(?) 정도 밖에 걸러주지 못하는 것 같다.
					사용하는 것이 사용하지 않는 것 보다 걸러주는 역할을 하기는 하지만 완전히 걸러주지는 못함
			3.	Dichroic Mirror 효율
				Dichroic Mirror는 Bandpassfilter 보다 광원 반사/투과 효율이 많이 떨어짐
				cf)	Bandpassfilter는 무 자르듯이 스펙 파형대과 동일하게 광원을 잘라주지만
					(ex, 640/20(630~650nm) 의 경우는 630~650nm 영역 안은 완벽하게 투과시켜주고 이밖의 영역은 완벽하게 차단시켜주지만)
					Dichroic Mirror는 스펙 파형하고는 다르게 거의 40%정도의 효율로 잘라주는 것 같음
					(ex, FF655-Di01 의 경우 스펙상으로는 655nm이하의 빛은 98% 빛을 차단시켜줘야 하지만 실제로는 40%만 차단시켜주는 것 같음)
			4.	Bandpassfilter / Dichroic Mirror 입사 각도에 따른 효율
				Bandpassfilter는 입사각이 90도일 때 가장 효율이 좋으며
				Dichroic Mirror는 입사각이 45도일 때 가장 효율이 좋다고 함

###	아주최고로중요
	5+1)CMOS 카메라 647형광 측정 구조
		1-1)Camera vs PhotoDiode 특성 비교
		    
   					|	Camera										|	PhotoDiode
		-----------------------------------------------------------------------------
		측정방식	|	면적측정방식								|	Point측정방식
		해상도		|	(각각의Pixel당 해상도는 낮지만(8bit/255)	|	(한지점에 대한 해상도는 월등히 높지만(12bit/4095)
					|	 다수의 면적으로 처리하기 때문에 해상도 증가|	 한지점만 측정하기 때문에 해상도는 0~4095로 한정 됨)
					|	 ex) 0~16000 = 62pixel x 255)				|
		-----------------------------------------------------------------------------		
		측정구조	|	사용자가 피사체를 어느정도 위치에 오도록	|	한지점만 측정할 수 있기 때문에
					|	한 다음 카메라로 측정하면 됨				|	면/축방향으로 측정하려면 Stepping motor 등
					|												|	피사체를 횡 방향으로 정밀 이동시켜주는 장치 필요
		-----------------------------------------------------------------------------
		위치편차	|	면적으로 촬영해서 이미지처리하기 때문에		|	한지점만 측정하기 때문에 측정 원소스의 위치가 틀어지면
		(기구)		|	측정 원소스의 위치가 틀어져도 위치 편차에 	|	측정편차를 감소시킬 방법이 없기 때문에 그대로 측정편차 발생
					|	따른 측정편차를 감소 시킬 수 있음			|
		-----------------------------------------------------------------------------
		위치편차	|	면적으로 촬영해서 평균화 하기 때문에		|	한지점만 측정하기 때문에 센서 위치별 불균형이 반응이 발생한 경우
		(센서)		|	센서 위치별 불균형 반응으로 발생하는	 	|	측정편차를 감소시킬 방법이 없음
					|	측정편차를 감소 시킬 수 있음				|
		-----------------------------------------------------------------------------
		측정민감도	|	카메라 노출계수/셔터스피드를				|	PhotoDiode에는 카메라와 같은 노출계수 설정 기능이 없기 때문에
		향상방법	|	증가시키면 측정민감도를 증가시킬 수 있음	|	측정민감도를 증가시킬 방법이 없음
					|	(Background는 증가되지 않고 Target 광원만	|	(PhotoDiode 보다 민감도가 높은 PMT를 사용할 수 있으나
					|	 상대적으로 증가되기 때문에 측정민감도를	|	 가격이 100만원 정도로 상당히 고가 임)
					|	 증가 시킬 수 있음)							|
		-----------------------------------------------------------------------------
		측정문제	|	센서 반응된 피사체를 카메라로 찍어서		|	센서 반응된 피사체를 수치 그래프로만 볼 수 있고
		원인분석	|	이미지로 볼 수 있기 때문에 무슨 문제가 		|	원 소스 이미지는 볼 수 없기 때문에 문제가 있어도
					|	있는지 원인 분석 하기 수월				 	|	원인 분석하기 어려움
		-----------------------------------------------------------------------------		
		가격		|	개당 4만원(?) 정도							|	개당 1천원(?) 정도
		-----------------------------------------------------------------------------
		S/W 개발	|	Android 등 OS가 필요하고 카메라 제어,		|	F/W선에서 처리 가능하고 Stepping motor 제어
		난이도		|	이미지 처리가 필요하기 때문에				|	등이 필요하기 때문에 S/W개발 난이도 중급
					|	S/W개발 난이도 최상급							|
		-----------------------------------------------------------------------------
		2D바코드	|	카메라로 촬영해서 Application 처리하면		|	2D바코드 인식 불가능
		인식		|	2D바코드 인식 가능						 	|	(인식하려면 별도의 2D바코드 Reader 필요)
		-----------------------------------------------------------------------------
		cf)	마커당 노출계수/민감도를 초저농도로 맞추고 고농도(Myoglobin) 마커의 경우는
			측정시간을 짧게 잡는 방식으로 처리하면 현 SmartMedi Prime 처럼 High gain / Low gain으로 이중으로 Gain을 잡을 필요가 없겠다.

		1) Camera / PhotoDiode 측정 성능 분석
		    형광 수신부를 Camera / PhotoDiode 중 어떤 방식으로 선정하는 것이 
		    측정성능을 높일 수 있는지 테스트 중	    
		    
		2) 1차테스트결과
		    -> 형광 측정 수신부를 Camera 방식으로 사용 가능함 1차 확인 완료
		    이유) 그림2)는 CMOS Camera로 647형광Dye 저/중/고를 촬영한 이미지로
		           그림과 같이 저/중/고를 변별력있게 촬영하고 있으며
		           특히 저농도 형광Line도 Background(검정색) 대비 변별력 있게 촬영 가능함
		           -> 이에, Camera 방식으로 647형광Dye 측정 가능함 1차 확인 됨
		3) 카메라 경통 구조
		   그림3)과 같이 647형광 광원을 694Filter2개와 Slit을 사용해서 잡광을 제거
		   그림2)와 같은 깨끗한 이미지를 얻음(Background 검정 대비 빨간색 형광Line)
		   
		   피사체(647형광 광원) -> 694Filter -> Slit -> 694Filter -> 카메라Lens(적외선Filter제거) 
		   -> CMOS 이미지 Sensor
		4) CMOS 카메라, 647형광 측정 스펙
		    가) 광원(피사체 좌/우 45도 대칭 구조)
		         635nm Laser 2개 & 630nm Bandpass filter 2개
		    나) 수신부
		         694 Bandpass filter -> Slit ->  694 Bandpass filter 
		         -> 카메라Lens(적외선Filter제거) -> CMOS 이미지 Sensor
		    다) 측정Target : Membrane 상에 Line으로 도포되어 있는 647nm 형광Dye
		    라) CMOS Camera 셋팅 변경
		         a) 카메라 노출시간을 증가시켜서 미세한 형광Dye 광원이 증폭되도록 셋팅
		         	가)	AECH(0x08), AEC(0x10) 값만 0xFF로(Max)로 변경
		         	나)	ADVFH(0x2E) Register 값 50으로 변경
		         b) Camera R/G/B 값 중에서 RED 이미지 Data만 수신되도록 셋팅
		             (형광Dye파장인 647nm파장 부근의 광원만 받아 들임)
		       		가)	BLUE(0x01) = 0x00, AWB-BLUE channel gain setting
					나)	RED(0x02) = 0x4B, AWB-Red channel gain setting
					다)	GREEN(0x03) = 0x00, AWB-Green channel gain setting


		5)	Camera vs Prime meter 측정 성능 분석
			Membrane에 Line으로 그어져 있는 647형광Dye를 Prime meter vs 상기 스펙의 CMOS Camera로 측정해서
			측정파형(Density graph)로 비교 분석한 결과 아래와 같은 1차 결론을 얻음
			
			No	Item			Prime meter		CMOS Camera		
			1	Peak1(Max)		1279			8258		
			2	Peak1(Min)		718				5722		
			3	=1-2			561				2536		
			4	=CMOS / Prime	4.5 			
					
			-> 1차 결론					
		    647형광Dye를 Prime meter로 측정하는 것 보다 CMOS Camera로 측정하면					
		    분해능이 4.5배 높아지는 것으로 분석됨					
		    단, 1차 분석 결과이며 보다 확실한 비교 분석을 위해서는 실제 광학JIG구현 & S/W & H/W					
		    를 구현시켜서 리얼검체로 비교 테스트를 진행해야 함


		6)	빛에 의한 색상 탈색
		가)	빨강색이 탈색이 제일 심하며 니스칠하면 탈색 줄어듦
		나)	자외선이 탈색을 제일 심하게 만듦
		다)	프리터잉크가 탈색 정도가 덜함
		라)	가시광선이 나무의 색을 변화시키나?
			나가세 카페에서 토론되었던 내용에 제 의견을 덧붙여 추가한 내용입니다.
			일반적으로 태양 빛에서 사람에게 혹은 나무에게 나쁜 영향을 주는 것은 자외선(Ultraviolet, UV)라고 알려져 있습니다. 
			자외선은 가시광선에 비해 파장이 짧고 따라서 더 큰 힘으로 세포에 영향을 주기 때문입니다. 
			가시광선의 긴 파장은 세포단위의 물질을 변화시키기에는 에너지가 부족하다는 것이 일반적인 견해였습니다. 
			이런 견해들에 대해서 검색을 통해 근거자료를 찾아 보았습니다.
			먼저 미국 국립공원 관리국(U.S. Department of the Interior National Park Service)에서 낸 "Reducing Visible and Ultraviolet Light Damage to Interior Wood Finishes" 
			라는 제목의 테크노트입니다. 이 노트는 나무 자체의 변색 보다는 나무에 칠해진 염료(dye)에 대한 빛의 안정성에 대한 실험 결과입니다.
			http://www.nps.gov/tps/how-to-preserve/tech-notes/Tech-Notes-Museum02.pdf
			3개의 조건으로 각각 수성스테인, 알콜스테인, 오일스테인으로 색을 칠하고 10년을 놓아본 것입니다. 
			모든 샘플에서 아래쪽은 10년동안 천으로 덮어 두어서 빛의 영향이 없도록 한 것이고, 
			위의 왼쪽 3개는 각각 햇빛에 노출시키고, 가운데 3개는 자외선 차단된 유리를 통과한 빛에 노출한 것이고, 
			오른쪽 3개는 스테인 위에 오렌지급 셀락을 바르고 난 뒤 빛에 노출시킨 결과입니다.
			
			10년이라는 긴 실험기간이 변색의 속도를 가늠할 수 없게 하긴 하지만 일률적으로 오일 스테인은 색깔의 변화가 없고, 
			일반 햇빛이든, UV를 차단한 가시광선만이든, 셀락으로 코팅을 했든지 간에 수성스테인과 알콜스테인의 색은 탈색이 되었다는 결과입니다. 
			더 자세히 살펴보니 오일스테인은 염료가 아니라 산화철 계열의 안료(pigment)를 사용한 것입니다. 

			결국 이 실험이 보여주는 것은 염료는 자외선 뿐 아니라 가시광선에 의해서도 탈색이 되며, 
			안료는 자외선이든 가시광선이든 변색을 막아준다는 것입니다. 그래서 이 테크노트는 박물관을 위한 지침으로 염료(dye)를 사용한 전시물에 대해서는 
			50룩스 이하의 조명을 사용할 것을 권하고 있습니다. 박물관을 가보면 조명이 굉장히 어두운데 다 이런 이유가 있습니다. 
		마)	안료와 염료
			안료					염료							인체
			용매에 녹지 않음		용매에 녹음						피부 속에서 녹아 다른 곳에서 발현 가능성
			내화학성 좋음			내화학성 좋지 못함				사람의 성질에 따라 달리 발현
			내광성,내후성 좋음		내광성,내후성 좋지 못함			오랜 빛에 노출 시 탈색
			은폐력 좋음				은폐력 좋지 못함, 투명성 좋음	기존 색소 커버 시 나중에 다른 색으로 발현
		바)	염료와 안료의 차이가 궁금해?
			일반적으로 용매에 용해된 상태로 사용하는 것을 염료(dye), 용매에 분산시켜 입자상태로 사용하는 것을 안료(pigment)라고 하는데요. 
			쉽게 말해?염료는 물, 기름에 녹아서 섬유 물질이나 가죽 등을 염색하는데 주로 쓰이는 색소를 말하고, 안료는 물이나 기름 등에 녹지않는 분말형태의 착색제를 말합니다. 
			가장 큰 차이는 염료는 물, 기름에 잘 녹고, 안료는 물이나 기름에 잘 안녹는 특성을 가지고 있다! 라고 보시면 되겠습니다.
			염료는 의류 등 섬유 물질에 주로 색을 입힐 때 주로 쓰이곤 하고요. 안료의 경우는?안료 그대로의 상태로는 섬유 등에 흡수되는 성능이 없지만 전색제의 도움에 의해 물체에 색이 도포되거나
			또는 물체 중에 미세하게 분산되어 착색됩니다. 			
			예를들어 안료를 니스, 합성수지액과 같은 전색제에 섞어 도료, 그림물감 등을 만들어서 사용하게 되면 물체에 잘 착색이 되지요.?

			<매니큐어는 안료의 일종!>
			쉽게 정리해서 의류에 착색된 색소는 염료라고 생각하시면 되고,
			프린터용 토너, 페인트?등은 안료라 할 수 있습니다! 롯데정밀화학의 컬러레이저프린터용 토너도 안료!에 속하는 것이겠죠
		사)	PRIME 측정기 Laser(647nm) 광원에 의한 탈색/측정값 변화 확인 테스트
			조건)	기준카트리지상의 Band 1곳만 계속해서 Laser(647nm) 광원을 조사 시킴
			결과)	Laser(647nm) 광원 조사 시킨 Band만 하기와 같이 측정값이 감소 됨
					1.	17시간만에 P3_2, 55% 측정값 감소 됨
					2.	1번 측정할 때 2초 정도 Laser가 Band를 스쳐감
						따라서, 1번 측정기 Calibration 할 때  80초(2초x4(4회스캔후측정결과나옴)x10(Offset+3차세팅+Alpha)) Laser가 Band 스쳐감
					3.	17 : 55 = x : 10
						x = 3, 연속 3시간 사용하면 10% 측정값 감소 됨
					4.	10,800초 = 3x60x60(3시간은 10,800초)
					5.	135회 = 10,800 / 80(135회 Calibration하면 측정값 10% 감소 됨)

		7)	488nm vs 647nm 형광 측정

###아주중요	가)	기존 647형광Dye 사용하는 것이 성능적으로 우세
        				이유) 488형광Dye가 647형광Dye 보다 Background가 2배 정도 높게 나타나기 때문에
               				Target의 형광Intensity가 묻히게 되어서 최종 상대적 측정값이 떨어지는 문제가 발생할 수 밖에 없음

						a)	일반 NC membrane을(Blank) 647nm 형광 구조로 보면 Laser광원이 아주 강할 때 약간 붉은 빛이 수신부로 들어가지만(647nm에 맞는 Bandpass filter 사용해서 측정)
						b)	일반 NC membrane을(Blank) 488nm 형광 구조로 보면 LED광원이 어느 정도 강해도 어느 정도 밝은 연녹색의 빛이 수신부로 들어감(647nm보다 2배 정도 밝은 빛이 들어 감)(488nm에 맞는 Bandpass filter 사용해서 측정)
						c)	본 현상은 일반 A4용지에서도 그대로 일어 남
						CF)	Membrane 종류 중에 Fluorescent 용으로 나온(Low fluorescence) membrane이 있기는 하지만 Lateral flow용이 아닌
								Western blotting용 인 것 같다(전기영동)
						


[75]	Source Insight
1-2.Source Insight 4.0	한글 깨짐 현상 방지
	->	Preference -> Files -> Other -> Default encoding : System Default (Windows ANSI)로 설정하면 됨
		cf)	Source Insight 프로그램이 자동으로 인코딩해서 한글 깨짐 현상을 방지해 주는 것 같다.

1-1.Source Insight 프로그램을 Linux samba와 연결시켜서 다량의 파일을 분석/수정하는 용도로 사용하면
	Source Insight 프로그램이 버벅거리는 문제 해결
	->	아래와 같이 설정하니 버벅거리는 문제가 해결 됨
	-> ptions -> Preferences -> General -> Project File Synchronization 
	-> []Synchronize on startup and project open, []Background synchronization every 60 minutes

1.	Source Insight 파일명 원래 파일명대로 보이기 (source insight - show exact case of file names)Tech./Tips 2009/11/30 14:13
	Source Insight에서 파일명을 항상 대문자로 시작하도록 보여주는 것이 기본인데... 이것때문에 몇번씩이나 헷갈리는 경우가 발생...
	이럴때는 Option > Preferences > Display : Options - Show exact case of file names를 설정한다.
2.	자주 쓰는 기능 정리	
	1.자주 쓰는 기능
	1.1 프로젝트 내 특정 심볼을 검색할 때?
	F7
	1.2 심볼이 검색이 안되는 경우는?
	프로젝트 전체 파일들에 대해 lookup reference 기능을 이용해서 찾는다.(grep 명령어와 비슷)
	ctrl + /
	1.3 특정 단어(심볼)을 하이라이트 해서 보고 싶을 때?
	shift + F8
	
	2.소스인사이트 세팅
	2.1 소스인사이트에서 ARM assembly language 추가하기
	안드로이드 소스 중 일부는 arm 기반의 어셈블리 파일로 되어 있다.
	소스 인사이트의 기본 설정은 arm assembly에 대한 언어 정보가 추가되어 있지 않으므로
	사용자가 별도로 추가해줘야 한다.
	http://kaisyu.springnote.com/pages/1578764
	2.2 소스인사이트 한글 주석 깨지는 걸 막는 매크로
	인터넷 검색중 가장 깔끔한 방식인 듯 싶네요.
	굳이 대화 상자 없이도 바로 입력 가능하게 하다니.. (정말 이 친구 아이디어 죽이네요 ^^)
	출처 : http://blog.daum.net/bluebread
	1. DoNoting() 이라는 macro를 만들어 추가한다. 진짜로 아무일도 하지 않는 걸로.
		macro DoNothing()
	    {
	    }
	2. Option > Key Assignment 을 선택한다.
	3. Macro: DoNothing 선택후에 Assign New Key를 누르고 다음의 키조합을 입력한다.
	    Shift + 한/영 (황당한 조합이지만 먹힌다.)
	4. 화면에 "shift+ " 로 표시되면 들어간 것이다.
	5. 완료!!	
	이후로 아무 것도 해줄 필요가 없다.
	그냥 메모장 쓰듯이 한글입력���면 된다. 쌍자음 그냥 입력해도 안 깨진다.
 	2.3 전체 file path를 보여주게끔 설정하기
	소스 인사이트는 기본적으로 긴 파일 path를 ...으로 축약해서 보여준다.
	소스 분석시 파일 경로를 제대로 아는 것은 매우 중요하다.
	다음과 같은 설정으로 긴 파일 path를 정확하게 볼 수 있다.
	Trim long path names with ellipses 체크를 지우기.
	2.4 떠 있는 창을 10개이내로 제한하기
	http://www.ericstory.com/tag/Source%20Insight
		
	3 단축키
	1. Ctrl + = 또는 Ctrl + 왼쪽 마우스 버튼
	=> 변수 및 함수에 커서를 위치시키고 이 키를 누르면 해당 선언문으로 이동 및 확인 할 수 있다.
	2. Ctrl + 0
	=> 우측 파일창으로 이동한다.
	3. Alt + L
	=> 좌측 함수창으로 이동한다.
	4. F7 키
	=> 프로젝트 전체에서 특정함수나 변수등을 찾기 위해 사용
	5. F8 키
	=> 현재 파일에서 특정함수나 변수등을 찾기 위해 사용
	6. F5 키 (라인수 입력창)
	=> 해당 라인으로 이동.
	7. Alt + < or >
	=> 이전/이후에 커서가 위치했던 곳으로 이동.
	8. Ctrl + f, F3, F4
	=> ctrl + f : 현재 파일 내에서 검색
	   F3 : 이전 검색 부분 이동
	   F4 : 다음 검색 부분 이동
	9. Alt + 드래그
	=> 블럭 단위로 선택.(라인 선택 아님)	
	10. Ctrl + L	
	=> 라인 번호 표시		 
	11. Ctrl + M	
	=> bookmark		
	12. Ctrl + H	
	=> replace	
	Ctrl+W(or w): close the current file
	Ctrl+Shift+W(or w) : close all the files
	Ctrl+S(or s): save the current file
	Ctrl+A(or a): save all the files
	F3/F4: search backward/forward
	Shift+F3/F4: search back/forward for the current word under cursor	
	Ctrl + =
	해당심볼의 선언부로 이동한다. 사용함수,변수의 선언부로 이동시 편리	
	Ctrl + /
	해당심볼로 프로젝트 전체범위로 검색	
	Shift + F9
	검색결과에서 다음검색으로 이동한다.	
	Ctrl + ,
	이전편집장소로 이동	
	F7
	프로젝트 내 심볼 검색 및 이동	
	F8
	파일 내 심볼 검색 및 이동	
	Shift + F8
	파일심볼창 보이기/숨기기




[76]	Excel -> PDF
1.	MS Word로 논문 쓸 때의 tip (pdf 변환, 그림 등)
http://yongjune.egloos.com/2895758
1. pdf 변환
1) MS word로 작성한 문서를 pdf로 변환할 때는 기본 add-in 기능을 쓰는 것이 가장 좋다. 
- 변환할 때는 반드시 pdf 옵션을 ISO 19005-1 호환으로 설정해야 한다. (참조: link)
- 변환하기 전에 모든 hyperlink를 제거해야 한다. 이 때는 CTRL+A로 전체를 선택하고, CTRL+SHIFT+F9로 hyperlink를 제거할 수 있다. 단, 텍스트 상자 내의 hyperlink는 제거 되지 않는다. (참조: link)
- 가급적이면 hyperlink를 유지한 원본 파일은 따로 보관하고, hyperlink를 제거한 파일을 추가로 만든다. 이후, word 작업을 할 때, hyperlink가 있는 것이 편리하다. 
(adobe acrobat 등으로 변환해도 되지만, EDAS에 업로드할 때는 '인쇄 품질'로 설정을 해야 한다. 그나마, 변환할 때, 그림의 캡션 등이 깨지는 현상이 발생할 수 있다.)

2. 그림
1) 그림은 텍스트 상자에 넣고 배치를 하는 것이 안정적이다. 
- 단, 텍스트 상자에 넣은 그림은 pdf 변환시 그림의 품질 저하를 막기 위해서는 ISO 19005-1로 pdf 변환해야 한다. (일반적인 option으로 변환하면 그림의 품질이 저하된다.)
2) 그림은 emf (확장 메타 파일)로 저장하는 것이 전반적으로 좋다. plot의 경우, eps가 좋을 수도 있다. 
3) 그림의 기준 위치는 고정해 놓는 것이 좋다. 기준 위치를 고정해 놓지 않으면, caption의 number가 뒤죽박죽이 될 수 있다. 기준 위치 고정은 레이아웃의 위치 탭에서 고정할 수 있다. 

정부 전자기록물 영구보존포맷 `PDF/A-1`로 확정  　공공기관 전자기록물을 영구적으로 보존하기 위한 문서보존포맷으로 ‘PDF( Portable Document Format)’가 확정됐다. 
따라서 내년에 보급될 정부기록관리시스템에 저장되는 전자문서는 ‘PDF/A-1’으로 저장된다. 
국가기록원은 2004년부터 추진해 온 ‘전자기록물 영구보존 기반기술 연구’ 사업 결과 ISO221 14721의 영구보존 패키지 개념을 수용한 문서보존포맷 ‘PDF/A-1(ISO 19005-1)’을 전자문서 장기보존용 포맷으로 결정했다고 27일 밝혔다. 
국가기록원은 보편성·안정성·메타데이터지원·상호운용성 등 국제적으로 제시되는 8개 고려사항을 만족시키는 문서보존포맷을 선정키 위해 XML·텍스트(Text)·이미지·PDF·CSD·PDF/A를 비교 검토했다. 
검토 결과 ‘PDF/A-1’이 8개 고려사항 모두를 만족시켰다고 국가기록원은 설명했다. 
특히 PDF/A-1은 특정업체에 기술이 종속되지 않는 공개용 표준으로 국제적으로도 호환성을 인정받았다.
윤대현 국가기록원 보존과장은 “전자문서 영구보존 포맷은 SW나 컴퓨터 환경변화에 관계없이 언제, 어디서나 내용재생이 가능해야 한다”며 “특정업체의 기술에 좌우되지 않고 이미 국내에도 독자적 기술이 있는 포맷을 선정했다”고 말했다. 
문서보존포맷이 결정되면서 국가기록원은 ‘PDF/A-1’ 변환모듈 개발작업에 나섰다. 국가기록원은 내년에 개발 보급될 ‘기록물관리시스템’에는 ‘PDF/A-1’을 장착할 예정이다.
한편 국내기술로 개발된 문서포맷으로 관심을 모았던 CSD는 공개용 표준이 아닐 뿐더러 편성(편재) 항목에서 ‘PDF/A-1’에 비해 불리한 것으로 나타났다.

3. C:\Users\user\AppData\Local\Microsoft\Office\UnsavedFiles




[77]	인쇄의 종류  인쇄 용어 / KNOWHOW  2013.08.04. 01:10 
        http://blog.naver.com/lis4574/110173386477 전용뷰어 보기 
       1. 마스터 인쇄 (Master Printing) 
      평판 인쇄방식으로 주로 경인쇄(輕印刷)에 사용됩니다. 
      마스터 페이퍼(옵셋에서는 인쇄판)를 판으로 사용하여 제판작업이 즉석에서 신속하게 처리되어 복사 인쇄물에 적합하며 비용도 저렴합니다. 
      내쇄력은 보통 2,000∼15,000매 정도입니다.
            장 점 빠른 속도로 발주에서 압기까지의 시간을 단축 적은 부수의 인쇄물에 사용합니다.
            단 점 색상면에서 미려하지 못하며 망점이 있는 원고(사진, 복잡한 로고)는 인쇄표현력이 좋지 못합니다.
            비 교 2도까지 일반적으로 처리가능 합니다.
            용 도 단색의 전단, 서식, 보고서, 빌지, 영수증
       
      2. 옵셋 인쇄 (Offset Printing) 
      평판 인쇄방식으로 판면(PS판,CTP판)에서 잉크화상을 고무 블랭킷에 전사하여 거기에서 종이 또는 피인쇄체에 인쇄하는 방법이며
      낱종이가 급지되는 매엽 인쇄방식과 두루마리 종이가 급지되는 윤전 인쇄방식이 있습니다. 
      기본적인 4도(CMYK)를 기준으로 하는 인쇄로 윤전인쇄는 대량의 인쇄물에 접합합니다. 
      정밀한 화상이 비교적 표면이 거친 종이에 인쇄되며 판면의 내쇄력이 수만매가 되어서 부수가 많은 인쇄물과 사진 칼라인쇄물에 적합합니다.
            장 점 고급인쇄물 정밀한 표현을 하고자 하는 인쇄물에 적합하며 색상표현이 풍부합니다.
            단 점 소량인쇄시 단가가 높으며 마스터에 비해 공정과정이나 시간이 더 소요됩니다.
            비 교 4도 풀칼라 및 금은별색, 별색인쇄
            용 도 화보집, 카다로그, 브로슈어, 잡지, 포스터, 인쇄광고지, 다색도의 고급인쇄물 등
       
      3. 실링 인쇄 (Seal Printing) 
      스티커, 라벨 등 상품의 포장, 봉함 또는 장식을 위해 붙이는 인쇄물로서 롤로 감거나 모양을 따서 인쇄가 가능하며 앞 또는 뒷면에 
      점착가공을 하는 인쇄방법입니다. 
      현재는 칼라 사진인쇄까지 가능하고 원형, 타원형 등 다양한 형태의 인쇄도 가능합니다.       
            장 점 인쇄 후 모양을 따는 것이 아니라 인쇄와 동시에 모양을 따낼 수 있어 시간이 절약됩니다.
            단 점 망점 표현등의 어려움과 원색인쇄시 퀼리티가 떨어집니다.
            비 교 1도 ~ 4도 칼라
            용 도 상품스티커 라벨, 라벨      
       
      4. 로타리방식 인쇄 (Rotary Printing) 
      행택, 입장권, 스키리프트, 곤돌라권/등등 롤로 감기게끔 인쇄가 되는 기계입니다. 
      실링인쇄와 비슷해보이나, 모양을 따거나 롤로 감기는 공통점 외에 여러가지 색으로 표현가능하고, 
      앞뒤로 같이 인쇄가 되는(앞4도뒤1도) 좋은 방식을 가지고 있는 인쇄기입니다. 
      윤전기(신문인쇄할때쓰는기계)의 축소판이라고 보면 되겠습니다.       
            비 교 1도 ~ 4도 칼라
            용 도 입장권, 행텍(라벨)       
       
      5. 활판 인쇄 (Letter Press Printing) 
      납을 주성분으로 하는 합금으로 주조된 사각기둥 위 부분에 문자 및 기호류를 도드라지게 만든 활자를 배열해서 
      만든 판으로 하는 볼록 인쇄의 일종으로 초창기 신문이나 서적 등에 이용된 인쇄방법입니다. 
      컴퓨터가 개발된 이후부터 경제적인 방법이 아닌 것으로 인식되어 현재는 많이 사용하지 않는 인쇄방법입니다.       
       
      6. 금박 인쇄 (金箔 , Stamping) 
      인쇄물을 아름답게 장식하기 위하여 볼록하게 만든 금형이나 수지판으로 엷은 금속막(금색,은색, 청색, 녹색 등)을 열을 가해서 압착 
      가공하여 인쇄하는 방법입니다. 
      주로 고급 포장박스나 책자의 표지 또는 고급 명함의 마크 등에 많이 이용됩니다.       
            장 점 인쇄물의 퀼리티를 높여 주며 상품의 가치를 높여주는 효과가 있습니다.
            단 점 망점 표현이 어렵고 복잡하거나 가느선 등의 표현이 어렵습니다.
            비 교 단색과 홀로그램 등 다양한 박지가 나와 있습니다.
            용 도 명함, 카다로그, 홀더, 청첩장, 안내장, 패키지 등 다양한 인쇄물에 적용   
      
      7. 플렉소 인쇄 (Flexo Graphic Printing)  
      &#65279; 
      볼록판 인쇄의 일종으로서 유연한 수지 또는 고무 볼록판을 사용하고 용제 건조형 잉크를 사용합니다. 
      양각부분에 잉크를 묻혀서 이를 프린트하는 방식으로 패턴의 주변부에 묻은 잉크가 강한 압력으로 밀려나와 윤곽이 한층 진하게 인쇄되므로 
      고급 인쇄에는 부적당하나 포장지, 박스, 라벨, 전산폼류와 사무용품류의 인쇄에 주로 사용됩니다.      
            장 점 건조형의 잉크의 특성상 증발에 의해 인쇄 후 빨리 마르며 식품에 직접 닿는 비닐 등에 사용해도
             안전하며 경제적입니다.
            단 점 망점표현이 어려워 퀼리티를 기대하기 힘듭니다.
            용 도 포장재료 인쇄
    
      8. 디지털 인쇄 (Digital Printing : POD) 
      컴퓨터로 작업된 데이터를 판을 만들지 아니하고 바로 인쇄하는 첨단방법으로 쇠로된 블랭킷에 직접 잉크를 분사하여 피인쇄체에 인쇄합니다. 
      소량 다품종의 신속한 인쇄에는 적합하나 아직까지 인쇄설비와 기자재가 고가(高價)인 관계로 국내에서 실용화되고 있지는 않습니다.       
            장 점 정확한 수량만큼만 인쇄하기 때문에 재고가 남지 않으며 단시간에 제작 가능합니다.
            단 점 소량인쇄는 적합하나 대량 인쇄시에는 경제적이지 못합니다.
            용 도 명함, 광고지, 팜플렛, 리플렛, 브로슈어, 카다로그, 청첩장, 안내책자 등 소량인쇄물
      
      9. 그라비어 인쇄 (Intaglio Printing) 
      종이 이외의 피인쇄체에 인쇄하는 특수인쇄의 하나로 오목판 인쇄방식으로 판을 만든 다음 옵셋인쇄처럼 고무 블랭킷에 잉크를 전이하여 
      피인쇄체에 인쇄하는 방식입니다. 주로 나무나 골프공 정제의약품 표면에 인쇄하는 등에 사용됩니다.       
            장 점 인체에 악영향이 적으며 대량인쇄시 옵셋에 비해 저렴한 편이며 풍부한 계조를 얻을 수 있기 때문에
             사진인쇄에 적합합니다. 종이 이외의 셀로판, 비닐, 폴리에틸렌, 금속, 나무 등에도 인쇄하기 쉽습니다.
            단 점 건조가 불충분하며 잔류 용제가 많다. 제작단가중 제판비가 비싸고 옵셋에 비해 많이 듭니다.
            용 도 포장지, 카톤박스, 쉬트
  
      10. 스크린 인쇄:실크인쇄 (Screen Process Printing) 
      공판인쇄방식으로 틀에 견포(絹布)나 기타 스크린을 걸고 수작업 혹은 사진원리의 방법에 의해 
      화상이외 부분의 스크린 결을 막고 잉크를 압출 투과하여 인쇄하는 방법입니다. 
      주로 병, 컵, 라이타, 타올, 전기부품, 현수막 등에 사용됩니다.       
            장 점 그림의 죄우가 바뀌지 않는 것이 특징이며 잉크의 선택이 자유롭습니다.
            단 점 다양한 색표현이 불가능하며 망점표현이 섬세하지 못합니다.
            용 도 포스터, 각종 플라스틱제품, 유리나 도자기 인쇄, 직물에 인쇄시 
   
      11. 스티커 인쇄 
      스티커인쇄는 크게 3가지 방법으로 제작되어집니다. 첫 번째는, 별색으로 동판을 사용하여 자동컷팅, 라미네이팅 되어지는 기법 으로 
      소량이나, 소형, 일반적인 스티커의대부분이 이 방법으로 제작되어집니다. 두 번째는, 4도 이상의 대형전문 스티커 기계로 대량의 또는 
      정밀묘사의 스티커를 제작할 때 주로 사용합니다. 세 번째로, 일반 옵셋인쇄기에 인쇄하는 기법으로 다종일 때 주로 사용합니다.       
            장 점 인쇄방법에 따라 선택이 용이하며 소량에서 대량까지 제품을 생산할 수 있습니다.
            단 점 양면인��가 불가하면 재질에 따라 양면인쇄가 가능하나 단가가 비쌉니다.
      
      12. UV 인쇄        
      옵셋과 같은 원리로 인쇄되���, 인쇄되면서 특수한 잉크를 쓰게 되게 UV를 쐬어서 말리는 형식의 인쇄입니다. UV인쇄를 하게 되면 
      종이에 잉크가 마르지 않아 묻어남이 없어 바로 가공하기에 편리하고 가공시간도 단축이 되며 다양한 재질에 인쇄가 가능하며 일반적으로 
      잉크를 흡수하지 못하는 재질에도 인쇄가 가능합니다.       
            장 점 빠른 건조로 후가공이 잇는 제품의 출고가 빠르며 재질선택에 구애를 받지 않습니다.
            단 점 인쇄단가가 일반 옵셋인쇄에 비해 단가가 비싼 편입니다.




[78]	랜선
		1.	다이렉트 케이블
			1번2번, 3번6번 선이 서로 꼬여 있지 않은 선으로
			보통 컴퓨터와 허브를 연결하거나 공유기를 할 때 사용되는 일반적인 랜선
			cf)	1번 위치(랜선을 뒤집어서 접촉 단자가 보이는 부분의 제일 왼쪽이 1번)
			cf)	핀 배열
				1	1
				2	2
				3	3
				4	4
				5	5
				6	6
				7	7
				8	8
		2.	크로스 케이블
			1번2번, 3번6번 선이 서로 꼬여 있는 선으로
			주로 컴퓨터와 컴퓨터를 직접 연결하거나 허브와 허브를 연결하는 등 동일한 장비를 연결할 때 사용 특수한 랜선
			cf)	1번 위치(랜선을 뒤집어서 접촉 ��자가 보이는 부분의 제일 왼쪽이 1번)
			cf)	핀 배열
				1	3
				2	6
				3	1
				4	4
				5	5
				6	2
				7	7
				8	8
				



[79]	



[80]	Heating Board
	1.	FND
		1)	단가
			[파츠키츠]7세그먼트/2채널/FND/Segment/아두이노 : 500원/1EA
			[DI031] 0.36인치 FND 7세그먼트 x2 (Cathode 타입) : 1,020원/1EA
		2)	제어 source, 4digit 동시 제어(깜박임 발생하지 않음)
#include <avr/io.h>
#include <util/delay.h>

char FND_cha(unsigned int);
char check_button(unsigned char);

unsigned char button=0x00;
unsigned char back_button = 0x00;
unsigned char FND=0x00, FND_A=0xff, FND_B=0xff, FND_C=0xff, FND_D=0xff;

int main(void){
    int a=0,b=0,c=0,d=0,i;
    
    DDRA = 0xff;
    DDRC = 0xff;
    DDRB = 0x00;
    

    while(1){
        button = PINB;
        if(button != back_button){
            if((button&0b00000001) == 0b00000001){
                FND_A = FND_cha(a);
                a++;
                if(a == 16){a=0;}
            }
            else if((button&0b00000010) == 0b00000010){
                FND_B = FND_cha(b);
                b++;
                if(b == 16){b=0;}
            }
            else if((button&0b00000100) == 0b00000100){
                FND_C = FND_cha(c);
                c++;
                if(c == 16){c=0;}
            }
            else if((button&0b00001000) == 0b00001000){
                FND_D = FND_cha(d);
                d++;
                if(d == 16){d=0;}
            }
        }
        PORTC = 0b00000001;
        PORTA = FND_A;
        _delay_ms(1);
        
        PORTC = 0b00000010;
        PORTA = FND_B;
        _delay_ms(1);
        
        PORTC = 0b00000100;
        PORTA = FND_C;
        _delay_ms(1);
        
        PORTC = 0b00001000;
        PORTA = FND_D;
        _delay_ms(1);
        
        back_button = button;
    }

 }

char FND_cha(unsigned int n){
    if(n == 0){FND = 0b11000000;}
    else if(n == 1){FND = 0b11111001;}
    else if(n == 2){FND = 0b10100100;}
    else if(n == 3){FND = 0b10110000;}
    else if(n == 4){FND = 0b10011001;}
    else if(n == 5){FND = 0b10010010;}
    else if(n == 6){FND = 0b10000010;}
    else if(n == 7){FND = 0b11111000;}
    else if(n == 8){FND = 0b10000000;}
    else if(n == 9){FND = 0b10011000;}
    else if(n == 10){FND = 0b10001000;}
    else if(n == 11){FND = 0b10000011;}
    else if(n == 12){FND = 0b11000110;}
    else if(n == 13){FND = 0b10100001;}
    else if(n == 14){FND = 0b10000110;}
    else if(n == 15){FND = 0b10001110;}
}




[81]	Altium
1.	Altium License 등록
Https://live.altium.com에 접속하시어 Sign in을 진행하시면 됩니다.
ID : yjlee@infopia21.com
P/W : Infopia21 입니다. 첫주 I의 경우 대문자 입니다.
위와 같이 Sign in을 진행하신 후 맨 상단위의 Dashboard를 클릭하신 후 Licenses에서
자회사에 속해져있는 Licenses를 확인 가능 합니다.
cf)	Altium License 등록 사용설명서는
Https://live.altium.com -> Advanced 교육자료에 기술되어 있음

인포피아는 Altium의 경우 1개의 License만 가지고 있다.

(주)알앤디테크 02-586-8111
sales@rndtech.co.kr

1)	? 뷰어로 보기 2016.06.01 20:06 ★★ Altium Designer Network v16버전설치 (1)(주)알앤디테크 댓글 0조회 수 212 ? 
(주)알앤디테크 입니다.
이번은 Altium Designer제품의 네트웍버전 설치에 대해 설명드리겠습니다.
크게 나누면 2가지 과정으로 나눌 수 있습니다.

A. 설치는 License Manager를 설치해 Client에서 누가 누가 사용하는지 확인하는 프로그램을 먼저 설치해 주셔야 합니다.
B. 그리고 Client가 Server와 접속해 연결될 수 있도록 방화벽을 해제하거나 ip프로토콜을 맞춰주면 사용가능합니다.
두번째 방화벽해제가 다소 어려움이 있어, 안내해 드리겠습니다.

1. live.altium.com에 접속해 프로그램을 다운로드 받습니다.
Product>Download>Private License Server의 경로로 라이센스 매니저를 다운로드 받습니다.
혹은 아래 링크를 통해 다운로드 받으실 수 있습니다.
Altium License Server 다운로드

2. Altium License Server를 설치하고 나면, 윈도우 바에서 오른쪽하단에 Tray 트레이를 선택합니다.
   Security가 나타나면, 오른쪽 마우스를 눌러서...Start Security Service가 활성화시킵니다.
3. Setting>Account Reference를 선택합니다.
4. Altium Portal Preferences가 나타나면, live.altium.com의 ID,PW를 입력하고 OK합니다.
5. Active를 클릭한후, Account Sign에서 로그인하면 됩니다.
이와 관련된 보다 자세한 설치방법은 Altium Blog를 클릭하셔서 열람하실 수 있습니다.

2)	? 뷰어로 보기 2016.06.01 20:17 ★★ Altium Designer Network v16버전설치 (2)(주)알앤디테크 댓글 0조회 수 187 ? 
(주)알앤디테크 입니다.
이번에 설명드릴 내용은, Altium Designer network버전을 설치하고 난 후, 윈도우 방화벽에 막혀 altium이 동작하지 
않을때를 대비한 설명입니다. 다소 난해한 부분이 있으니, 주의깊게 설치하시기 바랍니다.

1. 윈도우 제어판에서 "Windows 방화벽을 통해 프로그램 또는 기능허용"을 클릭합니다.
2. 방화벽에서 Altium License Manager가 통신하도록 연결설정합니다.
3. C:\Program Files(X86)\Altium\SecurityService\DXPSecurity.exe를 프로그램 등록을 해줍니다.
    1~3번까지 해서 Altium License Server셋팅은 완료되었습니다.

-------------------------------------------------------------------------------------------------------------------------
A. Windows 방화벽 > 고급설정을 선택합니다.
B. "고급 보안이 포함된 Windows방화벽"이 나타납니다.
C. 왼쪽 상단에 "인바운드 규칙"을 선택하고 오른쪽에 새규칙을 선택합니다.
D. 아래 그림처럼 프로그램을 선택하고, 경로에서 Altium License Server가 설치된 경로와 프로그램을 지정해줍니다. 
   일반적인 경로는, C:\Program Files(X86)\Altium\SecurityService\DXPSecurityService.exe를 지정해 줍니다.
   연결허용을 선택하고 다음을 클릭합니다.
E. 아래와 같이 도메인, 개인,공용이 기본적으로 선택되어 집니다. 여기서 다음을 선택하시고,
    인바운드 규칙(Inbound Rules)에 대한 이름을 설명으로 기입하고 마치면 됩니다.
-------------------------------------------------------------------------------------------------------------------------
혹은, Windows 방화벽의 Altium Communication Port를 이용해 연결하는 방법
1. 고급설정>인바운드>새규칙 에서 포트를 선택합니다.
2. 아래와 같은 화면에서 TCP를 선택하고, 특정로컬포트를 선택한후
3. 알티움이 통신하는 포트인 21001-21002를 입력하고 다음을 선택합니다.
4. 연결 허용을 선택하고, 다음을 선택
5. 화면에서 도메인,개인,공용을 선택하고 다음을 선택합니다.
6. 다음을 선택하면, 규칙이름을 정의하고 마침을 선택하면 규칙이 정의됩니다.

참고로 OrCAD, PADS는 Flexlm방식을 쓰지만 Altium은 자체 개발한 보안 프로그램을 사용해 네트웍버전을 관리하게 
됩니다. 보다 많은 altium user에게 도움이 되기를 바랍니다.

보다 자세한 그림과 설명은 Altium Blog를 클릭해 활용하시기 바랍니다.
감사합니다.

2.	Altium 설치 및 실행 방법
	1)	프로그램 설치
	2)	프로그램 실행 후
	3)	Home -> License Management -> Sign in
		ID : yjlee@infopia21.com
		P/W : Infopia21
	4)	Setup private license server
		Server name : RNDSVR-PC
		Server address : 10.1.75.245
		Server port : 21001
	5)	Private Server - Connected to 10.1.75.245
		Altium Designer -> Use
	6)	Altium 실행

3.	Altium -> PADS
	[SCH]
	PADS : Import -> Altium Designer(*.SCHDOC)
	[PCB]
	Altium : Save as -> Export P-CAD ASCII(*.PCB)
	PADS : Import -> P-CAD design files(*.PCB)
	
4.	PADS -> Altium
	[SCH]
	PADS : Export -> ASCII Files(*.TXT)
	Altium : Open -> All File(*.*)
	[PCB]
	PADS : Export -> ASCII Files(*.TXT)
	Altium : Open -> PADS PCB File(*.ASC)
	
	불러올 때 에러 발생하는 경우 PADS의 ASC 파일 버전을 2007/ 2005/ 5.0 으로 낮춰서 불러오면 됨
	9.X 버전의 ASC 일 경우 알고리즘이 틀려서 에러 발생할 수 있음




[81+1]	OrCAD
1.	Windows10 + OrCAD 16.0 Capture 실행시 리소스 이상 점유 문제
	본, 경우 CPU Resource를 100%로 잡아 먹는 현상 발생하며
	해결 방법은
	C:\OrCAD\OrCAD_16.0\tools\bin 폴더에 있는
	cdsMsgServer.exe와 cdsNameServer.exe 2개의 파일의 호환성설정을 XP Service Pack3로 설정하면 본 문제 해결 됨




[82]	Thermostatic Device
1.	Fuse bits
퓨즈 비트 내용 

[Bit 17] ■ ATmega103 Compatibility Model[M103C=0] 
-> 128을 103 대신 쓸때 체크 합니다. 

[Bit 16] ㅁ Watchdog Timer always on; [WDTON=0] 
-> 워치독을 하드웨어적으로 항상 On 시켜놓을 수 있습니다. 

[Bit 15] ㅁ On-Chip Debug Enabled; [OCDEN=0] 
[Bit 14] ■ JTAG Interface Enabled; [JTAGEN=0] 
-> JTAG을 사용하여 에뮬레이션 할때 사용합니다. JTAG 안쓰면 필요 없습니다. Bit 15도 체크 안하면 됩니다. 

[Bit 13] ■ Serial program downloading (SPI) enabled; [SPIEN=0] 
-> 항상 On 되어 있어야 합니다. ISP 케이블로는 이 비트를 지우거나 쓸 수 없게 되어 있습니다. 

[Bit 11] ㅁ Preserve EEPROM memory through the Chip Erase cycle; [EESAVE=0] 
-> 이 비트가 0이면(체크되어 있으면) 칩 Erase 시 EEPROM 데이터를 지우지 않습니다. 

[Bit 10,9] ㅁ Boot Flash section size=512 words Boot start address=$FE00; [BOOTSZ=11] 
[Bit 10,9] ㅁ Boot Flash section size=1024 words Boot start address=$FC00; [BOOTSZ=10] 
[Bit 10,9] ㅁ Boot Flash section size=2048 words Boot start address=$F800; [BOOTSZ=01] 
[Bit 10,9] ■ Boot Flash section size=4096 words Boot start address=$F000; [BOOTSZ=00] default value 
-> SelfProgramming 기능을 사용할때 부트로더의 크기를 지정합니다. 

[Bit 8] ㅁ Boot Reset vector Enabled (default address=$0000); [BOOTRST=0] 
-> 이 비트가 체크가 안 되어 있으면 위의 부트로더 크기는 상관 없습니다. 이 비트를 체크하면 리셋시 0번지가 아닌 위에서 설정된 부트섹션으로 점프합니다. 셀프프로그래밍 기능을 안 쓰시면 체크 안하시면 됩니다. 

[Bit 7] ㅁ Brown-out detection level an VCC=4.0V; [BODLEVEL=0] 
[Bit 7] ■ Brown-out detection level an VCC=2.7V; [BODLEVEL=1] default value 
[Bit 6] ㅁ Brown-out detection enabled; [BODEN=0] 
-> BOD 기능의 사용여부와, 레벨을 설정합니다. 데이터 쉬트 보세요 
-> MCU의 VCC전압 레벨이 일정 레벨 이하로 떨어질 때 MCU에서 발생할 수 있는 오동작을 방지하기 위해 MCU를 Reset 시켜주는 기능을 말함

[Bit 12] ㅁ CKOPT fuse(operation dependent of CKSEL fuses); [CKOPT=0] 
-> Cryastal 이나 Resonator의 발진 스윙폭과 관계 있습니다. 16MHz 를 쓰실땐 체크 해주셔야 합니다. 4MHz 정도면 체크 안해도 되고요. XTAL2에서 외부 디바이스로 클럭을 공급하실땐 체크 해줘야 합니다. 데이터쉬트 참고 하세요. 

% 이 부분부터 헷갈리실텐데, 데이터 쉬트 보십시요... 체크하면 0입니다. 아래쪽에서 적당한것 고르면 됩니다. 

[Bit 5,4 3,2,1,0] ㅁ Ext. Clock; Start-up time: 6 CK + 0 ms; [CKSEL=0000 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Clock; Start-up time: 6 CK + 4 ms; [CKSEL=0000 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Clock; Start-up time: 6 CK + 64 ms; [CKSEL=0000 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 1 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0001 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 1 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0001 SUT=01] 
[Bit 5,4 3,2,1,0] ■ Int. RC Osc. 1 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0001 SUT=10]; default value 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 2 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0010 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 2 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0010 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 2 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0010 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 4 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0011 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 4 MHz; Start-up time: 6 CK + 4 ms; [CKSEL=0011 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 4 MHz; Start-up time: 6 CK + 64 ms; [CKSEL=0011 SUT=10]; default value 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 8 MHz; Start-up time: 6 CK + 0 ms; [CKSEL=0100 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 8 MHz; Start-up time: 6 CK + 4 ms; [CKSEL= 0100 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Int. RC Osc. 8 MHz; Start-up time: 6 CK + 64 ms; [CKSEL= 0100 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz; Start-up time: 18CK + 0 ms; [CKSEL=0101 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz; Start-up time: 18CK + 4 ms; [CKSEL=0101 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz; Start-up time: 18CK + 64 ms; [CKSEL=0101 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz; Start-up time: 6CK + 4 ms; [CKSEL=0101 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz - 3.0 MHz; Start-up time: 18CK + 0 ms; [CKSEL=0110 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz - 3.0 MHz; Start-up time: 18CK + 4 ms; [CKSEL=0110 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz - 3.0 MHz; Start-up time: 18CK + 64 ms; [CKSEL=0110 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 0.9 MHz - 3.0 MHz; Start-up time: 6CK + 4 ms; [CKSEL=0110 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 3.0 MHz - 8.0 MHz; Start-up time: 18CK + 0 ms; [CKSEL=0111 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 3.0 MHz - 8.0 MHz; Start-up time: 18CK + 4 ms; [CKSEL=0111 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 3.0 MHz - 8.0 MHz; Start-up time: 18CK + 64 ms; [CKSEL=0111 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 3.0 MHz - 8.0 MHz; Start-up time: 6CK + 4 ms; [CKSEL=0111 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18CK + 0 ms; [CKSEL=1000 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18CK + 4 ms; [CKSEL= 1000 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 18CK + 64 ms; [CKSEL= 1000 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. RC Osc. 8.0 MHz - 12.0 MHz; Start-up time: 6CK + 4 ms; [CKSEL= 1000 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Low-Freq. Crystal; Start-up tie : 1K CK + 4 ms; [CKSEL= 1001 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Low-Freq. Crystal; Start-up tie : 1K CK + 64 ms; [CKSEL= 1001 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Low-Freq. Crystal; Start-up tie : 16K CK + 64 ms; [CKSEL= 1001 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 4 ms; [CKSEL= 1010 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 258 CK + 64 ms; [CKSEL= 1010 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 0 ms; [CKSEL= 1010 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 4 ms; [CKSEL= 1010 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 1K CK + 64 ms; [CKSEL= 1011 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 0 ms; [CKSEL= 1011 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 4 ms; [CKSEL= 1011 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Low Freq.; Start-up time: 16K CK + 64 ms; [CKSEL= 1011 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 4 ms; [CKSEL= 1100 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 258 CK + 64 ms; [CKSEL= 1100 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 0 ms; [CKSEL= 1100 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 4 ms; [CKSEL= 1100 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 1K CK + 64 ms; [CKSEL= 1101 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 0 ms; [CKSEL= 1101 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 4 ms; [CKSEL= 1101 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator Medium Freq.; Start-up time: 16K CK + 64 ms; [CKSEL= 1101 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 4 ms; [CKSEL= 1110 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 258 CK + 64 ms; [CKSEL= 1110 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 0 ms; [CKSEL= 1110 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 4 ms; [CKSEL= 1110 SUT=11] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 1K CK + 64 ms; [CKSEL= 1111 SUT=00] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 0 ms; [CKSEL= 1111 SUT=01] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 4 ms; [CKSEL= 1111 SUT=10] 
[Bit 5,4 3,2,1,0] ㅁ Ext. Crystal/Resonator High Freq.; Start-up time: 16K CK + 64 ms; [CKSEL= 1111 SUT=11] 

AVR Studio 에서 STK500에서 128에 대한 퓨즈만 골라 놓은 것입니다. 
이게 128 퓨즈비트의 전부죠 

이상 윤덕용 교수님 사이트에서 어떤 분이 올리신거 퍼온겁니다
----------------------------------------------------------
이 위로 퍼온겁니다. 제가 삽질을 워낙 많이 하면서도 잘 알지 못했던 부분이기에 나중에라도 AVR하시는 분은 fusebit때문에 삽질 안했으면 합니다. (철성생각)  
  



[82]	PATHFAST
1.	CLEIA(chemiluminescence enzyme immunoassay)
	화학발광효소면역측정법(CLEIA:Chemiluminescence Enzyme Immunoassay)을 이용한 전자동 면역측정장치이다. 
	효소를 이용한 화학발광법에 따라 검체 중의 미량물질을 측정하고 시료 흡입부터 측정 결과 표시까지 약 17분이라는 단시간에 측정할 수 있다는 점이 주된 특징이다.




[83]	LDO vs Switching regulator
http://cache.national.com/pf/LM/LM2576.html 로 가시면 알수 있구요.. 

7805는 linear regulator 이고 LM2576은 switching regulator 입니다. 
두 레귤레이터에 대한 비교는 다음과 같습니다.
 
스위칭 레귤레이터란? 
스위칭 레귤레이터는 출력 전압을 생성하기 위해, 에너지 저장 컴포넌트(커패시터 및 유도기) 및 출력 스테이지를 사용하는 장치로서, 켜짐과 꺼짐을 반복합니다. 
레귤레이션 기능은 출력 전압의 피드백 샘플에 기초한 스위치 타이밍 조정을 통해 이루어집니다. 고정 주파수 레귤레이터에서는, 
PWM 컨트롤로 알려져 있는 스위치 전압의 펄스 폭을 변조시킴으로써 스위치 타이밍을 조정합니다. 게이트 오실레이터 또는 버스트 방식 레귤레이터에서는 스위치 펄스 및 주파수가 일정하게 유지되지만, 
출력 스위치는 피드백 컨트롤에 의해 게이트 온 또는 오프됩니다.
스위치 및 에너지 저장 컴포넌트의 배열에 따라 출력 전압을 입력 전압 이상 또는 이하로 생성시킬 수 있으며, 
이러한 다중 출력 전압은 하나의 레귤레이터로도 생성될 수 있습니다. 대부분의 경우, 동일한 입력 전압 및 출력 전력 조건 하에서는 소스 buck(강압) 스위칭 레귤레이터가 
선형 레귤레이터보다 원시 전력 변환에 훨씬 더 효율적입니다..
->	Switching regulator는 Switching regulator 외부에서 setting할 수 있는 setting resistor에 의해서 출력 전압을 변경할 수 있으며
	본 setting resistor setting에 의한 출력 전압은 입력 전압이 변경되어도 변경되지 않음
	ex)	입력전압이 9V에서 12V로 변경되어도 출력 전압은 setting resistor에 의해서 정해진 전압으로 계속 유지 됨

LDO(Low Drop-Out) 레귤레이터란? 
LDO는 일종의 선형 레귤레이터입니다. 선형 레귤레이터는 선형 영역 내에서 작동되는 트랜지스터나 FET를 사용하여, 입력된 전압에서 과도한 전압을 제거해 줌으로써 원하는 출력 전압을 생성해 주는 장치입니다. 
레귤레이터가 출력 전압을 공칭값100mV 이내로 유지시키는 데 필요한, 출력 전압 차동(differential)에 대한 최소한의 입력 전압을 드롭 아웃 전압이라고 합니다.
포지티브(positive) 출력 전압을 위한 LDO(Low Drop-Out) 레귤레이터는 전력 트랜지스터(패스 장치라고도 함)를 위해 PNP를 자주 사용합니다. 
이 트랜지스터는 포화(saturate)가 허용되므로 레귤레이터가 통상적으로 200mV내외의 매우 낮은 드롭 아웃 전압을 지닐 수 있는 반면, 
NPN 복합 전력 트랜지스터를 사용하는 일반적인 선형 레귤레이터는 2V나 되기 때문에 많은 차이를 느낄 수 있습니다. 네거티브(negative) 
출력 LDO는 포지티브 출력 LDO의 PNP 장치와 비슷한 방식에서 작동하는 패스 장치를 위해 NPN을 사용합니다. 
CMOS 전력 트랜지스터를 사용하는 신형 제품들은 가장 낮은 드롭 아웃 전압을 제공할 수 있습니다. 
CMOS에 있어서 레귤레이터의 유일한 전압 드롭은 전력 장치의 ON 저항에 부하 전류를 곱한 값입니다. 부하가 적을 경우에 그 값은 수 십 밀리 볼트에 불과하게 됩니다.
->	출력전압이 불변

 선형 레귤레이터와 스위칭 레귤레이터의 비교? 

선형 전압 레귤레이터 							스위칭 전압 레귤레이터 
이점: 											이점: 
?단순함   										?높은 효율성(원시 전력 필요량 및 히트 싱크 요구 사항이 줄어듦) 
?낮은 출력 리플 전압   							?높은 전력 밀도를 처리할 수 있는 능력 
?탁월한 라인 및 부하 레귤레이션 				?입력 전압보다 높거나 낮은 단일 및 다중 출력 전압을 제공할 수 있는 토폴로지  
?부하 또는 라인 변화에 대한 빠른 대응 시간   	?열이 많이 나지 않음
?낮은 전자파 장애(EMI)							?setting resistor, setting으로 출력전압을 변경할 수 있음

단점:											단점: 
?낮은 효율성   									?상대적으로 높은 출력 리플 전압
?히트싱크 필요 시 많은 공간 필요?(열이 많이 남)	?상대적으로 느린 트랜지언트 회복 시간
?출력전압 불변									?전자파 장애 발생
 
 출처 http://cache.national.com/KRN/appinfo/power/0%2C1768%2C318%2C00.html
 
 
  

[84]	OpenCV
cf)	LearnOpenCV SOURCE
	https://github.com/spmallick/learnopencv/blob/master/README.md?ck_subscriber_id=1056442416

84_1-4.Python애서 OpenCV version check ( OpenCV 버전 확인)
1) 터미널에서 하단 명령 실행
	python
	>>> import cv2
	>>> cv2.__version__
	'4.1.0'

84_1-3.이미지 확장자중 가장 화질이 좋은 것은 무엇인가요?

Q :그림판에는 단색 비트맵, 16색 비트맵, 256색 비트맵, 24비트 비트맵, JPEG, GIF, TIFF, PNG 이런 이미지 파일 
형식으로 저장할 수 있는데요. 어느 것이 가장 화질이 좋은가요? PNG랑 bmp계열이 가장 화질이 나은거 같은데 맞나요? 맞다면 둘 중 어느 
것이 더 화질이 좋은가요?
그리고 저 것 보다 더 화질이 좋은 확장자는 없을까요? 그림판으로 만든 파일을 인쇄하니깐 글씨가 pdf나 한글파일처럼 아주 선명하진 않던데 
어떻게 방법이 없을까요? 더 화질이 좋은 확장자가 있는지, 그 확장자를 그림판을 통해 저장할 수 있는 방법이 있는지, 그렇게 할 수 없다면 그 
확장자로 저장하기 위해선 어떤 프로그램을 써야하는지 궁금하네요. 꼭 답변해주세요

A: 
단색은 그대로 단색만 표현되구요. 아마도 흑백일듯 싶네요.
16색이나 256색은 말 그대로 16가지나 256가지 색상만을 표현한 이미지입니다.
24비트 비트맵의 경우 아마도 8비트 비트댑스 이미지인듯 하네요.
우리가 보는 대부분의 이미지가 24비트 이미지구요.

8비트 비트댑스란...컴퓨터가 색을 표현함에 있어서 RGB 3가지 채널로 표현되는데 한가지 채널이 256가지 단계를 표현할수 있고 채널이 3개다 
보니 이걸 3번 곱해서 1천6백7십만 가지 색상이 표현됩니다.
정리하자면 채널 하나당 8비트(256단계칼라 표현) RGB 3가지해서 8*3=24...그래서 24비트 비트맵...
총 표현색상수 1천6백7십만가지..
그래서 일단 24비트 비트맵이 가장 화질이 좋습니다.

파일 포맷에 대해서는 BMP가 어떠한 압축도 하지 않은 원본 그대로의 화질을 유지합니다.
용량이 커서 잘 자용하지 않는 포맷입니다.
TIFF나 TGA 그리고 PNG 등은 모두 무손실 압축방식을 사용합니다.
압축을하기때문에 용량은 줄어들지만 화질은 그대로입니다.
단...무조건 압축되는게 아니라 면화나 텍스트와 같이 연속된 색이 많으면 많을수록 압축률이 좋습니다.
실제 사진같은 이미지의 경우 압축은 거의 되지 않습니다. 픽셀 하나하나가 전부 다른색이니까요.
바로 옆에 인접한 픽셀이 색상이 동일해야만 압축을 하게 됩니다.

gif의 경우 화질이 많이 떨어지구요 주로 저용량을 올리는 웹등에서 많이 사용합니다.

png는 gif의 화질이 많이 떨어지는걸 대체하기 위해 개발된 포맷으로 화질열화는 거의 없고 용량이 적기 때문에 요즘은 png를 많이 
사용하구요.

jpg가 가장 일반적인 국민 포맷인데 jpg의 경우 인접한 픽셀이 완전 같지 않아도 얼추 비슷한 색이다..라고 판단되면 압축을 해버리기 때문에 
화질열화가 생깁니다. 보통 최상품질로 저장했을경우 화질열화가 크게 일어나지않고 압축률도 좋기 때문에 많이 사용하지만 어쨌든 화질은 깨집니다.

psd와 같이 포토샵 전용포맷도 역시 화질 열화가 없구요.

기본적으로 화질변화가 없는 확장자는 bmp, tga, tiff, png, psd등이 있겠습니다.
이것들 자체가 원본화질을 유지하기때문에 이것보다 더 좋은 화질을 유지하는건 없구요.

보통 인쇄를 할때는 dpi라는 개념이 있습니다. 비트맵이미지가 픽셀이라는 작은 점들로 이루어진 이미지인지라 이미지 사이즈가 작다면 선명한 인쇄는 
힘들구요. 그래서 벡터형식을 지원하는 일러스트레이터등을 사용합니다. 비트맵 이미지를 인쇄하기 위해서는 dpi 라는 개념을 아셔야 합니다.
컴퓨터의 단위인 픽셀을 실단위인 cm나 mm 등으로 환산하기 위해서 dpi 수치에 의해 픽셀 사이즈가 변동사항이 있습니다. 이런건 그림판에서 
설정하기란 힘들도 처음부터 매우 큰 이미지에서 작업을 하셔야 합니다

cf)	
1. raw 생성 이미지 - 색상 경계선이 나름 확실하게 구별하여 이미징 되어 있다.
2. JPEG 생성 이미지 - 색상의 경계선 부분이 모호하게 또는 두리뭉실 처리되어 있다.

JPG, GIF, PNG, BMP 확장자란?
JPEG 는 포토샵 등에서 편집할 때 다양한 옵션 (압축률 등) 을 통해 같은 이미지를 다양한 품질과 크기 등으로 압축 저장하는 데 용이합니다. 
최소의 파일크기로 손실이 크지않은 이미지 보관용으로 적합하기 때문에 가장 널리 쓰이는 포맷이 된 것입니다. 모니터 표시용 색상 범위인 RGB 와 인쇄용 색상 범위 CMYK 모드를 지원합니다.

GIF 는 질문에 등록하신 이미지처럼 애니메이션 정보를 포함하는 것이 가능한 이미지 포맷입니다. 
여러 이미지들을 영사기처럼 차례대로 재생되도록 한 파일 안에 저장하는 것이 가능하지만 최대 256 색상까지밖에 지원되지 않기 때문에 
이미지 자체의 화질은 다른 포맷들에 비해 상당히 떨어지게 됩니다. PNG 포맷이 등장하기 전까지는 배경이 투명한 이미지를 사용할 때에도 GIF 포맷이 사용되었지만, 
PNG 처럼 픽셀의 반투명도 농도까지 지원하지 못하고 완전히 투명하지 않은 픽셀은 배경색이 하얀색으로 채워지기 때문에 투명 이미지의 가장자리에 하얀색 찌꺼기 픽셀들이 남게되는 불편한 단점이 존재합니다.

PNG 는 완전한 RGB 전용 파일로 8비트/32비트 채널 형식이 있으며 잘 알고계신 투명 배경 파일들은 이 포맷으로 저장된 이미지들입니다. 
투명 픽셀 저장이 가능한 기존의 GIF 보다 훨씬 많은 색상수로, 고품질의 이미지를 알파 채널(투명 픽셀) 정보와 함께 저장하는 것이 가능합니다. 
투명 픽셀의 농도를 0~255 단계까지 폭넓게 사용할 수 있기 때문에 반투명한 색상 픽셀이라도 다른 배경색이 섞이지 않고 완벽하게 투명도를 표현하게 해줍니다.
cf)	정말 File -> Export -> Save for Web(Legacy) -> JPEG를 PNG-24로 변경 -> Save하면
		GIF일 때는 이미지 외곽에 흰색찌꺼기가 껴 있던 것이 완전히 사라진 아주 깨끗하고 해상도가 높은 투명바탕의 이미지를 얻을 수 있음

BMP 는 가장 오래된 이미지 포맷 중 하나입니다. 높은 비트 수로 저장될수록 고품질의 이미지 화질이 보장되지만, 
JPEG 나 PNG 포맷에 비해 압축률이 상당히 떨어지기 때문에 고화질 이미지를 저장하게 될 경우 파일의 용량이 상당히 커지게 되어 실용성이 떨어지게 됩니다. 
하지만 예전에 개발된 프로그램에서 이미지 파일을 사용하게 될 경우, 근래에 개발된 파일 포맷이 호환되지 않을 수 있기 때문에 BMP 포맷이 아직까지도 널리 사용되고 있기도 합니다.

cf)	PNG (Portable Network Graphics)
PNG 포맷을 만들게 된 배경
PNG(Portable Network Graphics)는 비손실 그래픽 파일 포맷의 하나이다.
PNG는 미국의 컴퓨 서브(Compu Serve)가 중심이 되어 개발한 그래픽 포맷으로 인터넷과 같은 네트워크상에서 빠른 전송과 이미지 재생이 가능하다. 
PNG는 미국 유니시스(UNISYS)사의 GIF 포맷에 대항하기 위해 만들어졌다. 즉, GIF의 저작권을 가지고 있던 유니시스사가 GIF에 저작권료를 부가하려는 움직임을 보이자 
이에 대한 대안으로 컴퓨 서브가 주축이 된 연합세력이 등장하게 된 것이다. PNG는 1995년경에 처음으로 등장하였으며, 
유닉스 매킨토시 등 각기 다른 기종의 시스템과 어플리케이션에서 동일한 그래픽 이미지를 보여줄 수 있다. 
특히, PNG 파일에는 그 그래픽을 처음 제작했던 프로그램에 대한 정보를 기록할 수 있어, 웹 브라우저나 다른 프로그램에서 이 정보에 맞게 자동으로 이미지를 재구성할 수 있는 장점이 있다. 
또한, PNG는 기존 JPG나 GIF에 비해 월등히 빠른 출력 속도를 보이고 있어, 웹 관련 국제 컨소시엄인 W3C에 의해 새로운 www 이미지 표준으로 도입되기도 했다.

또한 256 색만을 저장할 수 있는 GIF는 한계가 있으므로 컴퓨터 성능이 좋아지면서 문제가 되어 왔다. 
1999년 8월, 유니시스가 자유 소프트웨어와 비상업 소프트웨어에 대한 무료 특허 정책을 거둬들이면서 PNG는 인기를 끌기 시작했다.
이 알고리즘은 미국 특허 4,558,302번으로 등록되어 있고, 다른 여러 나라에도 등록되어 있다.

GIF와의 비교
대부분의 경우 PNG는 GIF보다 압축률이 더 높다.
GIF의 단색 투명층과 달리 8비트 알파 채널을 이용한 투명층을 지원한다.
256색을 지원하는 GIF와 달리 트루 컬러를 지원한다.
GIF에서는 제공되는 애니메이션을 PNG는 지원하는 않는다. (대안으로 PNG에 기반한 APNG, JNG, MNG와 같은 파일 형식이 제안되었다.)

파일 크기
PNG가 GIF보다 최신의 압축 알고리즘을 사용하지만, GIF보다 더 큰 파일을 만든다고 알고 있는 사람이 있다. 여기에는 몇 가지 까닭이 있는데, 
GIF는 256색만을 지원한다. 트루 컬러 그림을 PNG로 압축할 때는 원본의 색을 다 저장하는 반면, GIF로 저장할 때는 256 색으로 수를 줄인 다음에 저장한다.
 만약 원본도 256색만을 사용한다면 이런 차이는 나오지 않는다.

PNG 파일 형식에는 메타데이터가 추가로 붙어 있는 경우가 있다. (어도비 사의 파이어웍스 등).
어도비 포토샵의 일부 옛 버젼에서는 PNG 압축 알고리즘을 잘 구현해 내지 못해 큰 파일을 만들곤 했다.
PNG 파일의 크기를 줄이는 OptiPNG나 pngcrush와 같은 오픈 소스로 MS-DOS에서 유닉스나 리눅스 등의 다양한 환경을 지원하여 제공하고 있다.

JPEG와의 비교
왼쪽의 JPEG 파일에 비해 오른쪽의 PNG 파일이 훨씬 더 깔끔하다.손실 압축 알고리즘을 사용하는 JPEG가 PNG에 비해 더 작은 파일을 만든다. 
경우에 따라 5-10배 차이를 보이기도 한다. 하지만 JPEG 압축은 양자화의 영향으로, 바라지 않던 잡티가 낄 수 있다. 
문자나 날카로운 경계가 있는 그림은 JPG에서 뭉게지기 쉽기 때문에 PNG를 쓰는 게 더 낫다.

또한, PNG는 비손실 압축이므로, 나중에 편집을 해야 한다면 PNG로 저장해 놓는 것이 낫다. JPEG를 사용할 때는 저장을 하면 할수록 계속 손실이 누적될 수 있다.

GIF (Graphics Interchange Format)
'Graphics Interchange Format'의 약자로 인터넷에서 그래픽을 압축하여 빠르게 전송하려는 목적으로 개발되었다. 
1987년 미국의 컴퓨서브(CompuServe)사가 처음 개발하였으며, 2002년 12월 현재 버전은 1989년 발표한 GIF89a이다.
GIF는 인터넷에서 래스터 화상을 전송하는 데 널리 사용되는 파일 형식으로, 최대 256가지 색이 사용될 수 있는데 실제로 사용되는 색의 수에 따라 파일의 크기가 결정된다. 
그러므로 적은 수의 색이 사용된 화상은 컴퓨터에서 많은 수의 색이 사용된 화상보다 적은 메모리 공간을 차지한다.
또 LZW 압축 방법을 사용하여 파일의 크기를 1.5:1에서 2:1의 비율로 압축함으로써 파일의 크기를 더한층 축소시킨다. 
GIF에는 특정한 색을 투명색으로 지정함으로써 한 페이지 또는 윈도의 배경을 투명하게 할 수 있는 투명 GIF, 화상을 저해상도부터 서서히 뚜렷한 화상으로 표시할 수 있는 
인터페이스 GIF, GIF를 연속적으로 표시하는 GIF 애니메이션 등이 있으며, 이것들을 조합할 수도 있다.
GIF는 JPEG 파일에 비해 압축률은 떨어지지만 사이즈가 작아 전송속도가 빠르고 이미지의 손상도 적다는 장점을 가지고 있다. 
이미지파일 내에 그 이미지의 정보는 물론 문자열(comment)과 같은 정보도 함께 저장할 수 있고, 여러 장의 이미지를 한 개의 파일에 담을 수도 있다.
또, 통신용 파일이므로 인터레이스 형식으로도 저장된다. 인터넷상에서 이미지파일 포맷으로 가장 널리 사용되어 사실상 표준으로 평가된다. 
그러나 저장할 수 있는 이미지가 256색상으로 제한되어 있어 다양한 색상을 필요로 하는 이미지를 저장하는 형식으로는 적당하지 않다.
그리고, 이미지를 조금씩 보여주는 기법인 Interlace기법, 이미지를 투명하게 만드는 Transparent기법, 그리고 고정된 각각의 이미지 파일을 재생시켜 움직이는 화면이 가능하게 할수 있어 
비교적 짧은 시간의 에니메이션 제작이 가능하다.
- 장점 : 압축률이 높고, 애니매이션, 즉 움직이는 이미지와 투명 이미지를 저장할 수 있다.
- 단점 : 화질 면에서 조금 떨어진다.
- 용도 : 아이콘, 애니매이션이 들어간 이미지 등등...

JPEG (Joint Photographic Coding Experts Group)
JPEG 위원회에 의해 개발되었다. 정지 화상을 위해서 만들어진 손실 압축 방법 표준이다. 이 표준은 ISO와 ITU-T에서 제정하였다. 
JPEG를 사용하는 파일 형식들도 보통 JPEG 이미지라 불리며, .jpg, .jpeg, .jpe 등의 확장자를 사용한다.
JPEG는 풀 컬러(full-color)와 그레이 스케일(gray-scale)의 압축을 위하여 고안되었으며, 사진이나 예술분야의 작업에서 장점을 나타낸다. 
GIF와 함께 인터넷에서 가장 자주 사용된다. GIF에 비해 데이터의 압축 효율이 더 좋다. 또한 GIF는 256색을 표시할 수 있는데 반해 JPEG는 1,600만 색상을 표시할 수 있어 고해상도 표시장치에 적합하다.
또 한 가지 JPEG의 유용한 점은 이미지를 만드는 사람이 이미지의 질과 파일의 크기를 조절할 수 있다는 것이다. 
예를 들어, 이미지가 큰 파일을 아주 작은 크기의 파일로 압축하려 하면 이미지의 질이 그만큼 떨어지게 된다. 
그러나 JPEG 압축기술을 이용하면 이를 적절히 조절하여 이미지에 손상에 가지 않도록 이미지를 압축할 수 있다.
JPEG 표준은 이미지가 어떻게 연속된 바이트로 바뀌는지만을 규정한다. 독립 JPEG 그룹(Independent JPEG Group; IJG)에서 만든 
JPEG의 확장인 JFIF(JPEG File Interchange Format)는 JPEG 스트림을 저장과 전송에 적합한 형태로 담는 이미지 파일 형식이다.
디지털 카메라의 사진 저장 방식으로는 다른 확장인 EXIF JPEG 형식이 더 자주 사용된다. 일반적으로 JPEG 파일이라고 할 때는 
JFIF 형식이거나 EXIF JPEG 형식을 가리키지만, JNG와 같은 JPEG 기반의 다른 파일 형식도 존재한다.
JPEG/JFIF는 웹 상에서 사진 등의 화상을 보관하고 전송하는 데 가장 널리 사용되는 파일 형식이다. 
하지만 이 압축 방법은 문자, 선, 세밀한 격자 등 고주파 성분이 많은 이미지의 변환에서는 GIF나 PNG에 비해 불리하며, 나쁜 품질을 보이는 경우가 많다.
JPEG 표준에도 비손실 압축 방법이 정의되어 있지만 특허 문제와 압축률 등의 이유로 잘 사용되지는 않으며, PNG 등의 비손실 압축을 지원하는 포맷을 많이 사용한다.
- 장점 : 고화질이며 압축률이 높아서 용량이 작고, 이미지 확장자 중 가장 많이 쓰인다.
- 단점 : 손글씨, 도트, 아이콘 등의 이미지는 화질이 저하 된다.
- 용도 : 사진, 대부분의 이미지 파일...

BMP (Bit Map)
비트맵 : 마이크로소프트 윈도, OS/2 등의 운영 체제에서 쓰는 그림 파일의 확장자.
- 장점 : 제일 기본적인 이미지 파일이며, 이미지 확장자 중에서 화질이 제일 선명하다.
- 단점 : 압축이 전혀 되지 않아서 용량을 많이 차지하며, 대부분의 사이트에서 업로드를 제한하기 때문에 인터넷에 올리기 어렵다.
- 용도 : 개인소장용 이미지, 설계도, 작업중인 이미지, 윈도우 배경파일 등등.


84_1-2.OpenCV 문법
0)
	가)	imwrite(im2,'myMultipageFile.tif','WriteMode','append')
	나)	subtract vs absdiff
			subtract 는 결과 음수값을 0으로 치환하는 반면
			absdiff 는 절대치 차를 표현
	다)	imread
    img = plt.imread(path)          # plt.imread -> 0~1 float으로 읽어들임(각 픽셀당 DATA배열 : RGB 순서)
                                    # ex) img:[0:69]:00:[0:71]:00:[0:3]: -> 0: 0.93333334(R), 1:0.9372549(G), 2:0.94509804(B)
                                    #     cf) plt.imread 로 읽어 들인 첫번째 이미지의 경우 Width 71pixels, Height 69pixels 이고
                                    #         첫번째 픽셀(1pixel, 1pixel) 값은  0: 0.93333334(R), 1:0.9372549(G), 2:0.94509804(B) 임
                                    #     cf) 0: 0.93333334(R) = 238/255, 1:0.9372549(G) = 239/255, 2:0.94509804(B) = 241/255

    img2 = cv2.imread(path)         # cv2.imread -> 0~255 integer로 읽어들임(각 픽셀당 DATA배열 : BGR 순서)
                                    # ex) img2:[0:69]:00:[0:71]:00:[0:3]: -> 0: 241(B), 1:239(G), 2:238(R)   
                                    #     cf) cv2.imread 로 읽어 들인 첫번째 이미지의 경우 Width 71pixels, Height 69pixels 이고
                                    #         첫번째 픽셀(1pixel, 1pixel) 값은  0: 241(B), 1:239(G), 2:238(R) 임
	라)	Mat 각 픽셀값 정보 얻는 방법
		Mat img2 = imread("../test/Orange/3_100.jpg", IMREAD_COLOR);		// ex) 3_100.jpg이미지 파일의 첫번째 pixel의 값은 245(B), 254(G), 255(R) 임
//	print_matInfo("img2", img2);											// img2 크기 [100 x 100],  자료형 CV_8UC3
																											// [245, 254, 255, 247, 255, 255, 250, 255, 253, 252, 255, 251, 255, 255, 249, 254, 255, 250, 254, 255, 253, 253, 255, 254,
//	cout << "img2 =" << endl << img2 << endl << endl;	// img2 =
																											// [245, 254, 255, 247, 255, 255, 250, 255, 253, 252, 255, 251, 255, 255, 249, 254, 255, 250, 254, 255, 253, 253, 255, 254,
	마)	cvtColor(img2, img3, COLOR_BGR2RGB);						// 본 명령 실행하면 BGR -> RGB 로 Blue와 Red가 순서가 제대로 바뀌는 것이 확실함(ex, 빨간색 사과가 청색 사과로 확실히 모양을 유지하면서 변경됨)
			ex)
			Mat img2 = imread("../test/Orange/3_100.jpg", IMREAD_COLOR);		// ex) 3_100.jpg이미지 파일의 첫번째 pixel의 값은 245(B), 254(G), 255(R) 임
	//	print_matInfo("img2", img2);												// img2 크기 [100 x 100],  자료형 CV_8UC3
																													// [245, 254, 255, 247, 255, 255, 250, 255, 253, 252, 255, 251, 255, 255, 249, 254, 255, 250, 254, 255, 253, 253, 255, 254,
	//	cout << "img2 =" << endl << img2 << endl << endl;		// img2 =
																													// [245, 254, 255, 247, 255, 255, 250, 255, 253, 252, 255, 251, 255, 255, 249, 254, 255, 250, 254, 255, 253, 253, 255, 254,
			Mat img3;
			cvtColor(img2, img3, COLOR_BGR2RGB);								// 본 명령 실행하면 BGR -> RGB 로 Blue와 Red가 순서가 제대로 바뀌는 것이 확실함(ex, 빨간색 사과가 청색 사과로 확실히 모양을 유지하면서 변경됨)
			cout << "img3 =" << endl << img3 << endl << endl;		// img3 =
																													// [255, 254, 245, 255, 255, 247, 253, 255, 250, 251, 255, 252, 249, 255, 255, 250, 255, 254, 253, 255, 254, 254, 255, 253,
	바)	폴더 내부 여러 이미지파일 읽어들이기
			vector<cv::String> fn;
			glob("/home/images/*.png", fn, false);
			
			vector<Mat> images;
			size_t count = fn.size(); //number of png files in images folder
			for (size_t i=0; i<count; i++)
			    images.push_back(imread(fn[i]));

1)	Class : Mat
	-	image.channels() : 이미지의 채널 수(ex, RGB컬러의 경우 3채널, 흑백인 경우 1채널)
	-	image.rows : 이미지의 세로 픽셀 수
	-	image.cols : 이미지의 가로 픽셀 수
	-	image.total() : 이미지의 총 픽셀 수 = (가로 픽셀 수 x 세로 픽셀 수)
	-	image.empty() : 이미지가 비어있는 경우 1을 반환하는 함수
	-	초기화
		Mat img = Mat(Size(width, height), CV_8UC3, Scalar(0, 0, 0));
		img.release();
2)	OpenCV 기본클래스
OpenCV를 공부하는데 앞서 제일 기본적인 OpenCV 기본 클래스에 대해서 간단히 정리해보기로 한다.
개발을 하다보면 제일 먼저 클래스가 어떤건지, 어떤식으로 돌아가는건지 기본적인 이해가 있어야 나중에 간단한 오류를 범하지 않게 된다. 

책은 가메출판사의 "C++API OpenCV 프로그래밍"을 쓰고 있고, 앞으로 이 폴더에 있는 대부분의 OpenCV 코드나, 내용은 이 책을 기반으로 한다. 
내가 생각하기에 현재 나와있는 OpenCV 3.0 기반으로 제일 명확하고 자세하게 잘 나와있는 책이 아닌가싶다.

1. DataType, Point, Point3 클래스
1.1 기본 자료형 및 DataType 클래스
 OpenCV는 uchar, bool, char, unsigned short, signed short, int, float, double 또는 이들 자료형의 튜플로 구성된 기본 자료형을 갖게 된다. 
 OpenCV 코드를 짜다보면 CV_8UC1, CV_32F, ... 이와같은 자료형을 접하게 되는데 다 외울 필요는 없고 이게 무슨 뜻인지 알면 될 것 같다.

CV_<깊이비트수>{U|S|F}C(<채널수>)     ,    (U: unsigned, S: signed, F: float)

 이러한 형식으로 구성이 되어있다. 예를들어 위에 써놓은 예제와 같이 CV_8UC1의 경우 깊이비트수는 8 비트 이고, 
 unsigned형, 1채널로 구성되어있는 데이터 구조이다. 예제 하나를 더 따져보자면 CV_16UC4는 16비트, unsigned, 4채널로 구성되어있는 데이터 구조이다. 

 그렇다면 뭔가 부족해보이는 CV_8U, CV_64F 등은 채널 수가 생략된 형태이다. 이들은 1채널이다. 
 C가 없는 것으로 보아 이런 자료형에서 항상 들어가는 C는 Channel의 줄임말인가보다. 이런 것을 배우다 보면 많은 자료형들을 외우는 것 보다 무엇인지 알 수 있으니 훨씬 이득(?)이다. 

여기까지 기본 자료형을 알아보았고 다음 DataType 클래스를 알아보자.
 DataType 클래스는 OpenCV 기본 자료형을 표현하기 위한 템플릿 클래스로 멤버 데이터나 메서드를 갖지 않는다. 
 기본 자료형을 표현하기 위해 DataType 템플릿을 구체화한 다양한 템플릿 클래스가 OpenCV 3.0은 traits.hpp에 있고 구버전인 2.4.10 은 core.hpp에 있다. 보통 core.hpp가 익숙한 것 같다.

 이는 주로 자료형을 OpenCV 자료형으로 변환하는 목적으로 사용이 된다. 보통 템플릿을 사용한 OpenCV 라이브러리 구측을 위해 이 클래스가 필요하다. 
 그런데 보통의(?) 사용자는 일반적으로 모두 구현된 라이브러리를 쓸꺼니까... 여기서는 상수 명칭을 사용하게 된다. 깊게 공부할 때 다시 보면 좋을 것 같다. 간단히 예를 들자면

Mat A1(1, 2, DataType<uchar>::type); 이렇게 쓰는 대신
Mat A1(1, 2, CV_8U); 이렇게 상수 명칭으로 쓰겠다는 이야기이다. 

1.2 Point_ 클래스
 OpenCV에서 필수적으로 공부해야하는 Point 클래스이다. 이는 2D 좌표를 표현 할 수 있는 클래스이고 당연히 멤버변수는 x축, y축을 표현하기 위한 x, y가 있다. 
 typedef를 이용하여 정의한 Point2i, Point, Point2f, Point2d 자료형이 있다. 뒤에 붙은 알파벳은 개발자라면 알 수 있듯, 
 int, float, double이다. 그냥 Point로 정의된 것은 Point 클래스의 객체, 즉 인스턴스를 뜻한다. 

1.3 Point3_ 클래스
 2D를 표현하는 Point_ 클래스가 있었다면 Point3_ 클래스는 3D를 표현 할 수 있다. 멤버변수는 x, y, z가 있으며, Point3i, Point3f, Point3d가 있다. 

1.4 Size_ 클래스
 Size 클래스는 이름처럼 크기를 표현할 수 있는 클래스이다. 이 클래스도 빈번히 쓰이는 클래스 중 하나이다. Size2i, Size, Size2f 자료형이 있다. 
 C++ API 이지만, C API의 CvSize, CvSize2D32f로 변환하여 사용할 수도 있다. 

1.5 Rect_ 클래스
 사각형을 표현하는 클래스이다. 멤버변수는 x, y, width, height 가 있다. 오직 정수형에 대한 Rect 자료형이 정의되어있다. 

아래 예제는 간단하게 사각형을 그려보는 예제를 실행해 보았다. 
참고로 색상을 나타내는 함수로써 Scalar(B, G, R) 순서이다.
r1 : 파란색 사각형
r2 : 초록색 사각형 
r3 : r1과 r2 크기를 intersection한 빨간색 사각형 (교집합 개념)
r4 : r1과 r2 크기를 담는 검은색 사각형 (합집합 개념)
pt1 은 좌표상에서 x=100, y=100 지점으로써 원(Circle)으로 표시해두었다. 

#include<opencv2/opencv.hpp>

using namespace std;
using namespace cv;

int main(){
	
	Rect r1(100, 100, 320, 240), r2(200, 200, 320, 240);
	Point pt1(100, 100);
	Size size(100, 100);

	Rect r3 = r1 & r2; // intersection
	Rect r4 = r1 | r2; // minimum area rectangle containing r1, and rt2

	cout << "r1 :" << r1 << endl;
	cout << "r2 :" << r2 << endl;
	cout << "r3 :" << r3 << endl;
	cout << "r4 :" << r4 << endl;

	if (r1 != r2)
		cout << "r1 and r2 are not the same rectangle." << endl;

	// for drawing r1 ~ r4

	Mat img(600, 800, CV_8UC3); // x=600, y=800, 8bit, unsigned, 3 channels 

	rectangle(img, r1, Scalar(255, 0, 0), 2);
	rectangle(img, r2, Scalar(0, 255, 0), 2);
	rectangle(img, r3, Scalar(0, 0, 255), 2);

	rectangle(img, r4, Scalar(0, 0, 0), 1);
	circle(img, pt1, 5, Scalar(255, 0, 255), 2);

	imshow("image", img);
	waitKey();

	return 0;
 

}

1.6 RotatedRect 클래스
말그래도 회전된 사각형을 표현하는 클래스이다. 멤버 변수는 중심점인 Point2f 자료형의 center와 크기인 Size2f 자료형의 size, 회전각을 나타내는 float 자료형의 angle이 있다.
C API의 CvBox2D 구조체와 호환 가능하다. 

출처: https://eehoeskrap.tistory.com/65?category=537364 [Enough is not enough]

2. Matx Vec, Scalar_, Range, Ptr 클래스
2.1 Matx 클래스
이 클래스는 고정된 작은 크기의 행렬을 위한 템플릿 클래스이다. 1x1에서 6x6 까지 작은 크기의 행렬과 다양한 행렬 연산함수를 제공한다. 
예를 들어 Matx33f 자료형은 3x3 의 float 행렬이다. 더욱 더 일반적인 행렬의 형태는 알다시피 Mat 클래스로 변환하여 사용한다. 
이 Matx 클래스에서는 '<<' 연산자 함수를 사용할 수 없다. 사용하려면 Mat 으로 변환하여 cout로 간단히 출력 할 수 있다. 

Matx33d A(1, -1, -2,
   2, -3, -5,
   -1, 3, 5);    // Matx<double, 3, 3> 템플릿 자료형이며, 3x3 배정도 실수 행렬, A를 초기화

여기까지 간단히 알아보도록하고, 더 중요한 클래스에 대해서 다뤄보도록하자.

2.2 Vec 클래스
이 클래스는 Matx 클래스에서 상속받은 클래스로, 짧은 수치 벡터를 위한 템플릿 클래스이다. 
기본적인 벡터 연산이 가능하고, 3차원 외적을 계산할 수 있고, [] 연산자에 의해 접근할 수 있다. 

Vec<T,2> - Point_
Vec<T,3> - Point3_
Vec<T,4> - Scalar_, CvScalar 

사이에서 변환이 가능하다. Vec2b, Vec3b 등의 클래스가 있다. 쓰임은 다음과 같다. 
Vec<float, 3> X(1,0,0);    // 3차원 벡터 X와 Y를 선언하고 초기화한다.
Vec<float, 3> Y(0,1,0);

2.3 Scalar_ 클래스
이 클래스는 저번 포스팅에서 잠깐 다루었던 클래스이기도하다. 이는 Vec 클래스에서 상속받은 4개의 요소를 갖는 템플릿 클래스이다. 계속 하위개념을 상속하는 형식이다. 
Scalar X = Vec4f(1,2,3,4);
Scalar Y = Scalar(10,20,30); // = Scalar(10,20,30,0);
Scalar Z = Scalar(100,200,300); 
이러한 형식으로 사용할 수 있다. 
cf)	Scalar 변수 초기화
	Mat matCell[TRILL_CODE_CELL_COUNT];
	Scalar matCell_Avg[TRILL_CODE_CELL_COUNT];

	//--	initialize	--//
	for (int iCnt = 0; iCnt < TRILL_CODE_CELL_COUNT; iCnt++)
	{
		matCell[iCnt].release();
		matCell_Avg[iCnt] = 0;
	}


2.4 Range 클래스
이 클래스는 Mat 클래스에서 행 또는 열의 범위를 지정 할 수 있는 템플릿 클래스이다. 
start는 포함이고, end는 포함하지 않는다. 아래를 보면 이해 할 수 있다.

Range(int _start, int _end);
Range(0,4) // 범위 0,3을 나타낸다. 즉, 이 클래스는 슬라이싱과 같은 기능을 하고있다.

Matx33f A(1, 2, 3,
   4, 5, 6,
   7, 8, 9);
Mat B(A);

cout << "B[0:1, 0:3]" << B(Range(0,1), Range(0,3)) << endl;   // 예제 1
cout << "B[1:2, 0:3]" << B(Range(1,2), Range(0,3)) << endl;   // 예제 2

이러한 코드에서 예제 1과 예제2의 출력결과는 어떻게 될까.
예제 1은 Range(0,1)은 범위 0,0을 나타내고
          Range(0,3)은 범위 0,2를 나타내므로 0과 0,1,2가 겹치는 0, 즉 B의 0행인 1, 2, 3 을 출력
예제 2는 Range(1,2)는 범위 1,1을 나타내고 Range(0,3)은 예제 1과 같이 범위 0~2 까지 나타내므로 1과 0,1,2가 겹치는 1, 즉 B의 1행인 4, 5, 6을 출력하게 된다.

2.5 Ptr 클래스
OpenCV 3.0에서 이 클래스의 사용이 많이 확대되었다. 이는 포인터를 감싸서 메모리를 안전하게 사용하는 템플릿 클래스이다. 
이 클래스의 사용으로 인해 OpenCV 2.~ 에서 사용하였던 메모리 해제(Release)를 번거럽게 하지 않고, 자동으로 메모리를 해제 해주는 클래스이다. 

Ptr<IplImage> Image(cvLoadImage("lena.jpg", IMREAD_GRAYSCALE));
Ptr<FILE> outFile(Fopen("matA.txt","w"));
Ptr<CvMat> mat(cvCreateMat(2, 3, CV_32FC1)); 
이러한 형식으로 사용되게 된다. 

3. Mat 클래스
Mat 클래스는 C++ API 에서 가장 중요한 클래스 중 하나로 1채널 또는 다채널의 실수, 복소수, 행렬, 영상 등의 수치 데이터를 표현하는 n 차원 행렬 클래스이다. 
Mat 클래스는 다양한 생성자와 메소드를 지원하게 된다. 구버전(3.0 미만)에서 사용되었던 CvMat, IplImage는 cvarrToMat 함수를 통해 호환하여 사용 할 수 있다. 

3.1 Mat 행렬 생성
Mat 클래스는 다양한 생성자를 통하여 행렬을 생성하게 된다. 
Mat A(2, 3, CV_8UC1);
Mat B(2, 3, CV_8UC1, Scalar(0));
Mat C(2, 3, CV_8UC3, Scalar(1, 2, 3));

이렇게 행렬 A, B, C를 생성하게 되었을 경우 각각 행렬의 내용은 어떻게 될지 생각해보자.
먼저 행렬 A는 2x3, 1채널 행렬이고, 초기화 된 결과가 없다. 두번째 행렬인 행렬 B는 2x3, 1채널 해열ㄹ에 0으로 초기화 되었다. 행렬C는 2x3, 3채널, 1,2,3으로 초기화 되었다.

각 행렬의 결과는 다음과 같다. 행렬B는 1채널이여서 배열 1칸에 1개의 값이 들어갔고, 행렬C는 3채널이여서 배열1칸에 3개의 값이 들어갔다.

행렬A
이상한 값	이상한 값	이상한 값 
이상한 값	이상한 값	이상한 값 

행렬B
0			0			0
0			0			0

행렬C
1, 2, 3		1, 2, 3		1, 2, 3
1, 2, 3		1, 2, 3 	1, 2, 3

행렬A, B, C의 배정도 2x3을 표현하였던 2,3은 Size(3,2)로도 표현 할 수 있고, Scalar(값, 값, 값, 값) 대신에 배열값 즉, {1,2,3,4,5,6} 이러한 형식으로도 값을 넣을 수 있음을 알아두도록 하자.

cf)	
	Mat m8UC1(2, 3, CV_8UC1, Scalar(1));
	Mat m8UC3(2, 3, CV_8UC3, Scalar(1,2,3));

	cout << "m8UC1 =" << endl << m8UC1 << endl;
	cout << "m8UC3 =" << endl << m8UC3 << endl;

	/*	출력결과
	m8UC1 =
	[  1,   1,   1;
	   1,   1,   1]
	m8UC3 =
	[  1,   2,   3,   1,   2,   3,   1,   2,   3;
	   1,   2,   3,   1,   2,   3,   1,   2,   3]	*/

Mat을 생성하는 또다른 방법은 다음과 같다. 
1) Vec을 이용하여 Mat 생성
// 3x1 행렬
Vec<float, 3> V(1,0,0);
Mat V1(V);
Mat V2(Vec<float, 3>(0,1,0));

2) Matx을 이용하여 Mat 생성
// 3x3 행렬
Matx<float, 3, 3> A(1,2,3,4,5,6,7,8,9);
Mat A1(A);

3) Range를 이용하여 Mat 생성
// 1x3 행렬
Mat A2(A1, Range(1,2), Range::all());

4) Rect을 이용하여 Mat 생성
// 3x3 행렬인 A1에 사각형만큼의 행렬을 생성, 2x2 행렬
Mat A3(A1, Rect(1,1,2,2)); 

5) cvMat을 변환하여 Mat 생성
// 3x3 행렬
CvMat mat = cvMat(3,3,CV_32FC1, A.val);
Mat A4 = cvarrToMat(&mat);
A.val[0]=100; // Matx을 이용하여 Mat을 생성했었던 코드 참조

Mat A5 = cvarrToMat(&mat, true);

행렬을 생성하는 방법이 너~무 많다. ㅠㅠ 앞으로가 더 많은데... 알아두면 좋겠지. 까먹지 않았으면 좋겠다. 다음은 3.차.원 행렬이다 ㅠㅠ

int sizes[] = {2,3,4};
Mat A(3, sizes, CV_32FC1);
Mat B(3, sizes, CV_32FC1, Scalar(0));

sizes = {2,3,4} 를 이용하여 행렬A,B는 2x3x4의 3차원 행렬으로 만들어졌다. 
A.dims, B.dims 으로 각각 출력을 해보면 차원이 나오게 되고, rows와 cols은 -1이 된다. 

행렬의 요소는 A.at<float>(i, j, k)로 접근하여 출력해볼 수 있다. 행렬 요소에 각각 접근하는 방법은 다음에 자세히 다뤄보도록 한다. 

3.2 Mat::create() 메소드에 의한 행렬 생성
이 메소드는 rows, cols, type, size, ndims 등에 의해 새로운 Mat 클래스 행렬을 생성한다.
Mat 클래스 생성자 등에 의해 이전에 생성된 Mat 클래스 행렬과 크기(rows, cols, size)와 type이 같으면 행렬을 위한 메모리를 새로 할당하지 않고 바로 리턴하게 된다. 
그러나 크기와 자료형이 다를 경우에는 Mat::release()를 호출하여 이전의 행렬 데이터를 위한 메모리를 해제하고, 행렬을 위한 새로운 데이터를 생성하게 된다. 

Mat A(2, 3, CV_32FC1, Scalar(0)); // 생성자를 이용하여 행렬 A 초기화
A.create(2, 3, CV_32FC1); // 행렬 A와 동일하므로 바로 리턴
A.create(3, 3, CV_32FC1); // 배정도가 다르므로 메모리를 재할당하여 행렬을 생성
A.create(Size(3,3), CV_8UC1); // 자료형이 다르므로 재할당

Mat B;
int sizes[] = {3,3};
B.create(2, sizes, CV_8UC1); // dims=2인 2차원 행렬이며, 3x3 배정도를 가진 행렬

다음은 create 함수를 이용하여 영상을 하나 생성해보겠다.
create 함수를 이용하여 영상을 생성한뒤, 그 영상의 rows 값과 cols 값에 하나씩 접근하도록 for문을 생성하고,
at<Vec3b>(i, j)를 이용하여 화소값에 직접 접근 한 뒤, 분홍색에 해당하는 값을 입력해주었다. 

#include<opencv2\opencv.hpp>
using namespace cv;
using namespace std;

int main(){
	Mat srcImage;
	srcImage.create(512, 512, CV_8UC3);

	for (int i = 0; i < srcImage.rows; i++)
		for (int j = 0; j < srcImage.cols; j++)
			srcImage.at<Vec3b>(i, j) = Vec3b(125, 0, 255);

	imshow("srcImage", srcImage);
	waitKey();

	return 0;
}

결과는 다음과 같다. 포토샵을 하도 해대니까 분홍색을 생각하고 Vec 값을 주었더니 진짜 분홍색이 나왔다 ㅋㅋㅋㅋㅋ

Mat 행렬 생성은 여기까지 포스팅 하도록 하고, 다음에는 Mat 행렬에 대한 정보라던가, 연산자, 행렬의 복제, 복사 등 부수적인 것들을 다뤄보도록 할 것이다. 
출처: https://eehoeskrap.tistory.com/66?category=537364 [Enough is not enough]

3.3 Mat 행렬 정보
행렬에 대한 정보들은 영상처리 프로그래밍을 할 때 필수적이다. 쭉 훑어보면 좋을 것 같다. 자주 쓰이는 것은 굵은색으로 표시해두었다. 
- Mat::rows    행의 개수
- Mat::cols     열의 개수
- Mat::data    행렬 데이터의 포인터
- Mat::dims    행렬의 차원(2보다 같거나 크다)
- Mat::isContinuous    각 행의 마지막에 공백없이 연속으로 데이터가 저장되었는지를 확인
- Mat::total()    행렬 요소의 전체 개수
- Mat:: elemSize()    행렬 요소 하나의 바이트 크기를 반환
						행렬의 한 행의 총 바이트 수는 Mat::cols x Mat::elemSize()
- Mat::type()    행렬의 자료형 반환
- Mat::depth()    행렬의 깊이를 반환
- Mat::channels()    행렬의 채널 개수를 반환
- Mat::empty()    공백행렬인지를 반환
- Mat::size()    행렬의 크기를 Size(cols, rows)로 반환

3.4 Mat::at에 의한 Mat 행렬 요소 접근
저번 포스팅에서 잠깐 다루었었는데 아래와 같은 형태로 쓰인다.
Mat A(3, 3, CV_32F);
for(int i=0; i<A.rows; i++)
for(int j=0; j<A.cols; j++)
A.at<float>(i, j) = i*A.cols+j; // 0~8을 차례대로 행렬에 저장 

3.5 Mat::ptr에 의한 Mat 행렬 요소 접근
Mat::ptr() 메소드는 행렬의 지정된 행의 시작주소를 저장한 포인터를 반환한다. uchar* 또는 템플릿으로 명시된 자료형의 포인터를 반환한다.
Mat (3, 3, CV_32F);
for(int i=0; i<A.rows; i++){
float* ptrA = A.ptr<float>(i);
for(int j=0; j<A.cols; j++)
ptrA[j] = i*A.cols+j;

확실히 ptr에 의해 행렬요소를 접근하는 것 보다는 Mat::at에 의해 행렬 요소에 접근하는 것이 더 편안(?)해 보인다. 

3.6 Mat 행렬의 행/열 지정에 의한 부분 행렬 헤더 생성
행렬의 헤더를 생성한다는 의미는 행렬 데이터를 위한 메모리를 새로 생성하지 않고 공유하여 사용한다는 의미이다. 
Mat::row y-행에 대한 행렬 헤더를 생성
Mat::col x-열에 대한 행렬 헤더를 생성
Mat::rowRange startrow에서 endrow-1 까지의 행렬 헤더를 생성
Mat::colRange startcol에서 endcol-1 까지의 행렬 헤더를 생성

3.7 Mat 행렬의 복제, 복사, 변환, 값 설정 및 모양 변환
Mat::clone()    행렬을 완전히 복제하여 반환
Mat::copyTo()    행렬을 다른 행렬 M으로 복사, 크기 및 자료형이 다르면 Mat::create()에 의해 다시 생성
Mat::convertTo()    행렬을 자료형이 rtype인 출력 행렬 m으로 변환, 채널수는 같아야함
Mat::assignTo()    convertTo와 동일한데, alpha와 beta가 없는 형태
Mat::setTo()    행렬의 요소를 Scalar 등에 의한 InputArray 자료형의 value 값으로 설정

3.8 Mat 행렬의 메모리 해제(release), 크기 변경(resize), 공간 확보(reserve)
Mat::release() 메소드는 행렬의 참조 카운터를 1 감소시킨다. 참조 카운터의 값이 0이 되면 행렬 데이터의 메모리를 해제하고 Mat::data = NULL로 변경한다.
명시적으로 호출이 가능하지만 대부분 행렬의 파괴자에 의해 자동으로 호출된다.
ex)	Mat m1(2, 6, CV_8UC1, Scalar(100));
	m1.release();

Mat::resize() 메소드는 행렬에서 행의 개수를 입력한 size로 변경시킨다. 두번째에 오는 값은 새로 추가된 행렬요소의 값을 입력한다. 
Mat::reserve() 메소드는 입력한 size 행의 개수 마늠의 메모리 공간을 확보하지만, 메모리 공간이 충분하면 아무 일도 하지 않는다. 
std::vector 클래스의 reserve 멤버와 같이 미리 메모리 용량을 확보하고 사용하면, 메모리 재할당이 빈번히 일어나는 것을 방지하여 성능저하를 막을 수 있다.

4. Mat_ 클래스
Mat_ 클래스는 Mat 클래스로부터 상속된 템플릿 클래스이다. 뎅터 멤버는 갖지 않고, 메소드만으로 존재하는 클래스이다. 
Mat 클래스를 감싸서 사용한다. 레퍼런스 &와 *포인터는 자유로이 사용할 수 있으나 자료형 변환은 주의해서 사용하도록 한다. 
Mat 클래스에도 _Mat과 상응하는 클래스가 많으나 _Mat 클래스의 메소드가 짧고, 사용하기 편리하다고 한다. 
이에 대한 메소드는 따로 다루지 않도록 한다...

5. std::vector 클래스
이 vector 클래스는 C++의 표준 템플릿 라이브러리(STL)의 대표적인 시퀀스 컨테이너 클래스로 C/C++의 배열을 대신하여 사용하면 편리한 점이 많으며, OpenCV 내에서 빈번히 사용된다.

cf)	vector 사용 시(ex, vector<Mat> tmpsplit;) 아래와 같은 에러 발생하는 ���우 대처 방법
1)	에러메시지
		File: minkernel\crts\ucrt\src\appcrt\heap\debug_heap.cpp
		Line: 996

		Expression: _acrt_first_block == header

2)	대처방법
		Visual studio -> 프로젝트 속성 -> 구성 속성 -> 고급 
		-> "정적 라이브러리에서 MFC 사용" -> "공유 DLL에서 MFC 사용"으로 변경

5.1 vector 생성자에 의한 초기화
vector<int> V1;        // 벡터 V1 생성
vector<int> V2(3, 0);    // 벡터 크기를 3으로, 각 요소값을 0으로 초기화하여 생성

int arr[] = {1,2,3,4,5,6,7,8,9};    // 이 배열을 이용하여 벡터를 초기화시켜 생성
vector<int> V3(arr, arr+sizeof(arr)/sizeof(arr[0]));    // arr는 시작주소, 그 뒤는 마지막 주소를 뜻함

Point pts[] = {Point(100,100), Point(200,100), Point(200,200), Point(100,200)};
vector<Point> V4(pts, pts+sizeof(pts)/sizeof(pts[0]));    // Point 값을 이용한 벡터 초기화

vector<Point> V5(V4.begin(), V4.end());    // V4를 이용한 벡터 초기화

5.2 vector를 배열로 사용
 vector 클래스를 사용하면 데이터의 크기를 지정하지 않고 vector::push_back() 멤버 함수로 데이터를 넣고, 사용할 때는 배열처럼 사용할 수 있으며, 
 vector::size() 멤버 함수로 저장된 데이터의 크기를 알 수 있다. 각 데이터 요소들이 배열과 같이 연속으로 할당되어 임의의 요소에 대한 접근 속도가 빠르고, 
 끝 지점에서 삽입과 삭제가 빠르다. 현재 할당된 용량은 vector::capacity() 멤버 함수를 통해 할 수 있다. 현재 할당된 용량보다 크게 삽입이 일어나면 메모리 재할당이 일어나며, 
 이러한 재할당은 성능 저하를 일으킬 수 있다. 

 그러나 vector::reserve() 함수로 미리 메모리 용량을 확보하고 사용하면 재할당이 빈번히 일어나는 것을 방지 할 수 있다. 
 vector 클래스를 사용하면 C/C++에서 배열을 사용할때 불편하였던 점을 해결 수 있는 장점이 있다. 

5.2.1 vector를 1차원 배열로 사용한 예
vector<float> V1;
V1.push_back(10.0f);    // push_back 을 이용하여 데이터 삽입
V1.push_back(20.0f);
V1.push_back(30.0f);
V1.push_back(40.0f);

cout << V1.capacity() << endl;    // capacity()를 이용하여 할당된 용량 계산 = 4
cout << V1.size() << endl;    // size()를 이용하여 크기 계산 = 4

V1.erase(V1.begin()+2);    // 30.0 삭제 
V1.insert(V1.begin()+2, 30.0f)    // 30.0 추가

V1.clear();    // 벡터 내용 삭제, 삭제 후 용량은 4, 크기는 0 

5.2.2 vector를 2차원 배열로 사용한 예
// vector<int> V1(3,0);
// vector<vector<int>> M1(2,V1);
vector<vector<int>> M1(2, vector<int>(3,0));
M1[0][0] = 10;
M1[0][1] = 20;
... 이런식으로 M1[1][2]까지 값을 넣음

M1.size() = 2
M1[0].size() = 3 이라는 결과를 얻을 수 있다.

5.3 vector를 다른 자료형으로 변환
vector를 Mat 클래스 또는 Point 배열로 변환할 필요가 있다. vector를 Mat 클래스로 변환 할 때는 
Mat 클래스 생성자 template<typename T> explicit Mat::Mat(const vector<T>& vec, bool copyData=false)를 사용한다. 
vector를 cv::copy 함수를 배열로 복사하거나, C언어 스타일로 사용자 정의 함수를 작성하여 복사하여 사용할 수 있다.

출처: https://eehoeskrap.tistory.com/67 [Enough is not enough]

5.4	Memory jpeg encode & decode in openCV  소프트웨어 개발 / 사
복사 https://blog.naver.com/jackslack/30149829790  
decode :::
CvMat *matJpg = cvCreateMat( 1, dwSizeBuffer, CV_8UC1 );
CopyMemory( matJpg->data.ptr, pBuffer, dwSizeBuffer );
IplImage* pImageFull = cvDecodeImage( matJpg );
cvReleaseMat(&matJpg);

// do some image manipulation with 'pImageFull'
cvReleaseImage(&pImageFull);

encode :::
IplImage* pImage = cvLoadImage("ddd.bmp" );
CvMat *pJpeg = cvEncodeImage( ".jpg", pImage );
LPBYTE pBufferJpg = pJpeg->data.ptr;
LONG lSizeJPEG = pJpeg->cols;

// do some file job with pBufferJpg, lSizeJPEG
cvReleaseMat(&pJpeg);
cvReleaseImage(&pImage);

5.5	Imageio or OpenCV saves black blank image after altering image array
from tkinter import filedialog
from tkinter import *
from PIL import Image
import cv2 as cv
import os
import numpy as np


def encrypt(k):

    iload = filedialog.askopenfilename(parent=Main,initialdir=os.getcwd(),title="Please select a file:",filetypes = (("PNG files","*.png"),("jpeg files","*.jpg"),("all files","*.*")))
    im= cv.imread(iload,cv.IMREAD_UNCHANGED)
    im = im.astype(np.uint16)   
    print("After Open File Type : ",im.dtype)
    print("Orinigal Image : ",im)   
    im = im.tolist()
    for l in range(len(im)):    
        for j in range(len(im[l])):
            for i in range(len(im[l][j])):
                im[l][j][i]+=k
    #im.putdata(npxls)
    im=np.array(im).astype(np.uint16)
    #imen.show()
    print("Encrypted Image : ",im)  
    #imageio.imwrite("encrypted.png",im,format='PNG-FI')
    cv.imwrite("encrypted.png",im)  
    img=cv.imread("encrypted.png",cv.IMREAD_UNCHANGED | cv.IMREAD_ANYCOLOR | cv.IMREAD_ANYDEPTH)    
    print("After Encrypting Saved File Type :",img.dtype)

def decrypt(k):

    iload = filedialog.askopenfilename(parent=Main,initialdir=os.getcwd(),title="Please select a file:",filetypes = (("PNG files","*.png"),("jpeg files","*.jpg"),("all files","*.*")))
    im=cv.imread(iload, cv.IMREAD_UNCHANGED | cv.IMREAD_ANYCOLOR | cv.IMREAD_ANYDEPTH)
    print("Original Image : ",im)
    print("After Decrypting Image Type: ",im.dtype)
    im = im.astype(np.uint16)   
    im = im.tolist()
    for l in range(len(im)):    
        for j in range(len(im[l])):
            for i in range(len(im[l][j])):
                im[l][j][i]-=k
    im=np.array(im).astype(np.uint16)
    #imen.show()
    print("Decrypted Image : ",im)  
    cv.imwrite("decrypted.png",im,[CV_LOAD_IMAGE_ANYDEPTH ])    
    img=cv.imread("decrypted.png", cv.IMREAD_ANYCOLOR | cv.IMREAD_ANYDEPTH)
    print("After Decrypting Saved Image type: ",img.dtype)




84_1-1.A Beginner’s Guide to Setting up OpenCV Android Library on Android Studio
	안드로이드 라이브러리 import로 처리
	https://android.jlelse.eu/a-beginners-guide-to-setting-up-opencv-android-library-on-android-studio-19794e220f3c
	\Default.corp\핵심_프로그램설명서\안드로이드\###[Android] 안드로이드 스튜디오 OpenCV 카메라 예제 및 설치 방법\###A Beginner’s Guide to Setting up OpenCV Android Library on Android Studio.mht

84_1.	안드로이드에서 OpenCV 사용
	1)	https://sourceforge.net/projects/opencvlibrary/files/opencv-android/ 사이트에서	OpenCV-3.0.0-android-sdk-1.zip 파일을 다운 받아서
		(OpenCV-3.2.0-android-sdk.zip 파일은 Camera2를 사용해야 하기 때문에 받지 말아야 함)
		C:\ProgramData\OpenCV-android-sdk 폴더에 압축을 풀음(C:\Program Files 폴더에 압축 풀면 안됨 -> NDK Build 할 때 Folder 구조 때문에 build 오류 발생)
	2)	Eclipse -> Import -> 1)번에 압축 풀어 놓은 파일 import
	3)	OpenCV Library - 3.0.0 -> Properties -> [v]Android 4.1.2 -> clean -> rebuild
	4)	OpenCV Sample - face-detecttion
		가)	-> Properties -> [v]Android 4.1.2 & Library []Is Library(반드시 uncheck상태여야함) & Add : OpenCV Library - 3.0.0
		나)	jni -> Android.mk -> include C:/ProgramData/OpenCV-android-sdk/sdk/native/jni/OpenCV.mk 으로 변경
		다)	-> Properties -> C/C++ Build -> Build command -> E:/UTIL/cygwin/home/krh/android-ndk-r9d/ndk-build.cmd 으로 변경
		라)	clean -> rebuild
	5)	OpenCV_3.0.0-dev_Manager_3.00_armeabi-v7a.apk install
		가)	OpenCV-3.0.0-android-sdk-1.zip -> apk -> OpenCV_3.0.0-dev_Manager_3.00_armeabi-v7a.apk 압축 풀기
		나)	cmd.exe(dos 명령 창) -> adb intall OpenCV_3.0.0-dev_Manager_3.00_armeabi-v7a.apk
	6)	Eclipse -> OpenCV Sample - face-detecttion -> Run As -> Android Application
	->	정상적으로 카메라 Preview 상태 화면이 나오며 사람얼굴의 경우만 녹색 사각형 박스로 인식된 사람얼굴 부분을 알려 줌

84_1_2.	안드로이드에서 OpenCV 버전 3.1.0 -> 4.2.0으로 업그레이드
1)	딥러닝 기술을 적용하기 위해 opencv 버전을 4.2.0으로 업그레이드 시킴(기존 3.1.0에서는 딥러닝 적용할 수 없음)
2)	기존 Android Studio 소스에서
		하기와 같이 변경하면 정말 오류없이 정상적으로 동작함 확인 완료
		가)	
		E:\Project\OpenCV-android-sdk\sdk\native\jni\include에
		F:\Default.corp\GL\SDK\opencv-4.2.0-android-sdk\OpenCV-android-sdk\sdk\native\jni\include에 있는
		opencv2 폴더 통째로 복사
		
		나)
		E:\Project\OpenCV-android-sdk\sdk\native\libs\arm64-v8a에 
		F:\Default.corp\GL\SDK\opencv-4.2.0-android-sdk\OpenCV-android-sdk\sdk\native\libs\arm64-v8a에 있는
		libopencv_java4.so 파일 복사
		
		다)
		E:\Project\OpenCV-android-sdk\sdk\native\libs\armeabi-v7a에 
		F:\Default.corp\GL\SDK\opencv-4.2.0-android-sdk\OpenCV-android-sdk\sdk\native\libs\armeabi-v7a에 있는
		libopencv_java4.so 파일 복사
		
		라)
		전체찾기로 libopencv_java3.so 으로 되어 있는 환경명령
		libopencv_java4.so로 변경 함
		
		마)	하기와 같이 opencv 4.2.0에서 사용하는 정의로 변경
		//  cvtColor( img_input, img_result, CV_RGBA2GRAY);
		    // fix, opencv 4.2.0
		    cvtColor( img_input, img_result, COLOR_RGBA2GRAY);
		    // fix

		바)	하기와 같은 오류 발생 시
				->	아래 2)해결방법으로 에러 제거 시킴
		
		undefined reference to 'cv::error(int, std::string const&, char const*, char const*, int)'  에러 발생 해결
		1)	문제원인
		1>ARM\Release\ComputerVisionForAndroid2.o: In function `Mat': 
		1>C:\Users\ddd\Downloads\opencv-4.1.0-android-sdk\OpenCV-android-sdk\sdk\native\jni\include\opencv2/core/mat.inl.hpp:548: undefined reference to `cv::error(int, std::string const&, char const*, char const*, int)' 
		1>C:\Users\ddd\Downloads\opencv-4.1.0-android-sdk\OpenCV-android-sdk\sdk\native\jni\include\opencv2/core/mat.inl.hpp:561: undefined reference to `cv::error(int, std::string const&, char const*, char const*, int)' 
		1>clang.exe: error: linker command failed with exit code 1 (use -v to see invocation)
		
		인자가 4개인 Mat 생성자에서 cv::error를 사용하는데 cv:error가 정의된 곳을 못찾는 것 같네요..
		libopencv_java4.so에 정의가 안되어 있단 말인가요..?
		삽질을 하다가 해결방법을 찾았습니다.

		OpenCV 공식 홈에서 4.1.0 버전이 아닌.. 3.4.6 버전의 안드로이드 파일들을 다운 받아서.. 프로젝트 설정에 설정하고 사용하면 됩니다.
		왜 이런 문제가 생겼는지 궁금해서..  libopencv_java3.so와 libopencv_java4.so 파일 안에 정의된 함수들을 찾아봤습니다.
		파일 중에서 문제와 관련된.. cv::error와 관련된 함수 정의를 찾아봤습니다.(맥에서 nm libopencv_java3.so 명령어 사용)
		3.4.6버전과 4.1.0버전의 header파일에 정의된 cv::error에 대한 형태는 같으나(참고:OpenCV-android-sdk\sdk\native\jni\include\opencv2\core\base.hpp).. 실제로 so파일에 정의된 구조를 보면 모양이 좀 다르네요.
		*header파일에 정의된 형태
		CV_EXPORTS void error(int _code, const String& _err, const char* _func, const char* _file, int _line);
		
		*libopencv_java4.so
		T _ZN2cv5errorEiRKNSt6__ndk112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEPKcSA_i
		
		*libopencv_java3.so
		T _ZN2cv5errorEiRKNS_6StringEPKcS4_i
		
		libopencv_java4.so에도 cv::error가 정의되어 있긴 하지만.. header파일에 정의된 형태와 달라서 linker에서 문제가 생긴 것 같습니다.
		
		2)	해결방법 -> E:\Project\ImageTag_Android\Program\NemoIn\app\build.gradle 파일을 아래와 같이 수정
		android {
		    compileSdkVersion 28
		    buildToolsVersion '28.0.3'
		    defaultConfig {
		        applicationId "app.nemoin"
		        minSdkVersion 21
		        targetSdkVersion 28
		        versionCode 3
		        versionName "1.0.3"
		        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
		
		        externalNativeBuild {
		            cmake {
		                arguments '-DANDROID_PLATFORM=android-15',
		                        '-DANDROID_TOOLCHAIN=clang',
		//                        '-DANDROID_STL=gnustl_static',
		                        // fix, opencv 4.2.0
		                        '-DANDROID_STL=c++_shared',
		                        // fix
		                        '-DANDROID_CPP_FEATURES=rtti exceptions'
		            }
		            ndk {
		                // Specifies the ABI configurations of your native
		                // libraries Gradle should build and package with your APK.
		                abiFilters 'arm64-v8a', 'armeabi-v7a'//, 'mips', 'mips64', 'armeabi'
		            }
		
		        }
		    }

		사)	참고) CMakeLists.txt
		# Sets the minimum version of CMake required to build the native
		# library. You should either keep the default value or only pass a
		# value of 3.4.0 or lower.
		
		cmake_minimum_required(VERSION 3.4.1)
		
		set(CMAKE_VERBOSE_MAKEFILE on)
		set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=gnu++11")
		
		#include_directories(C:/cvwork/OpenCV-android-sdk/sdk/native/jni/include/)
		include_directories(E:/Project/OpenCV-android-sdk/sdk/native/jni/include/)
		
		
		# Creates and names a library, sets it as either STATIC
		# or SHARED, and provides the relative paths to its source code.
		# You can define multiple libraries, and CMake builds it for you.
		# Gradle automatically packages shared libraries with your APK.
		
		add_library( # Sets the name of the library.
		             nemoapp-lib
		
		             # Sets the library as a shared library.
		             SHARED
		
		             # Provides a relative path to your source file(s).
		             # Associated headers in the same location as their source
		             # file are automatically included.
		             src/main/cpp/nemoapp-lib.cpp )
		
		add_library( lib_opencv SHARED IMPORTED )
		
		# set_target_properties(lib_opencv PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/JniLibs/${ANDROID_ABI}/libopencv_java3.so)
		# fix, opencv 4.2.0
		set_target_properties(lib_opencv PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/JniLibs/${ANDROID_ABI}/libopencv_java4.so)
		# fix
		
		# Searches for a specified prebuilt library and stores the path as a
		# variable. Because system libraries are included in the search path by
		# default, you only need to specify the name of the public NDK library
		# you want to add. CMake verifies that the library exists before
		# completing its build.
		
		find_library( # Sets the name of the path variable.
		              log-lib
		
		              # Specifies the name of the NDK library that
		              # you want CMake to locate.
		              log )
		
		# Specifies libraries CMake should link to your target library. You
		# can link multiple libraries, such as libraries you define in the
		# build script, prebuilt third-party libraries, or system libraries.
		
		target_link_libraries( # Specifies the target library.
		                       nemoapp-lib
		
		                       # Links the target library to the log library
		                       # included in the NDK.
		                       ${log-lib}
		
		                       lib_opencv )


84_2.	참고사이트
	1)	OpenCV #7-1 Example (캐니 연산자로 영상 외곽선 감지) 설명
		http://hongkwan.blogspot.kr/2013/01/opencv-7-1-example.html		
	2)	[Corner Detection] #2 캐니 에지(Canny Edge)
		http://carstart.tistory.com/188
	3)	OpenCV 예제 Search
		http://docs.opencv.org/master/d5/d26/ffilldemo_8cpp-example.html#a11
		http://docs.opencv.org/master/	-> 로 접속해서 Search 입력창에 floodfill등의 명령어 입력 후 -> Examples:파일을 click하면 해당하는 예제가 나옴

84_3.	ffilldemo.cpp
#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/videoio.hpp"
#include "opencv2/highgui.hpp"

#include <iostream>

using namespace cv;
using namespace std;

static void help()
{
    cout << "\nThis program demonstrated the floodFill() function\n"
            "Call:\n"
            "./ffilldemo [image_name -- Default: ../data/fruits.jpg]\n" << endl;

    cout << "Hot keys: \n"
            "\tESC - quit the program\n"
            "\tc - switch color/grayscale mode\n"
            "\tm - switch mask mode\n"
            "\tr - restore the original image\n"
            "\ts - use null-range floodfill\n"
            "\tf - use gradient floodfill with fixed(absolute) range\n"
            "\tg - use gradient floodfill with floating(relative) range\n"
            "\t4 - use 4-connectivity mode\n"
            "\t8 - use 8-connectivity mode\n" << endl;
}

Mat image0, image, gray, mask;
int ffillMode = 1;
int loDiff = 20, upDiff = 20;
int connectivity = 4;
int isColor = true;
bool useMask = false;
int newMaskVal = 255;

static void onMouse( int event, int x, int y, int, void* )
{
    if( event != EVENT_LBUTTONDOWN )
        return;

    Point seed = Point(x,y);
    int lo = ffillMode == 0 ? 0 : loDiff;
    int up = ffillMode == 0 ? 0 : upDiff;
    int flags = connectivity + (newMaskVal << 8) + (ffillMode == 1 ? FLOODFILL_FIXED_RANGE : 0);
    int b = (unsigned)theRNG() & 255;
    int g = (unsigned)theRNG() & 255;
    int r = (unsigned)theRNG() & 255;
    Rect ccomp;

    Scalar newVal = isColor ? Scalar(b, g, r) : Scalar(r*0.299 + g*0.587 + b*0.114);
    Mat dst = isColor ? image : gray;
    int area;

    if( useMask )
    {
        threshold(mask, mask, 1, 128, THRESH_BINARY);
        area = floodFill(dst, mask, seed, newVal, &ccomp, Scalar(lo, lo, lo),
                  Scalar(up, up, up), flags);
        imshow( "mask", mask );
    }
    else
    {
        area = floodFill(dst, seed, newVal, &ccomp, Scalar(lo, lo, lo),
                  Scalar(up, up, up), flags);
    }

    imshow("image", dst);
    cout << area << " pixels were repainted\n";
}


int main( int argc, char** argv )
{
    cv::CommandLineParser parser (argc, argv,
        "{help h | | show help message}{@image|../data/fruits.jpg| input image}"
    );
    if (parser.has("help"))
    {
        parser.printMessage();
        return 0;
    }
    string filename = parser.get<string>("@image");
    image0 = imread(filename, 1);

    if( image0.empty() )
    {
        cout << "Image empty\n";
        parser.printMessage();
        return 0;
    }
    help();
    image0.copyTo(image);
    cvtColor(image0, gray, COLOR_BGR2GRAY);
    mask.create(image0.rows+2, image0.cols+2, CV_8UC1);

    namedWindow( "image", 0 );
    createTrackbar( "lo_diff", "image", &loDiff, 255, 0 );
    createTrackbar( "up_diff", "image", &upDiff, 255, 0 );

    setMouseCallback( "image", onMouse, 0 );

    for(;;)
    {
        imshow("image", isColor ? image : gray);

        char c = (char)waitKey(0);
        if( c == 27 )
        {
            cout << "Exiting ...\n";
            break;
        }
        switch( c )
        {
        case 'c':
            if( isColor )
            {
                cout << "Grayscale mode is set\n";
                cvtColor(image0, gray, COLOR_BGR2GRAY);
                mask = Scalar::all(0);
                isColor = false;
            }
            else
            {
                cout << "Color mode is set\n";
                image0.copyTo(image);
                mask = Scalar::all(0);
                isColor = true;
            }
            break;
        case 'm':
            if( useMask )
            {
                destroyWindow( "mask" );
                useMask = false;
            }
            else
            {
                namedWindow( "mask", 0 );
                mask = Scalar::all(0);
                imshow("mask", mask);
                useMask = true;
            }
            break;
        case 'r':
            cout << "Original image is restored\n";
            image0.copyTo(image);
            cvtColor(image, gray, COLOR_BGR2GRAY);
            mask = Scalar::all(0);
            break;
        case 's':
            cout << "Simple floodfill mode is set\n";
            ffillMode = 0;
            break;
        case 'f':
            cout << "Fixed Range floodfill mode is set\n";
            ffillMode = 1;
            break;
        case 'g':
            cout << "Gradient (floating range) floodfill mode is set\n";
            ffillMode = 2;
            break;
        case '4':
            cout << "4-connectivity mode is set\n";
            connectivity = 4;
            break;
        case '8':
            cout << "8-connectivity mode is set\n";
            connectivity = 8;
            break;
        }
    }

    return 0;
}

84_4.	cvtColor.cpp
#include "opencv2/core/core.hpp" 
#include "opencv2/highgui/highgui.hpp" 
#include "opencv2/imgproc/imgproc.hpp" 
#include "iostream"   

using namespace cv; 
using namespace std;   

int main( ) 
{          
	Mat image;        
	image = imread("lena.jpg", CV_LOAD_IMAGE_COLOR);            
	
	if(! image.data )                                     
	{               
		cout <<  "Could not open or find the image" << std::endl ;               
		return -1;        
	}          
	
	// Create a new matrix to hold the gray image        
	Mat gray;          
	
	// convert RGB image to gray        
	cvtColor(image, gray, CV_BGR2GRAY); 
	         
	namedWindow( "Display window", CV_WINDOW_AUTOSIZE );          
	imshow( "Display window", image );                           
	
	namedWindow( "Result window", CV_WINDOW_AUTOSIZE );           
	imshow( "Result window", gray );          
	
	waitKey(0);                                                  
	return 0; 
} 

84_4+1.픽셀 색상값 추출
	private MatOfPoint MOPcorners;
	private int iX, iY, x, y, radius, iMinRadius, iMaxRadius, iCannyLowerThreshold, iCannyUpperThreshold, iAccumulator, iLineThickness = 3, iHoughLinesThreshold = 50, iHoughLinesMinLineSize = 20,
			iHoughLinesGap = 20, iMaxFaceHeight, iMaxFaceHeightIndex, iFileOrdinal = 0, iCamera = 0, iNumberOfCameras = 0, iGFFTMax = 40, iContourAreaMin = 1000;
	........................................................................................................
			case VIEW_MODE_CANNY:
				mRgba = inputFrame.rgba(); // inputFrame.rgba() 정보로 refresh
//				Imgproc.cvtColor(mRgba, mGray, Imgproc.COLOR_RGBA2GRAY);
				Imgproc.cvtColor(mRgba, mGray, Imgproc.COLOR_BGR2GRAY);

				// DON'T do a gaussian blur here, it makes the results poorer and
				// takes 0.5 off the fps rate

				// 이미지 중에서 모서리/Edge 튀는 이미지의 위치를 MOPcorners로 알려 줌
				Imgproc.goodFeaturesToTrack(mGray, MOPcorners, iGFFTMax, 0.01, 20);

				iY = MOPcorners.rows();
				Log.d(TAG, "iY = " + iY);

				corners = MOPcorners.toList();
				
				// add
				Point pCenter;
				Rect ccomp = new Rect();
				int flags = 4 + (255 << 8) + Imgproc.FLOODFILL_FIXED_RANGE;
				double[] dColor = new double[10];
				byte[] bColor = new byte[10];
				int iTemp;
				// add

				for (int iX = 0; iX < iY; iX++)
				{
					if(false)
					{
						Imgproc.circle(mRgba, corners.get(iX), 6, colorRed);
					}
					else
					{
						// add
						pCenter = corners.get(iX);
//						Log.d(TAG, "pCenter.x = " + pCenter.x + ", pCenter.y = " + pCenter.y);

						mask.setTo(new Scalar(0));
//						mask.setTo(new Scalar(0, 0, 0));

						Imgproc.threshold(mask, mask, 1, 128, Imgproc.THRESH_BINARY);

						if(true)
						{
							// 해당 좌표의 Pixel값을 읽음
							mGray.get((int)(pCenter.x), (int)(pCenter.y), bColor);

							if(true)
							{
//								iTemp = bColor[0];
								iTemp = bColor[0] & 0xff;				// signed를 unsigned 로 만들기 위해 "& 0xff"를 적용
								// test
//								iTemp = iTemp + 100;
								// test
								if(iTemp > 255)	iTemp = 255;
							}
							
							Log.d(TAG, "iTemp = " + iTemp);
							
							// test
							// 해당 좌표의 Pixel값을 변경
							mGray.put((int)(pCenter.x), (int)(pCenter.y), iTemp);
							// test
						}
						else
						{
							try
							{
								dColor = mGray.get((int)(pCenter.x), (int)(pCenter.y));
							}
							catch(Exception e)
							{
								Log.e(TAG, "Exception e = " + e);
							}
							finally
							{
								Log.d(TAG, "dColor[0] = " + dColor[0]);
							}
						}

//						Imgproc.floodFill(mGray, mask, pCenter, new Scalar(255));
//						Imgproc.floodFill(mGray, mask, pCenter, new Scalar(255), ccomp, new Scalar(3), new Scalar(3), flags);		// new Scalar(3) 인수에서 숫자 3의 사이즈가 클 수록 색상이 변경되는 영역이 넓어 짐
//						Imgproc.floodFill(mGray, mask, pCenter, new Scalar(iTemp), ccomp, new Scalar(3), new Scalar(3), flags);		// new Scalar(3) 인수에서 숫자 3의 사이즈가 클 수록 색상이 변경되는 영역이 넓어 짐
//						Imgproc.floodFill(mGray, mask, pCenter, mGray., ccomp, new Scalar(3), new Scalar(3), flags);		// new Scalar(3) 인수에서 숫자 3의 사이즈가 클 수록 색상이 변경되는 영역이 넓어 짐
//						Imgproc.floodFill(mRgba, mask, pCenter, new Scalar(255, 255, 255), ccomp, new Scalar(3, 3, 3), new Scalar(3, 3, 3), flags);
						// add
					}
				}
				
				// add
				Imgproc.cvtColor(mGray, mRgba, Imgproc.COLOR_GRAY2RGBA);
				// add				
				break;

84_4+2.픽셀 색상값 추출
byte[] vsout = new byte[1];
Mat HSV = new Mat();
Imgproc.cvtColor(sampledImage, HSV, Imgproc.COLOR_RGB2HSV);

Mat V = new Mat(sampledImage.rows(), sampledImage.cols(), CvType.CV_8UC1);

for(int i = 0; i<HSV.rows(); i++)
{
	for(int j = 0; j<HSV.cols(); j++)
	{
		V.get(i, j, vsout);
	}
}

84_4+3.픽셀 색상값 추출
Mat img = Highgui.imread("Input.jpg"); //Reads image from the file system and puts into matrix
int rows = img.rows(); //Calculates number of rows
int cols = img.cols(); //Calculates number of columns
int ch = img.channels(); //Calculates number of channels (Grayscale: 1, RGB: 3, etc.)

for (int i=0; i<rows; i++)
{
    for (int j=0; j<cols; j++)
    {
        double[] data = img.get(i, j); //Stores element in an array
        for (int k = 0; k < ch; k++) //Runs for the available number of channels
        {
            data[k] = data[k] * 2; //Pixel modification done here
        }
        img.put(i, j, data); //Puts element back into matrix
    }
}
Highgui.imwrite("Output.jpg", img); //Writes image back to the file system using values of the modified matrix

84_4+4.픽셀 색상값 추출
I am a beginner in using OpenCV for JAVA. I want to access individual pixel values of an image matrix. 
Since, JAVA jar for OpenCV doesn't offer nice functions like C++, 
I ran into some trouble. After lot of searching, I found out two different methods to do that though
 they are not explained properly (not even in documentation). 
 We can do that either using get() and put() functions or by converting the mat data into a primitive java type such as arrays. 
 I tried both but getting different output results! Please help explaining what am I doing wrong. 
 Am I using them wrong or some other silly problem. I am still a newbie so please forgive if its a stupid question. :)

CASE 1: Using get() function

Mat A = Highgui.imread(image_addr); \\"image_addr" is the address of the image
Mat C = A.clone();
Size sizeA = A.size();
for (int i = 0; i < sizeA.height; i++)
    for (int j = 0; j < sizeA.width; j++) {
        double[] data = A.get(i, j);
        data[0] = data[0] / 2;
        data[1] = data[1] / 2;
        data[2] = data[2] / 2;
        C.put(i, j, data);
    }
CASE 2: Using Array

Mat A = Highgui.imread(image_addr); \\"image_addr" is the address of the image
Mat C = A.clone();
int size = (int) (A.total() * A.channels());
byte[] temp = new byte[size];
A.get(0, 0, temp);
for (int i = 0; i < size; i++)
   temp[i] = (byte) (temp[i] / 2);
C.put(0, 0, temp);
Now according to my understanding they both should do the same thing. 
They both access the individual pixel values (all 3 channels) and making it half. 
I am getting no error after running. But, the output image I am getting is different in these two cases. 
Can someone please explain what is the issue? May be I don't understand exactly how get() function works? 
Is it because of the byte() casting? Please help.

Thanks

-> Answers
It was happening because of byte() casting. I changed the data type of mat image in second case to *CV_64FC3* so that I can use double[] instead of byte[] and it solved the problem.

Mat A = Highgui.imread(image_addr); //"image_addr" is the address of the image
Mat C = A.clone();
A.convertTo(A, CvType.CV_64FC3); // New line added. 
int size = (int) (A.total() * A.channels());
double[] temp = new double[size]; // use double[] instead of byte[]
A.get(0, 0, temp);
for (int i = 0; i < size; i++)
   temp[i] = (temp[i] / 2);  // no more casting required.
C.put(0, 0, temp);
FYI, I also did some time measurement and using second method is way faster than first method.

4+5.픽셀 색상값 추출
안드로이드 기반 OPENCV ? Core ? Histogram
이미지에 있어서 히스토그램은 무엇인가? 보통 히스토그램을 보면 X,Y 축 형태의 막대 그래프 형태를 가지고 있음을 알 수 있다.
이미지에서 히스토그램 그래프의 X 축은 Depth 즉 CV_8UC1 이라고 하면 0 ~ 255이 될 것이고, Y 축은 각 Depth 의 빈도가 될 것이다.
만약 CV_8UC4 라고 하면? 히스토그램 그래프가 4개가 나올 것이고 각각의 그래프는 위의 싱글채널 그래프와 동일한 형태로 표현될 것이다.
그럼 Android 기반의 OpenCV 에서 Histogram 을 다루는 방법을 알아보자. 아래는 OPENCV 샘플에 포함된 소스코드로
RED , Green, Blue, 색상, 명도 별 히스토그램을 화면에 출력하는 예제이다.

(1) 히스토그램 이미지를 담기 위한 메트릭스를 생성한다.
mRgba = inputFrame.rgba();

if ((mSizeRgba == null) || (mRgba.cols() != mSizeRgba.width) || (mRgba.height() != mSizeRgba.height))
{
//히스토그램 출력 이미지 편집을 위한 메트릭스 생성
CreateAuxiliaryMats();
}

//히스토그램 막대의 폭을 정의한다.
int thikness = (int) (mSizeRgba.width / (mHistSizeNum + 10) / 5);

if(thikness > 5)
{
thikness = 5;
}

int offset = (int) ((mSizeRgba.width ? (5*mHistSizeNum + 4*10)*thikness)/2);

(2) 카메라 이미지의 정보로 RGB 에 해당하는 히스토그램을 생성한다. 
// RED 에 대한 히스토그랩, GREEN에 대한 히스토그램, BLUE 에 대한 히스토그램을 그린다.
for(int c=0; c<3; c++)
{
	//mRgba : 원본 이미지, mChannels : RGB 중 원하는 채널 선택 , 출력값 : mMat0, mHist, mHistSize, mRanges
	Imgproc.calcHist(Arrays.asList(mRgba), mChannels[c], mMat0, mHist, mHistSize, mRanges);
	Core.normalize(mHist, mHist, mSizeRgba.height/2, 0, Core.NORM_INF);
	mHist.get(0, 0, mBuff);
	for(int h=0; h<mHistSizeNum; h++) {
	mP1.x = mP2.x = offset + (c * (mHistSizeNum + 10) + h) * thikness;
	mP1.y = mSizeRgba.height-1;
	mP2.y = mP1.y ? 2 ? (int)mBuff[h];
	Core.line(mRgba, mP1, mP2, mColorsRGB[c], thikness);
}
}

// RGB를 HSV [색상(H), 채도(S), 명도(V)] 로 변경하고 명도값을 추출하여 히스토그램으로 표현한다.
Imgproc.cvtColor(mRgba, mIntermediateMat, Imgproc.COLOR_RGB2HSV_FULL);
// Value
Imgproc.calcHist(Arrays.asList(mIntermediateMat), mChannels[2], mMat0, mHist, mHistSize, mRanges);
Core.normalize(mHist, mHist, mSizeRgba.height/2, 0, Core.NORM_INF);
mHist.get(0, 0, mBuff);
for(int h=0; h<mHistSizeNum; h++)
{
	mP1.x = mP2.x = offset + (3 * (mHistSizeNum + 10) + h) * thikness;
	mP1.y = mSizeRgba.height-1;
	mP2.y = mP1.y ? 2 ? (int)mBuff[h];
	Core.line(mRgba, mP1, mP2, mWhilte, thikness);
}

// RGB를 HSV [색상(H), 채도(S), 명도(V)] 로 변경하고 색상 값을 추출하여 표현한다.
Imgproc.calcHist(Arrays.asList(mIntermediateMat), mChannels[0], mMat0, mHist, mHistSize, mRanges);
Core.normalize(mHist, mHist, mSizeRgba.height/2, 0, Core.NORM_INF);
mHist.get(0, 0, mBuff);
for(int h=0; h<mHistSizeNum; h++)
{
	mP1.x = mP2.x = offset + (4 * (mHistSizeNum + 10) + h) * thikness;
	mP1.y = mSizeRgba.height-1;
	mP2.y = mP1.y ? 2 ? (int)mBuff[h];
	Core.line(mRgba, mP1, mP2, mColorsHue[h], thikness);
}

(3)	RGB / CMY / HSV
1.먼저 자신이 찾고자 하는 색깔의 Hsv를 알아내야 합니다. 만약 자신이 찾는 색깔의 Hsv를 모르는 경우 해당 색깔의 RGB를 Hsv로 변환하는 사이트를 이용합니다.
http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
ex)		R=255,	G=0,	B=0
	->	H=0,	S=100,	V=100
ex)		R=0,	G=255,	B=0
	->	H=120,	S=100,	V=100
ex)		R=0,	G=0,	B=255
	->	H=240,	S=100,	V=100
출처: http://elecs.tistory.com/51 [늦깎이 공대생의 좌충우돌 이야기]

cf)	case VIEW_MODE_COLOR_BLOB_DETECT:
		/*	RGB -> HSV
		 *	본 Android OpenCV에서 처리되는 HSV Range는(H,S,V:0~255)
		 *	통상적으로 사용되는 HSV Range와(H:0~360, S:0~100, V:0~100) Range만 다를 뿐이지 실제 적용되는 값은 동일 함
		 *	
		 *	이유)	R = 126,	G = 34,	B = 58 일 경우
		 *	1.	통상적으로 사용되는 HSV로 변환하면
		 *		H = 345,	S = 73.02,	V = 49.41
		 *	2.	HSV 각각의 값을 0~255 Range로 모두 변환하면
		 *		1)	H -> 345/360 = 0.9583 -> 255 x 0.9583 = 244.375
		 *		2)	S -> 73.02/100 = 0.7302 -> 255 x 0.7302 = 186.201
		 *		3)	V -> 49.41/100 = 0.4941 -> 255 x 0.4941 = 125.9955
		 *	3.	Range를 변경한 상기 2.번 H/S/V값과 실제 Android OpenCV에서 처리되는 H/S/V값이 서로 동일 함
		 *	
		 *		R = 126,	G = 34,	B = 58
		 *	->	H = 245,	S = 186,	V = 126
		 *
		 *		R = 255,	G = 0,	B = 0
		 *	->	H = 0,		S = 255,	V = 255
		 *
		 *		R = 0,		G = 255,	B = 0
		 *	->	H = 85,	S = 255,	V = 255
		 *
		 *		R = 0,		G = 0,	B = 255
		 *	->	H = 171,	S = 255,	V = 255
		 *
		 *		R = 0,		G = 0,	B = 0
		 *	->	H = 0,		S = 0,		V = 0
		 *
		 *		R = 255,	G = 255,	B = 255
		 *	->	H = 0,		S = 0,		V = 255	*/

		double aTemp[] = {126, 34, 58, 0};
				
		mBlobColorRgba.set(aTemp);
		mBlobColorHsv = converScalarRgba2Hsv(mBlobColorRgba);		// H = 245,	S = 186,	V = 126 출력
								
		mDetector.setHsvColor(mBlobColorHsv);
				
		mRgba = inputFrame.rgba(); // inputFrame.rgba() 정보로 refresh
		mDetector.process(mRgba);
		List<MatOfPoint> contours = mDetector.getContours();
		Log.d(TAG, "Contours count: " + contours.size());
		Imgproc.drawContours(mRgba, contours, -1, CONTOUR_COLOR);
		break;


주요 색상 모형 ( Main Color Model )
 주요 색상 모형		설명																			기준
 RGB				RGB 모형은 빛의 3원색인 빨강( Red ), 녹색( Green ), 파랑( Blue )을 				빛의 3원색
 					기본 색상으로 모든 색을 표현하는 모형
 CMY				색의 3원색인 청록색( Cyan ), 자주색( Magenta ), 노란색을 						색의 3원색
 					기본 색상으로 모든 색을 표현하는 모형
 HSV				색상( Hue ), 채도( Saturation ), 명도( Value)를 기준으로 색을 표현하는 모형		빛의 3속성

□ HSV ( Hue, Saturation, Value )
빛에는 세 가지 속성이 있습니다. 
 빛의 3속성					설명 
 색상( Color, Hue )			- 색상 자체를 의미
 							- 빛의 파장(주파수)의 길이에 의해 결정되며
 					  		  가시광선의 경우, 파장이 길면  빨강, 짧으면 보라색 계열이 됨
 채도( Saturation )			- 색의 순도. 즉, 색의 맑고 탁한 정도
 							- 순색의 경우 채도가 높고 색을 섞을수록 낮아져서 탁색(회색)이 됨
 명도( Value, Intensity )	- 색의 밝고 어두운 정도
 							- 빛의 진폭에 의해 결정되며 진폭이 크면 빛의 밝기(에너지)가 커짐

이와 같이 빛의 3속성을 이용하여 색을 표현하는 모형을 HSV 또는 HSI 모형이라고 합니다.
좀 더 구체적으로 설명하면, 색상( Color, Hue )이란, 구분가능한 색깔 자체를 말하는 것으로 빨강, 파랑, 노랑 등 색을 갖는 유채색을 말합니다. 
HSV 모형은 원뿔모양의 좌표계로 표현되는데, 이 좌표계 상의 원을 색상환이라고도 합니다. 색상환에서 빨강은 0도, 초록은 120도, 파랑색은 240도에 위치합니다.

채도는 색상의 순도, 즉 색의 포함정도라고 할 수 있습니다. 채도가 높다는 말은 짙다, 선명하다, 뚜렷하다란 뜻이며, 낮다는 말은 흐리거나 탁하다라고 할 수 있습니다. 
HSV 모형에서 채도는 0~1 사이의 값을 가지며, 원뿔 중심으로 원뿔 겉면과 수평거리로 표현됩니다.

명도는 색의 밝기를 뜻하는 것으로 가장 밝은 색은 흰색이고 가장 어두운 색은 검정색입니다.  
참고로, 명도에 의해 나타나는 흰색, 회색, 검정색과 같이 색을 갖지 않는 색상을 무채색이라고 합니다.
HSV 모형에서는 가장 아래쪽이 명도 0인 검정색, 가장 위쪽, 즉, 원의 중심이 명도 1인 흰색입니다.

사람이 색을 표현할 때, 색상은 빨강색인데 짙고 밝다라고 표현하듯이, HSV는 인간이 색을 인지하는 방식과 아주 유사합니다. 
따라서, 주로 시각예술, 염색과 같은 분야에서 자주 사용됩니다.

출처: http://driz2le.tistory.com/188 [홀로 떠나는 여행]

84_4+6.픽셀 색상값 추출
[CV] 입력 영상을 RGB 3채널로 분리하기
입력받은 영상의 각 색상 채널을 분리해서 싱글 채널로 만들어 작업하여야 할 때가 있다.

Core.split 메소드를 이용해 RGBA로 분리하는 소스
List<Mat> rgba = new ArrayList<Mat>();
      
Core.split(in, rgba);
 
Mat r = rgba.get(0);
Mat g = rgba.get(1);
Mat b = rgba.get(2);
Mat a = rgba.get(3); //  입력이 A 채널도 포함할 경우
 

분리한걸 다시 합쳐서 4채널 매트릭스를 만드는 소스
List<Mat> rgba = new ArrayList<Mat>();
 
rgba.set(0, r);
rgba.set(1, g);
rgba.set(2, b);
rgba.set(3, a); // A 채널도 합치고 싶을 경우 (생략 가능)
         
Core.merge(rgba, out);

출처: http://pjc0247.tistory.com/41 [pjc0247]

84_4+7.OpenCV image read
LoadImageActivity.java
package com.example.home.loadimagefromfile;

import android.app.Activity;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.os.Environment;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.widget.ImageView;
import android.widget.Toast;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;
import org.opencv.android.Utils;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

import java.io.File;

public class LoadImageActivity extends Activity {
    ImageView igv;
 Mat imgRGBA, imgBGA;
 private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
        @Override
 public void onManagerConnected(int status) {
            switch (status) {
                case LoaderCallbackInterface.SUCCESS:
                    File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
 Toast.makeText(LoadImageActivity.this, path.toString(), Toast.LENGTH_SHORT).show();
 Log.d("LoadImageFromFile:", path.toString());
 String filename = path.toString()+ "/"+ "xmen.jpg";
 imgBGA = Imgcodecs.imread(filename);
 if (imgBGA.empty()) {
                        Toast.makeText(LoadImageActivity.this, filename, Toast.LENGTH_SHORT).show();
 } else {
                        igv = (ImageView) findViewById(R.id.imageView);
 imgRGBA = new Mat(); //RGBA format
 Imgproc.cvtColor(imgBGA, imgRGBA, Imgproc.COLOR_BGR2RGBA);
 Bitmap bm = Bitmap.createBitmap(imgRGBA.cols(), imgRGBA.rows(),Bitmap.Config.ARGB_8888);
 Utils.matToBitmap(imgRGBA, bm);
 igv.setImageBitmap(bm);
 }

                    break;
 default:
                    super.onManagerConnected(status);
 }
        }
    };
 @Override
 protected void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);
 setContentView(R.layout.activity_load_image);



 }

    @Override
 public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
 getMenuInflater().inflate(R.menu.menu_load_image, menu);
 return true;
 }

    @Override
 public boolean onOptionsItemSelected(MenuItem item) {
        // Handle action bar item clicks here. The action bar will
 // automatically handle clicks on the Home/Up button, so long
 // as you specify a parent activity in AndroidManifest.xml.
 int id = item.getItemId();

 //noinspection SimplifiableIfStatement
 if (id == R.id.action_settings) {
            return true;
 }

        return super.onOptionsItemSelected(item);
 }
    public void onResume() {
        super.onResume();
 if (!OpenCVLoader.initDebug()) {
            //Internal OpenCV library not found. Using OpenCV Manager for initialization
 OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);
 } else {
            //OpenCV library found inside package. Using it!
 mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);
 }
    }
}

AndroidManifest.xml

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
 package="com.example.home.loadimagefromfile" >

 <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
 <application
 android:allowBackup="true"
 android:icon="@mipmap/ic_launcher"
 android:label="@string/app_name"
 android:theme="@style/AppTheme" >
 <activity
 android:name=".LoadImageActivity"
 android:label="@string/app_name" >
 <intent-filter>
 <action android:name="android.intent.action.MAIN" />

 <category android:name="android.intent.category.LAUNCHER" />
 </intent-filter>
 </activity>
 </application>

</manifest>
activity_load_image.xml

<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
 xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"
 android:layout_height="match_parent" android:paddingLeft="@dimen/activity_horizontal_margin"
 android:paddingRight="@dimen/activity_horizontal_margin"
 android:paddingTop="@dimen/activity_vertical_margin"
 android:paddingBottom="@dimen/activity_vertical_margin" tools:context=".LoadImageActivity"><![CDATA[

    TextView android:text="@string/hello_world" android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

    ]]>

    <ImageView
 android:layout_width="match_parent"
 android:layout_height="match_parent"
 android:id="@+id/imageView"
 android:layout_alignParentStart="true"
 android:layout_alignParentTop="true" />
</RelativeLayout>
build.gradle(Module:app)

apply plugin: 'com.android.application'

android {
    compileSdkVersion 23
 buildToolsVersion "23.0.0"

 defaultConfig {
        applicationId "com.example.home.loadimagefromfile"
 minSdkVersion 21
 targetSdkVersion 23
 versionCode 1
 versionName "1.0"
 }
    buildTypes {
        release {
            minifyEnabled false
 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
 }
    }
}

dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    compile project(':openCVLibrary300')
}

84_4+8.OpenCV image read/write
	mRgba = inputFrame.rgba(); // inputFrame.rgba() 정보로 refresh

	if(g_iCnt == 0)
	{
		g_iCnt = 1;

		Imgcodecs.imwrite("/sdcard/opencv.jpg", mRgba);					
		return mRgba;
	}
	else
	{
		Mat originalImage = new Mat();
		originalImage = Imgcodecs.imread("/sdcard/opencv.jpg");
//		Imgproc.cvtColor(originalImage, mRgba, Imgproc.COLOR_BGR2RGB);
		return originalImage;
	}

84_5.	OpenCV, Android 제어
1)	For grayscale image:

cv::Mat m(100, 100, CV_8UC1); //gray 
m = Scalar(5);  //used only Scalar.val[0] 
or
cv::Mat m(100, 100, CV_8UC1); //gray 
m.setTo(Scalar(5));  //used only Scalar.val[0] 
cf)	m.setTo(new Scalar(5));  //used only Scalar.val[0] 
or
Mat mat = Mat(100, 100, CV_8UC1, cv::Scalar(5));

2)	For colored image (e.g. 3 channels)

cv::Mat m(100, 100, CV_8UC3); //3-channel 
m = Scalar(5, 10, 15);  //Scalar.val[0-2] used 
or
cv::Mat m(100, 100, CV_8UC3); //3-channel 
m.setTo(Scalar(5, 10, 15));  //Scalar.val[0-2] used 
cf) m.setTo(new Scalar(5, 10, 15));  //Scalar.val[0-2] used 
or
Mat mat = Mat(100, 100, CV_8UC3, cv::Scalar(5,10,15));

84_6.	cv2.threshold(src, thresh, maxval, type) → retval, dst
Parameters:	
-	src ? input image로 single-channel 이미지.(grayscale 이미지)
-	thresh ? 임계값
-	maxval ? 임계값을 넘었을 때 적용할 value
-	type ? thresholding type

84_7.	각종 OpenCV 정의
이미지에서 히스토그램 그래프의 X 축은 Depth 즉 CV_8UC1 이라고 하면 0 ~ 255이 될 것이고, Y 축은 각 Depth 의 빈도가 될 것이다.
만약 CV_8UC4 라고 하면? 히스토그램 그래프가 4개가 나올 것이고 각각의 그래프는 위의 싱글채널 그래프와 동일한 형태로 표현될 것이다.

84_8.	OpenCV 함수 정리
IplImage 구조체 멤버명
● nChannels : 영상의 픽셀 당 채널 수를 나타내며 1~4 값이며 흑배???영상의 채널의 수는 1이고 RGB 컬러영상의 채널의 수는 3이고 RGB 컬러순서는 다음과 같다.
 b0 g0 r0 b1 g1 r1 b2 g2 r2 b3 g3 r3 ………
 
● origin : 영상의 원점을 나타낸다. 0은 top-left origin, 1은 bottom-left origin을 의미한다. 다음은 Opencv에서 origin이 나타내는 상수이다.
origin				설명
IPL_ORIGIN_TL (0)	TL은 Top Left의 약자이며 왼쪽 상단을 나타낸다.
IPL_ORIGIN_BL (1)	BL은 Bottom Left의 약자이며 왼쪽 하단을 나타낸다.
 
● depth : 영상데이터를 저장하기위해 사용되는 비트의 수를 나타낸다. depth는 컴퓨터 언어에서 자료형(data type)과 같이 예를 들어, C언어에서 정수형에 int형과 long형이 있고 실수형에 float과 double이 있듯이 데이터를 몇 비트를 가지고 표현할 것인가를 나타낸다.
다음은 OpenCV에서 depth를 나타나는 상ㄹ수이다.
depth				설명
IPL_DEPTH_8U		8비트 unsigned integer (0~255)
IPL_DEPTH_8S		8비트 signed integer (-128~127)
IPL_DEPTH_16U		16비트 unsigned integer
IPL_DEPTH_16S		16비트 signed integer
IPL_DEPTH_32S		32비트 signed integer
IPL_DEPTH_32F		32비트 floating-point number
IPL_DEPTH_64F		64비트 floating-point number
 
만약 흑백영상에서 depth가 IPL_DEPTH_8U이면 색상 데이터를 0~255사이의 정수로 나타내고 IPL_DEPTH_32F이면 32비트 실수로 표현하겠다는 뜻이다. 마찬가지로 RGB 컬러영상에서 depth가 IPL_DEPTH_8U이면 각 채널 당 색상 데이터를 0~255사이의 정수로 나타내고 IPL_DEPTH_32F이면 각 채널 당 32비트 실수로 표현하겠다는 뜻이다.
 
● width : 영상의 가로크기를 나타내며 단위는 픽셀이다.
● height : 영상의 세로크기를 나타내며 단위는 픽셀이다.
● widthStep : 영상에서 가로 크기를 나타내며 단위는 바이트이다. widthStep = width * nChannels이다. 8비트 1채널 영상에서 영상의 가로크기가 100픽셀이면 widthStep = 100 * 1인 100 바이트이고 8비트 3채널 영상에서 영상의 가로크기가 100픽셀이면 widthStep = 100 * 3인 300바이트가 된다.
● imageSize : 영상의 크기를 나타내며 단위는 바이트이다. imageSize = width * height * nChannels이다. 가로 256픽셀, 세로 256픽셀인 흑백영상에서 imageSize는 65,536 바이트 (256픽셀 * 256픽셀 * 1채널 = 65,536바이트)이고 가로 256픽셀, 세로 256픽셀인 컬러영상에서 imageSize는 196,608바이트 (256픽셀 * 256픽셀 *3채널 = 196,608바이트)가 된다.
● imageData : 256 * 256 흑백영상에서 첫 픽셀의 데이터는 imageData[0], 두 번째 픽셀의 데이터는 imageData[1], 마지막 픽셀의 데이터는 imageData[65535]에 들어 있다. 다음은 흑백영상에서 6개 픽셀에 저장된 픽셀값들을 보여주고 있다.
 
imageData[0]	imageData[1]	imageData[2]	imageData[3]	imageData[4]	imageData[5]
100				120				150				130				140				160
 
컬러영상에서 픽셀에 저장되는 채널의 순서는 BGR 순서에 따라 영상 데이터가 저장된다. 다음은 컬러영상에서 2개의 픽셀에 저장된 픽셀값들을 보여주고 있다.
imageData[0]	imageData[1]	imageData[2]	imageData[3]	imageData[4]	imageData[5]
100				120				150				130				140				160
여기서는 (B, G, R)이 (100, 120, 150) 혹은 (130, 140, 160)에 의해 각각 다른 두 가지 컬러 색을 나타낸다.
 
영상 읽기
● cvLoadImage 함수
영상을 메모리 상에 로드하는데 사용되는 함수이다.
IplImage* cvLoadImage( char * filename, int iscolor );
● filename
로드되는 파일의 이름을 가리킨다.
● iscolor
로드되는 영상의 색상을 가리킨다.
iscolor > 0이면 3채널 컬러 영상으로 변환하여 로드한다.
iscolor = 0이면 흑백 영상으로 변환하여 로드한다.
iscolor < 0이면 원래의 영상 그대로 로드한다. 즉, 원래 영상이 3채널 컬러영상은 컬러영상으로 흑백영상은 그대로 흑백영상으로 로드한다. 예를 들어, 다음은 Lena 컬러영상을 컬러영상 그대로 메모리 상에 로드한다.
 
IplImage* image;
image = cvLoadImage("../images/Lena.jpg", -1);
 
만약에 컬러영상을 흑백영상으로 변환하여 로드하고자 하는 경우는 다음과 같다.
 
IplImage* image;
image = cvLoadImage("../images/Lena.jpg", 0);
 
Opencv에서 지원되는 파일의 종류
파일				설명
BMP, DIB			Windows 비트맵
JPEG, JPG, JPE		JPEG 파일
PNG					Portable Network Graphics
PBM, PGM, PPM		Portable 영상 포맷
SR, RAS				Sun rasters
TIFF, TIF			TIFF 파일

cf)	cvLoadImage()
1) Format
- cvLoadImage(char* fileName, int isColor = CV_LOAD_IMAGE_COLOR);

2) Function
- 이미지 파일을 불러와서 그 이미지의 포인터를 반환한다.

3) Parameters
- fileName: 불러오고자 하는 이미지 파일의 경로.
- isColor: 색깔 타입. 다음과 값이 들어갈 수 있다.
?Color > 0: 3 채널 컬러 영상으로 변환하여 로드.
?Color = 0: 흑백 영상으로 변환하여 로드.
?Color < 0: 원래 영상 그대로 로드

또는 다음과 같은 flag를 사용할 수 있다.
?CV_LOAD_IMAGE_COLOR: 3 채널 컬러 영상으로 변환하여 로드
?CV_LOAD_IMAGE_GRAYSCALE: 흑백 영상으로 변환하여 로드
?CV_LOAD_IMAGE_UNCHANGED: 원래 영상 그대로 로드.


영상 출력
● cvNamedWindow 함수
영상을 출력하기 위한 윈도우를 만들기 위해 사용되는 함수이다.
int cvNamedWindow(char* name, int flags;
● name
윈도우의 이름을 나타낸다.
● flags
윈도우의 크기조절을 나타내기 위한 플래그이다. 플래그가 CV_WINDOW_AUTOSIZE이면 윈도우의 크기는 자동으로 출력할 영상의 크기에 맞춘다. CV_WINDOPW_AUTOSIZE 대신 1을 사용할 수 있다. 이 경우 출력된 윈도우의 크기를 사용자가 마우스를 가지고 크기 조절을 할 수 없다. 플래그가 0인 경우 사용자가 마우스로 크기 조절을 할 수 있다.
 
● cvShowImage 함수
cvNamedWindow() 함수에 의해 지정된 윈도우에 영상을 출력하기 위해 사용하는 함수이다.
void cvShowImage(char* name, CvArr* image);
● name
윈도우의 이름이며 cvNamedWindow() 함수ㅠ에 의해 지정된 이름과 동일하다.
● Image
출력할 영상을 나타내며 cvLoadImage() 함수에 의해 로드된 영상을 지정한다.
 
● cvWaitKey 함수
키보드로부터 키 입력을 기다리기 위한 함수이다.
int cvWaitKey(int delay);
● delay
지정된 시간(단위 : milliseconds) 동안 기다린다.
cvWaitKey() 함수는 영상을 화면에 출력할 때 출력되는 시간을 지정하기 위해 사용한다. delay ≤ 0인 경우 예를 들어, cvWaitKey(0)이면 영상이 출력된 상태에서 무한히 키보드 입력을 기다리다 키를 입력하면 입력된 키의 코드를 반환한다. cvWaitKey(1000)임녀 1초 동안 기다리고 cvWaitKey(10000)이면 10초동안 기다린다. 만약 지정된 시간동안 키보드로부터 사용자가 키를 입력하지 않으면 -1을 반환한다.
 
● cvReleaseImage 함수
cvLoadImage() 함수를 이용하여 메모리에 로드된 영상이 메모리로부터 해제하기 위해 사용하는 함수이다.
void cvReleaseImage( IplImage** image);
● image
image는 IplImage 구조체의 이중 포인터이다. 따라서 포인터 변수 image가 수록되어 있는 주소를 가리키므로 &image로서 나타낸다. 다음은 Lena 영상을 메모리에 로드하고 로드된 영상을 메모리에서 해제하는 예이다.
IplImage* image;
image = cvLoadImage("../images/Lena.jpg", -1);
cvReleaseImage(&image);
 
● cvCreateImage 함수
영상을 만들기 위해 사용하는 함수이다.
IplImage* cvCreateImage( cvSize size, int depth, int channels);
● size
영상의 크기를 지정한다. 영상의 크기는 cvSize() 함수와 cvGetSize() 함수를 사용하여 지정한다. 영상의 가로와 세로 길이를 직접 지정하고자 하는 경우는 cvSize() 함수를 사용하여 cvSize(width, height)처럼 지정하고 특정한 영상의 크기와 똑같은 크기의 영상을 만들고자 하는 경우는 cvGetSize() 함수를 사용하여 cvGetSize(src_image)처럼 지정한다.
● depth
영상 데이터의 깊이(단위:비트)를 지정한다. 1채널 영상인 경우는 픽셀의 깊이가 되고 3채널 영상인 경우 각 채널의 깊이가 된다.
depth					설명
IPL_DEPTH_8U			8비트 unsigned integer (0~255)
IPL_DEPTH_8S			8비트 signed integer (-128~127)
IPL_DEPTH_16U			16비트 unsigned integer
IPL_DEPTH_16S			16비트 signed integer
IPL_DEPTH_32S			32비트 signed integer
IPL_DEPTH_32F			32비트 floating-point number
IPL_DEPTH_64F			64비트 floating-point number
● channels
픽셀 당 채널 수를 지정한다.
예를 들어, 영상의 크기 640 * 480인 흑백영상을 만들고자 하는 경우 흑백영상은 1채널이므로 다음과 같다.
IplImage* image = cvCreateImage(cvSize(640,480), IPL_DEPTH_8U, 1);
여기서 채널의 깊이는 8비트로 지정하고 있다. 즉, 0과 255사이 256개의 정수값으로 표현하겠다는 의미이다. 만약에 영상의 크기 640 * 480인 컬러영상을 만들고자 하는 경우 RGB 컬러영상은 3채널이므로 다음과 같다.
IplImage* image = cvCreateImage(cvSize(640,480), IPL_DEPTH_32F, 3);
여기서는 각 채널의 깊이는 32비트로 지정하고 있다. 비록 컬러영상이지만 각 채널의 깊이를 흑백영상처럼 8비트로 다음과 같이 지정할 수도 있다.
IplImage* image = cvCreateImage(cvSize(640,480), IPL_DEPTH_8U,3);

● cvSplit 함수
다채널 영상을 단일 채널 영상으로 분리하고자 하는 경우 사용하는 함수이다.
void cvSplit( CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3);
● src
다채널 영상을 나타낸다.
● dst0, dst1, dst2, dst3
단일 채널 영상을 나타낸다.
영상 저장

● cvSaveImage 함수
영상을 파일에 저장하기 위한 함수이다.
int cvSaveImage( char* filename, CvArr* image);
● filename
저장할 파일이름을 나타낸다.
● image
저장할 영상을 가리킨다.
다음은 cvSaveImage() 함수의 사용 예를 보여준다.
IplImage* image;
cvSaveImage("../images/Lena.jpg", image);
 
산술연산
단일 영상에서 산술연산
 
● cvAddS 함수
영상에 상수값을 더하기 위해 사용하는 함수이다.
void cvAddS( CvArr* src, CvScalar value, CvArr* dst, CvArr* mask(NULL) );
● src
원 영상을 나타낸다.
● value
더하고자 하는 상수값을 지정한다. 상수값은 CvScalar 자료형을 갖는 CV_RGB와 cvScalarAll() 함수를 사용하여 지정한다. CV_RGB를 사용하여 지정하는 경우 예를 들어, 흑백영상에서 임의의 픽셀에 100을 더하고자 하는 경우 상수값은 CV_RGB(100, 100, 100)처럼 지정하고 컬러영상에서 RGB 각 채널에 상수값 100, 110, 120을 더하고자 하는 경우 상수값은 CV_RGB(100, 100, 120)처럼 지정하면 된다.
● dst
목적 영상을 나타낸다.
● mask
마스크를 지정한다. 마스크를 사용하지 않는 경우 NULL로 지정한다.
예를 들어, 원 영상 src에 60을 더하여 목적영상 dst를 얻고자 하는 rsuddn 다음과 같다
cvAddS(src, CV_RGB(60, 60, 60), dst, NULL);
 
● cvSubS 함수
영상에 상수값을 빼기 위해 사용하는 함수이다.
void cvSubS( CvArr* src, CvScalar value, CvArr* dst, CvArr* mask(NULL) );
● src
원 영상을 나타낸다.
● value
빼고자 하는 상수값을 지정한다.
● dst
목적 영상을 나타낸다.
● mask
마스크를 지정한다. 마스크를 사용하지 않는 경우 NULL로 지정한다.
예를 들어, 원 영상 src에 60을 빼서 목적영상 dst를 얻고자 하는 경우 다음과 같다.
cvSubS(src, CV_RGB(60, 60, 60), dst, NULL);
 
● cvMul 함수
두 영상 간의 곱셈을 수행하는 함수이다.
void cvMul( CvArr* src1, CvArr* src2, CvArr* dst, double scale=1 );
● src1
첫 번째 영상을 나타낸다.
● src2
두 번째 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● scale
곱하고자 하는 상수를 나타낸다.
cvMul() 함수는 dst = scale * src1 * src2를 수행한다. 따라서 cvMul() 함수를 이용하여 우리가 원하는 한 영상에서 상수값 곱셈을 수행하기 위해서는 두 번째 영상 src2를 픽셀값이 전부 1인 단위 영상으로 만들어 사용한다. Opencv에서 제공하는 cvSet() 함수를 사용하여 임의의 영상을 단위영상으로 만들 수 있다.
 
● cvSet 함수
행렬 혹은 영상을 주어진 원소 혹은 픽셀값으로 채우기 위해 사용하는 함수이다.
void cvSet( CvArr* arr, CvScalar value, CvArr* mask=NULL );
● arr
목적영상을 나타낸다.
● value
채우고자 하는 상수이며 상수값은 cvScalar 자료형을 갖는 CV_RGB와 cvScalarAll() 함수를 사용하여 지정한다. cvScalarAll() 함수를 사용하여 예를 들어, 0 혹은 255로 채우고자 하는 경우 cvScalarAll(0) 혹은 cvScalarAll(255)처럼 사용하면 된다.
● mask
마스크를 지정한다. 마스크를 사용하지 않는 경우 NULL로 지정한다.
 
두 영상간의 산술연산
 
● cvAdd 함수
두 영상 간의 덧셈을 수행하는 함수이다.
void cvAdd( CvArr* src1, CvArr* src2, CvArr* dst, CvArr* mask=NULL);
● src1
첫 번째 영상을 나타낸다.
● src2
두 번째 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● mask
마스크를 지정한다. 마스크를 사용하지 않는 경우 NULL로 지정한다.
cvAdd() 함수는 dst = src1 + src2를 수행한다.
 
● cvSub 함수
두 영상 간의 뺄셈을 수행하는 함수이다.
void cvSub( CvArr* src1, CvArr* src2, CvArr* dst, CvArr* mask=NULL );
● src1
첫 번째 영상을 나타낸다.
● src2
두 번째 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● mask
마스크를 지정한다. 마스크를 사용하지 않는 경우 NULL로 지정하낟.
cvSub() 함수는 dst = src1 - src2를 수행한다.
 
● cvDiv 함수
두 영상 간의 나눗셈을 수행하는 함수이다.
void cvDiv( CvArr* src1, CvArr* src2, CvArr* dst, double scale=1 );
● src1
첫 번째 영상을 나타낸다.
● src2
두 번째 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● scale
곱하고자 하는 상수를 나타낸다.
cvDiv() 함수는 dst = scale * (src1/src2)를 수행한다.
 
영상 반전
● cvNot 함수
반전 영상을 얻기 위해 사용하는 함수이다.
void cvNot( CvArr* src, CvArr* dst );
● src
원영상을 나타낸다.
● dst
목적영상을 나타낸다.
cvNot() 함수는 dst = ~ src를 수행한다.
 
이진영상
● cvThreshold 함수
영상에서 이진화하기 위한 함수이다.
cvThreshold( CvArr* src, CvArr* dst, double threshold, double maxValue, CvThreshType type );
● src
원영상을 나타낸다.
● dst
결과영상을 나타낸다.
● threshold
임계값을 나타낸다.
● maxValue
픽셀의 최대 명암값을 나타낸다.
● type
이진화 방식을 결정한다.
 
이진화 방식					설명
CV_THRESH_BINARY			임계값 초과 : 255, 임계값 이하 : 0
CV_THRESH_BINARY_INV		임계값 초과 : 0, 임계값 이하 : 255
CV_THRESH_TRUNC				임계값 초과 : 임계값, 임계값 이하 : 원래 픽셀값
CV_THRESH_TOZERO			임계값 초과 : 원래 픽셀값, 임계값 이하 : 0
CV_THRESH_TOZERO_INV		임계값 초과 : 0, 임계값 이하 : 원래 픽셀 값

영상 변환
● cvCvtColor 함수
컬러영상을 다른 영상으로 변환하는데 사용하는 함수이다.
void cvCvtColor( CvArr* src, CvArr* dst, int code );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● code
컬러 변환 모드이고 다음의 형식에 의해 변환하고자 하는 모드를 지정하면 된다.
CV_<src_color_space>2<dst_color_space>
여기서 <src_color_space>과 <dst_color_space>은 다음 중 하나이다.
RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS
예를 들어, RGB 컬러영상을 흑백영상으로 변환하기 위해서는 다음과 같다.
cvCvtColor(src_image, dst_image, CV_RGB2GRAY);
또는 RGB 컬러영상을 HSV 컬러 영상으로 변환하기 위해서는 다음과 같다.
cvCvtColor(src_iamge, dst_image, CV_RGB2HSV);
 
영상의 블러링
● cvSmooth 함수
영상을 스무딩하는데 사용하는 함수이다.
void cvSmooth( CvArr* src, CvArr* dst, int smoothtype, int param1, int param2, double param3);
● src
원 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● smoothtype
스무딩 형태를 지정한다.

스무딩 형태				설명
CV_BLUR					단순한 블러링을 나타낸다.
						param1 * param2 근방영역에 대해 합을 구한 다음 param1 * param2로 나눈다.
CV_GAUSSIAN				가우시안 블러링을 나타낸다.
						param1 * param2 근방영역에 대해 가우시안 마스크를 사용한다. param3은 표준편차이다.
CV_MEDIAN				중앙값 블러링을 나타낸다.
						param1 * param2 근방영역에 대해 중앙값을 취한다.
cf)	cv2.blur			:	ex, 영역의(ex, 3x3) 평균값으로 치환 작업으로 연속으로 영역 shift 하면서 평균화함, 외곽선이 가장 많이 뭉개짐
	cv2.GaussinaBlur	:	가우시안 곡선을 활용(외곽보다 중앙/중심으로 갈수록 값이 커짐) cvv2.blur 과 같이 평균화 작업을 거치기 때문에 cvv2.blur 보다는 덜하지만 외곽선이 뭉개지는 현상 생김
	cv2.medianBlur		:	cv2.blur 와는 달리 ex, 영역의(ex, 3x3) 평균값을 3x3 영역 모두에 적용시키기 때문에 후추가루 등의 노이즈를 제거시키면서도 외곽선을 제일 많이 유지시켜 줌

● param1
마스크의 가로를 나타낸다.
● param2
마스크의 세로를 나타낸다.
● param3
가우시안 마스크인 경우 표준편차(sigma)를 지정하는데 만약에 param3=0을 지정하면 param3값은 다음과 같다.
sigam = (n/2 -1) * 0.3 + 0.8
여기서 n은 n * n 마스크에서 n의 값이다.
 
● cvFilter2D 함수
사용자가 정의한 마스크를 가지고 영상을 컨벌류션하기 위해 사용하는 함수이다.
void cvFilter2D( CvArr* src, CvArr* dst, CvMat* kernel );
● src
원 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● kernel
컨벌류션 할 마스크를 나타내고 cvMat() 함수 및 cvCreateMat() 함수를 사용하여 지정한다. 단 마스크의 원소들은 1채널 실수형이어야 한다.
 
● cvMat 함수
이미 만들어진 행렬을 지정하는 함수이다.
CvMat cvMat( int rows, int cols, int type, void* data=NULL );
● rows
행렬에서 행의 수를 나타낸다.
● cols
행렬에서 열의 수를 나타낸다.
● type
행렬 원소의 형태를 지정하며 당므과 같은 형식에 의해 지정한다.
CV_<bit_depth>(S|U|F>C<number_of_channels>
예를 들어, CV_8UC1은 8-bit unsigned 1채널 행렬이고 CV_32SC2는 32-bit signed 2채널 행렬이다.

CV_8U : 8-bit unsigned integer: uchar ( 0..255 )
CV_8S : 8-bit signed integer: schar ( -128..127 )
CV_16U : 16-bit unsigned integer: ushort ( 0..65535 )
CV_16S : 16-bit signed integer: short ( -32768..32767 )
CV_32S : 32-bit signed integer: int ( -2147483648..2147483647 )
CV_32F : 32-bit floating-point number: float ( -FLT_MAX..FLT_MAX, INF, NAN )
CV_64F : 64-bit floating-point number: double ( -DBL_MAX..DBL_MAX, INF, NAN )

CV_8UC4	->	가장 마지막 4가 뜻하는 것은 4채널 행렬을 뜻함(ex, R/G/B/A)
->	설명
		CV_8UC4의 경우는 투명도까지 포함된 속성이며
		ex)	Mat m1(3, 4, CV_8UC4, Scalar(255, 100, 234, 0); 처럼 투명도까지 선언해줘야 함
				이때 가장 마지막 투명도 속성은
				0		: 완전투명
				255	: 완전불투명 임
		또한 이경우 jpg가 아닌 png로 저장해야지만 투명도가 적용됨
		ex)	imwrite("test.png", mat);


● data
행렬에 대한 포인터를 나타낸다.
 
영상의 샤프닝
OpenCV에서는 영상의 샤프링을 지원하는 함수는 없다. 우리는 OpenCV의 cvMat() 함수를 사용하여 샤프링 마스크를 정의하고 cvFilter2D() 함수를 사용하여 정의된 마스크를 사용하여 컨벌류션을 수행

에지 검출
● cvSobel 함수
Sobel 연산자를 이용하여 에지검출을 위한 함수이다.
void cvSobel( CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size=3 );
● src
원 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● xorder
x 방향 미분을 나타낸다.
● yorder
y 방향 미분을 나타낸다.
● aperture_size
커널의 크기를 나타낸다.
예를 들어, cvSobel(src, dst, 1, 0, 3)이면 x 방향으로 미분만을 고려한 Soble 방법을 의미하고 cvSobel(src, dst, 0, 1, 3)이면 y방향으로 미분만을 고려한 Sobel 방법을 의미한다. 그리고 cvSobel(src, dst, 1, 1, 3)이면 x 방향으로 미분과 y 방향으로 미분을 ��려한 Sobel 방법을 의미한다.
cvSobel() 함수를 사용하는데 주의할 사항은 src가 8비트 영상이면 dst는 16비트 영상이어야 한다. 따라서 에지 영상을 출력하기 위해서는 다시 8비트 영상으로 변환해야한다. 이를 위해 cvCVonvertScale() 함수를 사용하여 영상을 변환한다.
 
● cvConvertScale 함수
영상을 변환하는데 사용하는 함수이다.
void cvConvertScale( CvArr* src, CvArr* dst, double scale=1, double shift=0 );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● scale
스케일 파라미터를 나타낸다.
● shift
이동 파라미터를 나타낸다.
cvConvertScale() 함수는 src 영상을 dst 영상으로 변환하는덴 주어진 스케일 파라미터와 이동 파라미터를 가지고 다음과 같이 변환한다.
dst = src * scale + shift
 
● cvLaplace 함수
라플라시안 연산자를 이용하여 에지검출을 위한 함수이다.
void cvLaplace( CvArr* src, CvArr* dst, int aperture_size=3 );
● src
원 영상을 나타낸다.
● dst
목적영상을 나타낸다.
● aperture_size
커널의 크기를 나타낸다.
OpenCV를 이용한 히스토그램

● cvCreateHist 함수
히스토그램을 정의하는데 사용하는 함수이다.
CvHistogram* cvCreateHist( int dims, int* sizes, int type, float** ranges=NULL, int uniform=1 );
● dims
히스토그램 차원을 지정한다. 흑백영상이면 1차원이고 컬러영상이면 3차원이다.
● sizes
히스토그램 차원의 크기를 나타내며 배열로 표시한다. 예를 들어, 1차원 256 흑백영상인 경우 0부터 255까지 256개 막대를 사용하므로 다음과 같이 정의한다.
int sizes[1] = {256};
그리고 3차원 컬러영상인 경우 각각의 채널은 256개 막대를 사용함으로 다음과 같이 정의한다.
int sizes[3] = {256, 256, 256};
● type
히스토그램 표현 형식(histogram representation format)을 나타낸다. type = CV_HIST_ARRAY이면 다채널 밀집 배열(multi-dimensional dense array)을 나타내고 type = CV_HIST_SPARSE이면 다채널 희소 배열(multi-dimensional sparse array)을 나타낸다. 여기서 밀집배열이냐 희소배열이냐는 0인 원소가 많이 포함되면 희소배열이고 그렇지 않으면 밀집배열을 나타낸다.
● ranges
히스토그램의 x축 범위를 나타낸다.
● uniform
히스토그램에서 막대 간격을 같게 할 것인지 다르게 할 것인지 결정한다.
uniform ≠ 0이면 막대의 간격을 일정 간격으로 한다.
cvCreateHist() 함수는 CvHistogram 구조체를 반환하는데 CvHistogram 구조체의 형식은 다음과 같다.
 
typedef struct CvHistogram
{
	int type;
	CvArr* bins;
	float thresh[CV_MAX_DIM[3]; /* for uniform histograms */
	float ** thresh2; /* for non-uniform histograms */
	CvMatND mat; /* embedded matrix header for array histograms */
}CvHistogram;
 
● cvCalcHist 함수
영상으로부터 히스토그램을 계산하는데 사용하는 함수이다. 즉, 영상에서 cvCreateHist() 함수에 의해 이미 정의된 히스토그램을 계산한다.
void cvCalcHist( IplImage** img, CvHistogram* hist);
● img
원 영상을 나타낸다.
● hist
히스토그램에 대한 포인터를 나타낸다.

● cvGetMinMaxHistValue 함수
히스토그램ㅇ데서 막대에 대한 최대 빈도수와 최소 빈도수를 구하는 함수이다.
즉, 명암값 들에 대한 최대 빈도수와 최소 빈도수를 구한다.
void cvGetMinMaxHistValue( CvHistogram* hist, flaot* value_min, float* value_max);
● hist
히스토그램을 나타낸다.
● value_min
히스토그램의 최소 빈도수를 나타낸다.
● value_max
히스토그램의 최대 빈도수를 나타낸다.

● cvScale 함수
하나의 배열을 다른 배열로 선형 변환에 의해 변환하는 함수이다.
void cvScale( CvArr* src, CvArr* dst, double scale=1, double shift=0);
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● scale
스케일 파라미터를 나타낸다.
● shift
이동 파라미터를 나타낸다.
cvScale() 함수는 dst = src * scale + shift에 의해 변환된다. 참고로 cvScale() 함수는 cvConvertScale() 함수와 동일한 함수이다.
 
● cvRectangle 함수
직사각형을 그리기위한 함수이다.
void cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness=1 );
● img
직사각형이 그려질 영상을 나타낸다
● pt1
직사각형의 모서리를 나타낸다.
● pt2
직사각형의 반대편 모서리를 나타낸다.
● color
직사각형의 선의 색상을 나타낸다.
● thickness
직사각형의 선의 두께를 나타낸다.
cvRectangle() 함수에서 모서리 좌표 pt1과 pt2를 정할 때 원점 (0, 0)이 어디에 위치하느냐가 중요하다. 수학좌표에서 원점과 영상에서 원점은 다르기 때문이다.
수학 좌표에서 원점은 왼쪽 하단이나 영상 좌표에서 원점은 왼쪽 상단이다.
 
● cvGetReal1D 함수
1차원 히스토그램에서 i 번째 막대의 빈도수를 얻기 위한 함수이다.
double cvGetReal1D( CvArr* arr, int idx0 );
● arr
1차원 배열을 의미한다.
● idx0
원소의 위치에 대한 인덱스를 나타낸다.
예를 들어, cvGetReal1D(histo->bins, i)는 배열 bins에서 i번째 인덱스에 대한 원소를 반환한다.
 
● cvSet 함수
영상을 주어진 값으로 설정할 때 사용하는 함수이다.
void cvSet( CvArr* arr, CvScalar value, CvArr* mask=0 );
● arr
원 영상을 나타낸다.
● value
채울 값을 지정한다.
● mask
마스크를 나타낸다.
예를 들어, cvSet( histImage, cvScalarAll(255), 0 )이면 영상 histImage의 픽셀값을 255로 설정한다.
히스토그램 평활화
 
● cvEqualizeHist 함수
흑백영상에서 히스토그램 평활화하는데 사용하는 함수이다.
void cvEqualizeHist( CvArr* src, CvArr* dst );
● src
흑백 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
영상 확대 및 축소

● cvResize 함수
영상의 크기를 조절하는 함수이다.
void cvResize( CvArr* src, CvArr * dst, int interpolation=CV_INTER_LINEAR );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● interpolation
보간법을 나타내며 다음의 방법이 있다.
(a) CV_INTER_NN - 최근접 이웃 보간법(nearst-neighbor interpolation)
(b) CV_INTER_LINEAR - 양선형 보간법(bilinear interploation (used by default))
(c) CV_INTER_AREA - 재표본 추출법(resampling using pixel area relation)
(d) CV_INTER_CUBIC - 큐빅 보간법(bicubic interpolation)
 
회전 영상
● cv2DRotationMatrix 함수
 
2 * 3 변환행렬을 생성하기 위한 함수이다.
CvMat* cv2DRotationMatrix( CvPoint2D32f center, double angle, double scale, CvMat* map_matrix );
● center
회전 중심을 나타낸다.
● angle
회전 각도를 나타낸다. 각도는 화면좌표계에서 원점을 중심으로 반시계 방향의 각을 의미한다.
● scale
스케일 척도를 나타낸다. 예를 들어, scale=2이면 2배 만큼 영상이 확대된다.
● map_matrix
생성되는 2 * 3 변환행렬을 가리키는 포인터를 나타낸다.
<v:f eqn="if lineDrawn pixelLineWidth 0" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="sum @0 1 0" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="sum 0 0 @1" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="prod @2 1 2" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="prod @3 21600 pixelWidth" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="prod @3 21600 pixelHeight" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="sum @0 0 1" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="prod @6 1 2" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="prod @7 21600 pixelWidth" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="sum @8 21600 0" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="prod @7 21600 pixelHeight" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><v:f eqn="sum @10 21600 0" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></v:f><o:lock aspectratio="t" v:ext="edit" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></o:lock><w:wrap type="topAndBottom" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.5;"></w:wrap>
여기서 α=scale*cos(angle), β=scale*sin(angle)이다.
 
● cvWarpAffine 함수
cv2DRotationMatrix() 함수에서 생성된 변환 행렬을 영상에 적용하는 함수이다.
void cvWarpAffine( CvArr* src, CvArr* dst, CvMat* map_matrix, int flags=CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS, CvScalar fillval=cvScalarAll(0) );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● map_matrix
2 * 3 변환행렬을 나타낸다.
● flags
다음 중 하나의 선택사항을 지정한다.
(a) CV_INTER_LINEAR + CV_WARP_FILL_OUTLIERS
양선형 보간법을 사용하고 목적 영상의 모든 픽셀을 어떤 값으로 채운다.
(b) CV_WARP_INVERSE_MAP
목적 영상에서 원 영상으로 역 변환에 의해 보간한다. 즉, 역방향 사상에 의해 보간한다.
● fillval
목적 영상에서 회전 후 남는 공간을 채울 색을 지정한다. 디폴트는 픽셀값이 0인 검은색이다.
대칭 영상
 
● cvFlip 함수
void cvFlip( CvArr* src, CvArr* dst, int flip_mode=0);
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● flip_mode
(a) flip_mode = 0이면 상하 대칭(디폴트)이다.
(b) flip_mode > 0이면 좌우 대칭이다.
(c) flip_mode < 0이면 상하 대칭 후 좌우 대칭이다.
 
침식 연산과 팽창 연산
 
● cvDilate 함수
팽창연산을 수행하기 위한 함수이다.
void cvDilate( CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● element
구조적 요소를 나타내며 만약 element = NULL이면 3 * 3 사각형 구조적 요소가 사용된다. IplConvKernel은 구조적 요소를 표현하는 구조체이다.
● iterations
팽창 연산 수행 횟수를 나타낸다.

● cvCreateStructuringElementEx 함수
구조적 요소를 정의하기 위한 함수이다.
IplConvKernel* cvCreateStructuringElementEx( int cols, int rows, int anchor_x, int anchor_y, int shape );
● cols
구조적 요소의 열의 수를 나타낸다.
● rows
구조적 요소의 행의 수를 나타낸다.
● anchor_x
중심점의 x 좌표를 나타낸다(0 .. cols-1). 만약 3 * 3 사각형 구조적 요소이면 anchor_x=1이 되고
5 * 5 사각형 구조적 요소이면 anchor_x=2가 된다.
● anchor_y
중심점의 y 좌표를 나타낸다(0 .. rows-1). 만약 3 * 3 사각형 구조적 요소이면 anchor_y=1이 되고
5 * 5 사각형 구조적 요소이면 anchor_y=2가 된다.
● shape
구조적 요소의 모양을 지정한다.
(a) CV_SHAPE_RECT : 사각형 구조적 요소
(b) CV_SHAPE_CROSS : 십자형 구조적 요소
(c) CV_SHAPE_ELLIPSE : 타원형 구조적 요소
(d) CV_SHAPE_CUSTOM : 사용자 정의 구조적 요소
cvCreateStructuringElementEx() 함수의 사용 예는 다음과 같다.
int element_shape = CV_SHAPE_RECT;
int pos = 1;
IplConvKernel* element = cvCreateStructuringElementEx( pos*2+1, pos*2+1, pos, pos, element_shape);
 
● cvErode 함수
침식연산을 수행하기 위한 함수이다.
void cvErode( CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● element
구조적 요소를 나타낸다. 만약 element=NULL이면 3 * 3 사각형 구조적 요소가 사용된다. IplConvKernel은 구조적 요소를 표현하는 구조체이다.
● iterations
침식연산 수행 횟수를 지정한다.
열림 연산과 닫힘 연산

● cvMorphologyEx 함수
팽창연산과 침식연산으로부터 확장된 연산 즉, 열림연산, 닫힘연산 그리고 기울기 연산 등을 수행하기 위한 함수이다.
void cvMorphologyEx( const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations=1 );
● src
원 영상을 나타낸다.
● dst
목적 영상을 나타낸다.
● temp
임시 영상을 나타내며 열림연산과 닫힘연산인 경우 NULL을 지정한다.
● element
구조적 요소를 나타낸다. 만약 element=NULL이면 3 * 3 사각형 구조적 요소가 사용된다.
● operation
다음 연산 중 하나를 지정한다.
(a) CV_MOP_OPEN : 열림연산
(b) CV_MOP_CLOSE : 닫힘연산
(c) CV_MOP_GRADIENT : 기울기 연산
(d) CV_MOP_TOPHAT : top hat 연산(e) CV_MOP_BLACKHAT : black hat 연산
● iterations
연산 수행 횟수를 지정한다.
동영상 파일
 
● cvCaptureFromFile() 함수
동영상 파일을 불러오는데 사용하는 함수이다.
CvCapture* cvCaptureFromFile( char* filename );
● filename
동영상 파일의 이름을 나타낸다.

● cvReleaseCapture() 함수
불러온 동영상에 대해 메모리를 해제하기 위해 사용하는 함수이다.
void cvReleaseCapture( CvCapture** capture );
● capture
메모리 해제할 동영상을 나타낸다.

● cvGrabFrame() 함수
동영상 파일(혹은 카메라)로부터 하나하나의 프레임을 잡는데(grab)사용하는 함수이다.
int cvGrabFrame( CvCapture* capture );
● capture
재생할 출력할 동영상을 나타내며 cvGrabFrame() 함수가 호출될 때 마다 파일(혹은 카메라)로부터 한 프레임씩 잡아(grab) 내부 버퍼에 저장한다.
 
● cvRetrieveFrame() 함수
cvGrabFrame() 함수로부터 잡은 프레임으로부터 영상을 얻어내는데 사용하는 함수이다.
IplImage* cvRetrieveFrame( CvCapture* capture );
● capture
재생할 동영상을 나타내며 cvRetrieveFrame() 함수는 cvGrabFrame() 함수로부터 잡은 프레임으로부터 얻은 영상에 대한 포인터를 반환한다. 서 반환된 영상은 바로 메모리를 해제해서는 안 된다.
 
● cvCreateVideoWriter() 함수
디스크에 동영상 파일을 생성하기 위한 함수이다. 동영상 파일이름과 코덱을 지정하고 그리고 fps와 프레임 크기를 지정한다.
CvVideoWriter* cvCreateVideoWriter( char* filename, int fourcc, double 렌, CvSize frame_size );
● filename
출력할 동영상의 파일 이름을 지정한다.
● fourcc
프레임을 압축하기 위해 사용된 4-글자 코덱을 나타내는 코드를 설정한다. -1값을 지정하면 함수가 실행될 때 코덱을 선택할 수 있는 대화상자가 나타난다. 그렇지 않은 경우 CV_FOURCC 함수를 이용해 다음에서 코덱을 선택할 수 있다.
(a) CV_FOURCC('P', 'I', 'M', '1') = MPEG -1 codec
(b) CV_FOURCC('M', 'J', 'P', 'G') = motion-jpeg codec
(c) CV_FOURCC('D', 'I', 'V', '3') = MPEG-4.3 codec
(d) CV_FOURCC('D', 'I', 'V', 'X') = MPEG-4 codec
(e) CV_FOURCC('F', 'L', 'V', '1') = FLV1 codec
● fps
초당 재생되는 프레임의 수를 설정한다.
● frame_size
프레임 크기를 나타낸다.
 
● cvWriteFrame() 함수
지정된 동영상 파일에 한 프레임 씩 출력한다.
int cvWriteFrame( CvVideoWriter* writer, IplImage* image );
● writer
동영상 파일을 나타낸다.
● image
프레임을 나타낸다.
 
● cvReleaseVideoWriter() 함수
지정된 파일에 저장하는 것을 종료하고 저장 구조를 메모리에서 해제한다.
void cvReleaseVideoWriter( CvVideoWriter** writer );
● wrtier
동여상 파일을 나타낸다.
● cvQueryFrame() 함수
 
동영상 혹은 카메라로부터 프레임을 읽고 반환하는 함수이다.
IplImage* cvQueryFrame( CvCaptuer* capture );
● capture
동영상 파일을 나타낸다.
cvQueryFrame() 함수는 cvGrabFrame() 함수와 cvRetrieveFrame() 함수를 동시에 실행하는 효과를 갖고 있다.
 
● cvInitFont() 함수
글씨체를 초기화하는데 사용하는 함수이다.
void cvInitFont( CvFont* font, int font_face, double hscale, double vscale, double, italicScale = 0, int thickness=1);
● font
폰트에 대한 포인터이다.
● font_face
폰트 이름을 나타낸다.
(예) CV_FONT_HERSHEY_SIMPLEX - normal size s문-serif font 보통의 글자 크기를 나타내며 산세리프 글씨체이다.
● hscale
글자의 수평 스케일(horizontal scale)을 나타내며 1.0f이면 원래 글자의 넓이를 나타낸다.
● vscale
글자의 수직 스케일(vertical scale)을 나타내며 1.0f이면 원래 글자의 높이를 나타낸다.
● italicScale
글자의 기울어진 정도를 나타낸다. 0은 전혀 기울지 않은 폰트이고 1.0f는 45도 기운 폰트를 나타낸다.
● thickness
글자의 굵기를 나타낸다.
 
● cvPutText() 함수
텍스트를 영상에 추가한다. 어떤 영상에 어떤 색상의 텍스트를 어디에 추가할것인가를 지정한다.
void cvPutText( CvArr* img, char* text, CvPoint org, CvFont* font, int color );
● img
입력영상을 나타낸다.
● text
출력할 텍스트를 나타낸다.
● org
텍스트를 출력할 좌표를 나타낸다.
● font
폰트를 가리키는 포인터를 나타낸다.
● color
텍스트의 색상을 지정한다.
다음은 텍스트 “I Love U"를 영상에 추가하기 위한 문장이다. 여기서 텍스트의 폰트는
cvPoint(10, 10이고 색상은 CV_RGB(200, 0, 0)로 지정한다.
cvPutText( image, "I Love U", cvPoint(10, 10), &font, CV_RGB(200, 0, 0) );

PC 카메라로부터 영상 다루기
● cvCaptureFromCAM() 함수
PC카메라로부터 동영상을 캡쳐하는데 사용하는 함수이다.
CvCapture* cvCaptureFromCAM( int index );
● index
사용할 카메라를 지정한다. 카메라가 1개인 경우 혹은 여러 개 중에서 특정한 카메라를 지정하지 않을 경우는 -1을 사용한다. 만약 2개인 경우 index값이 0이면 카메라를 선택할 수 있는 창이 나타난다.
 
● cvCreateTrackbar() 함수
트랙 바를 만들고 지정된 윈도우에 부착한다.
int cvCreateTrackbar( char* trackbar_name, char* window_name, int* value, int count, CvTrackbarCallback on_change );
● trackbar_name
트랙 바의 이름을 나타낸다.
● window_name
트랙 바가 부착될 윈도우의 이름을 지정한다.
● value
정수형 포인터로서 슬라이더의 위치를 나타낼 정수이다.
● count
트랙 바의 최대 위치, 여기서 최소 위치는 0 이다.
● on_change
트랙 바가 움직일 때 마다 호출하는 함수에 대한 포인터, 만약 호출되는 함수가 없으면 NULL이다.)
OpenCV를 이용한 얼굴인식 프로그램
 
● cvCalcEigenObjects() 함수
입력 영상들에 대한 고유얼굴과 평균열상을 계산한다.
void cvCalcEigenObjects( int nObjects, void* input, void* output, int ioFlags, int ioBufSize, void* userData, CvTermCriteria* calcLimit, IplImage* avg, float* eigVals );
● nObjects
입력영상의 개수를 나타낸다.
● input
입력영상에 대한 포인터를 가리킨다.
● output
고유얼굴을 나타낸다.
● ioFlags
입력/출력 플러그를 나타낸다. 입출력 플러그를 사용하지 않으면 0이다.
● ioBufSize
입력/출력 버퍼 크기를 나타낸다.
● userData
콜벡함수(callback functions)를 위해 필요한 모든 데이터를 포함하는 구조에 대한 포인터이다. 콜벡함수를 사용하지 않으면 0이다.
● calcLimit
최대 고유얼굴 영상의 개수(calcLimit.max_iter)와 가장 큰 고유값에 대한 현재의 고유값의 비율에 대한 임계값(calcLimit.epsilon)을 지정한다.
● avg
평균영상을 나타낸다.
● eigVals
고유값을 나타낸다.
예를 들어, cvCalcEigenObjects() 함수의 사용 예는 다음과 같다.
cvCalcEigenObjects(M, images, eigenObjects, 0,0,0, &criteria, avg, eigVals);
이것은 M 개의 입력 영상에 대해 고유얼굴 영상 eigenObjects과 평균영상 avg을 계산한다.
여기서 criteria는 CvTermCriteria 자료형의 변수로서 고유얼굴을 계산하는데 최대 반복횟수와 고유값에 대한 임계값을 지정한다.
 
● cvTermCriteria() 함수
CvTermCriteria cvTermCriteria( int type, int max_iter, double epsilon );
● type
CV_TERMCRIT_ITER(최대 반복횟수)와 CV_TERMCRIT_EPS(고유값에 대한 임계값)를 고려하고자 하는 경우 CV_TERMCRIT_ITER+CV_TERMCRIT_EPS처럼 지정한다.
● max_iter
반복 최대 횟수를 지정한다.
● epsilon
가장 큰 고유값에 대한 현재의 고유값의 비율에 대한 임계값을 지정한다.
예를 들어 cvTermCriteria() 함수의 사용 예는 다음과 같다.
cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS, 10, 0.05);
인수로서 10은 최대 반복횟수이고 0.05는 고유얼굴을 결정하는데 고유값에 대한 임계값을 나타내며 최대 고유값에 대한 현재의 고유값의 비율이 0.05보다 작으면 반복을 종료한다.
 
● cvEigenDecomposite() 함수
입력영상을 고유얼굴 공간에 투영시켰을 때 분해계수(decomposition coefficients)를 계산한다.
void cvEigenDecomposite( IplImage* obj, int nEigObjs, void* eigInput, int ioFlags, void* userData, IplImage* avg, float* coeffs)
● obj
입력영상을 나타낸다.
● nEigObjs
고유얼굴 영상의 개수를 나타낸다.
● eigInput
고유얼굴 영상에 대한 포인터를 나타낸다.
● ioFlags
입력/출력 플러그를 나타낸다. 입출력 플러그를 사용하지 않으면 0이다.
● userData
콜벡함수(callback functions)를 위해 필요한 모든 데이터를 포함하는 구조에 대한 포인터이다. 콜벡함수를 사용하지 않으면 0이다.
● avg
평균영상을 나타낸다.
● coeffs
분해계수를 나타낸다.
예를 들어, cvEigenDecomposite() 함수의 사용 예는 다음과 같다.
cvEigenDecomposite(newone, nEigens, eigenObjects, 0,0, avg, coeffs);
이것은 입력영상 newone을 고유얼굴 eigenObjects 공간에 투영시켰을 때 분해 계수 coeffs를 계산한다.
 
● cvEigenProjection() 함수
고유얼굴 공간상에서 재구성된 영상을 얻는다. 즉, 고유얼굴과 평균영상 그리고 분해계수로부터 재구성된 영상을 얻는다.
void cvEigenProjection( void* input_vecs, int eigenvec_count, int io_flags, void* userdata, float* coeffs, IplImgae* avg, IplImage* proj );
● input_vecs
고유얼굴 영상에 대한 포인터를 나타낸다.
● eigenvec_count
고유벡터의 개수를 나타낸다.
● io_flags
입력/출력 플러그를 나타낸다. 입출력 플러그를 사용하지 안흥면 0이다.
● userdata
콜벡함수(callback functions)를 위해 필요한 모든 데이터를 포함하는 구조에 대한 포인터이다. 콜벡함수를 사용하지 않으면 0이다.
● coeffs
분해계수를 나타낸다.
● avg
평균 영상을 나타낸다.
● proj
고유얼굴 공간상에서 재구성된 영상을 나타낸다.
예를 들어, cvEigenProjection() 함수의 사용 예는 다음과 같다.
cvEigenProjection(eigenObjects, nEigens, 0, 0, coeffs, avg, proj);
이것은 고유얼굴 eigenObjects과 평균영상 avg 그리고 분해계수 coeffs로부터 재구성된 영상 proj을 얻는다.

● cvRound
Rounds floating-point number to the nearest integer
C: int cvRound(double value)
Python: cv.Round(value) → int
함수에 입력된 실수 값을 가장 가까운 integer값으로 변환한다.  

● Imgproc.goodFeaturesToTrack
Shi-Tomasi 특징점 추출 방법은 goodFeaturesToTrack() 이라는 함수명으로 opencv에 구현되어 있으며 흔히 optical flow 등을 계산할 때 사용할 특징점을 추출하는 용도 등으로 사용됩니다.
// 이미지 중에서 모서리/Edge 튀는 이미지의 위치를 MOPcorners로 알려 줌
Imgproc.goodFeaturesToTrack(mGray, MOPcorners, iGFFTMax, 0.01, 20);

OpenCV2 Computer Vision Application Programming Cookbook에서는 코너 검출을 위해서 4가지 커널을 사용한다. 사각형, 다이아몬드, X, 십자가 형태의 커널이며, 이 커널들을 이용하여 팽창, 침식 시킨 후 차영상을 통해 코너를 검출한다. 
OpenCV2에 간단히 코너를 검출할 수 있는 함수가 존재하며, goodFeaturesToTrack() 함수이다. goodFeaturesToTrack()함수의 원형과 각 파라미터에 대한 설명은 아래와 같다.
 
<함수원형>
C++: void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, doubleminDistance, InputArray mask=noArray(), int blockSize=3, bool useHarrisDetector=false, double k=0.04 )
? image ? 8비트, 32비트 부동소수점 단일 채널 영상
? corners ? 검출된 코너를 담을 벡터 ex) vector<Point2f>
? maxCorners ? 반환될 코너의 최대 개수, 만약 찾아낸 코너의 수가 더 많을 경우, 강력한 코너가 반환된다.
? qualityLevel ? 코너라고 판단하기 위한 기준이 되는 최소의 값, 이 값은 최고의 minimal eigenvalue를 가지는 코너의 quality에 곱해지며, 그 값보다 작은 quality를 갖는 코너는 코너라고 판단하지 않는다. 예를 들어, 최고의 minimal eigenvalue=1500 이고, qualityLevel= 0.01 이면, quality가 15보다 작은 코너는 무시된다.
? minDistance ? 반환되는 코너 사이의 최소 유클리디안 거리
? mask ? 코너를 찾을 관심영역, input과 크기가 동일해야한다..
? blockSize ? 평균 블록의 크기
? useHarrisDetector ? 해리스 코너 검출기를 사용할 것인가를 결정하는 플래그
? k ? 해리스 검출기를 위한 파라미터
 
<소스코드>
#include <opencv2/opencv.hpp>
using namespace cv;
 
int main(){
 Mat image=imread("building.jpg");
 Mat gray;
 cvtColor(image, gray, CV_BGR2GRAY);

 Mat cvCorner=image.clone();
 vector<Point2f> corners;
 goodFeaturesToTrack(gray, corners, 1000, 0.01, 10);

 for(int i=0; i<corners.size() ; i++){
  circle(cvCorner, corners[i], 5, Scalar(0, 255, 0));
 }
 imshow("cvCorner", cvCorner);

 waitKey(0);
 return 0;
}
[출처] [OpenCV] goodFeaturesToTrack 함수를 이용한 코너 검출 예|작성자 꼬꼬꼬

* Contour 중심점 찾기
#if false
Moments momentsPoint;
momentsPoint = moments(v_contourApproxpoly[largest_contour_index], true);

Point momentsPointCenter;				// contour 중심점 좌표가 저장
//add 1e-5 to avoid division by zero
momentsPointCenter = Point(momentsPoint.m10 / (momentsPoint.m00 + 1e-5),
						   momentsPoint.m01 / (momentsPoint.m00 + 1e-5));

TRACE("momentsPointCenter, x = %d, y = %d\n", momentsPointCenter.x, momentsPointCenter.y);

circle(matDrawRect, momentsPointCenter, 5, Scalar(128, 0, 0), -1);
imshow("Contour(Largest) & Center", matDrawRect);
#endif


84_9.	findContour 함수의 hierarchy(계층) 설명
	>>> image, contour, hierarchy = cv2.findContour(src, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

	Contour Hierarchy
	Contour를 찾다보면 각각 독립적으로 Contour가 존해하는 경우도 있고 Contour 내부에 Contour가 존해하는 경우도 있습니다.
	각각 동일한 레벨에서 Contour가 존재하는 경우 같은 계측에 존해한다고 하며
	Contour 내부에 또다른 Contour가 존재하는 경우, Contour를 포함하고 있는 Contour를 부모계층
	어떤 Contour안에 들어가 있는 Contour를 자식계층이라 합니다.


	4
	------------
	
	1
	-------------------------
	|	2					|
	|	-----------------	|
	|	|				|	|
	|	|	3			|	|
	|	|	---------	|	|
	|	|	|		|	|	|
	|	|	---------	|	|
	|	|				|	|
	|	-----------------	|
	|						|
	-------------------------

	1번 도형의 Contour는 바깥쪽 1개, 안쪽 1개	(각각 Contour1-out, Contour1-in)
	2번 도형의 Contour는 바깥쪽 1개, 안쪽 1개	(각각 Contour2-out, Contour2-in)
	3번 도형의 Contour는 1개					(Contour3)
	4번 도형의 Contour는 1개					(Contour4)
	
	cv2.findContours() 함수의 hierarchy 리턴값은 Contour들 간의 관계를 나타내며 아래와 같이 구성되어 있음
	[Next, Previous, First Child, Parent]
	Next:		동일레벨의 다음 Contour 인덱스. 동일레벨의 다음 Contour가 없으면 -1
	Previous:	동일레벨의 이전 Contour 인덱스. 동일레벨의 이전 Contour가 없으면 -1
	First Child:	최초의 자식 Contour 인덱스. 자식 Contour가 없으면 -1
	Parent:					부모Contour 인덱스. 부모 Contour가 없으면 -1
	
	Contour 2번째 인자
	cv2.RETR_LIST
	cv2.RETR_TREE
	cv2.RETR_EXTERNAL
	cv2.RETR_CCOMP
	
	주로 사용하는
	cv2.RETR_LIST는 이미지에서 발견한 모든 Contour들을 계층에 상관하지 말고 나열하는 것이고
	cv2.RETR_TREE는 이미지에서 발견한 모든 Contour들을 계층의 관계를 명확히 해서 리턴하는 인자임
	
	아래 결과값은 위에서 서술한 Contour1-out, Contour1-in, Contour2-out, Contour2-in, Contour3, Contour4 순서대로 임
	cv2.RETR_LIST인 경우 상기 도형의 hierarchy는
	hierarchy =[[[  1 -1 -1 -1]
				 [  2  0 -1 -1]
				 [  3  1 -1 -1]
				 [  4  2 -1 -1]
				 [  5  3 -1 -1]
				 [ -1  4 -1 -1]]]
	cv2.RETR_TREE인 경우 상기 도형의 hierarchy는
	hierarchy =[[[  5 -1  1 -1]
				 [ -1 -1  2  0]
				 [ -1 -1  3  1]
				 [ -1 -1  4  2]
				 [ -1 -1 -1  3]
				 [ -1  0 -1 -1]]]

	cf)	findContours 사용시 에러 발생 -> 아래와 같이 수정하면 에러 없어짐
		#image, contours, hierarchy = cv2.findContours(gray, mode, method)
		contours, hierarchy = cv2.findContours(gray, mode, method)


84_10. HoughLinesP
		HoughLinesP(matDrawRect,	// Input
				v_lines,		// Output
				1,				// rho, 원점으로부터의 거리의 간격
				CV_PI / 180/*(== 1)*/, // theta, x축과의 라디안 각도
				100,				// threshold, 직선을 검출하기 위한 accumulator의 임게값
				10,				// minLineLength, 검출한 직선의 최소 길이
				5);				// maxLineGap, 직선 위에서 에지점들의 최대 허용 간격
	
  v_Lines 예제
  v_Lines[0]
  
            |
  
  
  
  |
  v_Lines[1]
  
            |
  
  
  
  |         |
  v_Lines[2]
      -------
            |
  
  
  
  |         |

84_11. OpenCV / MFC 구동 시 0xC0000005에러 발생(~ 위치를 읽는 동안 엑세스 위반이 발생했습니다.)
    본, 에러는 Program source 자체의 문제로 발생한 것이 아닌
    Windows OS 자체가 꼬여서 발생한 것으로 보임
    ->  이유, Windows 10을 Format하고서 Windows 10을 새로 깔고 Visual studio를 새로 깔고서
        실행하니 본 에러 발생하지 않음

84_12.	adaptiveThreshold
	cf)	이전 Section에서의 결과를 보면 한가지 문제점이 있습니다. 임계값을 이미지 전체에 적용하여 처리하기 때문에 하나의 이미지에 음영이 다르면 일부 영역이 모두 흰색 또는 검정색으로 보여지게 됩니다.
		이런 문제를 해결하기 위해서 이미지의 작은 영역별로 thresholding을 하는 것입니다. 이때 사용하는 함수가 cv2.adaptiveThreshold() 입니다.
	-	기존 threshold의 경우 기준값 보다 작으면 흑 기준값 보다 크면 백 등 너무 기준값에 의해서 백/흑이 확연하게 갈리기 때문에 threshold 이후 이미지가 백과 흑 부분이 확연하게 구분되는 문제 있음
	-	adaptiveThreshold의 경우 이를 보완해서 작은 영역별로 ex)평균값에 대한 threshold 등을 거쳐서 보다 세밀하게 흑/백을 분리시켜 줌	*/

	cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)
	Parameters:
	-	src ? grayscale image
	-	maxValue ? 임계값
	-	adaptiveMethod ? thresholding value를 결정하는 계산 방법
	-	thresholdType ? threshold type
	-	blockSize ? thresholding을 적용할 영역 사이즈
	-	C ? 평균이나 가중평균에서 차감할 값
	
	@brief Applies an adaptive threshold to an array.

	The function transforms a grayscale image to a binary image according to the formulae:
	-   **THRESH_BINARY**
		\f[dst(x,y) =  \fork{\texttt{maxValue}}{if \(src(x,y) > T(x,y)\)}{0}{otherwise}\f]
	-   **THRESH_BINARY_INV**
		\f[dst(x,y) =  \fork{0}{if \(src(x,y) > T(x,y)\)}{\texttt{maxValue}}{otherwise}\f]
	where \f$T(x,y)\f$ is a threshold calculated individually for each pixel (see adaptiveMethod parameter).

	The function can process the image in-place.

	@param src Source 8-bit single-channel image.
	@param dst Destination image of the same size and the same type as src.
	@param maxValue Non-zero value assigned to the pixels for which the condition is satisfied
	@param adaptiveMethod Adaptive thresholding algorithm to use, see cv::AdaptiveThresholdTypes
	@param thresholdType Thresholding type that must be either THRESH_BINARY or THRESH_BINARY_INV,
	see cv::ThresholdTypes.
	@param blockSize Size of a pixel neighborhood that is used to calculate a threshold value for the
	pixel: 3, 5, 7, and so on.
	@param C Constant subtracted from the mean or weighted mean (see the details below). Normally, it
	is positive but may be zero or negative as well.

	@sa  threshold, blur, GaussianBlur
 
 	void adaptiveThreshold(InputArray src, OutputArray dst,
							double maxValue, int adaptiveMethod,
							int thresholdType, int blockSize, double C);

84_12_1.morphologyEx
고급예제)
Mat  preprocessing2(Mat image)
{
	Mat gray, th_img;
	double sigma = 1.4;

	GaussianBlur(image, gray, Size(5, 5), sigma, sigma);				// 블러링(blur 처리 하는 것이 최종 Noise가 적은 th_img 를 만들어줌)
	// temp
//	imshow("GaussianBlur", gray);
	// temp

	#if true
	/**
	cv2.MORPH_RECT : 직사각형 모양으로 매트릭스를 생성
	cv2.MORPH_ELLIPSE : 타원 모양으로 매트릭스를 생성
	cv2.MORPH_CROSS : 십자 모양으로 매트릭스를 생성
	중요)	문자를 morphologyEx 하는 경우 getStructuringElement(MORPH_ELLIPSE, ~ 를 사용하자
	이유)	getStructuringElement(MORPH_RECT, ~ 설정 보다 getStructuringElement(MORPH_ELLIPSE, ~ 설정이
			morphologyEx(~, MORPH_OPEN, ~ 처리 시 검정색 글자의 끊어짐 현상을 더 많이 제거시켜 줌(끊어져 있던 검정색 글자가 더 많이 이어짐)	*/
	Mat kernel = getStructuringElement(MORPH_ELLIPSE, cv::Size(2, 2));
	Mat kernel2 = getStructuringElement(MORPH_ELLIPSE, cv::Size(3, 3));
	Mat kernel3 = getStructuringElement(MORPH_ELLIPSE, cv::Size(4, 4));

	/** @brief Performs advanced morphological transformations.
	@param src Source image. The number of channels can be arbitrary. The depth should be one of
	CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
	@param dst Destination image of the same size and type as source image.
	@param op Type of a morphological operation, see #MorphTypes
	@param kernel Structuring element. It can be created using #getStructuringElement.
	@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
	kernel center.
	@param iterations Number of times erosion and dilation are applied.
	@param borderType Pixel extrapolation method, see #BorderTypes
	@param borderValue Border value in case of a constant border. The default value has a special
	meaning.
	@sa  dilate, erode, getStructuringElement
	@note The number of iterations is the number of times erosion or dilatation operation will be applied.
	For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
	successively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).

	cv2.MORPH_OPEN : Opening을 수행
	cv2.MORPH_CLOSE : Closing을 수행
	cv2.MORPH_GRADIENT : Dilation 이미지와 Erosion 이미지의 차이를 나타냄
	cv2.MORPH_TOPHAT : 원본 이미지와 opening한 이미지의 차이를 나타냄
	cv2.MORPH_BLACKHAT : closing한 이미지와 원본 이미지의 차이를 나타냄	*/
	morphologyEx(gray, gray, MORPH_CLOSE, kernel2, cv::Point(-1, -1), 2);
//	imshow("gray_morph_close", gray);
	#endif

//	threshold(gray, th_img, 32, 255, THRESH_BINARY | THRESH_OTSU);
	/*	adaptiveThreshold
		cf)	이전 Section에서의 결과를 보면 한가지 문제점이 있습니다. 임계값을 이미지 전체에 적용하여 처리하기 때문에 하나의 이미지에 음영이 다르면 일부 영역이 모두 흰색 또는 검정색으로 보여지게 됩니다.
			이런 문제를 해결하기 위해서 이미지의 작은 영역별로 thresholding을 하는 것입니다. 이때 사용하는 함수가 cv2.adaptiveThreshold() 입니다.
			-	기존 threshold의 경우 기준값 보다 작으면 흑 기준값 보다 크면 백 등 너무 기준값에 의해서 백/흑이 확연하게 갈리기 때문에 threshold 이후 이미지가 백과 흑 부분이 확연하게 구분되는 문제 있음
			-	adaptiveThreshold의 경우 이를 보완해서 작은 영역별로 ex)평균값에 대한 threshold 등을 거쳐서 보다 세밀하게 흑/백을 분리시켜 줌

			cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)
			Parameters:
			-	src ? grayscale image
			-	maxValue ? 임계값
			-	adaptiveMethod ? thresholding value를 결정하는 계산 방법
			-	thresholdType ? threshold type
			-	blockSize ? thresholding을 적용할 영역 사이즈
			-	C ? 평균이나 가중평균에서 차감할 값	*/
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 17, 3);
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 19, 5);	// OCR이미지에서 문자를 가장 Noise 없이 이진화 시켜주는 Setting(ex) M 문자 중간이 끊기게 이진화 시켜 주는 Setting)
	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 25, 5);	// OCR이미지에서 문자를 가장 Noise 없이 이진화 시켜주고 특히 ex) M 문자 등을 끊기지 않게 이진화 시켜 주는 Setting
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 25, 3);	// OCR이미지에서 문자를 가장 Noise 없이 이진화 시켜주고 특히 ex) M / W 문자 등을 끊기지 않게 이진화 시켜 주는 Setting, 단 배경Noise 상당히 많음

	Mat img_morph_close, img_morph_close_open;

	morphologyEx(th_img, img_morph_close, MORPH_CLOSE, kernel2, cv::Point(-1, -1), 2);
	morphologyEx(img_morph_close, img_morph_close_open, MORPH_OPEN, kernel2, cv::Point(-1, -1), 4);

	// temp
//	imshow("th_img", th_img);
//	imshow("img_morph_close", img_morph_close);
//	imshow("img_morph_close_open", img_morph_close_open);
	// temp

	return img_morph_close_open;
}

84_13.	matchTemplate
int main()
{
    cv::Mat input = cv::imread("../inputData/TemplateMatch.jpg");

    cv::Mat gray;
    cv::cvtColor(input,gray,CV_BGR2GRAY);

    cv::Mat templ = cv::imread("../inputData/Template2.jpg");

    cv::Mat img = input;
    cv::Mat result;
    /// Create the result matrix
    int result_cols =  img.cols - templ.cols + 1;
    int result_rows = img.rows - templ.rows + 1;

    result.create( result_cols, result_rows, CV_32FC1 );

    int match_method = CV_TM_SQDIFF;

    /// Do the Matching and Normalize
    matchTemplate( img, templ, result, match_method  );
    normalize( result, result, 0, 1, cv::NORM_MINMAX, -1, cv::Mat() );

    /// Localizing the best match with minMaxLoc
    double minVal; double maxVal; cv::Point minLoc; cv::Point maxLoc;
    cv::Point matchLoc;

    minMaxLoc( result, &minVal, &maxVal, &minLoc, &maxLoc, cv::Mat() );

    /// For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better
    if( match_method  == CV_TM_SQDIFF || match_method == CV_TM_SQDIFF_NORMED )
    { matchLoc = minLoc; }
    else
    { matchLoc = maxLoc; }

    /// Show me what you got
    cv::rectangle( input, matchLoc, cv::Point( matchLoc.x + templ.cols , matchLoc.y + templ.rows ), cv::Scalar::all(0), 2, 8, 0 );
    cv::rectangle( result, matchLoc, cv::Point( matchLoc.x + templ.cols , matchLoc.y + templ.rows ), cv::Scalar::all(0), 2, 8, 0 );


    cv::imshow("input", input);
    cv::imshow("template", templ);

    cv::imwrite("../outputData/TemplateMatch.jpg", input);
    cv::waitKey(0);
    return 0;
}

#include <iostream>
#pragma warning (disable:4996)
#include <cv.h>
#include <opencv.hpp>
#include <highgui.h>

using namespace cv;

int main()
{
    Mat img1 = imread("big.jpg");
    Mat img2 = imread("small.jpg");
    Mat img3(img1.rows,img1.cols,CV_8UC1);
 
    double minValue,maxValue;
    Point2i minloc;

    matchTemplate(img1,img2,img3,CV_TM_CCOEFF_NORMED);
    minMaxLoc(img3,&minValue, &maxValue, NULL, &minloc);
    rectangle(img1,minloc,Point(minloc.x + img2.cols, minloc.y + img2.rows),Scalar(255,0,0));
 
    imshow("result", img1);
    imshow("sample", img2);
    imshow("C", img3);

    waitKey(0);

    return 0;
}
출처: https://wldus2081.tistory.com/64 [블로그]

84_14.	두 사진의 유사도 비교하기
cf)	SIFT를 이용하면 일부 틀리게 매칭되는 부분이 있음
	SIFT 보다는 ORB가 더 정확하게 매칭해줌
	http://blog.naver.com/PostView.nhn?blogId=samsjang&logNo=220657424078&parentCategoryNo=&categoryNo=66&viewDate=&isShowPopularPosts=false&from=postView
	https://blog.naver.com/alsrb968/220914598675


1)	그러면 이제, 이번 글의 목적인 두 사진의 유사도를 검사하는 코드를 작성해보도록 하겠습니다.
opencv 모듈을 설치하면 /node_modules/opencv/examples 폴더가 생성됩니다.
이 폴더에는 openCV를 활용할 수 있는 많은 예제 코드가 존재합니다.

그 중에서 dissimilarity.js 파일을 보시면, 두 사진의 유사도를 검사하는 코드가 있는데, 단 한 줄입니다.
사용 방법은 ImageSimilarity( ) 메서드를 호출할 때, 비교할 두 사진을 인자로 전달하면 됩니다.

이를 참고해서 결과를 직접 확인해보도록 하겠습니다.
위에서 작성한 /routes/index.js를 수정하도록 하겠습니다.
 
router.get('/', function(req, res, next) {
  cv.readImage(__dirname + '/../public/img/img1.png', function (err, img1) {
    if (err) throw err;
 
    cv.readImage(__dirname + '/../public/img/img2.png", function(err, img2) {
      if (err) throw err;
 
      cv.ImageSimilarity(img1, img2, function (err, dissimilarity) {
        if (err) throw err;
        console.log('Dissimilarity: ', dissimilarity);
      });
    });
  });
  res.render("index",{ title: "express"})
});
module.exports = router;

테스트를 하기 위해서는 img1.png 파일과 img2.png 파일이 public/img 폴더에 존재해야 합니다.

그리고 두 사진의 크기는 꼭 일치할 필요는 없지만 어느 정도 비슷해야 합니다.
크기 차이가 심한 경우 에러가 발생하며, 유사도가 정확하지 않을 수도 있습니다.
저는 위의 두 사진을 비교하여 유사도를 검사하려 합니다.
바로 결과를 확인하기 위해 서버를 실행하고 브라우저에서 localhost:3000을 요청하면, 유사도가 95%임을 확인할 수 있습니다.
지금은 우연히 정수가 출력 되었는데 몇 번 테스트를 해본 결과 소수점 6자리까지 보여줬던 것 같습니다.
출처: https://victorydntmd.tistory.com/43 [victolee]

2) Check if two images are equal:
The code below is explained here: Check if two images are equal with Opencv and Python
 
import cv2
import numpy as np
 
original = cv2.imread("original_golden_bridge.jpg")
image_to_compare = cv2.imread("images/george-washington-bridge.jpg")
 
# 1) Check if 2 images are equals
if original.shape == image_to_compare.shape:
    print("The images have same size and channels")
    difference = cv2.subtract(original, image_to_compare)
    b, g, r = cv2.split(difference)
 
    if cv2.countNonZero(b) == 0 and cv2.countNonZero(g) == 0 and cv2.countNonZero(r) == 0:
        print("The images are completely Equal")
    else:
        print("The images are NOT equal")

3)
import cv2
import numpy as np
 
original = cv2.imread("original_golden_bridge.jpg")
image_to_compare = cv2.imread("images/different-golden-gate-bridge.jpg")
 
 
# 1) Check if 2 images are equals
if original.shape == image_to_compare.shape:
    print("The images have same size and channels")
    difference = cv2.subtract(original, image_to_compare)
    b, g, r = cv2.split(difference)
 
    if cv2.countNonZero(b) == 0 and cv2.countNonZero(g) == 0 and cv2.countNonZero(r) == 0:
        print("The images are completely Equal")
    else:
        print("The images are NOT equal")
 
# 2) Check for similarities between the 2 images
sift = cv2.xfeatures2d.SIFT_create()
kp_1, desc_1 = sift.detectAndCompute(original, None)
kp_2, desc_2 = sift.detectAndCompute(image_to_compare, None)
 
index_params = dict(algorithm=0, trees=5)
search_params = dict()
flann = cv2.FlannBasedMatcher(index_params, search_params)
 
matches = flann.knnMatch(desc_1, desc_2, k=2)
 
good_points = []
for m, n in matches:
    if m.distance < 0.6*n.distance:
        good_points.append(m)
 
# Define how similar they are
number_keypoints = 0
if len(kp_1) <= len(kp_2):
    number_keypoints = len(kp_1)
else:
    number_keypoints = len(kp_2)
 
 
print("Keypoints 1ST Image: " + str(len(kp_1)))
print("Keypoints 2ND Image: " + str(len(kp_2)))
print("GOOD Matches:", len(good_points))
print("How good it's the match: ", len(good_points) / number_keypoints * 100)
 
result = cv2.drawMatches(original, kp_1, image_to_compare, kp_2, good_points, None)
 
 
cv2.imshow("result", cv2.resize(result, None, fx=0.4, fy=0.4))
cv2.imwrite("feature_matching.jpg", result)
 
 
cv2.imshow("Original", cv2.resize(original, None, fx=0.4, fy=0.4))
cv2.imshow("Duplicate", cv2.resize(image_to_compare, None, fx=0.4, fy=0.4))
cv2.waitKey(0)
cv2.destroyAllWindows()

4)
#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <iostream>

using namespace std;
using namespace cv;

// quality-metric
namespace qm
{
	#define C1 (float) (0.01 * 255 * 0.01  * 255)
	#define C2 (float) (0.03 * 255 * 0.03  * 255)


	// sigma on block_size
	double sigma(Mat & m, int i, int j, int block_size)
	{
		double sd = 0;

		Mat m_tmp = m(Range(i, i + block_size), Range(j, j + block_size));
		Mat m_squared(block_size, block_size, CV_64F);

		multiply(m_tmp, m_tmp, m_squared);

		// E(x)
		double avg = mean(m_tmp)[0];
		// E(x²)
		double avg_2 = mean(m_squared)[0];


		sd = sqrt(avg_2 - avg * avg);

		return sd;
	}

	// Covariance
	double cov(Mat & m1, Mat & m2, int i, int j, int block_size)
	{
		Mat m3 = Mat::zeros(block_size, block_size, m1.depth());
		Mat m1_tmp = m1(Range(i, i + block_size), Range(j, j + block_size));
		Mat m2_tmp = m2(Range(i, i + block_size), Range(j, j + block_size));


		multiply(m1_tmp, m2_tmp, m3);

		double avg_ro 	= mean(m3)[0]; // E(XY)
		double avg_r 	= mean(m1_tmp)[0]; // E(X)
		double avg_o 	= mean(m2_tmp)[0]; // E(Y)


		double sd_ro = avg_ro - avg_o * avg_r; // E(XY) - E(X)E(Y)

		return sd_ro;
	}

	// Mean squared error
	double eqm(Mat & img1, Mat & img2)
	{
		int i, j;
		double eqm = 0;
		int height = img1.rows;
		int width = img1.cols;

		for (i = 0; i < height; i++)
			for (j = 0; j < width; j++)
				eqm += (img1.at<double>(i, j) - img2.at<double>(i, j)) * (img1.at<double>(i, j) - img2.at<double>(i, j));

		eqm /= height * width;

		return eqm;
	}



	/**
	 *	Compute the PSNR between 2 images
	 */
	double psnr(Mat & img_src, Mat & img_compressed, int block_size)
	{
		int D = 255;
		return (10 * log10((D*D)/eqm(img_src, img_compressed)));
	}


	/**
	 * Compute the SSIM between 2 images
	 */
	double ssim(Mat & img_src, Mat & img_compressed, int block_size, bool show_progress = false)
	{
		double ssim = 0;

		int nbBlockPerHeight 	= img_src.rows / block_size;
		int nbBlockPerWidth 	= img_src.cols / block_size;

		for (int k = 0; k < nbBlockPerHeight; k++)
		{
			for (int l = 0; l < nbBlockPerWidth; l++)
			{
				int m = k * block_size;
				int n = l * block_size;

				double avg_o 	= mean(img_src(Range(k, k + block_size), Range(l, l + block_size)))[0];
				double avg_r 	= mean(img_compressed(Range(k, k + block_size), Range(l, l + block_size)))[0];
				double sigma_o 	= sigma(img_src, m, n, block_size);
				double sigma_r 	= sigma(img_compressed, m, n, block_size);
				double sigma_ro	= cov(img_src, img_compressed, m, n, block_size);

				ssim += ((2 * avg_o * avg_r + C1) * (2 * sigma_ro + C2)) / ((avg_o * avg_o + avg_r * avg_r + C1) * (sigma_o * sigma_o + sigma_r * sigma_r + C2));
				
			}
			// Progress
			if (show_progress)
				cout << "\r>>SSIM [" << (int) ((( (double)k) / nbBlockPerHeight) * 100) << "%]";
		}
		ssim /= nbBlockPerHeight * nbBlockPerWidth;

		if (show_progress)
		{
			cout << "\r>>SSIM [100%]" << endl;
			cout << "SSIM : " << ssim << endl;
		}

		return ssim;
	}

	void compute_quality_metrics(char * file1, char * file2, int block_size)
	{

		Mat img_src;
		Mat img_compressed;

		// Loading pictures
		img_src = imread(file1, CV_LOAD_IMAGE_GRAYSCALE);
		img_compressed = imread(file2, CV_LOAD_IMAGE_GRAYSCALE);


		img_src.convertTo(img_src, CV_64F);
		img_compressed.convertTo(img_compressed, CV_64F);

		int height_o = img_src.rows;
		int height_r = img_compressed.rows;
		int width_o = img_src.cols;
		int width_r = img_compressed.cols;

		// Check pictures size
		if (height_o != height_r || width_o != width_r)
		{
			cout << "Images must have the same dimensions" << endl;
			return;
		}

		// Check if the block size is a multiple of height / width
		if (height_o % block_size != 0 || width_o % block_size != 0)
		{
			cout 	<< "WARNING : Image WIDTH and HEIGHT should be divisible by BLOCK_SIZE for the maximum accuracy" << endl
					<< "HEIGHT : " 		<< height_o 	<< endl
					<< "WIDTH : " 		<< width_o	<< endl
					<< "BLOCK_SIZE : " 	<< block_size 	<< endl
					<< endl;
		}

		double ssim_val = ssim(img_src, img_compressed, block_size);
		double psnr_val = psnr(img_src, img_compressed, block_size);

		cout << "SSIM : " << ssim_val << endl;
		cout << "PSNR : " << psnr_val << endl;
	}
}

5)
/**
 * @file SURF_FlannMatcher
 * @brief SURF detector + descriptor + FLANN Matcher
 * @author A. Huaman
 */

#include "opencv2/opencv_modules.hpp"
#include <stdio.h>

#ifndef HAVE_OPENCV_NONFREE

int main(int, char**)
{
    printf("The sample requires nonfree module that is not available in your OpenCV distribution.\n");
    return -1;
}

#else

# include "opencv2/core/core.hpp"
# include "opencv2/features2d/features2d.hpp"
# include "opencv2/highgui/highgui.hpp"
# include "opencv2/nonfree/features2d.hpp"

using namespace cv;

void readme();

/**
 * @function main
 * @brief Main function
 */
int main( int argc, char** argv )
{
  if( argc != 3 )
  { readme(); return -1; }

  Mat img_1 = imread( argv[1], CV_LOAD_IMAGE_GRAYSCALE );
  Mat img_2 = imread( argv[2], CV_LOAD_IMAGE_GRAYSCALE );

  if( !img_1.data || !img_2.data )
  { printf(" --(!) Error reading images \n"); return -1; }

  //-- Step 1: Detect the keypoints using SURF Detector
  int minHessian = 400;

  SurfFeatureDetector detector( minHessian );

  std::vector<KeyPoint> keypoints_1, keypoints_2;

  detector.detect( img_1, keypoints_1 );
  detector.detect( img_2, keypoints_2 );

  //-- Step 2: Calculate descriptors (feature vectors)
  SurfDescriptorExtractor extractor;

  Mat descriptors_1, descriptors_2;

  extractor.compute( img_1, keypoints_1, descriptors_1 );
  extractor.compute( img_2, keypoints_2, descriptors_2 );

  //-- Step 3: Matching descriptor vectors using FLANN matcher
  FlannBasedMatcher matcher;
  std::vector< DMatch > matches;
  matcher.match( descriptors_1, descriptors_2, matches );

  double max_dist = 0; double min_dist = 100;

  //-- Quick calculation of max and min distances between keypoints
  for( int i = 0; i < descriptors_1.rows; i++ )
  { double dist = matches[i].distance;
    if( dist < min_dist ) min_dist = dist;
    if( dist > max_dist ) max_dist = dist;
  }

  printf("-- Max dist : %f \n", max_dist );
  printf("-- Min dist : %f \n", min_dist );

  //-- Draw only "good" matches (i.e. whose distance is less than 2*min_dist,
  //-- or a small arbitary value ( 0.02 ) in the event that min_dist is very
  //-- small)
  //-- PS.- radiusMatch can also be used here.
  std::vector< DMatch > good_matches;

  for( int i = 0; i < descriptors_1.rows; i++ )
  { if( matches[i].distance <= max(2*min_dist, 0.02) )
    { good_matches.push_back( matches[i]); }
  }

  //-- Draw only "good" matches
  Mat img_matches;
  drawMatches( img_1, keypoints_1, img_2, keypoints_2,
               good_matches, img_matches, Scalar::all(-1), Scalar::all(-1),
               vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );

  //-- Show detected matches
  imshow( "Good Matches", img_matches );

  for( int i = 0; i < (int)good_matches.size(); i++ )
  { printf( "-- Good Match [%d] Keypoint 1: %d  -- Keypoint 2: %d  \n", i, good_matches[i].queryIdx, good_matches[i].trainIdx ); }

  waitKey(0);

  return 0;
}

/**
 * @function readme
 */
void readme()
{ printf(" Usage: ./SURF_FlannMatcher <img1> <img2>\n"); }

#endif

6)
#include <iostream>
#include "opencv2/core.hpp"
#ifdef HAVE_OPENCV_XFEATURES2D
#include "opencv2/highgui.hpp"
#include "opencv2/features2d.hpp"
#include "opencv2/xfeatures2d.hpp"

using namespace cv;
using namespace cv::xfeatures2d;
using std::cout;
using std::endl;

const char* keys =
    "{ help h |                          | Print help message. }"
    "{ input1 | ../data/box.png          | Path to input image 1. }"
    "{ input2 | ../data/box_in_scene.png | Path to input image 2. }";

int main( int argc, char* argv[] )
{
    CommandLineParser parser( argc, argv, keys );
    Mat img1 = imread( parser.get<String>("input1"), IMREAD_GRAYSCALE );
    Mat img2 = imread( parser.get<String>("input2"), IMREAD_GRAYSCALE );
    if ( img1.empty() || img2.empty() )
    {
        cout << "Could not open or find the image!\n" << endl;
        parser.printMessage();
        return -1;
    }

    //-- Step 1: Detect the keypoints using SURF Detector, compute the descriptors
    int minHessian = 400;
    Ptr<SURF> detector = SURF::create( minHessian );
    std::vector<KeyPoint> keypoints1, keypoints2;
    Mat descriptors1, descriptors2;
    detector->detectAndCompute( img1, noArray(), keypoints1, descriptors1 );
    detector->detectAndCompute( img2, noArray(), keypoints2, descriptors2 );

    //-- Step 2: Matching descriptor vectors with a FLANN based matcher
    // Since SURF is a floating-point descriptor NORM_L2 is used
    Ptr<DescriptorMatcher> matcher = DescriptorMatcher::create(DescriptorMatcher::FLANNBASED);
    std::vector< std::vector<DMatch> > knn_matches;
    matcher->knnMatch( descriptors1, descriptors2, knn_matches, 2 );

    //-- Filter matches using the Lowe's ratio test
    const float ratio_thresh = 0.7f;
    std::vector<DMatch> good_matches;
    for (size_t i = 0; i < knn_matches.size(); i++)
    {
        if (knn_matches[i][0].distance < ratio_thresh * knn_matches[i][1].distance)
        {
            good_matches.push_back(knn_matches[i][0]);
        }
    }

    //-- Draw matches
    Mat img_matches;
    drawMatches( img1, keypoints1, img2, keypoints2, good_matches, img_matches, Scalar::all(-1),
                 Scalar::all(-1), std::vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );

    //-- Show detected matches
    imshow("Good Matches", img_matches );

    waitKey();
    return 0;
}
#else
int main()
{
    std::cout << "This tutorial code needs the xfeatures2d contrib module to be run." << std::endl;
    return 0;
}
#endif

7)
# 0419.py
import cv2
import numpy as np

src1 = cv2.imread('./data/lena.jpg', cv2.IMREAD_GRAYSCALE)
src2 = np.zeros(shape=(512,512), dtype=np.uint8)+255

#dst1 = 255 - src1
#dst2 = cv2.subtract(src2, src1)
#dst3 = cv2.compare(dst1, dst2, cv2.CMP_NE) # cv2.CMP_EQ
#CV_CMP_EQ: Equal Value
#CV_CMP_GT: Greater Than
#CV_CMP_GE: Greater or Equal
#CV_CMP_LT: Lower Than
#CV_CMP_LE: Lower or Equal
#CV_CMP_NE: Not Equal
# temp
dst1 = cv2.imread('./data/genuine.jpg', cv2.IMREAD_GRAYSCALE)
dst2 = cv2.imread('./data/fake.jpg', cv2.IMREAD_GRAYSCALE)
dst3 = cv2.compare(dst1, dst2, cv2.CMP_NE) # cv2.CMP_EQ
# temp
n    = cv2.countNonZero(dst3)
print('n = ', n)

cv2.imshow('dst1',  dst1)
cv2.imshow('dst2',  dst2)
# add
cv2.imshow('dst3', dst3)
# add
cv2.waitKey()    
cv2.destroyAllWindows()

84_15.	자르기 (Slice)
1 영상이나 이미지의 크기를 원하는 크기로 자를 수 있습니다.
Main Code (1)
import cv2

src = cv2.imread("Image/pawns.jpg", cv2.IMREAD_COLOR)

dst = src.copy() 
dst = src[100:600, 200:700]

cv2.imshow("src", src)
cv2.imshow("dst", dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

-> Detailed Code
dst = src.copy() 
이미지는 numpy 형식과 동일합니다. 이미지를 복제할 때, dst=src로 사용할 경우, 원본에도 영향을 미칩니다.
그러므로, *.copy()를 이용하여 dst에 이미지를 복제합니다.

dst = src[100:600, 200:700]
dst 이미지에 src[높이(행), 너비(열)]에서 잘라낼 영역을 설정합니다. List형식과 동일합니다.

Main Code (2)
import cv2

src = cv2.imread("Image/pawns.jpg", cv2.IMREAD_COLOR)

dst = src.copy() 
roi = src[100:600, 200:700]
dst[0:500, 0:500] = roi

cv2.imshow("src", src)
cv2.imshow("dst", dst)
cv2.waitKey(0)
cv2.destroyAllWindows()

-> Detailed Code
dst = src.copy() 
이미지는 numpy 형식과 동일합니다. 이미지를 복제할 때, dst=src로 사용할 경우, 원본에도 영향을 미칩니다.
그러므로, *.copy()를 이용하여 dst에 이미지를 복제합니다.

roi = src[100:600, 200:700]
dst[0:500, 0:500] = roi
roi를 생성하여 src[높이(행), 너비(열)]에서 잘라낼 영역을 설정합니다. List형식과 동일합니다.
이후, dst[높이(행), 너비(열)] = roi를 이용하여 dst 이미지에 해당 영역을 붙여넣을 수 있습니다.

84_16.	빈공간(흰색/검정색) 이미지 만들기
from PIL import Image

im = Image.open("sample.jpg")
im.save("sample_bmp.bmp")
im.save("sample_png.png")
im.save("sample_gif.gif")

im2 = Image.new("RGB", (500,500), (200,200,200)) 
im3 = Image.new("RGB", (200,200)) 
im2.paste(im3, (20,20,220,220)) 
im2.save("paste_result.jpg") 

위의 예제는 회색 바탕의 500x500 px 사이즈 이미지와 검은색의 200x200 px 사이지의 이미지를 만든 것이다. 
첫번째 파라미터는 '모드'로 어떤 방식으로 색을 나타낼 것인지를 의미한다. 
두번째 파라미터는 가로와 세로 크기를 px 단위로 나타낸 것으로 튜플로 묶어줘야 한다.
세번째 파라미터는 바탕색을 지정하는 것으로 디폴트는 검은색으로 되어있다.
그 밑의 paste 함수는 이미지를 덧씌우는 함수로 im2에 im3를 덧씌우는 동작을 하게 된다. 
주의점은 두번째 파라미터에서 지정하는 '덧씌울 공간'의 값이 덧씌우는 이미지의 크기와 달라서는 안된다.

84_17.	에러 예외처리
try:
    matches = bf.match(des1,des2)
except cv2.error as e:
    print('error', e)
    exit()

84_18.	2016.12.12_Feature Detection  openframeworks   
복사 https://blog.naver.com/kjhye1004/220883389042  

* 소스 코드

#include "ofApp.h"
#include "opencv2/features2d/features2d.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/nonfree/features2d.hpp"

using namespace cv;
using namespace std;

ofImage image1;
ofVideoPlayer video;
Mat img_object, img_scene;
Mat img_matches;

void myFeatureDetector(Mat img_scene, Mat img_object){
    //-- 1.Detector를 이용하여 keypoint를 찾는다.
    int minHessian = 400;

    //SurfFeatureDetector detector( minHessian );
    OrbFeatureDetector detector( minHessian );

    vector<KeyPoint> keypoints_object, keypoints_scene;

    detector.detect( img_object, keypoints_object );
    detector.detect( img_scene, keypoints_scene );

    //-- 2.descriptors를 찾는다.
    //SurfDescriptorExtractor extractor;
    OrbDescriptorExtractor extractor;

    Mat descriptors_object, descriptors_scene;

    extractor.compute( img_object, keypoints_object, descriptors_object );
    extractor.compute( img_scene, keypoints_scene, descriptors_scene );

    //-- 3.keypoints와 descriptors를 BF 또는 FLANN matcher으로 매칭한다.
    //FlannBasedMatcher matcher;
    BFMatcher matcher(NORM_L2); //(NORM_HAMMING);
    vector< DMatch > matches;
    matcher.match( descriptors_object, descriptors_scene, matches );

    double max_dist = 0; double min_dist = 100;

    //-- 4.keypoint들 사이의 거리의 최소값과 최대값을 계산한다.
    for( int i = 0; i < descriptors_object.rows; i++ )
    { double dist = matches[i].distance;
        if( dist < min_dist ) min_dist = dist;
        if( dist > max_dist ) max_dist = dist;
    }

    printf("-- Max dist : %f \n", max_dist );
    printf("-- Min dist : %f \n", min_dist );

    //-- 5.결과값이 좋은 것만 그린다. (최소거리의 3배 이상보다 작은 거리의 것들만 그린다.)
    vector< DMatch > good_matches;

    for( int i = 0; i < descriptors_object.rows; i++ )
    { if( matches[i].distance < 3*min_dist )
    { good_matches.push_back( matches[i]); }
    }

    drawMatches( img_object, keypoints_object, img_scene, keypoints_scene,
                good_matches, img_matches, Scalar::all(-1), Scalar::all(-1),
                vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS );

    //-- 6.매칭이 잘된 것들로부터 키포인트를 구한다.
    vector<Point2f> obj;
    vector<Point2f> scene;

    for( int i = 0; i < good_matches.size(); i++ )
    {
        obj.push_back( keypoints_object[ good_matches[i].queryIdx ].pt );
        scene.push_back( keypoints_scene[ good_matches[i].trainIdx ].pt );
    }

    Mat H = findHomography( obj, scene, CV_RANSAC );

    //-- 7.동영상에서 검출될 책부분의 네 모서리를 찾는다.
    vector<Point2f> obj_corners(4);
    obj_corners[0] = cvPoint(0,0); obj_corners[1] = cvPoint( img_object.cols, 0 );
    obj_corners[2] = cvPoint( img_object.cols, img_object.rows ); obj_corners[3] = cvPoint( 0, img_object.rows );
    std::vector<Point2f> scene_corners(4);

    perspectiveTransform( obj_corners, scene_corners, H);

    //-- 8.책의 네 모서리끼리 선을 그어 사각형을 그린다.
    line( img_matches, scene_corners[0] + Point2f( img_object.cols, 0), scene_corners[1] + Point2f( img_object.cols, 0), Scalar(0, 255, 0), 4 );
    line( img_matches, scene_corners[1] + Point2f( img_object.cols, 0), scene_corners[2] + Point2f( img_object.cols, 0), Scalar( 0, 255, 0), 4 );
    line( img_matches, scene_corners[2] + Point2f( img_object.cols, 0), scene_corners[3] + Point2f( img_object.cols, 0), Scalar( 0, 255, 0), 4 );
    line( img_matches, scene_corners[3] + Point2f( img_object.cols, 0), scene_corners[0] + Point2f( img_object.cols, 0), Scalar( 0, 255, 0), 4 );
    
    //-- 9.결과물 출력
    imshow( "Good Matches & Object detection", img_matches );
}

void ofApp::setup(){
    /* camera setup */
//    vidGrabber.setDeviceID(0);
//    vidGrabber.setDesiredFrameRate(60);
//    vidGrabber.initGrabber(camWidth, camHeight);
//    videoInverted.allocate(camWidth, camHeight, OF_PIXELS_RGB);
//    videoTexture.allocate(videoInverted);
//    ofSetVerticalSync(true);

    image1.load("/Applications/of_v0.9.3_osx_release/apps/myApps/16.12.9/bin/data/image.jpg"); //이미지 불러들이기
    img_object = Mat(image1.getHeight(), image1.getWidth(), CV_8UC3, image1.getPixels().getData()); //Mat에 이미지 저장
    cvtColor(img_object, img_object, CV_BGR2GRAY); //그레이스케일 이미지로 변환

/* video */
String OutputFile = "/Applications/of_v0.9.3_osx_release/apps/myApps/16.12.9/bin/data/save.mov";
VideoCapture vc("/Applications/of_v0.9.3_osx_release/apps/myApps/16.12.9/bin/data/video.mov");

    int w = vc.get(CV_CAP_PROP_FRAME_WIDTH);
    int h = vc.get(CV_CAP_PROP_FRAME_HEIGHT);
    int nr_superpixels = 100;
    int nc = 50;
    double step = sqrt((w * h) / (double) nr_superpixels);

    //-- 결과 비디오 저장
    float out_fps = vc.get(CV_CAP_PROP_FPS);
    int out_cols = w;
    int out_rows = h;
    Size2i out_frameSize(out_cols, out_rows);
    int out_codec = CV_FOURCC('m','p','4','v'); //mov format
    VideoWriter OutVideo(OutputFile, out_codec, out_fps, out_frameSize);
    
    Mat frame, lab_image;
    int nframe = vc.get(CV_CAP_PROP_FRAME_COUNT);
    vector<Mat> video;
    for(int k=0; k<nframe; k++)
    {
        vc.set(CV_CAP_PROP_POS_FRAMES, k);
        vc >> frame;
        myFeatureDetector(frame, img_object);
        //OutVideo << save; //결과 비디오 저장
        if(waitKey(5)==27)
        {
            break;
        }
    }
}

* Feature Detection
SURF와 ORB를 이용하여 이미지 특성 매칭을 하였다.
두 이미지에서 특성을 비교하여, 일정범위 내에서 동일하다고 생각되는 키포인트 부분을 선으로 연결하여 매칭시킨다.
image와 video 소스를 활용하여, 매칭의 변화되는 모습을 확인해볼 수 있도록 한다.
FLANN은 SURF와 같은 4-byte floating point 기반 descriptor에서만 사용할 수 있다.
BRIEF는 (바이트 단위로 재구성된) 바이너리 스트링이기 때문에 FLANN을 사용하는 것은 어렵다.
두 이미지의 특성을 비교하는 단순한 방법은 전수조사 방법으로 BF(Brute-Force)매칭이 있다.
이것은 만약 두 이미지 A,B가 있다고 한다면, 이미지A에서 하나의 특성 디스크립터를 취하고, 이 디스크립터를 이미지B의 모든 특성 디스크립터와 거리 계산 방법을 통해 하나하나 비교하고, 이렇게 해서 나온 값 중 가장 비슷한 값을 리턴하는 방식이다. opencv에서는 BFMatcher라는 메소드를 제공하는데, 여기서 설정하는 normType은 BF매칭에 사용할 거리 계산 방법을 지정한다. 보통 SIFT나 SURF는 NORM_L2를 사용하고, ORB,BRIEF는 NORM_HAMMING을 사용하는 것이 좋다고 한다. crossCheck는 두 이미지 양방향으로 디스크립터를 비교하는 방법이다.
결과적으로 FLANN Matcher보다 BF Matcher가 더욱 빠르고, 정확한 결과값을 출력하였다.

* 참고사이트
opencv feature detection 소스코드를 참고하였다.
http://docs.opencv.org/2.4/doc/tutorials/features2d/feature_homography/feature_homography.html

이미지 매칭 방법에 대한 세부속성을 참고하였다.
http://m.blog.naver.com/samsjang/220657424078

84_19.	실제 실무에 적용한 유사점 연산 소스
# 0913.py
import cv2
import numpy as np

# temp
GOOD_MATCH_LEVEL = 50
# temp

#1    
#src1 = cv2.imread('./data/book1.jpg') # 'cup1.jpg'
#src2 = cv2.imread('./data/book2.jpg') # 'cup2.jpg'
#img1= cv2.cvtColor(src1,cv2.COLOR_BGR2GRAY)
#img2= cv2.cvtColor(src2,cv2.COLOR_BGR2GRAY)
# temp
src1 = cv2.imread('./data/03180101_Origin.jpg') # 'cup1.jpg'
#src2 = cv2.imread('./data/03180101_Origin.jpg') # 'cup2.jpg'
#src2 = cv2.imread('./data/Fake_Fake5.jpg') # 'cup2.jpg'
#src2 = cv2.imread('./data/Fake_Genuine1.jpg') # 'cup2.jpg'
src2 = cv2.imread('./data/Genuine27.jpg') # 'cup2.jpg'
#src2 = np.zeros(shape = (720, 720, 3), dtype = np.uint8) + 255
#src2 = cv2.resize(src2, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_LINEAR)

if(True):              # 이미지 자르기 실행
    src1_slice = src1.copy()
    #src1_slice = src1[25:(720-25), 25:(720-25)]     # Trillcode 안쪽 영역 모두
    src1_slice = src1[500:(720-25), 25:220]        # 좌측/하단 일부분
    src1 = src1_slice

    src2_slice = src2.copy()
    #src2_slice = src2[25:(720-25), 25:(720-25)]
    src2_slice = src2[500:(720-25), 25:220]
    src2 = src2_slice
    
cv2.imshow('src1', src1)
cv2.imshow('src2', src2)
img1= cv2.cvtColor(src1,cv2.COLOR_BGR2GRAY)
img2= cv2.cvtColor(src2,cv2.COLOR_BGR2GRAY)
# temp

#2-1
orbF   = cv2.ORB_create(nfeatures=1000)
kp1, des1 = orbF.detectAndCompute(img1, None)
kp2, des2 = orbF.detectAndCompute(img2, None)

#2-2
##briskF = cv2.BRISK_create()
##kp1, des1 = briskF.detectAndCompute(img1, None)
##kp2, des2 = briskF.detectAndCompute(img2, None)

#3-1
#bf = cv2.BFMatcher_create(cv2.NORM_HAMMING, crossCheck=True)
#matches = bf.match(des1,des2)
# temp
#bf = cv2.BFMatcher_create(cv2.NORM_HAMMING, crossCheck=True)        # 비교 대상이 별로 유사하지 않은 경우에도 유사점을 찾아주기는 하지만 cv2.NORM_HAMMING2 보다 더 엉뚱한지점을 유사점으로 찾아줌(ex, Genuine27.jpg의 경우 len(good_matches) = 6)
bf = cv2.BFMatcher_create(cv2.NORM_HAMMING2, crossCheck=True)      # 비교 대상이 별로 유사하지 않은 경우에도 가장 나은 유사점을 찾아줌(ex, Genuine27.jpg의 경우 len(good_matches) = 9)
#bf = cv2.BFMatcher_create(cv2.NORM_L2, crossCheck=True)            # 비교 대상이 별로 유사하지 않은 경우 아예 유사점을 찾아주지 못함(ex, Genuine27.jpg의 경우 len(good_matches) = 0)
#bf = cv2.BFMatcher_create(cv2.NORM_L1, crossCheck=True)            # 비교 대상이 별로 유사하지 않은 경우 아예 유사점을 찾아주지 못함(ex, Genuine27.jpg의 경우 len(good_matches) = 0)
try:
    matches = bf.match(des1,des2)
except cv2.error as e:
    print('error', e)
    exit()
# temp
	
#3-2
#flan = cv2.FlannBasedMatcher_create() 
#matches = flan.match(np.float32(des1),np.float32(des2))

#4  
matches = sorted(matches, key = lambda m: m.distance)
print('len(matches)=', len(matches))

#for i, m in enumerate(matches[:3]):
#        print('matches[{}]=(queryIdx:{}, trainIdx:{}, distance:{})'.format(
#            i, m. queryIdx, m.trainIdx, m.distance))
# temp
iSum = 0
for i, m in enumerate(matches[:len(matches)]):
    iSum += m.distance
    if(i < 3):
        print('matches[{}]=(queryIdx:{}, trainIdx:{}, distance:{})'.format(
            i, m. queryIdx, m.trainIdx, m.distance))
# temp

# temp
iMin = min(matches, key = lambda m: m.distance)
iMax = max(matches, key = lambda m: m.distance)
iAvr = iSum/len(matches)
print('min=', iMin.distance)
print('max=', iMax.distance)
print('distance sum=', iSum)
print('distance average=', iAvr)
print('GOOD_MATCH_LEVEL', GOOD_MATCH_LEVEL)
# temp	
minDist = matches[0].distance       # 가장 가까운 거리가 들어감
#good_matches = list(filter(lambda m: m.distance<4*minDist, matches))
# temp
#if(iAvr == 0):
#    good_matches = list(filter(lambda m: m.distance<100, matches))
#else:
#    good_matches = list(filter(lambda m: m.distance<iAvr, matches))
good_matches = list(filter(lambda m: m.distance<GOOD_MATCH_LEVEL, matches))
# temp
print('len(good_matches)=', len(good_matches))
# temp
if len(good_matches) < 5:
    print('sorry, too small good matches')
    exit()
# temp
    
dst = cv2.drawMatches(img1,kp1,img2,kp2,good_matches, None, flags=2)
cv2.imshow('dst',  dst)

#5
src1_pts = np.float32([ kp1[m.queryIdx].pt for m in good_matches])
src2_pts = np.float32([ kp2[m.trainIdx].pt for m in good_matches])

H, mask = cv2.findHomography(src1_pts, src2_pts, cv2.RANSAC, 3.0)#cv2.LMEDS
mask_matches = mask.ravel().tolist() # list(mask.flatten())

#6
h,w = img1.shape
pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)
pts2 = cv2.perspectiveTransform(pts, H)
#src2 = cv2.polylines(src2,[np.int32(pts2)],True,(255,0, 0),2)
# temp
#src2 = cv2.polylines(src2_slice,[np.int32(pts2)],True,(0,0,255),2)
src2 = cv2.polylines(src2,[np.int32(pts2)],True,(0,0,255),2)
cv2.imshow('src2', src2)
# temp
        
draw_params=dict(matchColor = (0,255,0), singlePointColor = None,
                 matchesMask = mask_matches,  flags = 2)                 
dst2 = cv2.drawMatches(src1,kp1,src2,kp2, good_matches, None,**draw_params)  
# temp
#dst2 = cv2.drawMatches(src1_slice,kp1,src2_slice,kp2, good_matches, None,**draw_params)  
# temp
cv2.imshow('dst2',  dst2)
cv2.waitKey()
cv2.destroyAllWindows()

84_20.	C++ - OpenCV feature detection with ORB

// Initiate ORB detector
    Ptr<FeatureDetector> detector = ORB::create();

// find the keypoints and descriptors with ORB
    detector->detect(gray_image1, keypoints_object);
    detector->detect(gray_image2, keypoints_scene);

    Ptr<DescriptorExtractor> extractor = ORB::create();
    extractor->compute(gray_image1, keypoints_object, descriptors_object );
    extractor->compute(gray_image2, keypoints_scene, descriptors_scene );

// Flann needs the descriptors to be of type CV_32F
    descriptors_scene.convertTo(descriptors_scene, CV_32F);
    descriptors_object.convertTo(descriptors_object, CV_32F);

    FlannBasedMatcher matcher;
    vector<DMatch> matches;
    matcher.match( descriptors_object, descriptors_scene, matches );

    double max_dist = 0; double min_dist = 100;

    //-- Quick calculation of max and min distances between keypoints
    for( int i = 0; i < descriptors_object.rows; i++ )
    {
        double dist = matches[i].distance;
        if( dist < min_dist ) min_dist = dist;
        if( dist > max_dist ) max_dist = dist;
    }

    //-- Use only "good" matches (i.e. whose distance is less than 3*min_dist )
    vector< DMatch > good_matches;

    for( int i = 0; i < descriptors_object.rows; i++ )
    {
        if( matches[i].distance < 3*min_dist )
        {
            good_matches.push_back( matches[i]);
        }
    }


    vector< Point2f > obj;
    vector< Point2f > scene;


    for( int i = 0; i < good_matches.size(); i++ )
    {
        //-- Get the keypoints from the good matches
        obj.push_back( keypoints_object[ good_matches[i].queryIdx ].pt );
        scene.push_back( keypoints_scene[ good_matches[i].trainIdx ].pt );
    }

    // Find the Homography Matrix
    Mat H = findHomography( obj, scene, CV_RANSAC );
    // Use the Homography Matrix to warp the images
    cv::Mat result;
    warpPerspective(image1,result,H,Size(image1.cols+image2.cols,image1.rows));
    cv::Mat half(result,cv::Rect(0,0,image2.cols,image2.rows));
    image2.copyTo(half);
    imshow( "Result", result );

84_21.	C++ - OpenCV feature detection with ORB & BFMatcher
OrbFeatureDetector detector; //OrbFeatureDetector detector;SurfFeatureDetector
vector<KeyPoint> keypoints1;
detector.detect(im_edge1, keypoints1);
vector<KeyPoint> keypoints2;
detector.detect(im_edge2, keypoints2);

OrbDescriptorExtractor extractor; //OrbDescriptorExtractor extractor; SurfDescriptorExtractor extractor;
Mat descriptors_1, descriptors_2;
extractor.compute( im_edge1, keypoints1, descriptors_1 );
extractor.compute( im_edge2, keypoints2, descriptors_2 );

//-- Step 3: Matching descriptor vectors with a brute force matcher
BFMatcher matcher(NORM_L2, true);   //BFMatcher matcher(NORM_L2);

vector< DMatch> matches;
matcher.match(descriptors_1, descriptors_2, matches);


vector< DMatch > good_matches;
vector<Point2f> featurePoints1;
vector<Point2f> featurePoints2;
for(int i=0; i<int(matches.size()); i++){
    good_matches.push_back(matches[i]);
}

//-- Draw only "good" matches
Mat img_matches;
imwrite("img_matches_orb.bmp", img_matches);

84_22.OpenCV-관심영역(일부영역)-자르기-Crop-Region-Of-Interesting-ROI
#include <opencv\cv.h>
#include <opencv\highgui.h>

using namespace cv;
using namespace std;

int main(){
	// 이미지 불러오기 (read image).
	Mat image = imread("image.jpg");
	
	// 에러 처리 (error).
	if ( !image.data ) {
		return -1;
	}

	// 관심영역 설정 (set ROI (X, Y, W, H)).
	Rect rect(100, 30, 150, 300);

	// 관심영역 자르기 (Crop ROI).
	Mat subImage = image(rect);

	// show
	imshow("image", subImage);

	waitKey(0);
	return 0;
}

84_23.	Matching 실제 사용 소스
/*	Image process(Some & Group sample comparison)
	1.	Slice
//	2.	Bright compensation
	2.	신규WhiteBalance
	->	테스트 결과
		1)	기존WhiteBalance를 실행해도 이미지가 어두운 경우, 본 신규WhiteBalance를 실행하면 이미지 밝기 밝아지고 유사도 약간 높아짐(ex, good_matches.size() = 372 -> 384로 증가)
		2)	기존WhiteBalance를 실행해도 이미지가 밝아지는 경우 본 신규WhiteBalance를 실행한다고 해서 더 밝아지지는 않고 유사도도 향상 되지 않음(ex, good_matches.size() = 212 -> 212로 증가 없음)
//	4.	Contrast
//		계수를 아래와 같이 2.0 -> 1.5로 변경
//		cf)	Scalar avg = mean(imgSrc2_ch2_2) / 1.5;
//			Mat imgSrc2_ch3_2 = imgSrc2_ch2_2 * 1.5 - avg[0];
//
//	->	테스트 결과(상기 1. -> 2. -> 3. -> 4. 처리 결과)
//		ex1)	너무 밝고 포커스 잘 맞지 않은 이미지			-> 적정 밝기에 어느정도 비표 등의 미세 문자도 선명해 짐
//		ex2)	너무 어둡고 포커스 잘 맞지 않은 이미지			-> 적정 밝기에 어느정도 비표 등의 미세 문자도 선명해 짐
//
//	4.	Good match level
//		1)	기존 절대값(m_iGOOD_MATCH_DIST_LEVEL = GOOD_MATCH_DIST_LEVEL)에서
//		2)	상대값(=iMin * 4)으로 변경		->	본 방식은 Matching이 잘 맞는 이미지가 오히려 작은 Good match값이 나오는 문제가 발생 함(Matching이 잘 맞는 이미지 일 수록 iMin의 값이 작기 때문에 4배를 곱해준다고 해도 iMin * 4으로 Good match level을 잡으면 작은 Good match값이 나오게 됨)
//		2)	상대값(=iAvr*0.9)으로 변경		->	본 방식은 Matching이 잘 맞는 이미지가 오히려 작은 Good match값이 나오는 문제가 발생 함(상기 iMin * 4 보다는 Matching이 잘 맞는 이미지와 아닌 이미지를 잘 구별함, 하지만 기존 신규WhiteBalance + Bright compensation 보다 유사도 떨어짐)
//			cf)	정품일지라도 옵셋 인쇄 방식 특성 상, 별색/먹색간의 위치 편차가 발생할 수 있고 
//				이에 상대값으로 처리해야지만 먹색의 위치 편차로 인한 Good match 값의 영향을 최소화 할 수 있음				
//				이를 보정하기 위해 상대적 방식 적용 및 효과 분석 예정
//	5.	가산점이 더해진 유사도 총합을 가지고 최종 유사도 판정
//		Matching distance 값이 작을 수록(유사도 더 높음) 가산점 더 주며 본 각각에 가산점이 더해진 유사도 총 합을 가지고 최종 유사도 판정
//		ex)	기준값이 MATCH_DIST_LEVEL 인 경우 -> (GOOD_MATCH_DIST_LEVEL-각각의 매칭거리)x2 으로 각각의 가산점이 더해진 유사도를 구하며
//			최종 본 유사도값을 모두 더한 값으로 최종 유사도 판정
//			
//	cf)	일부영역비교(측정영역 : 전체영역 Y축으로 5등분으로 나눈 영역 중 제일 상단, 별색 구간)의 경우 Target 작은 문자 / 별색 색상이 밝을 수록 유사도가 작아지는 문제 있음


[최종결론, 2019년4월24일]
아래와 같은 설정이 가장 정품/가품을 잘 구별해 줌
1.	설정
	Origin image = 0318_Origin.jpg 사용

	Ptr<ORB> orbF = ORB::create(1000);

	//BFMatcher matcher(NORM_L1, true);
	//BFMatcher matcher(NORM_L2, true);
	//BFMatcher matcher(NORM_HAMMING, true);
	BFMatcher matcher(NORM_HAMMING2, true);

	#define GOOD_MATCH_DIST_LEVEL	50
	#define GOOD_MATCH_DIST_LEVEL2	50

	MFC 상에서 처리(Tag 전체 이미지 비교)	
	신규WhiteBalance 만 처리
2.	테스트 결과
	 03180101_Origin vs Fake_Fake(N수 = 35)
	(10913) : atlTraceGeneral - ============= Total Good matches result ==============
	(10915) : atlTraceGeneral - min(Good count) = 115, TestList = ./SampleImage/Fake_Fake11.jpg
	(10916) : atlTraceGeneral - max(Good count) = 370, TestList = ./SampleImage/Fake_Fake32.jpg
	(10917) : atlTraceGeneral - sum(Good count) = 8037
	(10918) : atlTraceGeneral - avr(Good count) = 229
	(10920) : atlTraceGeneral - min(Average distance) = 45, TestList = ./SampleImage/Fake_Fake32.jpg
	(10921) : atlTraceGeneral - max(Average distance) = 53, TestList = ./SampleImage/Fake_Fake11.jpg
	(10922) : atlTraceGeneral - sum(Average distance) = 1742
	(10923) : atlTraceGeneral - avr(Average distance) = 49
	(10925) : atlTraceGeneral - min(AddSimilaritySum) = 1636, TestList = ./SampleImage/Fake_Fake11.jpg
	(10926) : atlTraceGeneral - max(AddSimilaritySum) = 7712, TestList = ./SampleImage/Fake_Fake32.jpg
	(10927) : atlTraceGeneral - sum(AddSimilaritySum) = 140126
	(10928) : atlTraceGeneral - avr(AddSimilaritySum) = 4003
	(10929) : atlTraceGeneral - ======================================================

	 03180101_Origin vs Fake_Genuine(N수 = 47)
	(10913) : atlTraceGeneral - ============= Total Good matches result ==============
	(10915) : atlTraceGeneral - min(Good count) = 222, TestList = ./SampleImage/Fake_Genuine30.jpg
	(10916) : atlTraceGeneral - max(Good count) = 409, TestList = ./SampleImage/Fake_Genuine47(hopi).jpg
	(10917) : atlTraceGeneral - sum(Good count) = 16356
	(10918) : atlTraceGeneral - avr(Good count) = 327
	(10920) : atlTraceGeneral - min(Average distance) = 42, TestList = ./SampleImage/Fake_Genuine10.jpg
	(10921) : atlTraceGeneral - max(Average distance) = 51, TestList = ./SampleImage/Fake_Genuine5.jpg
	(10922) : atlTraceGeneral - sum(Average distance) = 2315
	(10923) : atlTraceGeneral - avr(Average distance) = 46
	(10925) : atlTraceGeneral - min(AddSimilaritySum) = 3926, TestList = ./SampleImage/Fake_Genuine30.jpg
	(10926) : atlTraceGeneral - max(AddSimilaritySum) = 11026, TestList = ./SampleImage/Fake_Genuine10.jpg
	(10927) : atlTraceGeneral - sum(AddSimilaritySum) = 332848
	(10928) : atlTraceGeneral - avr(AddSimilaritySum) = 6656
	(10929) : atlTraceGeneral - ======================================================

	 03180101_Origin vs Genuine(N수 = 45)
	(10904) : atlTraceGeneral - ============= Total Good matches result ==============
	(10906) : atlTraceGeneral - min(Good count) = 346, TestList = ./SampleImage/Genuine33.jpg
	(10907) : atlTraceGeneral - max(Good count) = 606, TestList = ./SampleImage/Genuine43.jpg
	(10908) : atlTraceGeneral - sum(Good count) = 22537
	(10909) : atlTraceGeneral - avr(Good count) = 500
	(10911) : atlTraceGeneral - min(Average distance) = 34, TestList = ./SampleImage/Genuine43.jpg
	(10912) : atlTraceGeneral - max(Average distance) = 45, TestList = ./SampleImage/Genuine33.jpg
	(10913) : atlTraceGeneral - sum(Average distance) = 1741
	(10914) : atlTraceGeneral - avr(Average distance) = 38
	(10916) : atlTraceGeneral - min(AddSimilaritySum) = 7476, TestList = ./SampleImage/Genuine33.jpg
	(10917) : atlTraceGeneral - max(AddSimilaritySum) = 22582, TestList = ./SampleImage/Genuine43.jpg
	(10918) : atlTraceGeneral - sum(AddSimilaritySum) = 665726
	(10919) : atlTraceGeneral - avr(AddSimilaritySum) = 14793
	(10920) : atlTraceGeneral - ======================================================	*/
void CTagDecoderDlg::OnBnClickedButton11()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	int selectArea = GOOD_MATCH_ANALYZE_AREA_ALL;
//	int selectArea = GOOD_MATCH_ANALYZE_AREA_SOME;
	int m_iGOOD_MATCH_DIST_LEVEL = 0;

	#if true
	String TestList[] = { "./SampleImage/Genuine0.jpg",
							"./SampleImage/Genuine1.jpg",	"./SampleImage/Genuine2.jpg",	"./SampleImage/Genuine3.jpg",	"./SampleImage/Genuine4.jpg",	"./SampleImage/Genuine5.jpg",	"./SampleImage/Genuine6.jpg",	"./SampleImage/Genuine7.jpg",	"./SampleImage/Genuine8.jpg",	"./SampleImage/Genuine9.jpg",	"./SampleImage/Genuine10.jpg",
							"./SampleImage/Genuine11.jpg",	"./SampleImage/Genuine12.jpg",	"./SampleImage/Genuine13.jpg",	"./SampleImage/Genuine14.jpg",	"./SampleImage/Genuine15.jpg",	"./SampleImage/Genuine16.jpg",	"./SampleImage/Genuine17.jpg",	"./SampleImage/Genuine18.jpg",	"./SampleImage/Genuine19.jpg",	"./SampleImage/Genuine20.jpg",
							"./SampleImage/Genuine21.jpg",	"./SampleImage/Genuine22.jpg",	"./SampleImage/Genuine23.jpg",	"./SampleImage/Genuine24.jpg",	"./SampleImage/Genuine25.jpg",	"./SampleImage/Genuine26.jpg",	"./SampleImage/Genuine27.jpg",	"./SampleImage/Genuine28.jpg",	"./SampleImage/Genuine29.jpg",	"./SampleImage/Genuine30.jpg",
							"./SampleImage/Genuine31.jpg",	"./SampleImage/Genuine32.jpg",	"./SampleImage/Genuine33.jpg",	"./SampleImage/Genuine34.jpg",	"./SampleImage/Genuine35.jpg",	"./SampleImage/Genuine36.jpg",	"./SampleImage/Genuine37.jpg",	"./SampleImage/Genuine38.jpg",	"./SampleImage/Genuine39.jpg",	"./SampleImage/Genuine40.jpg",
							"./SampleImage/Genuine41.jpg",	"./SampleImage/Genuine42.jpg",	"./SampleImage/Genuine43.jpg",	"./SampleImage/Genuine44.jpg" };
//							"./SampleImage/Genuine41.jpg",	"./SampleImage/Genuine42.jpg",	"./SampleImage/Genuine44.jpg" };
//							"./SampleImage/Genuine41.jpg",	"./SampleImage/Genuine42.jpg",	"./SampleImage/Genuine43.jpg",	"./SampleImage/Genuine44.jpg",  "./SampleImage/Genuine43_blank(center).jpg", "./SampleImage/Genuine43_blank(left).jpg" , "./SampleImage/Genuine43_blank(right).jpg" };

	#elif true
	String TestList[] = { "./SampleImage/Fake_Fake0.jpg",
							"./SampleImage/Fake_Fake1.jpg",		"./SampleImage/Fake_Fake2.jpg",		"./SampleImage/Fake_Fake3.jpg",		"./SampleImage/Fake_Fake4.jpg",		"./SampleImage/Fake_Fake5.jpg",		"./SampleImage/Fake_Fake6.jpg",		"./SampleImage/Fake_Fake7.jpg",		"./SampleImage/Fake_Fake8.jpg",		"./SampleImage/Fake_Fake9.jpg",		"./SampleImage/Fake_Fake10.jpg",
							"./SampleImage/Fake_Fake11.jpg",	"./SampleImage/Fake_Fake12.jpg",	"./SampleImage/Fake_Fake13.jpg",	"./SampleImage/Fake_Fake14.jpg",	"./SampleImage/Fake_Fake15.jpg",	"./SampleImage/Fake_Fake16.jpg",	"./SampleImage/Fake_Fake17.jpg",	"./SampleImage/Fake_Fake18.jpg",	"./SampleImage/Fake_Fake19.jpg",	"./SampleImage/Fake_Fake20.jpg",
							"./SampleImage/Fake_Fake21.jpg",	"./SampleImage/Fake_Fake22.jpg",	"./SampleImage/Fake_Fake23.jpg",	"./SampleImage/Fake_Fake24.jpg",	"./SampleImage/Fake_Fake25.jpg",	"./SampleImage/Fake_Fake26.jpg",	"./SampleImage/Fake_Fake27.jpg",	"./SampleImage/Fake_Fake28.jpg",	"./SampleImage/Fake_Fake29.jpg",	"./SampleImage/Fake_Fake30.jpg",
							"./SampleImage/Fake_Fake31.jpg",	"./SampleImage/Fake_Fake32.jpg",	"./SampleImage/Fake_Fake33.jpg",	"./SampleImage/Fake_Fake34.jpg" };
	#else
	String TestList[] = { "./SampleImage/Fake_Genuine0.jpg",
							"./SampleImage/Fake_Genuine1.jpg",	"./SampleImage/Fake_Genuine2.jpg",	"./SampleImage/Fake_Genuine3.jpg",	"./SampleImage/Fake_Genuine4.jpg",	"./SampleImage/Fake_Genuine5.jpg",	"./SampleImage/Fake_Genuine6.jpg",	"./SampleImage/Fake_Genuine7.jpg",	"./SampleImage/Fake_Genuine8.jpg",	"./SampleImage/Fake_Genuine9.jpg",	"./SampleImage/Fake_Genuine10.jpg",
							"./SampleImage/Fake_Genuine11.jpg",	"./SampleImage/Fake_Genuine12.jpg",	"./SampleImage/Fake_Genuine13.jpg",	"./SampleImage/Fake_Genuine14.jpg",	"./SampleImage/Fake_Genuine15.jpg",	"./SampleImage/Fake_Genuine16.jpg",	"./SampleImage/Fake_Genuine17.jpg",	"./SampleImage/Fake_Genuine18.jpg",	"./SampleImage/Fake_Genuine19.jpg",	"./SampleImage/Fake_Genuine20.jpg",
							"./SampleImage/Fake_Genuine21.jpg",	"./SampleImage/Fake_Genuine22.jpg",	"./SampleImage/Fake_Genuine23.jpg",	"./SampleImage/Fake_Genuine24.jpg",	"./SampleImage/Fake_Genuine25.jpg",	"./SampleImage/Fake_Genuine26.jpg",	"./SampleImage/Fake_Genuine27.jpg",	"./SampleImage/Fake_Genuine28.jpg",	"./SampleImage/Fake_Genuine29.jpg",	"./SampleImage/Fake_Genuine30.jpg",
							"./SampleImage/Fake_Genuine31.jpg",	"./SampleImage/Fake_Genuine32.jpg",	"./SampleImage/Fake_Genuine33.jpg",	"./SampleImage/Fake_Genuine34.jpg",	"./SampleImage/Fake_Genuine35.jpg",	"./SampleImage/Fake_Genuine36.jpg",	"./SampleImage/Fake_Genuine37.jpg",	"./SampleImage/Fake_Genuine38.jpg",	"./SampleImage/Fake_Genuine39.jpg",	"./SampleImage/Fake_Genuine40.jpg",
//							"./SampleImage/Fake_Genuine41.jpg",	"./SampleImage/Fake_Genuine42.jpg",	"./SampleImage/Fake_Genuine43.jpg",	"./SampleImage/Fake_Genuine44.jpg",	"./SampleImage/Fake_Genuine45.jpg",	"./SampleImage/Fake_Genuine46.jpg" };
							"./SampleImage/Fake_Genuine41.jpg", "./SampleImage/Fake_Genuine42.jpg", "./SampleImage/Fake_Genuine43.jpg", "./SampleImage/Fake_Genuine44.jpg", "./SampleImage/Fake_Genuine45.jpg", "./SampleImage/Fake_Genuine46.jpg", "./SampleImage/Fake_Genuine47(hopi).jpg", "./SampleImage/Fake_Genuine48(hopi).jpg", "./SampleImage/Fake_Genuine49(hopi).jpg"};

	#endif

	vector<int> ResultList_GoodCount;
	vector<int> ResultList_AvrDistance;
	vector<int> ResultList_AddSimilaritySum;
	int TestListSize = sizeof(TestList) / sizeof(TestList[0]);

	for (int iCnt = 0; iCnt < TestListSize; iCnt++)
	{
		// Image read
		Mat img1_gray = imread("./SampleImage/0318_Origin.jpg", IMREAD_GRAYSCALE);
	//	Mat img1_gray = imread("./SampleImage/Genuine43.jpg", IMREAD_GRAYSCALE);
	//	Mat img2_gray = imread("./SampleImage/Genuine1.jpg", IMREAD_GRAYSCALE);
	//	Mat img2_gray = imread("./SampleImage/Fake_Fake1.jpg", IMREAD_GRAYSCALE);
		Mat img2_gray = imread(TestList[iCnt], IMREAD_GRAYSCALE);

		CV_Assert(img1_gray.data);
		CV_Assert(img2_gray.data);

		// Image slice
		Mat img1_gray_clone = img1_gray.clone();
		Mat img2_gray_clone = img2_gray.clone();

		Rect rect;
		Rect rect2(TAG_WIDTH_720_GAP, TAG_HEIGHT_720_GAP, (TAG_WIDTH_720 - TAG_WIDTH_720_GAP * 2), (TAG_HEIGHT_720 - TAG_HEIGHT_720_GAP * 2));				// Trillcode 안쪽 영역 모두, ROI(x, y, w, h)
		Rect rect3(TAG_WIDTH_720_ANALYZE_X, TAG_HEIGHT_720_ANALYZE_Y, TAG_WIDTH_720_ANALYZE_WIDTH, TAG_HEIGHT_720_ANALYZE_HEIGHT);							// Trillcode 안쪽 좌측/하단 일부, ROI(x, y, w, h)

		if (selectArea == GOOD_MATCH_ANALYZE_AREA_ALL)
		{
			rect = rect2;
			m_iGOOD_MATCH_DIST_LEVEL = GOOD_MATCH_DIST_LEVEL;
		}
		else
		{
			rect = rect3;
			m_iGOOD_MATCH_DIST_LEVEL = GOOD_MATCH_DIST_LEVEL2;
		}

		Mat img1_gray_slice = img1_gray_clone(rect);
		Mat img2_gray_slice = img2_gray_clone(rect);

//		imshow("img1_gray_slice", img1_gray_slice);
//		imshow("img2_gray_slice", img2_gray_slice);

	#if false
		// Image normalize(WhiteBalance)
		Mat img1_gray_slice_white, img2_gray_slice_white;
//		normalize(img1_gray_slice, img1_gray_slice_white, 0, 255, NORM_MINMAX);
		normalize(img2_gray_slice, img2_gray_slice_white, 0, 255, NORM_MINMAX);

//		imshow("img1_gray_slice_white", img1_gray_slice_white);
//		imshow("img2_gray_slice_white", img2_gray_slice_white);

		// Final return image
//		img1_gray_slice = img1_gray_slice_white.clone();
		img2_gray_slice = img2_gray_slice_white.clone();
	#elif false
		#if false
		// Image threshold
		Mat img2_gray_slice_th;
		threshold(img2_gray_slice, img2_gray_slice_th, 200, 255, THRESH_BINARY_INV);
		imshow("img2_gray_slice_th", img2_gray_slice_th);
		#elif false
		// Image Cutoff(일정이상값은 일정값(고정값)으로 변경)
		Mat img2_gray_slice_th = img2_gray_slice.clone();
		for (int i = 0; i < img2_gray_slice.rows; i++)
		{
			for (int j = 0; j < img2_gray_slice.cols; j++)
			{
				if (img2_gray_slice.at<uchar>(i, j) >= BRIGHT_CUTOFF)
					img2_gray_slice_th.at<uchar>(i, j) = 255;
			}
		}
		imshow("img2_gray_slice_th", img2_gray_slice_th);
		#else
		// Image Contrast
		Scalar avg = mean(img2_gray_slice) / 2.0;
		//	Mat img2_gray_slice_th = img2_gray_slice * 2.0 - avg[0];
		Mat img2_gray_slice_th = img2_gray_slice * 1.9 - avg[0];
		//		imshow("img2_gray_slice_th", img2_gray_slice_th);
		#endif

		// Image normalize(WhiteBalance)
		Mat img1_gray_slice_white, img2_gray_slice_th_white;
		normalize(img1_gray_slice, img1_gray_slice_white, 0, 255, NORM_MINMAX);
		normalize(img2_gray_slice_th, img2_gray_slice_th_white, 0, 255, NORM_MINMAX);

//		imshow("img1_gray_slice_white", img1_gray_slice_white);
//		imshow("img2_gray_slice_th_white", img2_gray_slice_th_white);

		// Final return image
		img1_gray_slice = img1_gray_slice_white.clone();
		img2_gray_slice = img2_gray_slice_th_white.clone();
	#elif false
		// Image bright compensation
		long img1_sum = sum(img1_gray_slice)[0];
		long img2_sum = sum(img2_gray_slice)[0];
		long img1_avr = img1_sum / img1_gray_slice.total();
		long img2_avr = img2_sum / img2_gray_slice.total();

		int img1_img2_gap = img1_avr - img2_avr;
		Mat img2_gray_slice_ch = img2_gray_slice + img1_img2_gap;

//		imshow("img2_gray_slice_ch(bright)", img2_gray_slice_ch);

		// Image normalize(WhiteBalance)
		Mat img2_gray_slice_ch2;
		normalize(img2_gray_slice_ch, img2_gray_slice_ch2, 0, 255, NORM_MINMAX);
//		normalize(img2_gray_slice_ch, img2_gray_slice_ch2, 0, 200, NORM_MINMAX);
		
//		imshow("img2_gray_slice_ch2(bright+white)", img2_gray_slice_ch2);

		#if false
		// Image Cutoff(일정이상값은 일정값(고정값)으로 변경)
		Mat img2_gray_slice_ch_ch2_ch3 = img2_gray_slice_ch_ch2.clone();
		for (int i = 0; i < img2_gray_slice_ch_ch2.rows; i++)
		{
			for (int j = 0; j < img2_gray_slice_ch_ch2.cols; j++)
			{
				if (img2_gray_slice_ch_ch2.at<uchar>(i, j) >= BRIGHT_CUTOFF)
					img2_gray_slice_ch_ch2_ch3.at<uchar>(i, j) = 255;
			}
		}
		//		imshow("img2_gray_slice_ch_ch2_ch3", img2_gray_slice_ch_ch2_ch3);

		// Final return image
		img1_gray_slice = img1_gray_slice_ch.clone();
		img2_gray_slice = img2_gray_slice_ch_ch2_ch3.clone();
		#elif false
		// Image Contrast
		Scalar avg = mean(img2_gray_slice_ch2) / 4;
		Mat img2_gray_slice_ch3 = img2_gray_slice_ch2 * 1.1 - avg[0];
//		Mat img2_gray_slice_ch3 = img2_gray_slice_ch2 * 1.3;
//		imshow("img2_gray_slice_ch3(bright+white+contrast)", img2_gray_slice_ch3);

		// Final return image
		img2_gray_slice = img2_gray_slice_ch3.clone();
		#elif false
		// Image threshold
		Mat img1_gray_slice_ch_ch2, img2_gray_slice_ch_ch2_ch3;

		threshold(img1_gray_slice_ch, img1_gray_slice_ch_ch2, 70, 255, THRESH_BINARY);
		threshold(img2_gray_slice_ch_ch2, img2_gray_slice_ch_ch2_ch3, 70, 255, THRESH_BINARY);

		imshow("img1_gray_slice_ch_ch2", img1_gray_slice_ch_ch2);
		imshow("img2_gray_slice_ch_ch2_ch3", img2_gray_slice_ch_ch2_ch3);

		// Final return image
		img1_gray_slice = img1_gray_slice_ch_ch2.clone();
		img2_gray_slice = img2_gray_slice_ch_ch2_ch3.clone();
		#else
		// Final return image
		img1_gray_slice = img1_gray_slice.clone();
		img2_gray_slice = img2_gray_slice_ch2.clone();
		#endif
	#elif false
		// Image Backup
		Mat img2_gray_slice_def = img2_gray_slice.clone();

		// Image Darkness
//		Scalar avg = mean(img2_gray_slice) / 2;
//		Scalar avg = mean(img2_gray_slice) * 0.3;
		Scalar avg = 0;
		Mat img2_gray_slice_ch = img2_gray_slice - avg[0];
//		imshow("img2_gray_slice_ch(darkness)", img2_gray_slice_ch);

		// Image normalize(WhiteBalance)
		Mat img2_gray_slice_ch2;
		normalize(img2_gray_slice_ch, img2_gray_slice_ch2, 0, 255, NORM_MINMAX);
//		imshow("img2_gray_slice_ch2(darkness+white)", img2_gray_slice_ch2);

		// Final return image
		img2_gray_slice = img2_gray_slice_ch2.clone();
	#else
		// Image Backup
		Mat img2_gray_slice_def = img2_gray_slice.clone();

		// Image normalize(WhiteBalance)
		Mat img2_gray_slice_ch;
		normalize(img2_gray_slice, img2_gray_slice_ch, 0, 255, NORM_MINMAX);
//		imshow("img2_gray_slice_ch(white)", img2_gray_slice_ch);

		// Final return image
		img2_gray_slice = img2_gray_slice_ch.clone();
	#endif

		// Step 1, 2 : detect the keypoints & descriptors
		vector<KeyPoint> keypoints1, keypoints2;
		Mat descriptors1, descriptors2;

		#if false
		// Initiate ORB detector
		Ptr<ORB> orbF = ORB::create(1000);
		orbF->detectAndCompute(img1_gray_slice, noArray(), keypoints1, descriptors1);
		orbF->detectAndCompute(img2_gray_slice, noArray(), keypoints2, descriptors2);
		#elif true
		// Initiate ORB detector
		/*	@brief The ORB constructor
		@param nfeatures The maximum number of features to retain.

		@param scaleFactor Pyramid decimation ratio, greater than 1. scaleFactor==2 means the classical
		pyramid, where each next level has 4x less pixels than the previous, but such a big scale factor
		will degrade feature matching scores dramatically. On the other hand, too close to 1 scale factor
		will mean that to cover certain scale range you will need more pyramid levels and so the speed
		will suffer.

		@param nlevels The number of pyramid levels. The smallest level will have linear size equal to
		input_image_linear_size/pow(scaleFactor, nlevels).

		@param edgeThreshold This is size of the border where the features are not detected. It should
		roughly match the patchSize parameter.

		@param firstLevel It should be 0 in the current implementation.

		@param WTA_K The number of points that produce each element of the oriented BRIEF descriptor. The
		default value 2 means the BRIEF where we take a random point pair and compare their brightnesses,
		so we get 0/1 response. Other possible values are 3 and 4. For example, 3 means that we take 3
		random points (of course, those point coordinates are random, but they are generated from the
		pre-defined seed, so each element of BRIEF descriptor is computed deterministically from the pixel
		rectangle), find point of maximum brightness and output index of the winner (0, 1 or 2). Such
		output will occupy 2 bits, and therefore it will need a special variant of Hamming distance,
		denoted as NORM_HAMMING2 (2 bits per bin). When WTA_K=4, we take 4 random points to compute each
		bin (that will also occupy 2 bits with possible values 0, 1, 2 or 3).

		@param scoreType The default HARRIS_SCORE means that Harris algorithm is used to rank features
		(the score is written to KeyPoint::score and is used to retain best nfeatures features);
		FAST_SCORE is alternative value of the parameter that produces slightly less stable keypoints,
		but it is a little faster to compute.

		@param patchSize size of the patch used by the oriented BRIEF descriptor. Of course, on smaller
		pyramid layers the perceived image area covered by a feature will be larger.

		@param fastThreshold

		CV_WRAP static Ptr<ORB> create(int nfeatures = 500, float scaleFactor = 1.2f, int nlevels = 8, int edgeThreshold = 31,
			int firstLevel = 0, int WTA_K = 2, int scoreType = ORB::HARRIS_SCORE, int patchSize = 31, int fastThreshold = 20);

		실제 테스트 결과
		-	float scaleFactor	: 값을 1.5f로 올려줄수록 더 정확한 Matching 결과가 나옮(값을 낮출 수록 아주 세부적인 곳까지 비교 대상에 포함시킴 -> 이 경우 너무 세부적인 것 까지 비교하기 때문에 오히려 엉뚱한 영역을 비교 대상으로 포함시키게 됨)
		-	int edgeThreshold	: 본 값은 patchSize와 대략 일치해야 함, 값을 25로 낮출수록 더 작은 이미지도 찾아서 비교함
		-	int WTA_K			: default 2가 아닌 3으로 선택하면 동일하지 않은 엉뚱한 지점을 더 많이 찾아 줌	
		-	int patchSize		: 값을 50으로 높이면 원본/비교 대조군의 edge image 사이즈가 거의 동일해야지만 matching으로 잡아줌(cf, 원본(큰K문자) / 비교군(작은K문자) -> 동일하게 K문자가 있지만 사이즈가 작기 때문에 matching으로 잡아주지 않음)
		-	int fastThreshold	: 값이 낮을 수록 검정색 옅은 이미지도 비교 대상에 포함시키는 것 같다	*/
		Ptr<ORB> orbF = ORB::create(1000);
//		Ptr<ORB> orbF = ORB::create(1000, 1.5f, 8, 20, 0, 2, ORB::HARRIS_SCORE, 50, 20);
//		Ptr<ORB> orbF = ORB::create(5000, 1.5f, 8, 20, 0, 2, ORB::HARRIS_SCORE, 80, 20);
//		Ptr<ORB> orbF = ORB::create(2000, 1.5f, 8, 15, 0, 2, ORB::HARRIS_SCORE, 50, 15);
//		Ptr<ORB> orbF = ORB::create(2000, 2.5f, 8, 15, 0, 2, ORB::HARRIS_SCORE, 50, 15);		// 큰 문자 작은 문자 골고루 제대로 비교해주는 설정 임
//		Ptr<ORB> orbF = ORB::create(3000, 2.5f, 8, 50, 0, 3, ORB::HARRIS_SCORE, 50, 15);
//		Ptr<ORB> orbF = ORB::create(2000, 2.0f, 8, 50, 0, 2, ORB::HARRIS_SCORE, 50, 15);		// 전체 이미지 비교
//		Ptr<ORB> orbF = ORB::create(2000, 2.0f, 8, 40, 0, 2, ORB::HARRIS_SCORE, 40, 5);		// 일부(별색) 이미지 비교
//		Ptr<ORB> orbF = ORB::create(3000, 2.0f, 8, 30, 0, 2, ORB::HARRIS_SCORE, 50, 5);		// 일부(별색) 이미지 비교
		orbF->detectAndCompute(img1_gray_slice, noArray(), keypoints1, descriptors1);
		orbF->detectAndCompute(img2_gray_slice, noArray(), keypoints2, descriptors2);
		#else
		// Initiate BRISK detector
		Ptr<BRISK> briskF = BRISK::create(1000);
		briskF->detectAndCompute(img1_gray_slice, noArray(), keypoints1, descriptors1);
		briskF->detectAndCompute(img2_gray_slice, noArray(), keypoints2, descriptors2);
		#endif

		// Step 3 : Matching descriptor vectors
		// Matching descriptor vectors with a brute force matcher
		/*	cv::BFMatcher::BFMatcher  ( int  normType = NORM_L2,  bool  crossCheck = false)
			Parameters
			-	normType One of NORM_L1, NORM_L2, NORM_HAMMING, NORM_HAMMING2.
				L1 and L2 norms are preferable choices for SIFT and SURF descriptors,
				NORM_HAMMING should be used with ORB, BRISK and BRIEF,
				NORM_HAMMING2 should be used with ORB when WTA_K==3 or 4 (see ORB::ORB constructor description).
			-	crossCheck If it is false, this is will be default BFMatcher behaviour when it finds the k nearest neighbors for each query descriptor.
				If crossCheck==true, then the knnMatch() method with k=1 will only return pairs (i,j) such that for i-th query descriptor the j-th descriptor in the matcher's collection is the nearest and vice versa,
				i.e. the BFMatcher will only return consistent pairs. Such technique usually produces best results with minimal number of outliers when there are enough matches. This is alternative to the ratio test, used by D. Lowe in SIFT paper.  */
		vector< DMatch> matches;
		//		BFMatcher matcher(NORM_L1, true);
		//		BFMatcher matcher(NORM_L2, true);
		//		BFMatcher matcher(NORM_HAMMING, true);
		BFMatcher matcher(NORM_HAMMING2, true);		// BFMatcher matcher(NORM_HAMMING2, false) 로 설정하면 더 많이 어뚱한 곳을 matching 시켜 줌
//		matcher.match(descriptors1, descriptors2, matches);
		// fix, 아래와 같이 처리해줘야지 matching error 발생 시 처리 가능 함
		if ((keypoints1.size() >= 2) && (keypoints2.size() >= 2))
			matcher.match(descriptors1, descriptors2, matches);
		else
			TRACE("Error, keypoints1.size() = %d, keypoints2.size() = %d\n", keypoints1.size(), keypoints2.size());
		// fix



		// Good matches process
		int iMin = 0, iMax = 0, iSum = 0, iAvr = 0, good_count = 0, matchesSize = 0;
		vector< DMatch > good_matches;
		matchesSize = matches.size();
		int AddSimilaritySum = 0;

		if (matchesSize > 0)
		{
			iMin = matches[0].distance;
			iMax = matches[0].distance;

			#if false
			for (int i = 0; i < matchesSize; i++)
			{
				if (matches[i].distance <= m_iGOOD_MATCH_DIST_LEVEL)		// GOOD_MATCH_DIST_LEVEL 보다 값이 적다는 것은 Matching이 좋다는 뜻
					good_matches.push_back(matches[i]);

				if (matches[i].distance > iMax)
					iMax = matches[i].distance;

				if (matches[i].distance < iMin)
					iMin = matches[i].distance;

				iSum += matches[i].distance;
			}

			iAvr = iSum / matchesSize;
			good_count = good_matches.size();
			#elif false
			for (int i = 0; i < matchesSize; i++)
			{
				if (matches[i].distance > iMax)
					iMax = matches[i].distance;

				if (matches[i].distance < iMin)
					iMin = matches[i].distance;

				iSum += matches[i].distance;
			}
			iAvr = iSum / matchesSize;

//			m_iGOOD_MATCH_DIST_LEVEL = (float)iAvr * 0.9;
			m_iGOOD_MATCH_DIST_LEVEL = m_iGOOD_MATCH_DIST_LEVEL + iMin;
			for (int i = 0; i < matchesSize; i++)
			{
//				if (matches[i].distance <= iMin * 4)						// iMin*4 보다 값이 적다는 것은 Matching이 좋다는 뜻
				if (matches[i].distance <= m_iGOOD_MATCH_DIST_LEVEL)		// iAvr 보다 값이 적다는 것은 Matching이 좋다는 뜻
				{
					good_matches.push_back(matches[i]);
					AddSimilaritySum += matches[i].distance;
				}
			}
			good_count = good_matches.size();
			#else
			for (int i = 0; i < matchesSize; i++)
			{
				if (matches[i].distance <= m_iGOOD_MATCH_DIST_LEVEL)		// GOOD_MATCH_DIST_LEVEL 보다 값이 적다는 것은 Matching이 좋다는 뜻
				{
					good_matches.push_back(matches[i]);

					/*	각 matching점 간 가산점이 더해진 유사도 구함	*/
					AddSimilaritySum += (m_iGOOD_MATCH_DIST_LEVEL - matches[i].distance)*2;
				}

				if (matches[i].distance > iMax)
					iMax = matches[i].distance;

				if (matches[i].distance < iMin)
					iMin = matches[i].distance;

				iSum += matches[i].distance;
			}

			iAvr = iSum / matchesSize;
			good_count = good_matches.size();
			#endif
		}
		else
		{
			iMin = 0;
			iMax = 0;
			iSum = 0;
			iAvr = 0;
			good_count = 0;
			matchesSize = 0;
			AddSimilaritySum = 0;
		}

		ResultList_GoodCount.push_back(good_count);
		ResultList_AvrDistance.push_back(iAvr);
		ResultList_AddSimilaritySum.push_back(AddSimilaritySum);

		#if false
		TRACE("======================================================\n");
		TRACE("matches.size(%s) = %d\n", TestList[iCnt].c_str(), matchesSize);
		TRACE("iMin of matches(%s) = %d\n", TestList[iCnt].c_str(), iMin);
		TRACE("iMax of matches(%s) = %d\n", TestList[iCnt].c_str(), iMax);
		TRACE("iAvr of matches(%s) = %d\n", TestList[iCnt].c_str(), iAvr);
		TRACE("GOOD_MATCH_DIST_LEVEL = %d\n", m_iGOOD_MATCH_DIST_LEVEL);
		TRACE("good_matches.size(%s) = %d\n", TestList[iCnt].c_str(), good_count);
		TRACE("AddSimilaritySum(%s) = %d\n", TestList[iCnt].c_str(), AddSimilaritySum);
		TRACE("======================================================\n");
		#else
//		TRACE("======================================================\n");
//		TRACE("matches.size(%s) = %d\n", TestList[iCnt].c_str(), matchesSize);
//		TRACE("iMin of matches(%s) = %d\n", TestList[iCnt].c_str(), iMin);
//		TRACE("iMax of matches(%s) = %d\n", TestList[iCnt].c_str(), iMax);
//		TRACE("iAvr of matches(%s) = %d\n", TestList[iCnt].c_str(), iAvr);
//		TRACE("GOOD_MATCH_DIST_LEVEL = %d\n", m_iGOOD_MATCH_DIST_LEVEL);
//		TRACE("good_matches.size(%s) = %d\n", TestList[iCnt].c_str(), good_count);
		TRACE("AddSimilaritySum(%s) = %d\n", TestList[iCnt].c_str(), AddSimilaritySum);
//		TRACE("======================================================\n");
		#endif

//		if(	(strcmp(TestList[iCnt].c_str(), "./SampleImage/Genuine33.jpg") == 0)		||			// 유사도가 낮게 나오는 이미지
//		if( (strcmp(TestList[iCnt].c_str(), "./SampleImage/Genuine27.jpg") == 0)		||			// 밝은(saturation) 이미지
//		if( (strcmp(TestList[iCnt].c_str(), "./SampleImage/Genuine42.jpg") == 0)		||			// 어두운 이미지
//		if( (strcmp(TestList[iCnt].c_str(), "./SampleImage/Genuine43_blank(right).jpg") == 0)		||			// temp
//		if ((strcmp(TestList[iCnt].c_str(), "./SampleImage/Genuine43_blank(left).jpg") == 0) ||			// temp
		if( (strcmp(TestList[iCnt].c_str(), "./SampleImage/Genuine0.jpg") == 0)		||			// temp
			(strcmp(TestList[iCnt].c_str(), "./SampleImage/Fake_Fake32.jpg") == 0)	||			// 유사도 높게 나오는 이미지
			(strcmp(TestList[iCnt].c_str(), "./SampleImage/Fake_Genuine31.jpg") == 0))				// 유사도 높게 나오는 이미지
		{
			imshow("img2_gray_slice_def", img2_gray_slice_def);
//			imshow("img2_gray_slice_ch(darkness)", img2_gray_slice_ch);
//			imshow("img2_gray_slice_ch2(darkness+white)", img2_gray_slice_ch2);
			imshow("img2_gray_slice_ch(white)", img2_gray_slice_ch);

			// Draw only "good" matches
			Mat img_matches, img_matches2;
			/*	drawMatches
				Parameters:
				?img1 ? First source image.
				?keypoints1 ? Keypoints from the first source image.
				?img2 ? Second source image.
				?keypoints2 ? Keypoints from the second source image.
				?matches1to2 ? Matches from the first image to the second one, which means that keypoints1[i] has a corresponding point in keypoints2[matches[i]] .
				?outImg ? Output image. Its content depends on the flags value defining what is drawn in the output image. See possible flags bit values below.
				?matchColor ? Color of matches (lines and connected keypoints). If matchColor==Scalar::all(-1) , the color is generated randomly.
				?singlePointColor ? Color of single keypoints (circles), which means that keypoints do not have the matches. If singlePointColor==Scalar::all(-1) , the color is generated randomly.
				?matchesMask ? Mask determining which matches are drawn. If the mask is empty, all matches are drawn.
				?flags ? Flags setting drawing features. Possible flags bit values are defined by DrawMatchesFlags.
					struct DrawMatchesFlags
					{
						enum
						{
							DEFAULT = 0, // Output image matrix will be created (Mat::create),
										 // i.e. existing memory of output image may be reused.
										 // Two source images, matches, and single keypoints
										 // will be drawn.
										 // For each keypoint, only the center point will be
										 // drawn (without a circle around the keypoint with the
										 // keypoint size and orientation).
							DRAW_OVER_OUTIMG = 1, // Output image matrix will not be
										   // created (using Mat::create). Matches will be drawn
										   // on existing content of output image.
							NOT_DRAW_SINGLE_POINTS = 2, // Single keypoints will not be drawn.
							DRAW_RICH_KEYPOINTS = 4 // For each keypoint, the circle around
										   // keypoint with keypoint size and orientation will
										   // be drawn.
						};
					};	*/
			drawMatches(img1_gray_slice, keypoints1, img2_gray_slice, keypoints2, matches, img_matches, Scalar::all(-1), (DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS));			//	matches에 해당하는 모든 경우 컬러라인으로 표시해 줌
			drawMatches(img1_gray_slice, keypoints1, img2_gray_slice, keypoints2, good_matches, img_matches2, Scalar(0, 255, 0), (DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS));	//	good_matches에 해당하는 경우만 녹색라인으로 표시해 줌
			imshow("img_matches", img_matches);
			imshow("img_matches2", img_matches2);
		}
	}

	int iMin2 = ResultList_GoodCount[0], iMax2 = ResultList_GoodCount[0], iSum2 = 0, iAvr2 = 0, ResultList_GoodCountSize = 0;
	int iMin2_index = 0, iMax2_index = 0;
	int iMin3 = ResultList_AvrDistance[0], iMax3 = ResultList_AvrDistance[0], iSum3 = 0, iAvr3 = 0, ResultList_AvrDistanceSize = 0;
	int iMin3_index = 0, iMax3_index = 0;
	int iMin4 = ResultList_AddSimilaritySum[0], iMax4 = ResultList_AddSimilaritySum[0], iSum4 = 0, iAvr4 = 0, ResultList_AddSimilaritySumSize = 0;
	int iMin4_index = 0, iMax4_index = 0;
	ResultList_GoodCountSize = ResultList_GoodCount.size();
	ResultList_AvrDistanceSize = ResultList_AvrDistance.size();
	ResultList_AddSimilaritySumSize = ResultList_AddSimilaritySum.size();
	for (int i = 0; i < ResultList_GoodCountSize; i++)
	{
		if (ResultList_GoodCount[i] > iMax2)
		{
			iMax2 = ResultList_GoodCount[i];
			iMax2_index = i;
		}

		if (ResultList_GoodCount[i] < iMin2)
		{
			iMin2 = ResultList_GoodCount[i];
			iMin2_index = i;
		}

		iSum2 += ResultList_GoodCount[i];


		if (ResultList_AvrDistance[i] > iMax3)
		{
			iMax3 = ResultList_AvrDistance[i];
			iMax3_index = i;
		}

		if (ResultList_AvrDistance[i] < iMin3)
		{
			iMin3 = ResultList_AvrDistance[i];
			iMin3_index = i;
		}

		iSum3 += ResultList_AvrDistance[i];

		if (ResultList_AddSimilaritySum[i] > iMax4)
		{
			iMax4 = ResultList_AddSimilaritySum[i];
			iMax4_index = i;
		}
		
		if (ResultList_AddSimilaritySum[i] < iMin4)
		{
			iMin4 = ResultList_AddSimilaritySum[i];
			iMin4_index = i;
		}
		
		iSum4 += ResultList_AddSimilaritySum[i];
	}

	iAvr2 = iSum2 / ResultList_GoodCountSize;
	iAvr3 = iSum3 / ResultList_AvrDistanceSize;
	iAvr4 = iSum4 / ResultList_AddSimilaritySumSize;

	TRACE("============= Total Good matches result ==============\n");
//	TRACE("GOOD_MATCH_DIST_LEVEL = %d\n", m_iGOOD_MATCH_DIST_LEVEL);
	TRACE("min(Good count) = %d, TestList = %s\n", iMin2, TestList[iMin2_index].c_str());
	TRACE("max(Good count) = %d, TestList = %s\n", iMax2, TestList[iMax2_index].c_str());
	TRACE("sum(Good count) = %d\n", iSum2);
	TRACE("avr(Good count) = %d\n", iAvr2);

	TRACE("min(Average distance) = %d, TestList = %s\n", iMin3, TestList[iMin3_index].c_str());
	TRACE("max(Average distance) = %d, TestList = %s\n", iMax3, TestList[iMax3_index].c_str());
	TRACE("sum(Average distance) = %d\n", iSum3);
	TRACE("avr(Average distance) = %d\n", iAvr3);

	TRACE("min(AddSimilaritySum) = %d, TestList = %s\n", iMin4, TestList[iMin4_index].c_str());
	TRACE("max(AddSimilaritySum) = %d, TestList = %s\n", iMax4, TestList[iMax4_index].c_str());
	TRACE("sum(AddSimilaritySum) = %d\n", iSum4);
	TRACE("avr(AddSimilaritySum) = %d\n", iAvr4);
	TRACE("======================================================\n");
}

84_24.	Matching parameter 설명
CV_WRAP static Ptr<ORB> create(int nfeatures = 500, float scaleFactor = 1.2f, int nlevels = 8, int edgeThreshold = 31,
			int firstLevel = 0, int WTA_K = 2, int scoreType = ORB::HARRIS_SCORE, int patchSize = 31, int fastThreshold = 20);

	@param nfeatures 보유 할 최대 피쳐 수입니다.

    @param scaleFactor 피라미드 데시 메이션 비율,
 1보다 큰 scaleFactor == 2는 고전적인 피라미드를 의미합니다.
 각각의 다음 레벨은 이전보다 4 배 적은 픽셀을 가지며,
그러나 이러한 큰 규모의 요인은 특징 매칭 스코어를 극적으로 저하시킬 것이다. 한편,
1 축척 계수에 너무 가깝다는 것은 특정 축척 범위를 커버하기 위해서는 더 많은 피라미드 레벨이 필요하므로 속도가 떨어질 것임을 의미합니다.

    @param nlevels 피라미드 레벨 수입니다. 가장 작은 레벨은 선형 크기가 input_image_linear_size / pow (scaleFactor, nlevels)와 같습니다.

    @param edgeThreshold 이것은, 기능이 검출되지 않는 경계의 사이즈입니다. patchSize 매개 변수와 대략 일치해야합니다.

    @param firstLevel 현재 구현에서는 0이어야합니다.

    @ 파라미터 WTA_K 방향성을 가지는 BRIEF descriptor의 각 요소를 생성하는 점의 수.
기본값 2는 간단한 포인트 쌍을 취해 그 밝기를 비교하는 BRIEF를 의미합니다.
    그래서 우리는 0/1 응답을 얻습니다. 다른 가능한 값은 3 W 4입니다.
예를 들어, 3은 임의의 3 점을 취한다는 것을 의미합니다 (물론 점 좌표는 무작위이지만
    미리 정의 된 시드이므로 BRIEF 설명 자의 각 요소는 픽셀 직사각형에서 결정적으로 계산됩니다.) 최대 밝기 점과 승자 출력 인덱스 (0, 1 또는 2)를 찾습니다.
이러한 출력은 2 비트를 차지하므로 해밍 거리의 특수한 변형이 필요합니다.
    NORM_HAMMING2 (bin 당 2 비트)로 표시됩니다.
WTA_K = 4 일 때 각 빈을 계산하기 위해 4 개의 무작위 포인트를 취합니다 (가능한 값 0, 1, 2 또는 3의 2 비트도 차지합니다).

    @param scoreType 기본 HARRIS_SCORE는 해리스 알고리즘을 사용하여 지형지 물의 순위를 매기는 것을 의미합니다.
    (스코어는 KeyPoint :: score에 쓰여지고 최고의 nfeatures 기능을 유지하는 데 사용됩니다);
    FAST_SCORE는 덜 안정적인 키포인트를 생성하는 매개 변수의 대체 값이지만 계산하는 데 약간 빠릅니다.

    @param patchSize 방향성의 기술자가 사용하는 패치의 사이즈입니다. 물론, 피라미드 층이 작 으면, 피사체에 의해 커버되는 인식 된 이미지 영역이 커질 것이다.

    @param fastThreshold

84_25.	warpPerspective & 시계방향90도회전 동시 수행 방법
	/*	상변 Trillcode image 획득 & 분석하기 쉽도록 이미지 변환	*/
	matUp = Mat(m_srcTagImageGrayPerspective.clone(), rectUp);

	//	Source
	//	-	북서(x,y)															-	북동(x,y)	
	//	-	남서(x,y)															-	남동(x,y)	
	src_pts[0] = { 0.0f, 0.0f };											src_pts[1] = { (float)TRILL_CODE_WIDTH2, 0.0f };
	src_pts[2] = { 0.0f, (float)TRILL_CODE_HEIGHT2 };						src_pts[3] = { (float)TRILL_CODE_WIDTH2, (float)TRILL_CODE_HEIGHT2 };

	//	Destination(warp & 수평이동)
	//	-	북서(x,y)															-	북동(x,y)	
	//	-	남서(x,y)															-	남동(x,y)	
	dst_pts[0] = { 0.0f, 0.0f };											dst_pts[1] = { (float)TRILL_CODE_WIDTH2_FIX, 0.0f };
	dst_pts[2] = { 0.0f, (float)TRILL_CODE_HEIGHT2 };						dst_pts[3] = { (float)TRILL_CODE_WIDTH2_FIX, (float)TRILL_CODE_HEIGHT2 };

	matTransform = getPerspectiveTransform(src_pts, dst_pts);
	if (matTransform.empty())
	{
		MESSAGE_BOX_RETURN_MESSAGE("상변 TrillCode, getPerspectiveTransform 에러", eERR_TRILLCODE_ERROR)
	}

	Mat matUp_dst;
	warpPerspective(matUp, matUp_dst, matTransform, Size(TRILL_CODE_WIDTH2_FIX, TRILL_CODE_HEIGHT2));
	if (matUp_dst.empty())
	{
		MESSAGE_BOX_RETURN_MESSAGE("상변 TrillCode, warpPerspective 에러", eERR_TRILLCODE_ERROR)
	}

	matUp = matUp_dst.clone();

	SetDebugFileName("TrillCode Gray - Up");
	SaveDebugImage(matUp);


	/*	좌변 Trillcode image 획득 & 분석하기 쉽도록 이미지 변환	*/
	matLeft = Mat(m_srcTagImageGrayPerspective.clone(), rectLeft);

	//	Source
	//	-	남서(x,y)															-	북서(x,y)	
	//	-	남동(x,y)															-	북동(x,y)	
	src_pts[0] = { 0.0f, (float)TRILL_CODE_WIDTH2 };						src_pts[1] = { 0.0f, 0.0f };
	src_pts[2] = { (float)TRILL_CODE_HEIGHT2, (float)TRILL_CODE_WIDTH2 };	src_pts[3] = { (float)TRILL_CODE_HEIGHT2, 0.0f };

	//	Destination(warp & 시계방향90도회전이동)
	//	-	북서(x,y)															-	북동(x,y)	
	//	-	남서(x,y)															-	남동(x,y)	
	dst_pts[0] = { 0.0f, 0.0f };											dst_pts[1] = { (float)TRILL_CODE_WIDTH2_FIX, 0.0f };
	dst_pts[2] = { 0.0f, (float)TRILL_CODE_HEIGHT2 };						dst_pts[3] = { (float)TRILL_CODE_WIDTH2_FIX, (float)TRILL_CODE_HEIGHT2 };

	matTransform = getPerspectiveTransform(src_pts, dst_pts);
	if (matTransform.empty())
	{
		MESSAGE_BOX_RETURN_MESSAGE("좌변 TrillCode, getPerspectiveTransform 에러", eERR_TRILLCODE_ERROR)
	}

	Mat matLeft_dst;
	warpPerspective(matLeft, matLeft_dst, matTransform, Size(TRILL_CODE_WIDTH2_FIX, TRILL_CODE_HEIGHT2));
	if (matLeft_dst.empty())
	{
		MESSAGE_BOX_RETURN_MESSAGE("좌변 TrillCode, warpPerspective 에러", eERR_TRILLCODE_ERROR)
	}

	matLeft = matLeft_dst.clone();

	SetDebugFileName("TrillCode Gray - Left");
	SaveDebugImage(matLeft);

84_26.	OCR 소스, C++ API 환경
#include <string>
#include <tesseract/baseapi.h>
#include <leptonica/allheaders.h>
#include <opencv2/opencv.hpp>
 
using namespace std;
using namespace cv;
 
int main(int argc, char* argv[])
{
    string outText;
    string imPath = argv[1];
 
    // Create Tesseract object
    tesseract::TessBaseAPI *ocr = new tesseract::TessBaseAPI();
     
    // Initialize tesseract to use English (eng) and the LSTM OCR engine. 
    ocr->Init(NULL, "eng", tesseract::OEM_LSTM_ONLY);
 
    // Set Page segmentation mode to PSM_AUTO (3)
    ocr->SetPageSegMode(tesseract::PSM_AUTO);
 
    // Open input image using OpenCV
    Mat im = cv::imread(imPath, IMREAD_COLOR);
   
    // Set image data
    ocr->SetImage(im.data, im.cols, im.rows, 3, im.step);
 
    // Run Tesseract OCR on image
    outText = string(ocr->GetUTF8Text());
 
    // print recognized text
    cout << outText << endl; // Destroy used object and release memory ocr->End();
   
    return EXIT_SUCCESS;
}

84_27.	Tesseract OCR 인식 프로그램 사용 방법
cf)	https://m.blog.naver.com/tommybee/221307497468
cf)	https://m.blog.naver.com/PostView.nhn?blogId=tommybee&logNo=221307497468&proxyReferer=http%3A%2F%2Fwww.google.com%2Furl%3Fsa%3Dt%26rct%3Dj%26q%3D%26esrc%3Ds%26source%3Dweb%26cd%3D1%26cad%3Drja%26uact%3D8%26ved%3D2ahUKEwj33dedlJbkAhXOM94KHeRtBsAQFjAAegQIBRAB%26url%3Dhttp%253A%252F%252Fm.blog.naver.com%252Ftommybee%252F221307497468%26usg%3DAOvVaw2NoaMVSKxnSr0csvxShLYM
1.	Tesseract 프로그램 설치
	https://github.com/UB-Mannheim/tesseract/wiki
	사이트에서 tesseract-ocr-w64-setup-v5.0.0-alpha.20190708.exe 를 설치 함
2.	설치완료 후
	시작 -> Tesseract-ocr -> Console 실행
3.	윈도우 Console(CMD.EXE)창에서 아래 명령을 실행하면
	OCR문자가 들어 있는 이미지를 읽어서 Text로 Console창에 출력시켜 줌

C:\Program Files\Tesseract-OCR>tesseract --help-extra
Usage:
  tesseract --help | --help-extra | --help-psm | --help-oem | --version
  tesseract --list-langs [--tessdata-dir PATH]
  tesseract --print-parameters [options...] [configfile...]
  tesseract imagename|imagelist|stdin outputbase|stdout [options...] [configfile...]

OCR options:
  --tessdata-dir PATH   Specify the location of tessdata path.
  --user-words PATH     Specify the location of user words file.
  --user-patterns PATH  Specify the location of user patterns file.
  --dpi VALUE           Specify DPI for input image.
  -l LANG[+LANG]        Specify language(s) used for OCR.
  -c VAR=VALUE          Set value for config variables.
                        Multiple -c arguments are allowed.
  --psm NUM             Specify page segmentation mode.
  --oem NUM             Specify OCR Engine mode.
NOTE: These options must occur before any configfile.

Page segmentation modes:
  0    Orientation and script detection (OSD) only.
  1    Automatic page segmentation with OSD.
  2    Automatic page segmentation, but no OSD, or OCR. (not implemented)
  3    Fully automatic page segmentation, but no OSD. (Default)
  4    Assume a single column of text of variable sizes.
  5    Assume a single uniform block of vertically aligned text.
  6    Assume a single uniform block of text.
  7    Treat the image as a single text line.
  8    Treat the image as a single word.
  9    Treat the image as a single word in a circle.
 10    Treat the image as a single character.
 11    Sparse text. Find as much text as possible in no particular order.
 12    Sparse text with OSD.
 13    Raw line. Treat the image as a single text line,
       bypassing hacks that are Tesseract-specific.

OCR Engine modes:
  0    Legacy engine only.
  1    Neural nets LSTM engine only.
  2    Legacy + LSTM engines.
  3    Default, based on what is available.

Single options:
  -h, --help            Show minimal help message.
  --help-extra          Show extra help for advanced users.
  --help-psm            Show page segmentation modes.
  --help-oem            Show OCR Engine modes.
  -v, --version         Show version information.
  --list-langs          List available languages for tesseract engine.
  --print-parameters    Print tesseract parameters.

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 0
Warning, detects only orientation with -l eng
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
Too few characters. Skipping this page
Warning. Invalid resolution 0 dpi. Using 70 instead.
Too few characters. Skipping this page
Error during processing.

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 1
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
Too few characters. Skipping this page
OSD: Weak margin (0.00) for 9 blob text block, but using orientation anyway: 0
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 2
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
Orientation: 0
WritingDirection: 0
TextlineOrder: 2
Deskew angle: 0.0000

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 3
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 4
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 5
Warning: Invalid resolution 0 dpi. Using 70 instead.
~-
al
N
ⓒO
Ov
)
ⓒ
O
| il
'@

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 6
Warning: Invalid resolution 0 dpi. Using 70 instead.
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 7
Warning: Invalid resolution 0 dpi. Using 70 instead.
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 8
Warning: Invalid resolution 0 dpi. Using 70 instead.
(GL00098213_

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 9
Warning: Invalid resolution 0 dpi. Using 70 instead.
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 10
Warning: Invalid resolution 0 dpi. Using 70 instead.
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 11
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 12
Warning: Invalid resolution 0 dpi. Using 70 instead.
Estimating resolution as 733
Too few characters. Skipping this page
OSD: Weak margin (0.00) for 9 blob text block, but using orientation anyway: 0
~6L00098213

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 13
Warning: Invalid resolution 0 dpi. Using 70 instead.
(GL00098213_

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 0 --psm 8
Failed loading language 'eng'
Tesseract couldn't load any languages!
Could not initialize tesseract.

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 1 --psm 8
Warning: Invalid resolution 0 dpi. Using 70 instead.
(GL00098213_

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 2 --psm 8
Failed loading language 'eng'
Tesseract couldn't load any languages!
Could not initialize tesseract.

C:\Program Files\Tesseract-OCR>tesseract "image_GL00098213(white).jpg" stdout -l eng --oem 3 --psm 8
Warning: Invalid resolution 0 dpi. Using 70 instead.
(GL00098213_

C:\Program Files\Tesseract-OCR>


cf)	Android에서의 Tesseract API 소개
2017.08.03 16:17 

OCR의 경우 관련지식이 없으면 API의 이해가 힘들 수 있으므로 소개해 보고자합니다.
버전은 Tesseract 3.05이며 모든 함수명은 tess-two에서 제공하는 TessBaseAPI를 기준으로 합니다. 
C코드로 되어있는 Tesseract 원본의 경우 함수명이 약간 다릅니다만, 함수명이 비슷하고 매개변수도 포인터로 되어있다 뿐이지 원하는 정보는 크게 다를 게 없기 때문에 
원본 Tesseract를 사용하시는 분도 이해하시는 데 큰 문제는 없을겁니다.

1. 가장 기본적인 API
- init(String datapath, String language) : Tesseract를 사용하도록 초기화합니다. datapath는 traineddata가 있는 주소, language는 사용할 언어를 입력하시면 됩니다.( ex. eng / kor / eng+kor )
- setImage(Bitmap bitmap) : 읽어들일 이미지를 지정합니다. 입력값으로 활용할 수 있는 타입은 비트맵, 파일주소, Leptonica에서 사용하는 pix, byte[]로 된 이미지 데이터��� 있습니다.)
- getUTF8Text() : 인식한 결과값을 String형으로 출력합니다.
- end() : 메모리를 해제합니다.

2. 추가 기능 API
- setRectangle(Rect rect) : 전체 이미지에서 원하는 영역만 지정해서 OCR 인식할 때 사용합니다. 
	x, y, width, height값으로 영역을 지정할 수 있고 동일한 결과를 낼 수 있는 방법으로는 전체 이미지에서 createBitmap으로 원하는 영역의 이미지만 crop해서 setImage 후 getUTF8Text를 실행하는 방법이 있습니다.
- setVariable(String var, String value) : 일반적으로 Whitelist나 Blacklist를 사용할 때 사용합니다. 
	WhiteList는 입력한 값만 출력되도록 하는 것이고 BlackList는 입력한 값을 출력에서 배제하는 것입니다. var에는 API에서 제공하는 속성값을 넣고 value에 값을 넣으시면 됩니다.
	*setVariable("VAR_CHAR_WHITELIST", "1234567890") -> 숫자만 출력하고 싶을 때 사용합니다.
	*setVariable("VAR_CHAR_BLACKLIST", "1234567890") -> 출력값에서 숫자를 배제하고 싶을 때 사용합니다.
- setPageSegMode(int mode) : 텍스트 이미지를 인식할 때 분할 방법을 결정합니다. 
	이부분은 OCR의 구동 원리와 가까운 내용이라 자세한 건 나중에 원리에 대해 설명하게 되면 다시 언급하겠습니다. 
	전체를 인식할 땐 기본 모드를 쓰는 게 낫기 때문에 그대로 두시고, 한줄만 읽고 싶으시다면 PSM_SINGLE_LINE을 사용하시는 것을 추천드립니다.

실제로 쓰이는 건 이정도입니다. 그나마도 setVariable은 전처리가 완벽히 확보된 이미지가 아니라면 안쓰시는 것이 인식결과가 좋기 때문에 실제로 자주 사용되는 것은 
필수적인 API를 제외하고는 setRectangle과 setPageSegMode 정도입니다. 다음 Tesseract 관련 포스팅은 Tesseract로 가장 인식률을 높힐 수 있는 방법과 인식률이 떨어지는 사례가 될 것 같습니다.

참고
Android Tesseract Github : https://github.com/rmtheis/tess-two


84_28.	정품인증(Android), Tesseract OCR 인식률 개선 방법

cf)	eng.traineddata등의 *.traineddata 파일 생성 방법
		jTessBoxEditor를 사용해��� 인식시키고자 하는 문자/폰트를 트레이닝시켜서 *.traineddata 파일로 생성시킴

native-lib.cpp

        ///////////////////////// OCR용 태그 이미지 회전보정
        Point2f perspectivePointOCR[4], edgePoint[4];
        int nOCRLength;

        if (nTagShape == TAG_SHAPE_SQUARE)
        {
            nOCRLength = m_nTagWidth / 7 + 60;    // OCR 영역의 세로길이
//            nOCRLength = m_nTagWidth / 7 + 30;    // OCR 영역의 세로길이

            perspectivePointOCR[0] = {0.0f, 0.0f};
            perspectivePointOCR[1] = {(float) m_nTagWidth, 0.0f};
            perspectivePointOCR[2] = {0.0f, (float) nOCRLength};
            perspectivePointOCR[3] = {(float) m_nTagWidth, (float) nOCRLength};

            Point2f edgePoint[4];

            edgePoint[0].x = m_edgePoint[2].x;
            edgePoint[0].y = m_edgePoint[2].y;
            edgePoint[1].x = m_edgePoint[3].x;
            edgePoint[1].y = m_edgePoint[3].y;

            dx = (int) (m_edgePoint[2].x - m_edgePoint[0].x);
            dy = (int) (m_edgePoint[2].y - m_edgePoint[0].y);

            edgePoint[2].x = m_edgePoint[2].x + (nOCRLength * dx) / m_nTagWidth;
            edgePoint[2].y = m_edgePoint[2].y + (nOCRLength * dy) / m_nTagWidth;

            dx = (int) (m_edgePoint[3].x - m_edgePoint[1].x);
            dy = (int) (m_edgePoint[3].y - m_edgePoint[1].y);

            edgePoint[3].x = m_edgePoint[3].x + (nOCRLength * dx) / m_nTagWidth;
            edgePoint[3].y = m_edgePoint[3].y + (nOCRLength * dy) / m_nTagWidth;

            matTransform = getPerspectiveTransform(edgePoint, perspectivePointOCR);
            if (matTransform.empty())
                return eERR_PERSPECTIVE_TRANSFORM_MAT;

            Mat srcOCRColorPerspective = m_srcTagImageColor.clone();

            warpPerspective(m_srcTagImageColor, srcOCRColorPerspective, matTransform, cv::Size(m_nTagWidth, nOCRLength));

			// add
			/*	이곳 warpPerspective 바로 직후 m_srcTagImageColorPerspective에 whiteBalance 적용
				ex) 실제 테스트를 통해 효과 있음 확인 완료, 포장지에 광원이 direct를 비춘 경우(역광이 비춘 경우처럼 된 경우) 본 whiteBalance를 적용하면 어두운 영상을 밝은 영상으로(명암차이 높음) 변화시켜 줌	*/
//			SaveImage("srcOCRColorPerspective(origin)", srcOCRColorPerspective);
			whiteBalance(srcOCRColorPerspective, srcOCRColorPerspective, 1);
//			SaveImage("srcOCRColorPerspective(whiteBalance)", srcOCRColorPerspective);
			// add

            cvtColor(srcOCRColorPerspective, srcOCRColorPerspective, CV_BGRA2GRAY);

            Mat bw, bwCopy, matBlack;
            threshold(srcOCRColorPerspective, bw, 0, 255, CV_THRESH_BINARY_INV | CV_THRESH_OTSU);

			#if false
            const double HTHRESH = srcOCRColorPerspective.rows * 0.3;    // height threshold
            vector<vector<cv::Point>> contours;
            vector<Vec4i> hierarchy;

            bwCopy = bw.clone();

            matBlack = Mat(srcOCRColorPerspective.rows, srcOCRColorPerspective.cols, CV_8UC1, Scalar::all(0));

            findContours(bwCopy, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));

            Mat binary = Mat(srcOCRColorPerspective.rows, srcOCRColorPerspective.cols, CV_8UC3, Scalar::all(0));
            for (int idx = 0; idx >= 0; idx = hierarchy[idx][0])
            {
                cv::Rect rect = boundingRect(contours[idx]);
                if (rect.height > HTHRESH)
                {
                    rectangle(binary, cv::Point(rect.x, rect.y), cv::Point(rect.x + rect.width - 1, rect.y + rect.height - 1), Scalar(0, 0, 255), 1);

                    for (int h = rect.y; h < rect.y + rect.height; h++)
                        for (int w = rect.x; w < rect.x + rect.width; w++)
                            matBlack.at<unsigned char>(h, w) = bw.at<unsigned char>(h, w);
                }
            }

            m_srcTagOCR = matBlack.clone();
			#elif false
			// fix,	Contour를 제대로 처리해주지 못해서 OCR문자를 잘라서 App으로 보내주는 등 문제 발생
			//		이에, 차라리 Contour는 skip 시키고 "OCR threshold"까지 만의 이미지로 OCR인식 시키도록 수정 함
			m_srcTagOCR = bw.clone();
			// fix
			#elif false
			if(g_nOCRDispOff != 0)
				// g_nOCRDispOff flag가 1인 경우(OCR표시OFF) m_srcTagOCR을 검정색 사각형으로 변경시켜서 App으로 전송시켜
				// App에서는 OCR이 없는것으로 처리되게 함
				m_srcTagOCR = Mat(srcOCRColorPerspective.rows, srcOCRColorPerspective.cols, CV_8UC1, Scalar::all(0));
			else
				// fix,	Contour를 제대로 처리해주지 못해서 OCR문자를 잘라서 App으로 보내주는 등 문제 발생
				//		이에, 차라리 Contour는 skip 시키고 "OCR threshold"까지 만의 이미지로 OCR인식 시키도록 수정 함
				m_srcTagOCR = bw.clone();
				// fix
			#else
			// fix,	Contour를 제대로 처리해주지 못해서 OCR문자를 잘라서 App으로 보내주는 등 문제 발생
			//		이에, 차라리 Contour는 skip 시키고 "OCR threshold"까지 만의 이미지로 OCR인식 시키도록 수정 함
			//		추가적으로, OCR처리의 기본이 백색바탕의 검정색글자이기 때문에 threshold 처리도 skip 시킴(-> 본 사항 적용하면 OCR인식률 향상됨)
			m_srcTagOCR = srcOCRColorPerspective.clone();
			// fix
			#endif
        }
        ///////////////////////// OCR용 태그 이미지 회전보정 종료


ScanActivity.java
	private String TESSBASE_PATH = "/storage/emulated/0/TesseractSample/";
	private String TESS_DATA_PATH = "tessdata";
//	private String DEFAULT_LANGUAGE = "NanumSquare";
	// fix
//	private String DEFAULT_LANGUAGE = "OCRA";		//  GL00061169를 GLooooT , og로 읽음
	private String DEFAULT_LANGUAGE = "eng";		//	GL00061169를 GL00061169로 거의 대부분 정확하게 읽음(기존 보다 확실하게 인식률 향상됨), eng.traineddata파일을 tessdata 폴더에 추가시키고 DEFAULT_LANGUAGE = "eng";로 변경
	// fix
	private String REGISTER_LANGUAGE = "OCRA";
//    private String DEFAULT_LANGUAGE = "eng";
	private TessBaseAPI baseApi = new TessBaseAPI();


ScanActivity.java
	/**
	 * ocr 초기화
	 */
	private void initOcrApi() {
		TESSBASE_PATH = getFilesDir().getAbsolutePath() + "/";

		try {
			copyTessdataToStorage();
		} catch (Exception e) {
			e.printStackTrace();
		}
		baseApi.init(TESSBASE_PATH, DEFAULT_LANGUAGE);
//        baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_LINE);
//        String blackList = "!@#$$%^&*()-_+=/?<>'\''";
//        baseApi.setVariable(TessBaseAPI.VAR_CHAR_BLACKLIST, blackList);
		// fix
//		Default, 아래 설정을 아무것도 하지 않은 경우
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_OSD_ONLY);						// PSM_OSD_ONLY = 0, 아예 OCR 읽지 못함
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_AUTO_OSD);						// 1,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_AUTO_ONLY);						// 2,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_AUTO);							// 3,	Default와 동일한 인식률
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_COLUMN);					// 4,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_BLOCK_VERT_TEXT);			// 5,	GL00061169를 .9로 읽음(GL00061169에서가장마지막문자9), Vertical로 읽음
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_BLOCK);					// 6,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_LINE);					// 7,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_WORD);					// 8,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_CIRCLE_WORD);					// 9,
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SINGLE_CHAR);					// 10,	GL00061169를 W로 읽음
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SPARSE_TEXT);					// 11
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_SPARSE_TEXT_OSD);				// 12
//		baseApi.setPageSegMode(TessBaseAPI.PageSegMode.PSM_RAW_LINE);						// 13,	GL00061169를 7GL00<>61169로 읽음
		String blackList = "!@#$$%^&*()-_+=/?<>'\''i";
		baseApi.setVariable(TessBaseAPI.VAR_CHAR_BLACKLIST, blackList);						// 본 설정을 추가하니 인식률 확실히 좋아짐
		// fix
		makeFolder();
		mOcrTask = new OCRTask();
	}


TessBaseAPI.java
    public boolean init(String datapath, String language) {
		return init(datapath, language, OEM_DEFAULT);
		// temp, 아래와 같이 변경해도 GL00061169를 GLDDD61169로 읽음
//		return init(datapath, language, OEM_TESSERACT_ONLY);
		// temp
    }






84_29.	OpenCV 손글씨 학습시키기(kNN, KNearest)(Python)
아래 예제는 학습할 때 마다(random) 인식률 차이가 발생 함
-	1회 학습 :  인식률 50%
-	4회 학습 :	인식률 100%

import numpy as np
import cv2

def resize20(digitImg):
    img = cv2.imread(digitImg)
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    ret = cv2.resize(gray, (20, 20), fx=1, fy=1, interpolation=cv2.INTER_AREA)
    
    ret, thr = cv2.threshold(ret, 127, 255, cv2.THRESH_BINARY_INV)
    
    cv2.imshow('ret', thr)
    
    return thr.reshape(-1, 400).astype(np.float32)
    
def learningDigit():
    img = cv2.imread('images/digits.png')
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    cells = [np.hsplit(row, 100) for row in np.vsplit(gray, 50)]
    x = np.array(cells)
    
    train = x[:, :].reshape(-1, 400).astype(np.float32)
    
    k = np.arange(10)
    train_labels = np.repeat(k, 500)[:, np.newaxis]
    
    np.savez('digits_for_ocr.npz', train=train, train_labels=train_labels)
    print('data saved')
    
def loadLearningDigit(ocrdata):
    with np.load(ocrdata) as f:
        traindata = f['train']
        traindata_labels = f['train_labels']
        
    return traindata, traindata_labels
    
def OCR_for_Digits(test, traindata, traindata_labels):
    knn = cv2.ml.KNearest_create()
    knn.train(traindata, cv2.ml.ROW_SAMPLE, traindata_labels)
    ret, result, neighbors, dist = knn.findNearest(test, k=5)
    
    return result
    
def main():
    #learningDigit() #이미지 학습할때 주석제거
    #return
    ocrdata = 'digits_for_ocr.npz'
    traindata, traindata_labels = loadLearningDigit(ocrdata)
    digits = ['images/' + str(x) + '.png' for x in range(10)]
    
    print(traindata.shape)
    print(traindata_labels.shape)
    
    savenpz = False
    for digit in digits:
        test = resize20(digit)
        result = OCR_for_Digits(test, traindata, traindata_labels)
        
        print(result)
        
        k = cv2.waitKey(0)
        if k > 47 and k < 58:
            savenpz = True
            traindata = np.append(traindata, test, axis=0)
            new_label = np.array(int(chr(k))).reshape(-1, 1)
            traindata_labels = np.append(traindata_labels, new_label, axis=0)
            
    cv2.destroyAllWindows()
    if savenpz:
        np.savez('digits_for_ocr.npz', train=traindata, train_labels=traindata_labels)
        
main()

[출처] [OpenCV] 손글씨 학습시키기|작성자 버들피리


84_30.	OpenCV 인쇄된 OCR 숫자 인식시키기(kNN, KNearest)(C++)
KNN_number.cpp
#include "kNN.hpp"

//-- 학습결과)	기존 Noise가 많아서 엉뚱하게 인식되던(ex) Noise가 많은 숫자1을 4로 인식) 문제가 제거되어
//				Noise가 많은 숫자1도 1로 인식 함		--//
int main()
{
	//--	학습실행 / 학습데이터저장		--//
	Size  size(40, 40);			// 학습 셀 크기 
	int  K = 15;				// 선출하는 이웃 샘플수
	int  Nclass = 10;			// 인식 숫자(카테고리) 개수
	int  Nsample = 20;		// 숫자당 학습 샘플수

#if true
//	string image_file = "../image/train_numbers.png";
//	string image_file = "../image/train_numbers_hangeul(grid).png";
	string image_file = "../image/train_numbers_fix.png";
	Mat  train_image = imread(image_file, 0);		// 영상 로드
	CV_Assert(train_image.data);

	//	threshold(train_image, train_image, 32, 255, CV_THRESH_BINARY);
	// fix
	//--	(중요) 하기와 같이 threshold를 설정해 주고 하단 Test에서도 threshold(test_img3, test_img4, 128, 255, THRESH_BINARY); 와 같이 threshold를 동일하게 설정해줘야지만
	//		Noise등이 많은 Test image도 옳바른 결과값으로 인식시켜 줌
	//		ex)	이렇게 하지 않으면 Noise가 많은 1번 숫자의 경우 4번으로 인식하는 문제 발생 함	--//
	threshold(train_image, train_image, 128, 255, THRESH_BINARY);
	// fix

	Mat  trainData, classLable;
	for (int i = 0, k = 0; i < Nclass; i++) {
		for (int j = 0; j < Nsample; j++, k++)
		{
			Point start(j * size.width, i * size.height);
			Rect  roi(start, size);
			Mat   part = train_image(roi);			// 숫자 영상 분리
			// temp
			imshow("part", part);
			int key = waitKey(10);				// 본 명령 실행해야지만 상기 imshow명령에 의한 이미지 볼 수 있음
			// temp

			Mat  num = find_number(part);		// 숫자 영역 영상
			Mat  data = place_middle(num, size);	// 정규화 및 1행데이터 구성
			// temp
			#if false
			int iColsNum = data.cols;
			cout << "iColsNum : " << iColsNum << endl;		// iColsNum = 1600 = 40x40

			//--	실제테스트 결과
			//		1.	아래 data.at<float>(i)의 값은 하기와 같은 형식으로 나오며
			//			255	255	255	255	255	255	255	255	255	255	255	255	255	255	249	134	19	0	0	0	0	0	0	0	0	0	108	223	255	255	255	255	255	255	255	255	255	255	255	255
			//		2.	본 data값을 40열 x 40행으로 나열지어서 보면
			//			첫번째 trainData의 경우 '0'의 모양임을 알 수 있음
			//		->	따라서, 결론적으로 아래 trainData에는 모든 숫자의 raw data가 들어가 있음을 알 수 있음
			cout << "data : " << endl;
			for(int i = 0; i < iColsNum; i++)
			{
				cout << data.at<float>(i) << endl;
			}
			#endif
			// temp
			trainData.push_back(data);		// 학습 데이터 수집
			classLable.push_back(i);		// 레이블링
			// temp
//			classLable.push_back(i + 10);		// 레이블링
			// temp
		}
	}

	Ptr<ml::KNearest>  knn = ml::KNearest::create();
	knn->train(trainData, ml::ROW_SAMPLE, classLable);	// k-NN 학습

	knn->save("./test.knn");
#endif


	//--	학습데이터 load / 실제테스트
	//		1.	매번 상단에서 Train 시킨 다음 하단에서 Test 시키는 것이 아닌
	//		2.	상단에서 한번 Train 시킨 데이터를 저장시키고
	//			이후, 하단에서는 이를 읽어들여서 Test시키려면
	//			- Ptr<ml::KNearest> knn2 = ml::KNearest::load<ml::KNearest>("./test.knn"); 명령으로 Train 데이터를 읽어 들이고
	//			- 하단에서 knn2->findNearest(data, K, result); 명령과 같이 knn2를 사용해서 Test 시키면 됨	--//
	Ptr<ml::KNearest> knn2 = ml::KNearest::load<ml::KNearest>("./test.knn");

	while (true)
	{
		int no;
		cout << "영상번호를 입력하세요: ";
		cin >> no;									// 영상번호 입력

		string demo_file = format("../image/num/%02d.png", no);
//		string demo_file = format("../image/num/%03d.png", no);
		Mat  test_img = imread(demo_file, 0);			// 실험 영상 로드
		Mat  test_img2, test_img3, test_img4;
		CV_Assert(test_img.data);						// 예외처리
		imshow("test_img", test_img);

		normalize(test_img, test_img2, 0, 255, NORM_MINMAX);
		imshow("test_img2", test_img2);
		
		resize(test_img2, test_img3, size);					// 크기 변경
		imshow("test_img3", test_img3);

		threshold(test_img3, test_img4, 128, 255, THRESH_BINARY);	// 이진화
//		threshold(test_img3, test_img4, 32, 255, THRESH_BINARY);	// 이진화
		imshow("test_img4", test_img4);

		Mat  num = find_number(test_img4);				// 숫자객체 검출
		Mat  data = place_middle(num, size);			// 숫자객체 셀 중심 배치 

		Mat result;
		knn->findNearest(data, K, result);				// 숫자 분류 수행
//		knn2->findNearest(data, K, result);				// 숫자 분류 수행
		cout << "분류결과 : " << result.at<float>(0) << endl;

		int key = waitKey(3000);
		cout << "key : " << key << endl;
		if (key == 27)
			break;
	}
	return 0; 
}


kNN.hpp
#include <opencv2/opencv.hpp>
using namespace cv;
using namespace std;

void find_histoPos(Mat img, int & start, int &end, int direct)
{
	reduce(img, img, direct, REDUCE_AVG);

	int  minFound = 0;
	for (int i = 0; i< (int)img.total(); i++) {
		if (img.at<uchar>(i) < 250) 		// 빈라인이 아니면
		{
			end = i;					// 히스토그램 마지막 위치
			if (!minFound) {
				start = i;			// 히스토그램 첫 위치
				minFound = 1;
			}
		}
	}
}

Mat find_number(Mat part)
{
	Point start, end;
	find_histoPos(part, start.x, end.x, 0);		// 수직 투영 
	find_histoPos(part, start.y, end.y, 1);   	// 수평 투영 

	// add
	//--	(중요) 본 명령을 추가해야지만 입력된 숫자이미지가 잘리는(특히 숫자 왼쪽부분이 잘림) 문제 없어 짐	--//
	int iEndX = end.x + 2;
	int iEndY = end.y + 2;

	if (iEndX <= part.cols)
		end.x = iEndX;
	if (iEndY <= part.rows)
		end.y = iEndY;
	// add

	return part(Rect(start, end));			// 숫자객체 영상
}

Mat  place_middle(Mat number, Size new_size)
{
	int  big = max(number.cols, number.rows);
	Mat  square(big, big, number.type(), Scalar(255));	// 정방영상

	Point start = (square.size() - number.size()) / 2;
	Rect middle(start, number.size());					// 중앙 관심영역
	number.copyTo(square(middle));						// 숫자객체를 중앙에 복사	
	
	resize(square, square, new_size);					// 크기 변경
	// temp
	imshow("square", square);
	// temp
	square.convertTo(square, CV_32F);
	return square.reshape(0, 1);						// 1행 데이터 변경후 반환
}

84_31.	OCR인식의 경우 knn보다 svm이 더 정확도가 높다
cf)	SVM이 개발되었을 때 간단한 분류 문제에 대해 최고 수준의 성능을 달성했고 광범위한 이론으로 무장된 몇 안 되는 머신러닝
방법 중 하나가 되었습니다. 또 수학적으로 깊게 분석하기 용이하여 이론을 이해하고 설명하기 쉽습니다.
이런 유용한 특징 때문에 SVM이 오랫동안 머신 러닝 분야에서 매우 큰 인기를 끌었습니다.
하지만 SVM은 대용량의 데이터셋에 확장되기 어렵고 이미지 분류 같은 지각에 관련된 문제에서 좋은 성능을 내지 못했습니다.
SVM은 얕은 학습 방법이기 때문에 지각에 관련된 문제에서 SVM을 적용하려면 먼저 수동으로 유용한 표현을 추출해야 하는데
(이런 단계를 특성공학이라고 합니다) 이는 매우 어렵고 불안정합니다.
cf)	딥러닝은 자연어 처리 같은 다른 종류의 문제에도 적용되었습니다. 다양한 애플리케이션에서 SVM과 결정 트리를 완전히 대체하고 있습니다.

https://qkqhxla1.tistory.com/440

OCR of Hand-written Data using SVM 
http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_ml/py_svm/py_svm_opencv/py_svm_opencv.html

앞의 knn의 예제에서는 단순히 knn으로 분류하고 글자를 정하는것까지 다 했었는데, 
이번에는 hog란걸로 특징점을 찾고, svm으로 글자들을 구분할 것이다. hog라는건 각각 글자들의 특징벡터를 찾아서 특징들을 기억해놓는거라고 보면 된다.
hog : https://en.wikipedia.org/wiki/Histogram_of_oriented_gradients

hog와 svm의 조합을 사용해보면서 느낀점은, knn만 사용하는것보다 많이 정확도가 높다는것이다. 
knn이 단순히 픽셀의 위치중 가까운 위치들을 찾아서 같은지를 판별하는 알고리즘이라면, 
hog는 이미지의 특정한 부분을 찾아서 판별하기 때문에 저번의 http://qkqhxla1.tistory.com/362 여기서 다뤘던 SIFT였나 그 알고리즘처럼 
글자가 살짝 우그러지더라도 더 판별을 잘하는것 같다.

그리고 knn은 픽셀 위치에서 가장 가까운 픽셀을 근거로 판단하기 때문에 트레이닝 데이터가 
내가 실행할 테스트 데이터와 글자의 위치가 다르면(트레이닝 데이터는 20*20의 중앙에 글자가 있다고 하면 테스트 데이터는 글자가 오른쪽에 붙는다던가 등등) 
그런것에서도 인식률이 떨어지는 것 같다. (knn의 속은 깊숙히 파보지 못해서 이게 맞는지는 모르겠는데 여러 이미지로 삽질해본 결과 이렇게 결론 내렸다.)

svm에 관련된 글을 가볍게 읽어봤다. 
http://opencv-python-tutroals.readthedocs.org/en/latest/py_tutorials/py_ml/py_svm/py_svm_basics/py_svm_basics.html#svm-understanding
가장 이해가 잘됬던 그림.
이 svm이란게 트레이닝을 많이하면 많이할수록 검출력이 높아지는데 그 검출력이란게 위의 그림에서 
원과 사각형을 나누는 선분이 더 정교해진다는 소리이다. 그런데 저번에 wechall의 crackcha였나 그 문제를 삽질하면서 느낀건데 
빅데이터,영상처리 등등 이쪽은 알고리즘 한번 확인을 위해서 트레이닝할 데이터들을 만들고, 트레이닝하고 판별하고 전체적으로 
일반적인 코딩보다 상당히 많은 시간이 들어간다. 처음 하는 사람들은 코딩에 익숙하지 않으면 몇일동안 이것만 삽질해도 못하는 경우가 많을것같다.

참고를 위해 간단하게 하나 트레이닝후 판별하는 코드를 올리겠다.
트레이닝 데이터를 가지고 기본적으로 트레이닝하고, 비슷한 이미지를 찾는 예제.

1. 현재 파이썬 스크립트와 같은 디렉터리에 train이라는 폴더가 있으며, 
train폴더 내부에는 Sample001~Sample016 디렉터리가 있다. 
Sample001은 숫자 0, Sample002는 숫자 1, ~~Sample010은 숫자 9, Sample011은 영어 A, Sample016은 F가 여러가지 글자체로 들어있다.

# -*- encoding: cp949 -*-
#현재 파일 경로 : file_path = "%s%s" % (os.path.dirname(os.path.realpath(__file__))+"\\", filename)
import os
import Image
b = Image.new('RGB', (2000,2240), (255, 255, 255)) #한글자당 20*20크기, 100개를 트레이닝 시킬것이므로 X는 20*100인 2000, 글자가 16개이므로(0~9,A~F)면서 한글자당 7줄을 만들 것이므로 Y는 20*16*7인 2240.
 
cnt = 0
y = 0
for all_dirname, inner_dirnames, all_filenames in os.walk('train'):
    for i in inner_dirnames:
        for a,dir,f in os.walk('train\\'+i):
            x = 0
            for file in f:
                if file != 'Thumbs.db':
                    if x==100: 
                        x=0
                        y += 1
                    b.paste(Image.open('train\\'+i+'\\'+file),(x*20,y*20))
                    cnt += 1
                    if cnt==800:
                        cnt = 0
                        break
                x += 1
b.save('zero2.png') #zero2.png라는 이름으로 만든다.
 
요렇게 나누어져 있던것들이 zero2.png에는
이렇게 정렬되어 들어간다. 만들기 귀찮으면 이거 다운받아서 쓰길... (한글자당 20*20의 크기)

2. 이렇게 정렬된 사진들을 트레이닝해서 svm으로 처리해보자.
# -*- encoding: cp949 -*-
import cv2
import numpy as np
 
SZ=20
bin_n = 16 # Number of bins
 
svm_params = dict( kernel_type = cv2.SVM_LINEAR,
                    svm_type = cv2.SVM_C_SVC,
                    C=2.67, gamma=5.383 )
 
affine_flags = cv2.WARP_INVERSE_MAP|cv2.INTER_LINEAR
 
def deskew(img):
    m = cv2.moments(img)
    if abs(m['mu02']) < 1e-2:
        return img.copy()
    skew = m['mu11']/m['mu02']
    M = np.float32([[1, skew, -0.5*SZ*skew], [0, 1, 0]])
    img = cv2.warpAffine(img,M,(SZ, SZ),flags=affine_flags)
    return img
 
def hog(img):
    gx = cv2.Sobel(img, cv2.CV_32F, 1, 0)
    gy = cv2.Sobel(img, cv2.CV_32F, 0, 1)
    mag, ang = cv2.cartToPolar(gx, gy)
    bins = np.int32(bin_n*ang/(2*np.pi))    # quantizing binvalues in (0...16)
    bin_cells = bins[:10,:10], bins[10:,:10], bins[:10,10:], bins[10:,10:]
    mag_cells = mag[:10,:10], mag[10:,:10], mag[:10,10:], mag[10:,10:]
    hists = [np.bincount(b.ravel(), m.ravel(), bin_n) for b, m in zip(bin_cells, mag_cells)]
    hist = np.hstack(hists)     # hist is a 64 bit vector
    return hist
 
img = cv2.imread('zero2.png',0)
 
cells = [np.hsplit(row,100) for row in np.vsplit(img,112)]
 
# First half is trainData, remaining is testData
train_cells = [ i[:50] for i in cells ]
test_cells = [ i[50:] for i in cells]
 
######     Now training      ########################
 
deskewed = [map(deskew,row) for row in train_cells]
hogdata = [map(hog,row) for row in deskewed]
trainData = np.float32(hogdata).reshape(-1,64)
responses = np.float32(np.repeat(np.arange(16),350)[:,np.newaxis])
 
svm = cv2.SVM()
svm.train(trainData,responses, params=svm_params)
svm.save('svm_data.dat')
 
######     Now testing      ########################
 
deskewed = [map(deskew,row) for row in test_cells]
hogdata = [map(hog,row) for row in deskewed]
testData = np.float32(hogdata).reshape(-1,bin_n*4)
result = svm.predict_all(testData)
 
#######   Check Accuracy   ########################
mask = result==responses
correct = np.count_nonzero(mask)
print correct*100.0/result.size
 
내가 만든 zero2.png를 반은 트레이닝하고 반은 테스트해봤는데 95%의 정확도가 나온다. 
동일한 사진으로 knn이 70%정도?의 정확도가 나왔었는데(기억이 잘 안남) svm은 훨씬 정확도가 높고 믿음직하다. 

지금까지 공부하면서 생각한건데 knn은 비슷한 그림?을 찾는 느낌이고, svm이 ocr에 더 적합한 그런 알고리즘같다.
출처: https://qkqhxla1.tistory.com/440 [archives]

84_32.	OpenCV에서 QR코드 인식
1.	OpenCV 4.0.0 이상 부터	QR을 자동으로 읽어주기는 기능 사용
cf)	1.바코드 추천 라이브러리
1.ZXing : 
1.따로 라이브러리가 있는건 아니다.
2.오픈소스 가져와서 통합 해야된다.(유지 관리가 힘들다)
3.업데이트가 잘된다. 
4.인식율이 좋다.
5.

2.Zbar
1.따로 라이브러리가 존재한다
2.인식율이 좋지 않다
3.12년도 이후로 거의 개선이 되지 않았다.
4.https://github.com/dm77/barcodescanner
3.Google
1.Mobile Vision API
1.SurceView로 바로 스캔해서 읽어 드린다.
2.Defrecated 됐다. ML Kit api 사용 권장
3.

2.ML Kit API
1.Firebase 기반으로 된다.
1.https://firebase.google.com/docs/ml-kit/android/read-barcodes
2.https://github.com/firebase/quickstart-android/tree/master/mlkit
2.카메라로 찍은 이미지를 이용해야된다.
3.

1)	[최종결론]
	###	OpenCV 4.0.0 부터 제공하는 QRCodeDetector Library를 사용해서 QR코드를 읽자

	cf)	이유
		1)	Zbar가 QRCodeDetector 보다 더 인식 성능과 속도가 좋다고는 하지만
			Zbar도 모든 QR코드를 읽는 것은 아니고(QR코드 내부에 다른 문자 삽입 등 오염이 많으면 못 읽음)
		2)	QRCodeDetector의 경우도 morphologyEx 명령으로 QR코드 내부 오염 제거 및
			setEpsX / setEpsY 설정값을 변경해 가면서 QR코드를 읽으면 100% 모든 QR(태그 중간에 QR삽입 등)을 인식하기 때문에
		->	QRCodeDetector Library를 사용해서 QR코드를 읽는 방식 사용하자
		cf)	단 아래 TEXT 예제와 같이 Data 용량이 큰 경우는
			Zbar 의 경우 1초 이내 QR해석 vs QRCodeDetector 의 경우 3초 정도 QR해석 속도가 느리지만
			일반적인 URL QR해석(ex, https://     ~    .com/nm/43/47/95R4s446L0/09000106/qr/8809610270689A2000014704)의 경우는 1초 둘 다 1초 이내로 빠르게 QR해석하기 때문에
			QR인식 속도가 느려 QRCodeDetector를 사용하지 못하는 것은 아님
			ex)	TEXT = 33.3 AHA AMA ART ASK BIG BIN BIT BOY CAM CAN CAY DAY DEV EAT EEL ERR FOX FUN GAG GENCO GOD GOL GULAN HEP HES HIT IFF ISM JOY KAL KEL KUL LOL MEN MOM NON OFF OHH PIT POT RED SIK SOK THE THY TWO UGH ULU UPS WAR WAY WOK VAZ YAK YAZ YOK YOL ZIP ZOO ZZZ

2)	[결론]
	QR코드를 제대로 읽으려면 OpenCV에서 제공하는 QR Reading 기능 보다
	ZBar library를 이용해서 읽어야 함

	속도
	ZBar 라이브러리는 OpenCV QR 코드 검출기보다 거의 두 배 빠릅니다.

	견고성
	ZBar 라이브러리는 위의 비디오에서 볼 수 있듯이 다음 요소에 대해 OpenCV와 비교할 때보다 강력한 결과를 제공합니다.
	-	ZBar는 다양한 회전에서 더 좋거나 비슷합니다.
	-	ZBar는 비디오의 다른 줌 레벨에서 볼 때 다른 이미지 크기에서 더 좋습니다
	-	ZBar는 원근 왜곡을 처리하는 데 더 좋습니다 (이미지가 카메라에서 똑바로 세워지지 않은 경우).

	풍모
	ZBar 라이브러리는 OpenCV에는 아직없는 바코드도 지원합니다.

	총평
	전반적으로 QR 코드가 최근 OpenCV에서 시작되었으며 향후 릴리스에서 더 나아질 수 있다고 말할 수 있습니다. 
	그때까지 애플리케이션에서 바코드 또는 QR 코드를 사용하려면 ZBar를 사용하십시오.

EX)
Mat  preprocessing(Mat image)
{
	Mat gray;

	// temp
	imshow("image_src", image);
	// temp

	cvtColor(image, gray, COLOR_BGR2GRAY);							// 명암도 영상 변환
	normalize(gray, gray, 0, 255, NORM_MINMAX);						// normalize / 명암비 최대로 변경

	// temp
	imshow("gray & normalize", gray);
	// temp

	return gray;
}

Mat  preprocessing3(Mat image)
{
	Mat gray, th_img;
	double sigma = 1.4;

//	GaussianBlur(image, gray, Size(5, 5), sigma, sigma);				// 블러링(blur 처리 하는 것이 최종 Noise가 적은 th_img 를 만들어줌)
//	// temp
//	imshow("GaussianBlur", gray);
//	// temp

	th_img = image.clone();

	#if true
	/**
	cv2.MORPH_RECT : 직사각형 모양으로 매트릭스를 생성
	cv2.MORPH_ELLIPSE : 타원 모양으로 매트릭스를 생성
	cv2.MORPH_CROSS : 십자 모양으로 매트릭스를 생성
	중요)	문자를 morphologyEx 하는 경우 getStructuringElement(MORPH_ELLIPSE, ~ 를 사용하자
	이유)	getStructuringElement(MORPH_RECT, ~ 설정 보다 getStructuringElement(MORPH_ELLIPSE, ~ 설정이
			morphologyEx(~, MORPH_OPEN, ~ 처리 시 검정색 글자의 끊어짐 현상을 더 많이 제거시켜 줌(끊어져 있던 검정색 글자가 더 많이 이어짐)	*/
	Mat kernel = getStructuringElement(MORPH_RECT, cv::Size(2, 2));
	Mat kernel2 = getStructuringElement(MORPH_RECT, cv::Size(3, 3));
	Mat kernel3 = getStructuringElement(MORPH_RECT, cv::Size(5, 5));

	/** @brief Performs advanced morphological transformations.
	@param src Source image. The number of channels can be arbitrary. The depth should be one of
	CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
	@param dst Destination image of the same size and type as source image.
	@param op Type of a morphological operation, see #MorphTypes
	@param kernel Structuring element. It can be created using #getStructuringElement.
	@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
	kernel center.
	@param iterations Number of times erosion and dilation are applied.
	@param borderType Pixel extrapolation method, see #BorderTypes
	@param borderValue Border value in case of a constant border. The default value has a special
	meaning.
	@sa  dilate, erode, getStructuringElement
	@note The number of iterations is the number of times erosion or dilatation operation will be applied.
	For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
	successively: erode -> erode -> dilate -> dilate (and not erode -> dilate -> erode -> dilate).

	cv2.MORPH_OPEN : Opening을 수행
	cv2.MORPH_CLOSE : Closing을 수행
	cv2.MORPH_GRADIENT : Dilation 이미지와 Erosion 이미지의 차이를 나타냄
	cv2.MORPH_TOPHAT : 원본 이미지와 opening한 이미지의 차이를 나타냄
	cv2.MORPH_BLACKHAT : closing한 이미지와 원본 이미지의 차이를 나타냄	*/

	/*	주의)	본 morphologyEx 명령을 실행하면 할 수록 원본 이미지 대비 변경 이미지가 우측/하단으로 점점 shift되는 문제 있음
				하지만 본 경우는 Mat kernel3 = getStructuringElement(MORPH_ELLIPSE, cv::Size(4, 4)); 와 같이 Size를 짝수(4, 4)로 설정한 경우 발생하는 문제로
				(5, 5)와 같이 홀수로 설정하면 본 문제 발생하지 않음	*/
//	morphologyEx(gray, gray, MORPH_CLOSE, kernel2, cv::Point(-1, -1), 2);
//	imshow("gray_morph_close", gray);
	#endif

//	threshold(gray, th_img, 32, 255, THRESH_BINARY | THRESH_OTSU);
	/*	adaptiveThreshold
		cf)	이전 Section에서의 결과를 보면 한가지 문제점이 있습니다. 임계값을 이미지 전체에 적용하여 처리하기 때문에 하나의 이미지에 음영이 다르면 일부 영역이 모두 흰색 또는 검정색으로 보여지게 됩니다.
			이런 문제를 해결하기 위해서 이미지의 작은 영역별로 thresholding을 하는 것입니다. 이때 사용하는 함수가 cv2.adaptiveThreshold() 입니다.
			-	기존 threshold의 경우 기준값 보다 작으면 흑 기준값 보다 크면 백 등 너무 기준값에 의해서 백/흑이 확연하게 갈리기 때문에 threshold 이후 이미지가 백과 흑 부분이 확연하게 구분되는 문제 있음
			-	adaptiveThreshold의 경우 이를 보완해서 작은 영역별로 ex)평균값에 대한 threshold 등을 거쳐서 보다 세밀하게 흑/백을 분리시켜 줌

			cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)
			Parameters:
			-	src – grayscale image
			-	maxValue – 임계값
			-	adaptiveMethod – thresholding value를 결정하는 계산 방법
			-	thresholdType – threshold type
			-	blockSize – thresholding을 적용할 영역 사이즈
			-	C – 평균이나 가중평균에서 차감할 값	*/
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 17, 3);
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 19, 5);	// OCR이미지에서 문자를 가장 Noise 없이 이진화 시켜주는 Setting(ex) M 문자 중간이 끊기게 이진화 시켜 주는 Setting)
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 25, 5);	// OCR이미지에서 문자를 가장 Noise 없이 이진화 시켜주고 특히 ex) M 문자 등을 끊기지 않게 이진화 시켜 주는 Setting
//	adaptiveThreshold(gray, th_img, 255.0, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 25, 3);	// OCR이미지에서 문자를 가장 Noise 없이 이진화 시켜주고 특히 ex) M / W 문자 등을 끊기지 않게 이진화 시켜 주는 Setting, 단 배경Noise 상당히 많음

	Mat img_morph_close, img_morph_close_open;

	/*	문제 / 해결방법
		1)	Mat kernel3 = getStructuringElement(MORPH_RECT, cv::Size(5, 5)); 와 같이 Size를 홀수로 설정해서, 변경 이미지가 우측 / 하단으로 shift되는 현상 제거 (짝수로 설정한 경우)
		2)	morphologyEx(th_img, img_morph_close, MORPH_CLOSE, kernel3, cv::Point(-1, -1), 1, 0, Scalar::all(255)); 와 같이 borderValue를  all(255)로(흰색) 설정해서
			변경 이미지의 경계부분의 바코드가(검정색) 두꺼워지는 문제 제거 시킴(바코드 경계부분은 흰색이 정상이기 때문에 경계부분 색상을 all(255)(흰색)으로 설정해도 아무 문제 없음)	*/
//	morphologyEx(th_img, img_morph_close, MORPH_CLOSE, kernel3, cv::Point(-1, -1), 1);
//	morphologyEx(img_morph_close, img_morph_close_open, MORPH_OPEN, kernel3, cv::Point(-1, -1), 1);
	morphologyEx(th_img, img_morph_close, MORPH_CLOSE, kernel3, cv::Point(-1, -1), 1, 0, Scalar::all(255));	
	morphologyEx(img_morph_close, img_morph_close_open, MORPH_OPEN, kernel3, cv::Point(-1, -1), 1, 0, Scalar::all(255));

	// temp
	#if false
	imshow("image", image);
	imshow("img_morph_close", img_morph_close);
	imshow("img_morph_close_open", img_morph_close_open);
	#endif
	// temp

	return img_morph_close_open;
}

void CTagAnalyzerDlg::OnBnClickedButton14()
{
	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.
	CFileDialog fileDlg(TRUE, "모든 파일(*.*)", "*.*", OFN_PATHMUSTEXIST | OFN_ALLOWMULTISELECT, "이미지 파일(*.jpg, *.bmp, *.png) | *.jpg;*.bmp;*.png;*.JPG;*.bmp;*.PNG | All Files(*.*)|*.*||", NULL);

	TCHAR strPath[4096];
	GetCurrentDirectory(4096, strPath);

	Mat img1_color;
	Mat img1_gray_pre;
	Mat img1_gray;

	if (fileDlg.DoModal() == IDOK)
	{
		for (POSITION pos = fileDlg.GetStartPosition(); pos != NULL; )
		{
			CString fileName = fileDlg.GetNextPathName(pos);
			img1_color = imread(string(fileName), IMREAD_COLOR);
			imshow("img1_color", img1_color);

			img1_gray_pre = preprocessing(img1_color);						// 전처리(gray & normalize 이미지 전처리)
//			imshow("img1_gray_pre", img1_gray_pre);

			#if true
			img1_gray = preprocessing3(img1_gray_pre);						// 전처리(closing & opening 이미지 전처리)
			imshow("img1_gray", img1_gray);
			#else
			img1_gray = img1_gray_pre.clone();
			#endif

			/*[최종결론]
			###	OpenCV 4.0.0 부터 제공하는 QRCodeDetector Library를 사용해서 QR코드를 읽자

			cf)	이유
				1)	Zbar가 QRCodeDetector 보다 더 인식 성능과 속도가 좋다고는 하지만
					Zbar도 모든 QR코드를 읽는 것은 아니고(QR코드 내부에 다른 문자 삽입 등 오염이 많으면 못 읽음)
				2)	QRCodeDetector의 경우도 morphologyEx 명령으로 QR코드 내부 오염 제거 및
					setEpsX / setEpsY 설정값을 변경해 가면서 QR코드를 읽으면 100% 모든 QR(태그 중간에 QR삽입 등)을 인식하기 때문에
				->	QRCodeDetector Library를 사용해서 QR코드를 읽는 방식 사용하자
				cf)	단 아래 TEXT 예제와 같이 Data 용량이 큰 경우는
					Zbar 의 경우 1초 이내 QR해석 vs QRCodeDetector 의 경우 3초 정도 QR해석 속도가 느리지만
					일반적인 URL QR해석(ex, https://     ~    .com/nm/43/47/95R4s446L0/09000106/qr/8809610270689A2000014704)의 경우는 1초 둘 다 1초 이내로 빠르게 QR해석하기 때문에
					QR인식 속도가 느려 QRCodeDetector를 사용하지 못하는 것은 아님
					ex)	TEXT = 33.3 AHA AMA ART ASK BIG BIN BIT BOY CAM CAN CAY DAY DEV EAT EEL ERR FOX FUN GAG GENCO GOD GOL GULAN HEP HES HIT IFF ISM JOY KAL KEL KUL LOL MEN MOM NON OFF OHH PIT POT RED SIK SOK THE THY TWO UGH ULU UPS WAR WAY WOK VAZ YAK YAZ YOK YOL ZIP ZOO ZZZ

			cf)	
			QR코드를 제대로 읽으려면 OpenCV에서 제공하는 QR Reading 기능 보다
			ZBar library를 이용해서 읽어야 함

			속도
			ZBar 라이브러리는 OpenCV QR 코드 검출기보다 거의 두 배 빠릅니다.

			견고성
			ZBar 라이브러리는 위의 비디오에서 볼 수 있듯이 다음 요소에 대해 OpenCV와 비교할 때보다 강력한 결과를 제공합니다.
			-	ZBar는 다양한 회전에서 더 좋거나 비슷합니다.
			-	ZBar는 비디오의 다른 줌 레벨에서 볼 때 다른 이미지 크기에서 더 좋습니다
			-	ZBar는 원근 왜곡을 처리하는 데 더 좋습니다 (이미지가 카메라에서 똑바로 세워지지 않은 경우).

			풍모
			ZBar 라이브러리는 OpenCV에는 아직없는 바코드도 지원합니다.

			총평
			전반적으로 QR 코드가 최근 OpenCV에서 시작되었으며 향후 릴리스에서 더 나아질 수 있다고 말할 수 있습니다.
			그때까지 애플리케이션에서 바코드 또는 QR 코드를 사용하려면 ZBar를 사용하십시오.	*/

			/** setEpsX / setEpsY
			@brief sets the epsilon used during the horizontal scan of QR code stop marker detection.
			@param epsX Epsilon neighborhood, which allows you to determine the horizontal pattern
			of the scheme 1:1:3:1:1 according to QR code standard.

			setEpsX / setEpsY 값을 설정하면 기존 잘 못 읽던 QR도 잘 읽게 됨
			하지만 모든 QR(태그 중간에 QR삽입 등)을 완벽하게 읽어내는 것은 아님

			setEpsX (), setEpsY () : 수평 및 수직 스캔 감지 계수를 설정합니다. 기본값은 각각 0.2, 0.1입니다.
			cf)	pixels_position은 흑백 경계 픽셀의 위치를 ​​저장하는 데 사용됩니다. test_line은 특정 픽셀 전후에 5 개의 연속 흑백 세그먼트의 길이를 저장합니다. 
				비율은 일치를 감지하는 데 사용됩니다. 계수 eps_vertical은 공차의 정도를 정의합니다. 
				결국 이미지가 왜곡되고 스케일이 일치하지 않을 수 있습니다. 이 방법을 사용하면 결과 점은 항상 세 번째 접합점이고 두 번째 점은 가장 왼쪽 경계점입니다.
			
			cf)	1:1:3:1:1 이란
				QR코드 Area 위치를 알려주기 위해 북서/북동/남서/남동에 3겹의 사각형인 Finder pattern이 위치해 있으며
				본 Finder pattern은 7x7 사이즈의 크기로 구성되어 있으며
				3겹(검정 최외각 띠사각형 + 흰색 중간 띠사각형 + 검정 가장안쪽 사각형)의 형태로
				가로/세로 모두 : 7 = 1(검정) + 1(흰색) + 3(검정) + 1(흰색) + 1(검정) 의 형태로 구성되어 있으며
				1:1:3:1:1은 본 1(검정) + 1(흰색) + 3(검정) + 1(흰색) + 1(검정)을 가르키는 것임	*/

			/*	테스트 결과
				다양한 QR코드 이미지로 테스트 한 결과 setEpsValue의 값은 0.03 ~ 0.15로 다양한 값을 갖음	*/
			QRCodeDetector detector;
			double dEpsGap = 0.01;

			for (int iCnt = 0; iCnt < 30; iCnt++)
			{
				double setEpsValue = 0.00 + dEpsGap*iCnt;
				detector.setEpsX(setEpsValue);
				detector.setEpsY(setEpsValue);

				vector<Point> points;
				String info = detector.detectAndDecode(img1_gray, points);

				if (info.length() > 0)
				{
					TRACE("OK, QR Decoded Data = %s, setEpsValue = %lf\n", info.c_str(), setEpsValue);
					polylines(img1_gray, points, true, Scalar(0, 0, 255), 2);
					putText(img1_gray, info, Point(10, 30), FONT_HERSHEY_DUPLEX, 1, Scalar(0, 0, 255));
					break;
				}
				else
				{
					TRACE("NG, QR Code not detected\n");
				}
			}

			imshow("img1_gray_QRdetect", img1_gray);
			waitKey(0);
		}
	}
}

2.	Zbar를 이용한 C++에서 QR 읽기 코드
중요)	libzbar-0.lib 라이브러리의 경우 공식적으로 x86 버전만 제공하기 때문에 Visual studio에서 x64 버전으로 build 할 때 에러가 발생하는 심각한 문제 있다
		이경우 https://github.com/NaturalHistoryMuseum/ZBarWin64/blob/master/lib/libzbar64-0.lib 사이트에서 libzbar64-0.lib, libzbar64-0.dll, libiconv.dll 라이브러리를 다운 받아서 사용하면 됨

//Reference:https://www.learnopencv.com/opencv-qr-code-scanner-c-and-python/

#include <iostream>
#include <algorithm>
#include <vector>
#include <zbar.h>

#include <opencv2/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

using namespace std;
using namespace cv;
using namespace zbar;

typedef struct
{
  string type;
  string data;
  vector <Point> location;
}decodedObject;

// Find and decode barcodes and QR codes
void decode(Mat &im, vector<decodedObject>&decodedObjects)
{

  // Create zbar scanner
  ImageScanner scanner;

  // Configure scanner
  scanner.set_config(ZBAR_QRCODE, ZBAR_CFG_ENABLE, 1);

  // Convert image to grayscale
  Mat imGray;
  cvtColor(im, imGray,CV_BGR2GRAY);

  // Wrap image data in a zbar image
  Image image(im.cols, im.rows, "Y800", (uchar *)imGray.data, im.cols * im.rows);

  // Scan the image for barcodes and QRCodes
  int n = scanner.scan(image);

  // Print results
  for(Image::SymbolIterator symbol = image.symbol_begin(); symbol != image.symbol_end(); ++symbol)
  {
    decodedObject obj;

    obj.type = symbol->get_type_name();
    obj.data = symbol->get_data();

    // Print type and data
    cout << "Type : " << obj.type << endl;
    cout << "Data : " << obj.data << endl << endl;
    decodedObjects.push_back(obj);
  }
}

int main(int argc, char *argv[])
{

  // Read image
  string imagepath = argv[1];
  Mat im = imread(imagepath);

   // Variable for decoded objects
   vector<decodedObject> decodedObjects;

   // Find and decode barcodes and QR codes
   decode(im, decodedObjects);

   return 0;
 }


[85]	ATmega128
1.	ADC Converter 결과값 10bits / 8bits
[ADCH:ADCL] 레지스터
  A/D 변환 결과는 10비트이기 때문에 SFR 두 개가 필요한데 ADCH과 ADCL 두개의 레지스터가 변환된 값이 저장되는 레지스터이다. 
  변환값의 상위 바이트와 하위 바이트를 저장하는데 각각 사용되고 ADC의 최대 분해능이 10비트이기 때문에 이중에 10개의 비트만이 
  변환 값을 저장하는데 사용된다. 
  뒤에 설명할 ADMUX 레지스터의 ADLAR 비트의 값에 따라 저장하는 방식은 두 가지가 있는데 이를 [그림 1]과 [그림 2]에 도시하였다.

ADCH
ADC9	ADC8

ADCL
ADC7	ADC6	ADC5	ADC4	ADC3	ADC2	ADC1	ADC0
[그림 1] ADLAR='0' 일 때 변환 결과를 저장하는 방식 (우측 정렬)

ADCH
ADC9	ADC8	ADC7	ADC6	ADC5	ADC4	ADC3	ADC2	

ADCL
ADC1	ADC0
[그림 2] ADLAR='1' 일 때 변환 결과를 저장하는 방식 (좌측 정렬)

변환 값을 10비트(511(0x1FF) ~ 1(0x001) ~ 0(0x000) ~ -1(0x3FF) ~ -512(0x200)) 모두 사용하고자 한다면 [그림 1]과 같이 ADLAR='0'으로 설정한 후
상위 6개의 비트는 무시하고 사용하면 된다. 
하지만, 변환 결과를 8비트만(0~255) 쓰고 싶을 때에는 [그림 2]와 같이 ADLAR='1'로 설정한 후 ADCH 값만을 취하여 사용하면 된다. 

2.	ATMEGA128을 이용한 LCD(캐릭터)제어 - 4bit

ATMega128에서 4-bit cLCD 제어 
댓글1 
초초 이웃추가 | 2008. 12. 11. 23:27 
앱으로 보기 본문 기타 기능 
본문 폰트 크기 조정본문 폰트 크기 작게 보기본문 폰트 크기 크게 보기 가 공감하기 공유하기 URL복사 번역하기 character LCD(cLCD)를 ATMega128에서 4-bit 데이터 선으로 제어하는 소스입니다..
- MCU: ATMega128-16AU
- Compiler: AVR + gcc

다음은 소스와 예제입니다..
--------- lcd.h -----------------
// ATMega 128용 CLCD 제어
// 
//=======================
// 4비트 제어
//=======================
//
//Control bus
//   PF4 : RS  
//   PF5 : R/W  
//   PF6 : EN  
//DATA_BUS 
//   PD4 : D4
//   PD5 : D5
//   PD6 : D6
//   PD7 : D7
//
//다른 포트에서 사용하고 싶을 경우
// DATA_BUS CONTROT_BUS
// DDRX PINX 를 해당 포트로 변경해줄것
//

#ifndef _DELAY_H_
   #define _DELAY_H_
#endif

#define sbi(reg,bit) reg |= (1<<(bit))            
#define cbi(reg,bit) reg &= ~(1<<(bit))

//#include "delay.h"

//===== 재 정의가 필요한 부분 =======
#define CNTL_BUS                      PORTF    // control line(Rs, RW, EN)
#define CNTL_BUS_DIRECTION     DDRF
#define DATA_BUS                      PORTD   // data lines (4-bits)
#define DATA_BUS_DIRECTION     DDRD
#define DATA_BUS_BUSY             PIND

#define    CNTL_EN            0b01000000     // bit 6
#define    CNTL_RW            0b00100000    // bit 5
#define    CNTL_RS            0b00010000    // bit 4
#define    DATA_BUS_OUT   0xF0             // 0b11110000, 상위 비트 1111(출력)
#define    DATA_BUSY        0x80             // data의 최상위 1개 비트
#define    DATA_BUS_IN      0x0F            // 상위 비트 0000(입력)
#define    BUSY_TIME         1000            // busy check 대기 시간
//====================================

#define    EN_ON                  CNTL_EN
#define    EN_OFF                 (~CNTL_EN)
#define    RW_OFF                (~CNTL_RW)
#define    RS_ON                  CNTL_RS
#define    CNTL_BUS_OUT     (CNTL_EN|CNTL_RW|CNTL_RS)      // 0b01110000, 4,5,6-bit에 해당
#define    CNTL_EN_ON         (CNTL_BUS |= EN_ON)
#define    CNTL_EN_OFF        (CNTL_BUS &= EN_OFF)
#define    CNTL_RW_OFF        (CNTL_BUS &= RW_OFF)
#define    CNTL_BUS_OFF      (CNTL_BUS &=~CNTL_BUS_OUT)
#define    DATA_BUS_OFF      (DATA_BUS &=~DATA_BUS_OUT)
#define    CNTL_RW_EN_ON    (CNTL_RW | CNTL_EN)        // 0b01100000
#define    CNTL_RS_EN_ON    (CNTL_RS | CNTL_EN)        // 0b01010000
#define    CNTL_RS_RW_OFF  (~(CNTL_RS | CNTL_RW))    // 0b11001111

#define CMD_CLR_DISPLAY    0x01

// check busy flag
void busy(void) {
  CNTL_BUS_DIRECTION = CNTL_BUS_OUT;     // 컨트롤 출력
  DATA_BUS_DIRECTION = DATA_BUS_IN;        // data 입력       
  CNTL_BUS = CNTL_BUS_OFF;                        // EN= 0
  DATA_BUS = DATA_BUS_OFF;          
         
  unsigned char busy_flag= 0;
  unsigned int  busy_time= 0;  

  do { // 상위 4비트 입력
    CNTL_BUS = CNTL_RW_EN_ON;       // RS= 0, RW= 1, EN= 1
    asm ("nop");
    busy_flag = DATA_BUS_BUSY;
      CNTL_EN_OFF;                           // EN= 0
    // 하위 4비트 입력해서 무시한다.
      CNTL_EN_ON;                             // EN= 1
      CNTL_EN_OFF;                            // EN= 0
    busy_time++;
  } while((busy_flag & DATA_BUSY) && (busy_time < BUSY_TIME));     // busy=1 인 경우 루프 
    // busy=0인 경우, 원래대로 리턴
    CNTL_BUS_DIRECTION= CNTL_BUS_OUT;   // 모두 출력        
    DATA_BUS_DIRECTION= DATA_BUS_OUT;   // 모두 출력        
    CNTL_EN_OFF;                                        // EN= 0
}

// command output function
void command(unsigned char cmd) {
   busy();                              // check busy flag
   // [7:4] 4 bit output
   CNTL_BUS_OFF;                 // RS = 0  // RW = 0  // EN= 0
   DATA_BUS = (cmd & 0xF0);   // 상위니블
   CNTL_EN_ON;                     // EN= 1
   CNTL_EN_OFF;                   // EN= 0
   // [3:0] 4 bit output
   
   DATA_BUS = (cmd & 0x0F)<<4 ;  
   CNTL_BUS_OFF;                 // RS = 0  // RW = 0  // EN= 0
   CNTL_EN_ON;                    // EN= 1
   CNTL_EN_OFF;                   // EN= 0
} 

// 1 char output
void lcd_char(unsigned char data) {
   busy();                                 // check busy flag
   // [7:4] 4 bit output
   CNTL_RW_OFF;                     // RW= 0
   DATA_BUS = (data & 0xF0);      // 상위
   CNTL_BUS |= CNTL_RS_EN_ON;     // RS= 1  EN= 1
   CNTL_EN_OFF;                       // EN= 0
   // [3:0] 4 bit output
   CNTL_RW_OFF;                       // RW= 0
   DATA_BUS = (data & 0x0f)<<4 ;  // 하위
   CNTL_BUS |= RS_ON;              // RS= 1
   CNTL_EN_ON;                          // EN= 1
   CNTL_EN_OFF;                        // EN= 0
}

void lcd_str(unsigned char cmd, unsigned char *string) {
  command(cmd);
  while(*string !='\0') {
    lcd_char(*string);
    string++;    
  }
}
        
// lcd init
void lcd_init(void) {
  delay_ms(30);                                         // min 30 ms
  CNTL_BUS_DIRECTION = CNTL_BUS_OUT;
  DATA_BUS_DIRECTION = DATA_BUS_OUT;  // PC0-PC7 output

  CNTL_EN_OFF;                                        // EN = 0
  delay_ms(30);                                          // min 30 ms

  // function set [3:0] 4 bit
  CNTL_BUS &= CNTL_RS_RW_OFF;            // RS = 0 // RW = 0
  delay_ms(5);                                           // time dealy

  // function set [3:0] 4 bit
  CNTL_EN_ON;                         // EN = 1
  CNTL_EN_OFF;                        // EN = 0
  delay_us(100);

  // function set [3:0] 4 bit
  CNTL_EN_ON;                         // EN = 1
  CNTL_EN_OFF;                        // EN = 0
  delay_us(100);
  
  // function set [3:0] 4 bit
  CNTL_BUS &= CNTL_RS_RW_OFF;             // RS = 0 // RW = 0
  CNTL_EN_ON;                         // EN = 1
  CNTL_EN_OFF;                        // EN = 0
  delay_us(100);

  // command output
  command(0x28);              // 4 bit mode
  command(0x08);              // display off
  command(0x01);              // display clear
  command(0x06);              // entry mode set
  command(0x0C);              // display on
} 

------ delay.h -------------
/*	16 Mhz의 경우 한 주기가 0.0625 us 이므로 16 cycle 일경우 정확하게 1 us가 된다.	*/
void delay_us(unsigned char time_us)    { // time delay(us)
  register unsigned char i;
  for(i = 0; i < time_us; i++) {        // 4 cycle
    asm volatile("PUSH R0 ");       // + 2 cycle
      asm volatile("POP  R0 ");      // + 2 cycle
      asm volatile("PUSH R0 ");      // + 2 cycle
      asm volatile("POP  R0 ");       // + 2 cycle
      asm volatile("PUSH R0 ");      // + 2 cycle
      asm volatile("POP  R0 ");       // + 2 cycle    
    // 16 cycle * 62.5 ns = 1000 ns = 1 us at 16.000MHZ
  }
}

void delay_ms(unsigned int time_ms) {      // time delay(ms)
  register unsigned int i;
  for(i = 0; i < time_ms; i++) {
    delay_us(250);
      delay_us(250);
      delay_us(250);
      delay_us(250);
  }
}

------------ main.c ---------------

#include <avr/io.h>
#include "delay.h"
#include "clcd.h"

int main(void)
{
    lcd_init();
    delay_ms(50);

    while(1){
        lcd_str(0x80, "LCD on ATMega128");
        lcd_str(0xC0, " Hello CLCD ");
    }
}

2.	ATMEGA128을 이용한 LCD(캐릭터)제어 - 8bit

//###################################################################////        
      캐릭터 LCD 제어 프로그램                                      
// Compiler : CodeVision
// Productor: Shim Woo Sung
//<각 포트 구현>
//RS : PORTB.0
//RW : PORTB.1
//E  : PORTB.2
//Data line : PORTD
//###################################################################//
#include<mega128.h>
#include<delay.h>
#include<string.h>
//###################################################################//
//
//                      <LCD 제어 포트 설정>
#define H 1
#define L 0
#define TRUE  1
#define FALSE 0
#define RS   PORTB.0 
#define RW   PORTB.1
#define E    PORTB.2
#define DATA PORTD
//###################################################################//
//
//                      <Function Set>
// <설 명>
// - LCD초기화를 설정하기 위한 명령 
//
// RS RW DB7 DB6 DB5 DB4 DB3 DB2 DB1 DB0
//  0    0    0     0     1    DL    N    F     -     -
//
//  DL   : 몇 비트의 라인으로서 인터페이스를 할 것인지를 결정한다.
//  DL=1 : 8비트(DB7 ~ DB0) 라인을 사용해서 인터페이스 할 수 있다.
//  DL=0 : 4비트(DB7 ~ DB4) 라인을 사용해서 인터페이스 할 수 있다.
//  (이때는 상위 4비트의 데이터 전송을 하고, 다음에 하위 4비트의 데이터를 전송해야 한다.)
//  N    : 글자를 표기하는 디스플레이 라인의 수를 결정한다.(글자 한개를 표기때 드는 라인수를 뜻한는 것 같다)
//  F    : 글자 폰트를 결정한다.
//
//  N   F       디스플레이 라인         글 자 폰 트        Duty Factor     
//  0   0               1                        5*8  Dot             1/8
//  0   1               1                        5*10 Dot            1/11
//  1   *               2                        5*8  Dot             1/16       
      
//  ※ 5*10 Dot의 글자폰트는 2라인으로 디스플레이 안 됨

#define INTERFACE_8BIT 0x30
#define INTERFACE_4BIT 0x20
#define LINE_1         0x20
#define LINE_1_58DOT   0x24
#define LINE_2         0x28
unsigned char FUNCTION_SET = INTERFACE_8BIT | LINE_2;
//###################################################################//
//
//                      <Entry Mode Set>
//
// <설 명>
// - DB2 비트가 1인 경우로서 커서의 움직이는 방향을 설정하거나 글자 시프트할 것인지 결정한다.
//   명령이 수행하는데 필요한 시간 : 37uS
 
// RS RW DB7 DB6 DB5 DB4 DB3 DB2 DB1 DB0
//  0    0    0     0     0     0     0     1    I/D   S
// I/D : D.D.RAM의 어드레스의 인크리먼트(증가 : I/D=1) 혹은 디크리먼트(감소 : I/D=0) 결정한다.
//  S  : 글자가 표기된 전체 디스플레이를 오른쪽.왼쪽으로 이동시키기 위한 변수
//          I/D=1, S=1 : 글자가 표기된 디스플레이는 왼쪽으로 시프트한다.
#define LEFT_SHIFT  0x07
//          I/D=0, S=1 : 글자가 표기된 디스플레이는 오른쪽으로 시프트한다.
#define RIGHT_SHIFT 0x05
//          S=0 : 글자가 표기된 디스플레이는 시프트되지 않는다.
#define SHIFT_OFF 0x00
unsigned char ENTRY_SET = RIGHT_SHIFT;
//###################################################################//
//
//                      <Display ON/OFF Control>
//
// <설 명>
// - DB3번 비트가 1인 경우 Display On/Off 제어 한다.
//   명령이 수행하는데 필요한 시간 : 37uS
// RS RW DB7 DB6 DB5 DB4 DB3 DB2 DB1 DB0
//  0    0    0     0     0     0     1     D     C    B
//
// D : 글자가 표기되는 디스플레이를 ON/OFF 하기 위한 변수이다.
//          D=1 : 글자가 표기되는 디스플레이 부분이 ON되어서 글자가 나타난다.
#define DISPLAY_ON       0x0c
// D=0 : 글자가 표기되는 디스플레이 부분이 OFF되어서 글자가 나타나지 않는다.
// (이때, 디스플레이 부분의 글자 데이터가 D.D.RAM에 남아 있기 때문에 D=1로 하면 글자가 나타 난다.)
#define DISPLAY_OFF      0x08
// C : 커서 부분의 ON/OFF 제어하는 변수이다.
//      C=1 이면 커서가 나타난다.
#define CURSER_ON        0x0a
//      C=0 이면 커서가 나타나지 않는다.
//      ※ 5*8 Dot의 경우 8행째에, 5*10도트의 경우 11행째에 커서가 존재한다.
#define CURSER_OFF       0x08
// B : 커서의 위치에 있는 문자를 깜박이게 하는 변수이다.
//      B=1 이면 커서 위치의 문자를 깜박인다.
#define CURSER_BLANK_ON  0x09
//      B=0 이면 커서 위치의 문자를 깜박이지 않는다. 
#define CURSER_BLANK_OFF 0x08
unsigned char DISPLAY_SET = DISPLAY_ON | CURSER_OFF | CURSER_BLANK_OFF;
//###################################################################//
//
//                      <Etc Command>
//
//※ 화면 클리어
//  - LCD의 화면의 내용을 클리어하고 커서 위치는 홈(0번지)으로 돌아간다.
// RS RW DB7 DB6 DB5 DB4 DB3 DB2 DB1 DB0
//   0   0    0     0     0     0     0     0     0     1
#define CLEAR            0x01
//※ 커서 홈
//  - 커서의 위치를 홈으로 돌아가게 하는것으로 D.D.RAM의 내용은 변하지 않는다.
//   명령이 수행하는데 필요한 시간 : 1.52mS
// RS RW DB7 DB6 DB5 DB4 DB3 DB2 DB1 DB0   
//  0    0    0     0     0     0     0      0     1    -
#define RETURN_HOME      0x02         
//###################################################################//
void portSet(void) //PORT I/O 기능 설정
{
        DDRB = 0xff; //LCD 제어 포트
        DDRD = 0xff; //LCD 데이터 포트
        
        PORTB = 0x00;//포트 초기화
        PORTD = 0x00;//포트 초기화
}
                  
void instructionSet(unsigned char data)
{
        RS = L;
        RW = L;
        delay_ms(1);
        E = H;
        DATA = data;
        delay_ms(1);
        E = L;
        RS = L;
        RW = L;
        delay_ms(1);
}
void charPosition(int x, int y)
{
        unsigned char position;
         if (y > 1) y = 1;
         if (x > 15) x = 15;
         position = y ? x + 0xc0 : x + 0x80;
         instructionSet(position);
}
void charDisplay(char display)
{
         RW = L;    
         RS = H;     
         delay_ms(1);
         E = H;    
         delay_ms(1);
         DATA = display;
         delay_ms(1);
         RW = L;
         RS = H; 
         E = L;
         delay_ms(1);       
}
void stringDisplay(char *str)
{        
        int i=0;
        for(i=0; i<16; i++)
        {
                charDisplay( *(str+i));
        }       
}
//###################################################################//
//
//                      <LCD 초기화 순서>
//
// 1. VCC가 4.5V가 된 후 15ms이상 지연 (명령중에는 비지 플러그 체크 불가)
//
// 2. Fuction Setting
//      - Data Line Interface 방식
//      - 출력 라인
//      - 커서 On/Off
//      - 커서 위치(커서 On 했을 시)
//      - 디스플레이 On/Off
//
// 3. 화면 클리어
// <함수 구현시>
void initLCD(void)
{
        delay_ms(15);
        instructionSet(FUNCTION_SET); //Funtion Set 주석 참조
        instructionSet(DISPLAY_SET);  //Display On/Off 주석 참조
        instructionSet(CLEAR); //Etc Command 주석 참조
}
//###################################################################//
void main(void)
{
        char *str = "      Zero      ";
       
        //초기화
        portSet(); //LCD 관련 포트 설정 / 초기화
        initLCD(); //LCD 초기화 / 화면 클리어        
    
        charPosition(0, 0); //화면상 출력될 글자 위치 설정
        stringDisplay(str); //문자열 화면 출력
        while(TRUE)
        {
        
        }
}

/*
               LCD 제어             P.263
               // 문자열 입력
               " System Control
                  Suwon ATmega128 "
               0310B_LCD_p263.c                         
*/                                                     

#include <mega128.h>
#include <delay.h>
#define FUNCSET       0x28               // Function Set
#define ENTMODE     0x06                // Entry Mode Set
#define ALLCLR         0x01                // All Clear
#define DISPON          0x0c               // Display On
#define LINE2              0xc0               // 2nd Line Move

void LCD_init(void);
void LCD_String(char flash *);
void Busy(void);
void Command(unsigned char);
void Data(unsigned char);

void main(void)
{
                  LCD_init();
                  LCD_String(" System Control ");                       // 첫번째 라인에 출력
                  Command(LINE2);
                  LCD_String(" Suwon ATmega128 ");                 // 두번째 라인에 출력
                  while(1);
}//end main              

// LCD 초기화                               
void LCD_init(void){
                        DDRD = 0xff;                      // port D
                        PORTD &= 0xfb;                // E = 0
                        delay_ms(15);
                        Command(0x20);
                        delay_ms(5);
                        Command(0x20);
                        delay_us(100);
                        Command(0x20);
                        Command(FUNCSET);
                        Command(DISPON);
                        Command(ALLCLR);
                        Command(ENTMODE);                        
}//endLCD_init                                      

// 문자열 출력 함수
void LCD_String(char flash str[]){
                            char flash *pStr = 0;
                            pStr = str;
                            while(*pStr) Data(*pStr++);
}//endLCD_String                                            

// 인스트럭션 쓰기 함수
void Command(unsigned char byte){
                         Busy();
                         
                         // 인스트럭션 상위 바이트
                         PORTD = ( byte & 0xf0 );                    // 데이터
                         PORTD &= 0xfe;                              // RS = 0, ��령어
                         PORTD &= 0xfd;                             // RW = 0, write
                         delay_us(1);
                         PORTD |= 0x04;                              // E = 1, LCD 동작
                         delay_us(1);
                         PORTD &= 0xfb;                               // E = 0
                         
                         // 인스트럭션 하위 바이트
                         PORTD = (( byte << 4 ) & 0xf0) ;         // 데이터?
                         PORTD &= 0xfe;                                    // RS = 0, 명령어
                         PORTD &= 0xfd;                                    // RW = 0, write
                         delay_us(1);
                         PORTD |= 0x04;                                     // E = 1, LCD 동작
                         delay_us(1);
                         PORTD &= 0xfb;                                     // E = 0
}//endCommand

// 데이터 쓰기 함수
void Data(unsigned char byte){
                 Busy();
                 
                 // 데이터 상위 바이트
                 PORTD = ( byte & 0xf0 );                                // 데이터
                 PORTD |= 0x01;                                              // RS = 1, 데이터
                 PORTD &= 0xfd;                                             // RW = 0, write
                 delay_us(1);
                 PORTD |= 0x04;                                              // E = 1, LCD 동작
                 delay_us(1);
                 PORTD &= 0xfb;                                               // E = 0
                 
                 // 데이터 하위 바이트
                 PORTD = (( byte << 4 ) & 0xf0 );                      // 데이터 좌로 4 shift
                 PORTD |= 0x01;                                                // RS = 1
                 PORTD &= 0xfd;                                                // RW = 0
                 delay_us(1);           
                 PORTD |= 0x04;                                                 // E = 1
                 delay_us(1);
                 PORTD &= 0xfb;                                                 // E = 0
}//endData      
                                                                                                          
/*
  // Busy Flag Check > 일반적인 BF를 체크하는 거싱 아니라, 일정한 시간 지연을 이용
*/
void Busy(void){
                 delay_ms(2);
}//endBysy    

3.	delay 명령
/*	16 Mhz의 경우 한 주기가 0.0625 us 이므로 16 cycle 일경우 정확하게 1 us가 된다.	*/
void delay_us(unsigned int time_us) {		// time delay(us)
	register unsigned int i;
	for(i = 0; i < time_us; i++) {		// 4 cycle
		#if 0
		asm volatile("PUSH R0");		// + 2 cycle
		asm volatile("POP  R0");		// + 2 cycle
		asm volatile("PUSH R0");		// + 2 cycle
		asm volatile("POP  R0");		// + 2 cycle
		asm volatile("PUSH R0");		// + 2 cycle
		asm volatile("POP  R0");		// + 2 cycle
		#else
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
		_NOP();		// + 1 cycle
//		_NOP();		// + 1 cycle
//		_NOP();		// + 1 cycle	
//		_NOP();		// + 1 cycle
		#endif		
		// 16 cycle * 62.5 ns = 1000 ns = 1 us at 16.000MHZ
		// -> 실제 OSC로 측정해 보니 정확하게 1us로 동작하지 않고 1.23us로 동작해서 _NOP();명령 3개를 제외시켜서 1.04us로 동작 되도록 함
	}
}

void delay_ms(unsigned int time_ms) {	 // time delay(ms)
	register unsigned int i;
	for(i = 0; i < time_ms; i++) {
		delay_us(250);
		delay_us(250);
		delay_us(250);
		delay_us(250);
	}
}




[86]	분광광도계
1.	원리
	Scanning & PDA(Photodiode Array) type                                                                                	                                                                                                                                                                                                                                                                
    Scanning type의 분광광도계는 광원의 다색광을 분광 시킨 후, 원하는 단   색광만을 시료에 통과시켜, 그 광량을 PMT나 PD와 같은 단일 Sensor를    이용하여 측정하는 반면, 
    PDA type은 먼저 광원으로부터 나 온 다색광을    시료에 통과시킨 후, 투과된 빛을 분광 시키고, 분광된 빛을 PDA나 CCD등   의 Array 센서를 이용하여 전 파장영역을 동시에 측정하는 방식이다.                           
    PDA type은 Scanning type에 비해 측정 속도가 빠른 장점이 있는 반면,   고해상도 분광광도계로서의 한계와 가격이 높은 단점이 있다. 
    광원에서 나온 빛이 시료셀을 지나서 입구 슬릿과 분산장치를 지나서 검출기인 다이오   드 어레이에 도달한다.  
    시료셀을 외부에 두기 때문에 편리하고 1초에 10번   측정해 평균값으로 나타내 주기 때문에 정확하고 반응속도가 빠른 것을 측정 할 수 있다.
	cf)	광원을 프리즘 등으로 분광시켜 광원이 분리되어 비추는 곳에 Photodiode array나 CCD Camera를 설치해서 각각의 파장의 빛의 강도를 측정하는 방식인 것 같다.
	cf)	PMT	광전자증배관다른 표기 언어 photomultiplier tube , 光電子增倍管 
		가격 : 130만원(HAMAMATSU TYPE : H11902-01) + Precision voltage 장비 함께 필요(cf, 기성품으로 산다면 100만원 소요)		
		요약 : 2차방출로 전자수가 늘어나는 것을 이용하여 약한 빛의 세기를 측정하는 전자증배관.                                                                                                                                                                                             
        텔레비전 촬영관이나 천문학에서 희미한 별의 광도를 잴 때 또는 원자핵 연구에서 약한 빛을 검출하고 측정할 때 유용하다. 
        이 관은 빛을 비추면 전자를 내보내는 감광성 음극을 사용하고 일련의 추가전극이나 다이노드를 연결하는데, 
        각 다이노드는 연속적으로 약간씩 더 높은 양전위상태에 있어 바로 앞에 놓인 다이노드에서 나온 전자를 끌어당긴다.
        첫째 다이노드는 전자 하나가 부딪힐 때 여러 개의 전자를 내보내도록 되어 있다.                                                                                                                                                                                                                                                           
        이렇게 생성된 전자들 중 하나가 2번째 다이노드와 충돌할 때도 마찬가지로 몇 개의 전자를 방출하기 때문에, 
        결과적으로 마지막 다이노드에 도달할 때까지 각각의 다이노드에서 전자가 증가 또는 증폭된다. 보통 9개의 다이노드가 사용되므로 총 100만 배까지 증폭될 수 있다.                                                                      




[87]	분자진단 추출기
1.	Adapter
	24V 13A 상용 Adapter 사용하며 가격은 5만원 선




[88]	세종바이오메드
0.	Real sample / 리얼샘플 측정 자료(실제 Cartridge에 Real sample을 넣어서 Prime Analyzer로 측정한 결과 자료)
1.	NT-proBNP
	U:\세종바이오메드\07_개발\IDx_POCT\IPI-CP01\문태석
2.	그 밖의 측정마커 자료(QC Data)
	U:\세종바이오메드\06_생산\POCT\QC 
3.	디지탈옵틱 실험자료
	U:\세종바이오메드\11_보관\디옵인수자료\조정환자료\실험자료\2007년\20071024
	
1.	인증문서
0)	전기시험인증(디지탈옵틱)
	U:\세종바이오메드\11_보관\디옵인수자료\인증관련\2014년자료 (5-12월)\TUV_라인란드\프라임(측정기)_전기안정성테스트\CE인증준비(측정기)전기안정성시험
1)	김성희
	부장님, 품질시스템 기본 문서 주소입니다.  
	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\품질시스템_세종바이오메드  
	1번부터 4번까지 분류된 내용으로 확인해주시면 되구요. 해당 폴더에 없는 제품별로 작성된 문서(위험관리, 제조공정도 등)는 문차장님이 알고 계실것 같아요  
	출력된 문서는 이쪽 사무실에 있습니다.
	2017-06-08
	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\품질시스템_세종바이오메드\3. 양식\702 위험관리  
	프라임 위험관리계획서/보고서 초안 주소입니다  
	U:\세종바이오메드\05_품질관리_인허가\법령 규격 자료\국제규격\IVDD_해외표준규격  
	위험관리보고서의 ISO14971내의 Annex를 확인할 수 있는 주소입니다  
	14971은 국문본과 영문본이 둘다 있으니 참고해주세요  
	04, 05, 10 ISO 14971 버전별로 있어요  
	
	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\품질시스템_세종바이오메드\파일링 라벨
	
	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\품질시스템_세종바이오메드\2. 품질절차서\7항_제품실현\SBQP-705(설계및개발관리절차서)
	
	U:\세종바이오메드\05_품질관리_인허가\품질관리\ISO13485\TUV Sud_2017\Stage2 finding list-CAPA\Stage 2 CAPA 1차 보완_20170721

	U:\세종바이오메드\05_품질관리_인허가\인허가\CE Marking\Technical File\최종본\Techincal File_Rev.2(word)
	
	-	국내 의료기기 관련 변경 신청
		U:\세종바이오메드\03_운영\인증서\식약처 제조허가증_전문\6. 의료기기제조신고증_SmartMed Prime(열람용)
	
	-	제품표준서
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\3. 양식\701 제품실현기획관리\DMR-XXX-XX_제품표준서\POCT
		
	-	작업표준서
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\3. 양식\701 제품실현기획관리\WS-XXX-XX_작업표준서\POCT

	- Software validation
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\3. 양식\705 설계 및 개발관리\소프트웨어 밸리데이션(측정기)

	-	담당자 Signature
		U:\세종바이오메드\05_품질관리_인허가\품질관리\서명모음

	-	사후심사 시정조치관련 서류
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\4. 기록한 양식\808 시정및예방조치
		U:\세종바이오메드\05_품질관리_인허가\품질관리\ISO13485\TUV Sud_2017\Stage2 finding list-CAPA\Stage 2 CAPA final_20170714\attachment	->	관련참고서류모두들어있음

	-	ID CHIP 공정밸리데이션
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\3. 양식\708 공정밸리데이션_\5. ID chip 제조 공정밸리데이션

	-	Check device qc
		U:\세종바이오메드\06_생산\POCT\QC

	-	카트리지 아이디칩 생산 정보
		U:\세종바이오메드\06_생산\POCT\재고관리_rev 11_문태석.xlsx

	-	프라임 CE 자가선언
		U:\세종바이오메드\05_품질관리_인허가\인허가\CE Marking\CE DOC

	-	문서번호
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\2. 품질절차서\4항_품질경영시스템\SBQP-401 (문서관리절차서)
		->	왜 SmartMedi Prime 문서 번호가 111인지 나와 있음

	-	Calibrator(기기QC용, 기기보정용) 기준값 기술
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\2. 품질절차서\7항_제품실현\SBQI-711-01(자체검교정지침서)\SBQI-711-01(0) 자체검교정업무지침서.hwp
		cf)	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\4. 기록한 양식\711 계측기관리_\F711-05(0) 자체검교정성적서_180320.xlsx
				->	Check device -> 여기에 나오는 값은 random으로 Check device 기준값으로 나오도록 랜덤함수처리 되어 있음(엔터치면 값이 변경)
	
	-	공정밸리데이션절차서
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\2. 품질절차서\7항_제품실현\SBQP-708(공정밸리데이션절차서)	

	-	ISO 13485 2016 관련 문서
		U:\세종바이오메드\05_품질관리_인허가\품질관리\ISO13485\ISO 13485 2016 ver. upgrade\ISO 13485-2003, 2016요구사항 비교표.pdf
		U:\세종바이오메드\05_품질관리_인허가\품질관리\ISO13485\ISO 13485 2016 ver. upgrade\2018-01-03_의료기기 GMP 국제 품질관리 민원인 안내서_공개본.pdf

	-	2018년 양산이관문서(PCB변경)
		U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\03 품질시스템_세종바이오메드\4. 기록한 양식\705 설계 및 개발관리\PCB변경\이관문서

	-	SmartMedi Prime에서 관리해야할 것
		U:\세종바이오메드\06_생산\POCT\프라임 생산 이관.xlsx	



2	문태석
	2017-06-08
	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\품질시스템_세종바이오메드\3. 양식\701 제품실현기획관리\DMR-XXX-XX_제품표준서  
	2017-07-03
	U:\세종바이오메드\05_품질관리_인허가\품질관리\GMP\품질시스템_세종바이오메드\4. 기록한 양식\602 제조설비관리 
	
	U:\세종바이오메드\06_생산\POCT \ 재고관리_rev 9_문태석.xlsx -> 미터기 & 센서 재고관리기입되어 있음
	
3.	소프트웨어밸리데이션
	U:\세종바이오메드\05_품질관리_인허가\인허가\디지탈옵틱 자료 (2)\인증관련\2014년자료 (5-12월)\1인증(13485및GMP)자료 총모음\7항_제품실현\708-밸리데이션
4.	Risk Management
	1)	Green Zone[위험도 1~4]은 허용가능한 위험영역(Broadly Acceptable Region, BAR)으로 설정하고 이 영역에 속한 위험은 위험통제(Risk Control)를 하지 않아도 되는 위험 수준이다.
	2)	Yellow Zone[위험도 6~9]은 ALARP(As Low Reasonably Practicable)영역이라고도 하며, 합리적으로 실현할 수 있는 가장 낮은 영역이다. 즉 이 영역의 위험은 합리적으로 위험통제(Risk Control)를 실시하여
		허용 가능한 위험 영역으로 위험을 감소시켜야 한다.
	3)	Red Zone[위험도 12~16]은 허용할 수 없는 영역(Intolerable Region, IR)으로 제품 개발을 중단해야 하는 영역이며, 위험을 줄이기 위한 설계변경을 통하여 허용 가능한 위험영역까지 줄여야 한다.
	
	4)	심각성(1~4)
	5)	가능성(1~4)
5.	간단한 제품 구입
	U:\세종바이오메드\02_구매\00_구매처_Fax_내선번호_세종연락망_기기AS\General info_구매처_전화_fax사용 관련.xlsx
	들어가면 G마켓등의 아이디와 비밀번호 있으며 해당 사이트로 들어가서 해당제품을 장바구니로 담아 놓은 다음
	문준혜씨에게 구두로 구매 부탁을 하면 구입할 수 있음
	cf)	소모품비는 문준혜씨가 중기청과제카드로 결제해줌(30만원 이하?)
	cf)	Gmarket 	소모품/비품 관련 구매시 활용		
		Website	http://www.gmarket.co.kr/	문준혜	2017.05.12 변경
		ID	sjbiomed
		PW	drndc0605
		
		11st	소모품/비품 관련 구매시 활용
		Website	www.11st.co.kr
		ID	sjbiomed
		PW	drndc0605
		
		Auction	소모품/비품 관련 구매시 활용
		Website	www.auction.co.kr 
		ID	tpwhdapelzkf
		PW	sjm1004
		
		하이비투올	:사무/전산용품 전문몰
		Website	http://www.hib2all.co.kr/_front.php
		ID	sejongmed
		PW	sjm1004
5+1.휴가신청서 등 각종 양식
U:\세종바이오메드\10_자료\일반문서양식\바이오메드양식

6.	품의서 작성 요령
	1)	U:\세종바이오메드\01_보고_기안\03_기안서\기안서 작성본\2017년 폴더에서 해당 품의서 파일 작성
		cf)	품의서 번호는 기안서/공문 문서관리대장(2015년~)(진단연구소)에 신규로 추가시켜서 생성된 번호 기재
	2)	중기청과제 기안서 내용은 S1P/POCT 개발을 한다는 가정으로 작성하면 됨
		
7.	지출결의서 처리
	1)	U:\세종바이오메드\03_운영\비용관리\DRNDC_2016 월별 상세지출내역_공통.xlsx
		파일 제일 마지막 줄에 해당 지출 사항 기제(세종바이오메드 내부 관리용)
	2)	U:\세종바이오메드\02_구매\01_지출결의서\세종바이오메드
		폴더에 새로운 파일로 해당 지출문서 추가
	3)	지출문서(지출결의서, 영수증(신용카드매출전표), 실물스캔문서), 중소기업융복합기술개발사업 도장 찍은 다음 김은진대리 소장님 사인 받은 다음
	4)	Scanner로 scan (각각의 PDF파일로)
		해당 스캔 파일 -> U:\세종바이오메드\02_구매\04_중기청 과제비 -> 해당폴더에 스캔파일로 저장
		cf) 스캔본 저장 : U:\세종바이오메드\02_구매\08_중기청 과제비_2018년
		(지출결의서 스캔, 카드매출전표 스캔, 증빙자료(제품사진, 거래명세서), 기안서(기안서작성시), 견적서(견적서받은경우))
		cf)	100만원이상 기안서 작성의 경우 기안서 완료본도 스캔 & 복사
		(U:\세종바이오메드\01_보고_기안\03_기안서\기안서 스캔본, U:\세종바이오메드\02_구매\04_중기청 과제비\기안서 스캔)
	5)	지출문서 원본(기안서 작성의 경우 포함시켜서) -> 중소기업융복합기술개발사업 파일철에 철
	6)	지출문서, 복사본(기안서 작성의 경우 포함시켜서) -> 김은진대리

8.	선입금 처리
	세금계산서, 거래명세서, 사업자등록증, 통장사본	->	업체로부터 받아야 할 것
	1)	U:\세종바이오메드\03_운영\비용관리\DRNDC_2016 월별 상세지출내역_공통.xlsx
		파일 제일 마지막 줄에 해당 지출 사항 기제(세종바이오메드 내부 관리용)(3월 선입금 필요하면 2월달 TAB애 추가, 지출결의일은 3월)
	2)	U:\세종바이오메드\02_구매\01_지출결의서\세종바이오메드
		폴더에 새로운 파일로 해당 지출문서 추가
		지출결의서(중기청도장)(지출요청일:선입금희망날짜)(3월 선입금 필요하면 지출결의일 3월, 지출요청일 3월) -> 선입금
	3)	거래명세서 & 제품사진만을 제외한 나머지 문서 스캔 -> 해당폴더에 저장
	4)	실제제품들어오면 거래명세서(실제입고날짜) & 제품사진 찍어서 기존과 같이 나머지 지출 관련 문서 처리
	cf)	세금계산서는 개인메일로 받지 말고 info@sejongbiomed.com 메일로 받으며
		info@sejongbiomed.com 메일 확인은 http://mail.sejongbiomed.com 사이트에서 아래 ID와 PW로 확인 가능 함
		ID : info
		PW : biomed0725

8+1.중기청과제비로 처리하는 것이 아닌 세종바이오메드 자금으로 처리하는 경우
	1)	세금계산서 받아서 지출결의서까지 작성 하고(ex, 결재일 : 2018-06-18, 지출요청일 : 2018-07-15)
	2)	U:\세종바이오메드\03_운영\비용관리\DRNDC_2016 월별 상세지출내역_공통.xlsx
		파일 제일 마지막 줄에 해당 지출 사항 기제(세종바이오메드 내부 관리용) 하고	
	3)	기안서 있으면 Scan 떠서 해당 클라우디움 폴더에 복사한 다음
			U:\세종바이오메드\01_보고_기안\03_기안서\기안서 작성본
			U:\세종바이오메드\01_보고_기안\03_기안서\기안서 스캔본
	4)	곽현영 대리에게 지출결의서(원본) & 기안서(사본) 등 모두 주면 됨
		cf)	기안서(원��)은 세종바이오메드 서류철에 철 해 놓아야 됨

	cf)	외근(주유비/식비/하이패스)
	1)	U:\세종바이오메드\02_구매\01_지출결의서\세종바이오메드
		폴더에 새로운 파일로 해당 지출문서 추가
		-	주유비는 네이버길찾기 -> 주유비
		-	하이패스는 회사 하이패스 사용해서 지출결의서에 함께 처리
	2)	서진실씨에게 전달
		-	이후, 회사주유비카드 받아서 문발셀프주유소가서(회사 바로 근처 샛길로 자유로 집입할 수 있는 도로에 있는 주유소)
			->	외상거래 선택하고 지출결의서 주유비 만큼 결제해서 주유

 8+2.온라인 결제
	법인카드(9379) 온라인 결제방법	
	신한카드 일반결제 클릭: "패스워드 + 뒷면 CVC번호 3자리" 로 결제	
	카드번호	9410-6440-9690-9379
	패스워드	biomed0725!
	CVC	840
		
	20만원까지 소장님 전결로 온라인 결제 가능-->지출결의서	
	20만원이상은 재경부 통해 진행(승인 및 공인인증서 요구됨)	


9.	클라우디움
	2017-09 x64 기반 시스템용 Windows 10 Version 1703에 대한 누적 업데이트(KB4038788)
	2017-08 x64 기반 시스템용 Windows 10 Version 1703에 대한 누적 업데이트(KB4034674)
	
	cf)	메일상으로 파일을 첨부할 때 반드시 클라우디움에 있는 파일을 첨부파일로 보내기


[89]	보금자리론
1.	상환방식 내용닫기 
매월 원리금균등분할상환, 체감식(원금균등)분할상환, 체증식분할상환(만 40세 미만에 한하여 선택 가능 
원리금균등분할상환 : 원금과 이자의 합계금액이 매월 일정하게 납부되도록 만든 방식으로 초기 회차에 상환하는 금액에는 이자가 많고 원금이 적지만 회차가 지날수록 이자금액이 적고 원금회수가 많아지는 방법입니다. 
체감식(원금균등)분할상환 : 대출원금을 대출기간에 따라 균등하게 나누어 매월 일정한 원금을 상환하고 이자는 매월 원금 상환으로 인해 줄어든 대출잔액에 대해 납부하는 방식입니다. 
체증식분할상환 : 원리금상환기간 중에 상환회차별 상환금액이 증가하는 방식으로 초기 상환금액은 적고 회차가 지날수록 상환금액을 늘려가게 됩니다. 
거치기간(이자만 납부하는 기간) 없음 
조기(중도)상환수수료 2015.3.2 이후 실행건 : 최대 3년, 최대요율 1.2% 잔여일수에 따라 일할계산되어 감소하는 슬라이딩 방식
2012.9.24~2015.2.27 실행건 : 최대 3년, 최대요율 1.5% 잔여일수에 따라 일할계산되어 감소하는 슬라이딩 방식
2012.9.23일 이전 대출실행건 : 실행일로부터 1년까지 2%, 1∼3년까지 1.5%, 3∼5년까지 1% 적용, 5년 이후 면제

2.	디딤돌 및 보금자리론 구비서류 안내입니다.| 농협 
2017.05.01. 18:13
디딤돌과 보금자리론 규정이 거의 같으므로 아래 서류 준비하시면 됩니다.


1. 가족관계증명서 1통 - 디딤돌신청자, 미혼자, 등본상 부부가 같이 전입되어 있지 않은 경우 필요합니다.
2. 인감증명서 3통 - 공동명의시 공동명의자(배우자)도 함께 필요합니다.
3. 주민등록등본2통 - 대출신청자
4. 주민등록초본2통(전주소포함) - 공동명의시 공동명의자(배우자)도 함께 필요합니다.
5. 소득서류는 해당서류 준비하셔야 됩니다.(부부합산 기준이라 부부인경우 모두 서류 준비하셔야 됩니다.)
?? (근로자인경우)
?? 건강보험자격득실확인서,재직증명서 - 기혼자 부부공통 필수?서류
???근로소득원천징수영수증(회사직인필) 또는 소득금액증명원? - 기혼자 부부공통 필수?서류
?? 사업자등록사실없음증명원 - 기혼자 부부공통 필수 서류
???소득사실없음증명원 - 소득이 없는 경우 해당자 (ex)외벌이 부부 배우자
?? (사업자인경우)
?? 건강보험자격득실확인서- 기혼자 부부공통 필수 서류
?? 사업자등록증 사본 또는 사업자등록증명원
?? 소득금액증명원 - 기혼자 부부공통 필수 서류
???소득사실없음증명원 - 소득이 없는 경우 해당자 (ex)외벌이 부부 배우자
?? (연금소득)
?? 연금수급권자 확인서
?? (소득이 없는 경우 추정소득으로 가능)
?? 건강보험자격득실확인서 - 기혼자 부부공통 필수 서류
?? 사업자등록사실없음 증명원 - 기혼자 부부공통 필수 서류
?? 소득사실없음증명원 - 기혼자 부부공통 필수 서류
???건강보험납부확인서 또는 연금산정용 가입내역확인서
6. 분양계약서원본(옵션계약서)
??? 전매시 매매계약서, 부동산실거래신고필증
7. 인감도장 (공동명의일 경우 공동명의자(배우자) 필수)
8. 신분증 ( 부부일 경우 모두 필요합니다.)
9. 공인인증서 (스마트폰 또는 USB 복사) - U보금자리론 상품 신청자인 ?경우만 필요합니다.
10. 우대금리 부분 해당자 
? 복지카드, 결혼예정자 ( 청첩장, 예식장계약서사본), 신혼가구 (혼인관계증명서)
? 디딤돌상품에만 적용 (청약통장, 예금거래조회표)


* 주택금융공사로 개인 접수 하시면 시간이 더 오래 소요될 수 있습니다.
?? 주택금융공사로 접수 하시면 서류 제출을 이중으로 하셔야 됩니다.
?? 접수 내역을 주택금융공사로 부터 승인이 오기까지 ?볼 수 없어 은행에서 준비시간을 가지기 어렵습니다.
?? 신청 도중 조건변경사항 등 체크하기가 어렵습니다.
?? 위 서류중 해당되시는 서류 준비하셔서 사전점검일,주말접수 또는 은행시간내에 가능하신 날짜에
?? 한번 만 나오시면 번거롭지 않게?최대한 시간을 단축시켜 처리 가능합니다.
?
? (심사도중 추가서류가 발생 될 수 있습니다.)

3.	[KEB하나은행] 아낌e보금자리론 제출서류
강래호님, 요청하신 아낌e보금자리론 심사진행 관련 관할지사 제출 서류 안내 문자입니다. 추후 심사중 추가서류 요청될수있습니다. 
1)	배우자신분증사본
2)	배우자 개인(신용)정보 수집,이용,제공 동의서(배우자) 홈페이지의 서식자료실
3)	행정정보 공동이용 사전 동의서(배우자) 홈페이지의 서식자료실
4)	매도인의 주민번호 뒷자리가 삭제된 매매계약서 사본
5)	소득금액증명원 (본인) 세무서(홈텍스=>www.hometax.go.kr)
6)	건강보험자격득실확인서 (본인) 건강보험관리공단
7)	사실증명원(납세신고사실 없음) (배우자) 세무서, www.hometax.go.kr
8)	관할지사 서울중부지사(02-2014-7500)
	지사주소(보내실 곳) [04512] 서울특별시 중구 세종대로 17 3층 한국주택금융공사 u_보금자리론 담당자
	※심사기간중 진행상황이나 기타 문의사항에 대한 부분은 관할지사로 문의 해 주시면 자세한 안내를 받을 수 있습니다.※ 




[90]	꼬마사전
1.	Internet explorer 11에서 꼬마사전을 사용하면 Internet explorer 11을 닫을 때
	Internet explorer 11가 hold되는 문제가 발생 함
	->	본 문제는 꼬마사전 프로그램 버전이 6.6으로 낮아서 발생하는 것으로
		7.4버전으로 설치하면 본 문제는 생기지 않음
2.	하지만 7.4버전도 Internet explorer 11에서 자동으로 팝업창이 뜨면서
	뜻을 알려주는 기능이 동작하지 않는데
	->	이때는 DaumDic.exe, DaumDicSGReceiver.exe 파일의 속성을 관리자권한, 호환모드 Windows7으로
		설정해 주면 정상적으로 동작 함




[91]	Office / 한글 작성 프로그램
1.	머리글을 이전과 동일하게 연결하고 싶은 경우
	머리글/바닥글 -> 이전 머리글에 연결
2.	한글 -> 글상자 -> 채우기 -> 투명도 : 50%로 설정하면 컴퓨터 LCD상에서는 정상적으로 투명도가 적용되어 보이지만
	인쇄하면 투명도 적용한 구간이 격자모양으로 변경되어 인쇄됨
	->	해결방법 -> 해당 전체복사(자르기) -> 붙이기 -> 골라붙이기 ->  그림(메타파일)로 붙여 넣으면 본 문제 해결됨
	하지만 그림으로 붙여넣기 했기 때문에 추후 글자 수정 불가
3.	한글 사진 추가하면 파일 용량 늘어나는 문제 해결 방법
	(해당)사진 -> 줄이기 -> 용량 줄이기 설정 -> [v] 저장할 때 모든 그림에 적용 & [v] 삽입한 그림 크기에 맞춰 줄이기
	설정하면 본 문제 제거 됨
4.	숫자 자동으로 채우기(엑셀처럼)
	숫자를 1, 2 까지만 타이핑 -> 숫자 1, 2를 포함시켜서 연속으로 숫자를 채울 영역 마우스로 Drag -> 오른쪽마우스버튼 -> 채우기 -> 표 자동 채우기 선택 하면
	해당 영역에 자동으로 숫자가 증가되어서 기입됨 
5.	한글 표 안에 쪽번호 넣기
	1)	제일 처음 페이지 선택
	2)	쪽 -> 머리말 -> 머리말/꼬리말 -> 없음 -> 만들기
		쪽번호를 넣을 표안으로 스페이스키와 문자사이즈를 조절해서 대략적으로 위치시킨 다음(cf, 완벽하게 표 안 중앙에 쪽번호를 위치시킬 수는 없음)
		쪽번호넣기 선택
	3)	나중에 머리말 편집하려면
		쪽 -> 머리말 -> 머리말/꼬리말 -> 편집을 눌러서 편집함
	



[91+2]Office / 워드(word)
1.	워드 프로그램 상에서는 제대로 쪽번호가 보이지만
		프린트 하면 쪽번호가 초기화되어서 프린팅되는 경우 해결 방법
		->	파일 -> 옵션 -> 고급 -> 인쇄 -> [ ] 다른 작업하면서 인쇄하기 (체크 해제)




[92]	특허 / 아이디어 / 특허거래
1-2.정품인증 특허 출원
안녕하세요, 네모인사이트 강래호 입니다.
오늘 협의 했던 특허분석 요청 자료 아래와 같이 보내 드립니다.
특허 가능성 / 방향 등 검토 부탁 드립니다.
cf) 첨부파일로 당사 특허 참고 자료 송부 드립니다.

================= 아   래 ==================== 
1. 종이태그에 인쇄된 자성성분을 분석해 정품 인증
   종이태그에 자성성분을 인쇄한 다음 스마트폰App으로 자성 유무 or 방향을 감지해서 정품 판별
   1) 1스탭
      스마트폰을 종이태그에 멀리서부터 근접시키면서 자성값이 변하는 것을 확인 -> 종이태그에 자성이 있음 1차 확인하고 곧바로
   2) 2스탭
      종이태그에 인쇄된 자성성분의 방향이 특정방향을 가르키면 -> 최종 정품임 2차 확인

2. 별색/CMYK 조합을 분석해 정품 인증
   육안상으로는 별색과 CMYK를 조합한 색상이 거의 동일하지만
   스마트폰 App을 통해서 별색/CMYK조합의 차이를 분석해서 정품 인증
   ex) 패턴의 일정구간은 별색, 일정구간은 CMYK조합이며
       육안으로 봤을 때는 동일한 색상의 패턴이지만
       스마트폰App으로 확대해서 분석하면 별색구간과(면으로 인쇄도어 있음) CMYK구간(CMYK 점의 조합으로 인쇄되어 있음)이 서로 다름 확인 가능하며
       본 기능을 활용해서 정품 여부 판단

3. 흐트러져 있던 이미지를 조합해서 정품 여부 판단
   1) 특정패턴 이미지를 잘게 잘라내서 아주 복잡한 이미지와 섞어서 인쇄 함
   2) 인쇄된 태그를 스마트폰App으로 촬영한 다음
      1)번에서 흐트러져 있던 잘라낸 이미지를 모두 모아서(흐트러져 있는 잘라낸 이미지 위치/사이즈 정보를 가지고 합침)
      이미지분석을 통해 패턴이 매끄럽게 이어져 있으면 정품으로 판단 함
      cf) 인쇄된 태그가 가품인 경우 잘라낸 이미지를 모두 모아 보면 패턴이 매끄럽게 이어져 있지 않음

- 강래호 드림


1-1.미국 특허 출원
	cf)	http://cafe.daum.net/alaskaindigo/3JJm/11?q=%B9%CC%B1%B9%C6%AF%C7%E3%20%C3%E2%BF%F8%20%BA%F1%BF%EB
	1)	한국에서 특허를 이미 받은 경우
		실용 특허의 경우 1600불에서 2200불 가량 소요
		cf)	번역이 되어 있지 않은 경우 추가로 500불에서 700불 정도 소요
	2)	미국에서 곧바로 처음 출원하는 경우
		실용 특허의 경우 5000불에서 8000불가양 소요
	->	따라서 비용적으로 한국 특허를 먼저 받고 번역해서 미국 특허를 받는 것이
		비용이 가장적게 소요됨

1.	국토교통기술부 아이디어공모전
또한 국토교통부는 개막식에 앞서 글로벌 벤처캐피털인 요즈마그룹*(회장 : 이갈 에를리히)과 
벤처·중소기업 해외 진출 지원을 위한 양해각서를 체결할 계획이다.
* ’93년 이스라엘 정부·민간(6:4) 공동 설립 캐피탈, ‘요즈마펀드’로 전세계 이스라엘계 벤처기업 지원(20여개 이상 나스닥상장)
, ’15년 한국법인 설립

양해각서의 주요 내용은 ①미래 유망기술·투자정보 공유, ②해외진출 희망기업의 해외 바이어 발굴 및 설명회 행사 공동개최, ③
요즈마 스타트업 캠퍼스 활용, ④요즈마 펀드 지원 검토 등이다. 

현재 국토부가 추진 중인 중소기업 기술 사업화(연간 약 200억원 지원) 사업에 요즈마 그룹의 협력이 더해질 경우 시너지 효과가 기대된다. 

국토부 관계자는 “본 행사를 통해 국토교통 R&D가 국민들에게 친근감있게 한걸음 더 다가갈 수 있는 계기가 되길 바라며, 
우수한 연구개발 성과를 보유한 기업들에게 기술 상용화 및 시장진출 기회를 제공함으로써 우리 경제의 튼튼한 뿌리가 되길 기대한다”고
 밝혔다. 

이번 “2016 국토교통기술대전”의 주요일정, 세부 프로그램 등은 공식 누리집(www.techfair.kr)을 통해 확인할 수 있으며, 
누구나 무료로 입장이 가능하다.

2.	특허괴물 회사는 소송 걸어 돈 벌고, 특허천사는 기술 사서 빌려주죠
특허는 아이디어나 제품의 독창성을 보호하기 위한 법적 장치다. 하지만 최근엔 특허가 다른 사람이나 기업의 영업활동을 방해하거나, 돈을 뜯어내는 공격적 수단으로 사용되는 경우가 늘고 있다. 
이른바 특허괴물(Patent Troll)의 등장이다. 반대의 움직임도 있다. 특허괴물에 맞서 기업들의 정상정인 영업활동을 보호하는 기능을 갖는 특허천사(Patent Angel)도 나타났다. 
특허가 경제 전쟁터에서 첨단의 공격과 방어의 무기가 되면서다. 이로 인해 특허를 둘러싼 괴물과 천사의 대결은 갈수록 치열해질 전망이다. 

등록 연 6만 건 세계 4위, 그중 5만 건은 휴면상태

특허는 과학기술 연구의 결과물이다. 노동과 자본을 투입해 대량으로 물건을 찍어내는 시대를 지나, 과학기술이 기업의 경쟁력이 되는 시기에 접어든 이후 특허는 경쟁력의 상징이 됐다. 
국가든 기업이든, 보다 많은 특허를 얻기 위해 상당한 비용과 시간을 투입한다.

과학기술 진흥정책의 결과를 특허로 평가하는 구조도 생겼다. 이미 한국은 특허 건수에 있어서는 선진국 수준이다. 2008년 지식재산백서에 따르면 최근 5년간 한국 특허청에 들어온 특허출원은 연평균 16만건, 
등록은 연평균 6만건을 기록했다. 출원 건수는 미국과 일본,중국에 이어 세계 4위다. 특허청이 한나라당 김정훈 의원에게 제출한 자료에 따르면 2007년 기준으로 한국은 25만 달러를 투자할 때마다
 특허 1건이 나와 81만 달러를 쓰는 미국을 크게 앞섰다. 한국의 연구개발(R&D) 지출 대비 특허 산출건수가 높다는 얘기다. 

하지만 속을 들여다보면 속 빈 강정이다. 6만건의 등록 특허 가운데 5만건은 활용되지 않고 연구실 서랍에 처박힌다. 
연구 결과에 따르면 활용되지 않는 5만건 중 최소 2500건은 산업적으로 활용가능하며 상품성도 있다는 데도 말이다. 
2008년 기술 수출액을 기술 수입액으로 나눈 비율인 기술무역수지 배율은 0.43배로 일본(3.49배)의 12% 수준에 불과하다.
 기술 분야에서만 31억4000만 달러의 적자를 냈다. 스위스에 이어 꼴찌에서 두 번째 성적이다. 이 때문에 학계나 기업에서 특허가 전시용, 또는 업적보고용이라는 자조의 말까지 나올 정도다.

특허 싸게 사서 비싸게 빌려주는 라이센싱 회사도 등장

2000년대 들어 특허도 거래대상이 되기 시작했다. 서랍에 처박아둔 특허를 꼼꼼히 살펴보니 만든 사람에겐 당장 필요치 않을지라도 다른 사람에겐 요긴하게 쓰일 수 있는 특허가 제법 있다는 것을 깨달은 것이다. 
텍사스인스투루먼트나 폴라로이드가 이런 방식으로 쏠쏠한 이익을 올리자 시장의 관심이 커지기 시작했다. 

특히 달아올랐던 정보기술(IT) 업계의 거품이 2001년께 꺼지면서 많은 IT 벤처가 파산하자 이들이 갖고 있던 특허를 재빨리 사들인 회사들이 나타났다. 
생산활동은 없이 특허만 전문적으로 관리하는 회사(NPE, Non-Praticing Entity)가 등장한 것이다. 당시 2억 달러에 그치던 특허거래 시장의 규모는 2008년엔 14억 달러로 확 커졌다.

사업 초기 NPE들은 사들인 특허를 필요한 곳에 다시 팔거나 빌려주는 방식에 그쳤지만 점차 다양한 영역으로 사업영역을 넓혀갔다. 
단순 특허 중개에서 여러 공급자와 수요자가 참여할 수 있도록 경매시장을 열어주는 것도 하나의 사업으로 발전했다. 
오션토모라는 회사는 2006년 최초로 오프라인 특허경매를 시작한 데 이어 지식재산 전략이 우수한 300개 기업의 주식에 투자하는 OT300 상장지수펀드(ETF)를 개발해 미국 증시에 상장하기도 했다. 

특허침해 여부를 전문적으로 조사하는 기업(Chipworks)도 등장했다. 벤처캐피털들도 특허에 눈독을 들이기 시작했다. 앨티튜드 캐피털 파트너스는 2억5000만 달러의 자금을 운용하면서 특허 관련 기업에 투자했다.
 이 회사로부터 3500만 달러를 투자받은 비스토는 휴대전화 블랙베리의 제조사인 림이 자사의 모바일 e-메일 특허를 침해했다며 소송을 제기, 2억6800만 달러의 특허사용료를 받아내기도 했다. 

돈이 부족한 중소기업이 보유특허를 판 뒤 다시 사용료를 내고 그 특허를 이용하는 '매각 후 라이센싱'이라는 기법도 등장했다. 
이스라엘의 보칼텍이라는 회사는 특허 22개 중 15개를 이런 방식으로 현금화해 1540만 달러를 조달하기도 했다. 

삼성경제연구소 임영모 수석연구원은 최근 ‘진화하는 특허 비즈니스’라는 보고서를 통해 “특허 유통 부문은 다양한 전문기업이 등장하면서 시장이 급성장하고 신상품도 봇물을 이뤘던
 1980년대의 미국 주택 모기지 산업과 비슷한 양상을 보이고 있다”고 밝혔다. 그는 이어 “한국 기업들도 특허 보유건수에 연연하던 기존의 방식에서 벗어나 내부에 사장된 휴면특허를 외부에 공개해 
 수익창출과 함께 새시장 창출의 가능성을 모색해야 한다”고 지적했다.

무단사용 기다렸다 소송 제기 … 삼성전자 최다 피소

이처럼 다양해진 특허비즈니스 가운데 가장 눈에 띄는 게 라이센싱, 이른바 특허괴물이다. 라이센싱이란 특허를 갖고 있지만 돈과 활용능력이 부족한 개인이나 중소기업으로부터 특허를 사들인 뒤 
이 기술을 다른 기업에 팔거나 빌려주고 사용료를 받는 방식이다. 문제는 특허괴물들이 확보한 특허를 적극적으로 빌려주거나 팔아서 돈을 벌기보다는 다른 기업이 해당 기술을 무단사용하기를 조용히 기다리고 있다 
장사가 좀 된다 싶으면 불시에 소송을 제기한다는 것이다. 이미 시장에서 인기있는 상품을 만들고 있는 기업으로선 특허 침해는 명백한데 해당 기술을 우회한 새 제품을 만들 수도 없어 속수무책으로 당하고 만다. 

특허괴물 중 가장 규모가 큰 곳은 인텔렉추얼 벤처스(IV)다. 마이크로소프트(MS)의 최고 기술책임자(CTO) 출신 네이선 마이어볼드가 2000년 설립한 이 회사는 사모펀드 형태로 조성한 50억 달러의 실탄으로 
무려 3만 개에 이르는 특허를 확보했다. IV는 그동안 법정 밖 협상에 치중해왔다. 소송은 주로 자회사를 통해 진행했다. 하지만 12월 9일 IV가 세계적인 IT 기업 9개를 상대로 거액의 소송을 제기해 본격적인 선전포고를 했다. 
여기에는 한국의 하이닉스도 포함됐다.

지금까지 소송을 가장 많이 낸 회사는 아카시아다. 이 회사는 밴처캐피털로 출발했는데 당시 벤처회사에 돈을 대주면서 엄청난 양의 특허를 확보했고, 
지금은 이를 바탕으로 수많은 소송을 제기해 돈을 벌고 있다. 삼성전자도 지난 3월 아카시아의 자회사인 비디오 인핸스먼트 솔루션으로부터 동영상 재생시 화질개선 기술을 침해했다는 이유로 소송을 당했다.
이 기술은 원래 LG전자가 개발했는데, 특별히 사용되지 않아 2008년 국내 특허거래 회사에 매각한 것으로 알려졌다.

특허 관련 조사기관인 패이튼 프리덤에 따르면 2004~08년 동안 특허괴물로부터 소송을 가장 많이 당한 회사가 삼성전자(38건)로 집계됐다. 
지난해 전국경제인연합회의 조사에서도 R&D 투자액이 많은 국내기업 30개사 중 90%가 이미 특허괴물의 공격을 받았거나 받을 가능성이 있다고 답했다. 
특히 IV가 국내 대학과 중소기업을 돌며 사들인 특허가 268개에 이르는 것으로 알려져, 국내 기업들이 바짝 긴장하고 있다.
특허전문 변호사인 전경릉 변호사는 “아이디어 차원의 개발내용에 대해 큰 돈을 내고, 나중에 사업화나 권리화ㅍ까지 돕겠다고 나서는 특허괴물의 제안은 솔깃할 수밖에 없다”며 
“기업은 물론이고 대학이나 연구소도 원천 특허에 대한 관심을 더 기울여야 한다”고 말했다.

펀드 구성, 분쟁 소지 있는 기술 사들여 ‘괴물’에 맞서

창이 있으면 방패도 있게 마련이다. 특허괴물이 기승을 부리자 곳곳에서 이에 대항하는 움직임이 나타나고 있다. 시스코·HP·노키아·소니 등 16개사는 특허방어펀드 RPX를 만들었다. 
분쟁 소지가 있는 특허를 사들여 특허괴물에 대응하는 펀드다. 삼성전자와 LG전자도 여기에 가입했다. 패이턴트 프리덤이라는 라이센싱 전문기업은 업계의 동향을 모니터링해 기업에 정보와 컨설팅을 제공한다. 

국내에서도 비슷한 펀드가 등장했다. 올 초 정부가 245억원을 투자해 만든 ‘아이큐브파트너스’다. 또 9월에는 1호 민관합동 창의자본회사 인텔렉추얼 디스커버리가 출범했다. 
이 회사는 2015년까지 5000억원을 투자받기로 했다. 이미 몇몇 특허에 대한 심사를 진행 중이어서 내년 초쯤 1호 지식재산이 탄생할 전망이다.

인텔렉추얼 디스커버리의 사업 영역은 특허괴물과 유사하다. 종자돈으로 특허를 미리 사들이고, 필요한 곳에 빌려주는 라이센싱은 기본이다. 
일반펀드나 관련 기업들의 모임과 달리 종자돈이 많고, 업종에도 제한이 없다. 또 다양한 특허 포트폴리오를 구축할 수도 있다. 
특허 포트폴리오는 단독으로는 사업화가 어려운 단순 특허나, 기존 특허와 결합해 경쟁력있게 키울 수 있는 힘을 준다. 당장에는 요건을 맞추지 못해 특허를 받기 어려운 아이디어나 발명도 다른 특허나 
기술로 보완해 키우면 강력한 특허를 받을 수도 있다. 이른바 특허 인큐베이팅 사업이다. 

인텔렉추얼 디스커버리는 민간기업이 투자형태로 참여할 수 있는 열린 구조다. 참여 기업은 필요한 특허를 외국에서 사달라고 요청할 수도 있다. 
이렇게 구축된 포트폴리오는 기업 입장에서는 특허괴물의 공세를 피할 수 있는 '특허우산'이 되는 것이다.

다수의 특허권자가 보유한 특허를 공동으로 관리·사용하는 특허 풀도 구축할 예정이다. 주로 자금력과 연구개발 기능이 취약한 중소기업들이 대상이다. 
대기업이 안쓰는 특허를 넘겨받아 필요한 중소기업을 지원하는 사업도 진행하기로 했다. 

허경만 인텔렉추얼 디스커버리 대표는 “국내 대학·연구소·특허법인·기술중개기관 등과 네트워크 구축작업을 벌이고 있다”며 “기존에 계획했던 사업 외에도 더 다양한 사업모델도 개발할 예정”이라고 말했다.

특허괴물과 다른 게 있다면 특허침해를 이유로 소송을 걸고, 돈을 요구하는 일은 하지 않는다는 다는 점이다. 
순수하게 국내 기업과 연구소의 특허를 보호하고 키우는 역할만 하겠다는 것이다. 이 때문에 특허괴물에 대항하는 특허천사라고도 불린다. 
대신 특허를 운용하고 키워내는 것을 통해 돈을 벌어 참여한 투자자들에게 일정한 수익은 보장할 방침이다. 

인텔렉추얼 디스커버리의 유영철 사업지원팀장은 “특허 천사의 힘이 커질수록 국내 기업들이 특허괴물로부터 시달림을 받을 가능성이 줄어들게 되는데 성패는 기업들이 얼마나 적극적으로 참여하느냐에 달려 있다”고 강조했다.

[출처: 중앙일보] [뉴스 클립] Special Knowledge [231] 특허

3.	지난달 애플의 자율주행차 개발 프로젝트가 좌절됐다는 소식이 전해진 가운데 이번엔 구글의 자율주행차 개발이 난관에 봉착했다. 
기술적으로 진척이 없는 상태에서 프로젝트를 이끄는 핵심 직원들까지 회사를 떠난 것으로 알려졌다.

▲ 구글의 자율주행차 테스트카
블룸버그 등 외신은 구글의 자율주행차 생산이 사실상 포기 단계에 이르렀다고 보도했다. 다만, 애플과 마찬가지로 자동차를 직접 생산하는 대신 소프트웨어 개발에 집중할 것으로 보인다고 전망했다.
지난 2009년 자율주행차 개발에 가장 먼저 나섰던 구글이 불과 7년 만에 프로젝트를 포기하는 것으로, 스스로 디자인한 자동차를 선보이는 등 성과가 가시화되기도 했지만, 
해당 프로젝트에 대한 투자자들의 불신과 IT 업체 특성상 자동차 개발의 한계를 보이는 등 순조롭지 못한 부분도 있었다.
특히, 지난 8월에는 프로젝트를 이끌던 최고기술책임자인 크리스 엄손(Chris Urmson)이 회사를 떠났다. 구글은 이후 후임자를 찾지 못해 프로젝트를 이끄는 리더가 부재인 상태로 전해졌다. 
여기에 지아준 주(Jiajun Zhu)와 데이브 퍼거슨(Dave Ferguson), 제임스 커프너(James Kuffner), 앤소니 레반도브스키(Anthony Lewandowski), 돈 버넷(Don Burnette) 등 핵심 기술자들까지 구글을 떠났다.

▲ 구글의 자율주행차 테스트카
매체는 핵심 기술자들이 퇴사한 이유로 구글 측의 고집을 꼽았다. 구글이 완전한 자율주행차 개발만 추진하는 가운데 다른 전기차 및 완성차 업체들은 반자율주행 시스템 등을 선보이면서 
기술적으로 완성도를 높여가고 있다는 설명이다.?반면, 구글은 자동차 디자인 외에 별다른 성과를 내놓지 못했다.
이후 다른 업체와의 경쟁에서 뒤처질 것을 우려한 일부 직원들은 반자율주행 시스템이 적용된 모델의 출시를 건의했다. 하지만, 구글 측은 완전하지 못한 자율주행 시스템은 의미가 없다면서 제안을 거부한 것으로 전해졌다.
이런 상황에서 별다른 진척이 없자 직원들이 회사를 그만두기 시작했고, 이로 인해 기술적으로 공백이 발생하고 있는 것으��� 매체는 분석했다.

▲ 테슬라 오토파일럿
완성차 업체의 경우, 운전보조장치를 시작으로 반자율주행 시스템 등 첨단 기술이 탑재된 자동차를 실제로 판매하면서 기술적인 노하우와 완성도를 확보해 가고 있다. 
여기에 테슬라 등 전기차 업체와 우버 등 IT 업체까지 가세한 상황이며, 국내에서는 이동통신업체까지 '딥러닝' 자율주행차 기술 확보에 나섰다. 특히, 이들 업체는 오는 2020~2021년경 완전한 자율주행차를 내놓겠다고 
선포하는 등 기술 완성에 자신하고 있다.

▲ 테슬라 오토파일럿
업계 한 관계자는 "자동차 산업은 이익률을 비롯해 구조적인 부분까지 전반적으로 IT업체와 많은 차이점이 있다"면서 "자동차를 판매한 적 없는 구글이 한계를 드러낸 것으로 불과 몇년만에 
기술적 선두 자리를 빼앗길 상황에 처한 것"이라고 설명했다. 이어, "특단의 조치가 없을 경우 구글도 애플카처럼 자율주행차 개발을 포기할 가능성도 있다"라고 전망했다.

▲ 구글의 자율주행차 개발 프로젝트에서 디자인을 총괄한 안유정씨
한편, 구글은 현재 34대의 '구글카' 프로토타입과 24대의 렉서스 RX450h 테스트카를 운용 중이다. 
특히, 스티어링 휠과 페달이 없는 구글카의 디자인은 한국인 '안유정'씨가 디자인을 총괄한 것으로 전해졌다.

4.	엘론 머스크가 모든 특허를 공유한 이유
2015년 11월 11일 by 이한결 

※ 역자주: 테슬라 모터스의 최고 경영자인 엘론 머스크가 테슬라 모터스 블로그를 통해 자신들의 특허를 모두와 공유하겠다는 의지를 밝혔다. 전문을 읽어보니 소름이 돋아 아무래도 더 많은 사람들이 읽고 생각을 나눴으면 해서 
부족한 실력이지만 번역을 시도해봤다.

우리의 특허는 이제 모두의 것입니다.
어제까지만 해도 테슬라 모터스를 둘러싸고 있던 특허의 벽은 더 이상 존재하지 않습니다. 우리는 오픈 소스 운동의 정신으로 전기 자동차 기술의 발전을 위해 그 벽을 제거하기로 결정했습니다.

테슬라 모터스는 지속가능한 이동수단의 도래를 앞당겨보고자 만든 회사입니다. 만약 우리가 뛰어난 전기 자동차를 만들어 나가는 와중에도 우리보다 뒤에 있는 다른 경쟁자들의 나아갈 길에 
지적 재산권이라는 지뢰를 깔아둔다면, 그건 우리의 처음 목표와는 반대되는 방향으로 나아가는 꼴이 될 것입니다. 테슬라는 앞으로 우리의 기술을 “올바르게(in good faith)”
 사용하고자 하는 그 누구에게도 특허 소송을 걸지 않을 계획입니다.
처음 Zip2라는 회사를 시작했을 때만 해도 저는 특허는 좋은 것이라 생각했고 그것들을 얻기 위해 심혈을 기울였습니다. 과거에는 그런 특허들이 순기능으로 작용했던 때가 있었습니다.
 그러나 요즘 시대의 특허는 단순히 더 빠른 기술의 진보를 억누르고, 거대 기업들의 자리를 더욱 공고히 하며, 실제 특허의 발명자보다는 법조계에서 일하는 사람들의 배만 불리는 역할을 하고 있습니다.
  특허가 실제로는 언젠가 있을 소송에서 이길 수도 있는 복권에 불과하다는 것을 깨달은 이후로 저는 가능한 한 특허 취득을 최대한 피해왔습니다.
그러나 테슬라 모터스에선 부득이하게 특허를 낼 수밖에 없었습니다. 거대한 자동차 기업들이 우리의 기술을 베껴 그들의 거대한 생산력, 판매력, 마케팅력 등을 동원해 테슬라를 압박해 올 것이라는 걱정에서였습니다. 
그러나 이보다 더 잘못된 판단은 없었습니다. 불행하게도 현실은 예상과는 반대였습니다. 주요 자동차 기업에서 전기차 프로그램, 또는 탄화수소를 연료로 쓰지 않는 그 어떤 종류의 이동수단 프로그램은
 매우 작은 부분을 차지하고 있거나 아예 존재하지 않습니다. 평균적으로 총 판매량의 1%에도 훨씬 미치지 못하는 수준입니다.
전기 자동차라고 하면 기껏해야 제한된 기술력으로 제한된 수량을 생산하는 것이 전부입니다. 어떤 회사는 무공해 자동차(Zero emission cars)를 전혀 생산하지 않습니다.
한 해에 새롭게 만들어지는 자동차가 1억대에 육박하고 전 세계적으로는 총 20억대의 자동차가 있다고 추정되는 이 현실에서 테슬라가 작금의 탄소 위기를 개선할 만한 수준의 빠르기로
 전기 자동차를 생산하는 것은 불가능합니다. 그러나 이는 우리의 시장이 거대함을 의미하기도 합니다. 우리의 진정한 경쟁 상대는 테슬라가 아닌 다른 전기 자동차 회사들이 생산해내는, 
 그렇게 많지도 않은 전기 자동차들이 아닙니다. 전 세계의 공장에서 매일 같이 쏟아져나오는 가솔린 자동차들이야말로 테슬라의 진정한 경쟁 상대입니다.

테슬라가, 다른 전기 자동차 회사들이, 그리고 궁극적으로 우리 모두가 빠르게 발전하는 하나의 공유된 기술 플랫폼으로부터 이득을 얻을 것이라 믿습니다.
역사는 반복적으로, 기술을 이끌어나가는 리더십이 고작 작은 보호에 불과한 특허에 의해 정의되지 않는다는 것을 보여왔습니다.
 기술의 리더십이란 세계에서 가장 뛰어난 엔지니어들의 마음을 끌고 그들에게 동기부여를 할 수 있는 능력으로 정의되는 것입니다. 
 이런 관점에서 우리의 특허에 오픈 소스의 철학을 적용하는 것은 결코 테슬라의 입지를 약화하지 않고 오히려 그것을 더 튼튼하게 할 것이라 믿습니다.
 
4.	현대車 특허팀, 자율주행 특허맵 이렇게 짰다
최근 40년 관련특허 중 0.1% 핵심특허 도출해 집중분석?
기사입력2016-07-08 20:06 
?
전략특허맵을 만들기 위해 필연적으로 거쳐야 할 과정이 있다. 선행기술 조사다. 그러기 위해선 이미 출원된 특허를 살펴야 하는데 숫자가 만만치 않다. 
우리 회사가 집중적으로 분석해야 할 특허가 무엇인지 옥석을 가리는 게 일이다. 바닷가에서 크고 작은 돌이 섞인 모래를 가져온 뒤 깔때기에 부어 가늘고 고운 모래를 걸러내는 과정을 연상하면 된다.?

8일 지식재산협회 주최 조찬세미나에 참석한 현대자동차 신언율 이사에 따르면 최근 40년간 전 세계에 출원된 자율주행차 관련 특허는 약 9만8466건이다. 
해당 특허를 모두 검토하는 것은 현실적으로 불가능할뿐더러, 실제로는 무의미한 특허들도 많다.

현대차는 자율주행차 특허 전략맵을 만들기 위해 9만여건 중 연관성이 떨어지거나 완결성이 떨어지는 자료는 덜어내고 1만1733건만 추출했다. 
특허 분석에서 노이즈 제거라고 부르는 과정이다. 노이즈 제거는 기계적으로 한다. 일정 조건을 입력해 놓고 자동으로 필터링을 거친다.

이렇게 해서 나온 1만1733건은 자율주행 분야에서 관련성이 높은 특허다. 분석 결과 자율주행차 관련 특허 출원은 일본이 가장 많았다. 
일본이 5761건, 한국 2333건, 유럽 1350건, 미국 645건이었다. 기업별로 보면 도요타가 1013건으로 가장 많았고 닛산(909건), 현대차(388건), 구글(117건) 등으로 이어졌다.

현대차는 노이즈가 제거된 1만여 건의 특허 중 유효특허 604건을 뽑아낸 뒤 현업팀, 변리사, 특허부서가 워크숍을 거쳐 또다시 핵심특허 108건을 도출했다. 
특허 데이터베이스 검색에서 나온 9만8466건의 특허 중 0.1%만을 걸러내는 과정이다.?

핵심특허 108건은 집중적으로 분석에 들어갔다. 각 특허의 기술장벽은 어느 정도인지, 현대차에서 특허를 확보할 수 있는 가능성은 어느 정도인지 분석했다. 
현재 자율주행차 기술에서 공백 상태인 기술을 찾아내는 것도 필요하다. 현대차에 반드시 필요한 기술인데 타사에서 이미 특허 권리확보를 해 둔 경우에는 해당 특허를 침해하지 않는 회피설계 계획도 세운다.

특허만 분석한 것은 아니다. 관련 논문과 언론보도, 소셜네트워크서비스(SNS)도 검토했다. 빅데이터 분석이라 불리는 과정이다. 
현재 SNS에서 자율주행 관련 언급이 얼마나 이뤄지는지, 이용자들은 자율주행 기술 중 어떤 분야에 관심을 가지고 있는지 분석한다. 
국내외 외부 전문가로부터 자문도 받는다. 기업 내부에서는 발견하지 못한 오류들을 찾아내내기 위해서다.

신 이사는 기업이 활용할 수 있는 특허정보 사이트도 소개했다. 기본적으로는 한국 특허청의 ‘키프리스’, 일본 특허청의 ‘IPDL’, 미국 특허청의 ‘USPTO’, 유럽 특허청의 ‘Espacenet’를 활용할 수 있다. 
민간 업체로는 톰슨로이터의 ‘톰슨 이노베이션’, 프랑스 퀘스텔(QUESTEL)과 미국 오르비트(ORBIT)가 만든 ‘오르비트-퀘스텔’이 있다.?

신 이사는 “경쟁사 기술동향, 시장 환경과 법규, 특허·논문·빅데이터 분석, 전문가 자문을 바탕으로 자율주행기술 개발 전략과 특허 전략을 도출했다”면서 
“현재 자율주행차 시장에서는 완성차, 부품사, 대학 등 뜻이 맞는 주체들간의 연구개발 협력도 활발하다”고 말했다.

5.	애플카(자율주행자동차)
아이폰으로 움직이는 차 … 애플, 관련 특허 무더기 취득 
 2016-05-27 카가이 취재팀 구글, 애플, 애플카, 자율주행차, 전기차, 특허
머지 않아 아이폰에서 손가락 터치만으로 차 문을 열고, 시동을 켜고, 온도를 조절하거나 주차를 하는 모든 일이 가능해진다.
외신에 따르면 애플이 지난 25일 ‘휴대용 기기를 이용해 차량을 제어할 수 있는 (Accessing a vehicle using portable devices)’ 통신기술 특허 45종을 미국특허상표국에 등록했다.
?
아이폰으로 주행 속도까지 조절

애플은 이미 2001년 출원 신청한 특허에서 자동차와 아이폰을 페어링해서 문을 여닫거나 시동을 켜고, 라디오·CD 등 엔터테인먼트 시스템을 제어하는 기술 특허를 신청한 바 있다. 
이번 특허에는 한걸음 더 나아가 아이폰으로 라이트를 켜거나 좌석 시트·거울을 조종하고 선루프나 와이퍼도 작동시키는 기술이 포함됐다.
 심지어는 차량 속도 제어, 자동 주차도 액정 터치나 음성 명령으로 해결할 수 있다. 한마디로 자동차에서 버튼으로 조작할 수 있는 거의 모든 기능을 아이폰으로 대체할 수 있는 기술이다.

아이폰만 가능한 것은 아니다. 스마트폰과 테블릿, 노트북, 데스크탑 등 블루투스 연결이 가능한모든 기기에서 작동한다.
차량 소유주는 다른 사람의 모바일 기기에서도 차량을 제어하도록 허가할 수 있다. 예를 들어 주행중에서 뒷좌석에 탄 사람이 스마트폰으로 움직이는 차량을 제어할 수도 있다.
?
구글은 피아트와, 애플은 독자 차량 개발
사실 이번에 허가된 특허의 내용이 그리 새로운 것은 아니다. 테슬라는 이미 비슷한 기능을 하는 모바일 앱을 만들어 사용하고 있다. 볼보와 포드도 어플리케이션을 통해 차량을 제어하는 서비스를 도입했다. 
더구나 애플이 이 기술을 상용화시키기 위해서는 설계 단계서부터 자동차 메이커와 핵심 기술들을 공유하는 단계가 필요하다.
그래서 이번 특허를 두고, 자동차업계 후발주자인 애플이 갈수록 치열해지는 자율주행차·전기차 개발 경쟁에서 미리 기술선점을 하기 위한 포석으로 보기도 한다.
올해 초까지 애플은 벤츠·BMW 등 메이저 업체들과 자율주행차·전기차 공동개발을 협의를 했으나 두 회사 모두 애플의 제안을 거부했다. 
피아트와 자율주행차 공동개발을 하고 있는 구글과 달리 애플은 독자적으로 애플카를 개발할 수 밖에 없는 상황이다. 차량개발과 더불어 애플이 가장 먼저 해야 할 일은 
연구 기술의 상용화를 대비해 관련 특허를 미리 확보하는 일이다.

6.	특허거래
1)	프라임 특허법률사무소(www.primepat.com)
	프라임 특허법률사무소는 개인, 중소기업·벤처기업, 대학, 연구기관 등의 유망한 특허·기술을 발굴하여 이전·중개합니다. 
2)	특허법인 충무https://www.cmpatent.com/
	BIRCS(Biz-IP-R&D Convergence Strategy). IP-R&D 연계전략 서비스. 기술동향조사 및 특허맵. 교육/연수/강연. 기술 사업화 및 기술투자 컨설팅. 기술거래 중개
	※ 주소 :?서울시 서초구 남부순환로 347길 53?(영초빌딩 2층)
	※ 대표전화 : 02-546-2735, FAX: 02-546-2736
	※ 대표메일 : mail@cmpatent.com
3)	인텔렉추얼 벤처스(외국계 특허 구매)
	인텔렉추얼 디스커버리
4)	http://www.ipmarket.or.kr/usr/iu03/iu0301_v0.ipm#link
	국가지식재산거래플랫폼
	박수기 : midas@kipa.org
	서찬용 : seocy@kipa.org
	이낙범 : biomecca@kipa.org	-> 답변 주심
	김현덕 : vivace@kipa.org
5)	구글자율주행자동차 : https://waymo.com/ (가장 앞선 자율주행자동차 업계)	-> 직접특허판매문의
6)	https://www.mobileye.com/	-> 자율주행자동차 비전처리장치 판매 업체 -> 직접특허판매문의

7.	해외 특허판매 문의 메일
아래 메일 waymo / mobileye / 바이두(http://apollo.auto/index.html) 에 보냄
I have a PCT patent on how to distinguish a traffic light when there are several traffic lights at an intersection, and I would like to sell this patent to your company. So, I want to know where to send the patent document.

support@waymo.com에 보냄
Hello, I am Raeho Kang, 
Thank you for your reply.

I will send you my patent ("How to distinguish multiple lights at intersection") as attachments.
This document is described to description / benefit of the patent and the PCT registration is completed.

This patent is proven to be practical
If you are interested, I would like to sell this patent to your company.

I look forward to having good news.



https://phantom.ai/contact/main 에는 아직 보내지 않음

나는 신호등 인식 특허를 가지고 있다.
본 특허의 장점은 일반적으로 자율주행자동차가 교차로 등에서
여러개 신호등을 제대로 구분하지 못하는 문제점을 개선시켜 줄 수 있다.

본 특허를 간단히 설명하면
교차로에 있는 여러개 신호등을 
- 기존과는 다르게(사전에 여러개 신호등 정보를 알고 있어야 함) 
- 본 특허는 광학적으로 여러개 신호등을 구분할 수 있다(사전에 신호등 정보를 ��고 있지 않아도 됨)

이에, ���율주행자동차가 신호등 정보가 없는 교차로 등을 주행하는 경우에도
신호등을 혼동하지 않고 주행할 수 있음.

자세한 PT자료를 원하신다면 당신의 e-mail 주소를 알려 주시기 바랍니다.

서로 이득이 되길 희망하며...그럼.

Hello, I am Raeho Kang,

I have a traffic light recognition patent.
The advantage of the present patent is that it can improve the problem 
that an autonomous vehicle can not properly distinguish a several traffic lights at an intersection.

Briefly describing this patent
If there are several traffic lights at the intersection
- Unlike a conventional method (it is necessary to know several traffic lights information beforehand)
- This patent can distinguish several lights by optical analysis.
  (No need to know traffic light information beforehand)

Thus, even when an autonomous vehicle runs at an intersection without traffic information,
it can drive without confusing the traffic lights.

For more information, please provide your e-mail address.

I hope to benefit from each other ... well.



주)LG전자, 주)만도에 아래 내용으로 메일 보냄

[특허판매문의] 자율주행자동차, 신호등 구별방법 특허 판매 문의

안녕하세요, 저는 강래호라고 합니다.

다름이 아니고
저는 아래와 같은 자율주행자동차, 신호등 구별 특허를 가지고 있으며
만약, 귀사에서 본 특허에 관심이 있다면 판매하고자 메일 드립니다.

1.	본 특허 장점
	본 특허의 장점은 일반적으로 자율주행자동차가 교차로 등에서
	여러개 신호등을 제대로 구분하지 못하는 문제점을 개선시켜 줄 수 있습니다.

2.	간단히 본 특허를 설명드리면
	교차로에 여러개 신호등이 있는 경우
	1)	기존 신호등 구별 방법은(어떤 신호등이 어떤 방향의 신호등인지 미리 알고 있어야 함)
	2)	하지만 본 특허는 광학적으로 여러개 신호등을 구분할 수 있기 때문에(사전에 신호등 정보를 알고 있지 않아도 됨)

	->	이에, 자율주행자동차가 신호등 정보가 없는 교차로 등을 주행하는 경우에도
		신호등을 혼동하지 않고 주행할 수 있습니다.
		
3.	자세한 정보는 첨부파일로 전송 드립니다.

서로 이득이 되길 희망하며...

- 이상 입니다. -



8.	 특허는 특허고 특허권리주장은 다른 사항이다.
1)	만약 당사가 A특허를 받아서 A특허로 많은 돈을 벌고 있는데
2)	타사가 A특허와 동일한 특허를 이미 당사 보다 먼저 받았고 이에
	당사에 특허침해를 주장해 온다면
3)	당사의 A특허는 무효가 됨과 동시에 타사로 A특허를 가지고 당사가 번 돈에 대한 손해배상을 타사에 부담해야 함
4)	이때, 특허를 내준 특허청이나 특허청구를 해준 특허사무소는 이런 손해배상 피해에 책임이 없다고 함
	cf)	특허청은 특허를 내줬지만 해외에 엄청나게 많은 특허를 모두 조사할 수는 없기 때문에
		이런 특허침해 소송은 특허청/특허사무소 책임은 아니고 해당 특허를 받은 업체의 책임이라고 함

	


[93]	Digital Optic, PRIME측정기
1-2.측정방식을 기존:면적 -> 개선:Peak로 변경하면 CV가 더 좋아질 가능성 높음
	이유)
	PRIME으로 측정한 파형을 살펴보면 파형은 거의 비슷한데 CV가 안 좋은 경향이 있음
	이에, 이를 기존:면적 -> 개선:Peak 방식으로 변경시켜서 비교해 보니
	기존:면적(CV:11%) -> 개선:Peak(CV:2.5%)로 CV가 상당히 좋았졌음
	이에, PRIME 측정 방식을 기존:면적 -> 개선:Peak로 변경하는 방식을 적용하는 것이 좋을것 같음
	cf)	면적방식의 경우 Membrane 특성 상 혈액 흐름 방향으로 흐름자국이 발생하며 이에 Peak는 같지만 면적이 커지는 현상 발생할 수 있음
		이로 인해서 상기와 같은 문제 발생할 수 있음
	이유)
	현, Prime Analyzer는 Stepping motor를 사용해서 횡으로 이동시켜서 측정하는 방식이기 때문에
	만약, Stepping motor 속도가 변화가(개개의 Analyzer 마다 속도 차이, 1개 Analyzer에서 측정시마다 속도 편차) 있을 경우 횡으로 이동하는 속도가 틀려지게되고
	->	이에, 측정파형 형 길이가 변화가 있게되며 -> 이에, 측정파형 면적 차이기 발생 -> 측정값 편차가 일어남
	->	따라서, Stepping motor를 사용해서 횡으로 이동시켜서 측정하는 방식의 경우(ex, 하마마쯔 등)는
		측정 방식을 면적 방식 보다는 Peak 방식을 사용하는 것이 측정편차를 줄일 수 있음
		(Stepping motor를 사용해서 횡으로 이동시켜서 측정하는 방식의 경우에도 측정파형의 횡길이는 변할 수 있을지라도 Peak는 변할 수 없기 때문)
		cf)	현, Prime Analyzer는 Stepping motor 속도 편차로 인해 측정파형 편차가 일어나지는 않는 것으로 보임
			이유, Calibration 완료된 여러개의 Prime Analyzer 측정파형을 살펴 보았는데 측정파형 횡 길이 편차는 거의 없는 것으로 보임
			

	보고서 : 측정방식 기존:면적방식 대비 신규:Peak방식 측정성능 비교 분석 보고서
	1. 1차 테스트 결과
	   1) NT-prpBNP 등 CV가 24%대로 워낙 좋지 않던 마커의 경우 측정방식을 기존:면적방식 -> 신규:Peak방식으로 변경하면
	       CV가 24.3% -> 16.2%로 33% 향상되는 결과를 얻음
	   2) 하지만 TroponinI 와 같이 CV가 7.7%로 좋던 마커의 경우는 측정방식을 기존:면적방식 -> 신규:Peak방식으로 변경해도
	       CV가 7.7% -> 6.8%로 거의 동일한 결과를 얻음
	   3) 정확한 성능 비교를 위해서는 측정방식을 Peak방식으로 취한 경우에는
	       미터기 Calibration 또한 Peak방식으로 취한 다음 측정 성능을 비교해야 함
	       이유) 파형1, 파형2 -> 적색파형의 경우 Peak가 높아도 Band 폭이 상대적으로 좁음
	              이런 파형이 있는 이유는 미터기 Calibration을 면적방식으로 수행했기 때문이며
	              이 경우 면적방식을 취하면 오히려 측정편차가 줄어듦
	              따라서, 정확한 성능 비교를 위해서는 측정방식이 Peak이면 미터기 Calibration 또한 Peak 방식을 취한 다음
	              성능 비교를 해야 함
	2. 1차 결론
	   1) NT-proBNP, TroponinI, CK-MB, Myoglobin 등 모든 마커에서
	       기존:면적방식 보다 신규:Peak 방식을 취하면 측정 CV가 대부분 향상되는 경향을 보임
	   2) 또한, 미터기 Calibration을 Peak방식으로 취하면 측정 CV가 보다 더 향상될 가능성이 높음
	   3) 이에, 측정방식을 Peak방식으로 변경하면 측정CV가 보다 더 향상될 것으로 보임  
			
	
	2018년02월19일 결론															
	1) 아래 표만을 보면 기존(면적) 보다 신규(Peak)가 CV개선효과가 좋은 것으로 보이지만
	2) 아래, 고농도 -> 2번(Peak가 높은(빨간색파형) 파형이 Band 폭이 상대적으로 좁은 경우)의 경우가 많으면 면적 방식이
	   오히려, CV가 좋은 것 처럼 보임
	3) 하지만, 여기서 중요한 것은 Prime analyzer를 Calibration할 때 Peak가 아닌 면적을 통해서 미터기를 Calibration하기 때문에
	   아래, 고농도 -> 2번(Peak가 높은(빨간색파형) 파형이 Band 폭이 상대적으로 좁은 경우) 경우의 수가 많을 수 있고
	   이에 면적 방식이 CV가 더 좋아 보일 수도 있는 것임
	4) 따라서, 제대로 엄격하게 면적과 Peak 측정방식을 비교하기 하기 위해서는 
	   1) 면적방식으로 Calibration한 미터기 들과
	   2) Peak 방식으로 Calibration한 미터기 들 각각을 리얼샘플로 측정한 자료가 있어야지만
	   제대로 두 측정방식의 CV 성능을 비교할 수 있음
	5) cf) TroponinI 이외의 워낙 CV가 안 좋은 마커들은(CK-MB, Myoglobin, NT-proBNP)은 면적 보다는 Peak방식을 사용하면 CV가 더 좋아 짐 확인 함
	
	TroponinI						
			No.	기존CV(면적)	신규CV(Peak)	CV개선효율	CV개선효율(Total평균)
	저농도	1	4.2 			1.7 			58.4 		37.3 
			2	9.1 			13.0 			-43.3 	
			3	12.0 			8.7 			28.1 	
			4	13.8 			0.7 			94.8 	
			5	15.8 			8.1 			48.5 	
	중농도	1	4.1 			3.9 			6.7 		11.2 
			2	6.1 			5.0 			18.2 	
			3	6.8 			7.8 			-15.7 	
			4	11.3 			8.7 			23.0 	
			5	2.8 			2.1 			23.9 	
	고농도	1	8.2 			1.7 			79.4 		2.6 
			2	3.8 			6.2 			-63.5 	
			3	6.8 			8.6 			-26.7 	
			4	7.7 			4.6 			39.6 	
			5	9.7 			7.3 			25.0 	
			6	6.3 			5.2 			17.3 	
			7	4.2 			6.4 			-52.7 	
	표) 면적 vs Peak 측정 방식 비교	

		
1-1.PRIME 측정기 측정값 변화
	PRIME 측정기 전원을 오래 켜 놓을 수록
	Base line을 포함해서 P1/P2/P3 Peak까지 모든 파형이 올라가는 현상 있음(Y절편 shift up)
	대략적으로 1시간 켜 놓으면 Y절편값으로 100정도 올라가는 것으로 보이며
	오래 켜 놓을 수록 계속 Y절편값이 올라가는 것은 아니고 MAX 200정도 올라가는 것으로 보임
	파형으로 보았을 때 전체파형이 Y축으로 Shift하는 것이기 때문에 측정값이 심하게는 변하지는 않는 것으로 보임

1.	Quick test 측정으로 변경 방법
	1)	Prime 프로그램을 통해 ID-chip을 아래와 같이 변경하면 됨
		가)	Reaction : 1				-> S버튼 누름		=>	측정시간 1분
		나)	Washing delay : 1, 1, 1		-> S버튼 누름
		다)	Baseline delay : 2			-> S버튼 누름(인쇄된 기준카트리지를 사용할 경우 본 값을 2로 설정해도 측정값의 영향 없음)
		라)	Blood_T,Blood_C,Blood_M,Plasma,Serum : 모두 1	->	S버튼 누름
		마)	Barcode check : off			-> S버튼 누름
		바)	Used cartridge check : off	-> S버튼 누름
		사)	Flow check : off			-> S버튼 누름
ITEM#_T001
DATA_17:11:18
A_:0001.000  0001.000  0001.000  
B_:0000.000  0000.000  0000.000  
T_:0001.000  
B_T:01.00
B_C:01.00
B_M:01.00
P_V:01.00
S_V:01.00
aV:000001
bV:000001
g1:4
g2:2
E1:001 E2:001 
M:0002
U:100 V1:080000
V2:080000

1+1.Prime(16.08.20)	윈도우 프로그램 설정값 설명
	1)	A, E1, E2, B & F1, F2 설명
		가)	카트리지에 혈액 샘플 로딩이후 시작버튼을 눌러서 Tray를 삽입 시킴
		나)	이후, A(900초) 시간동안 1차 반응을 기다림
		다)	이후, Washing buffer piston을 F1(220)위치만큼 이동시킨 다음 E1(60초) 시간만큼 기다림
		라)	이후, Washing buffer piston을 F2(260)위치만큼 이동시킨 다음 E2(60초) 시간만큼 기다림
		마)	이후, B(10초) 시간만틈 기다림
		바)	이후, Membrane background를 읽어서 제대로 Washing이 되었는지 체크를 계속하며
		사)	Washing이 제대로 되었으면 측정을 완료하고, 결과값을 LCD창에 표시해 줌
		
		cf)	LCD상단 중앙에 표시되어 있는 "900 060 010"이 바로 상단 항목 중 일부를 표시하는 것임
			900 -> A
			060 -> E1/E2(E1 끝난 다음 E2 표시)
			010 -> B
		cf)	Prime 측정기 측정시간
				1)	17분10초(정상인 경우, = 15분(900초) + 1분(60초) + 1분(60초) + 10초)
				2)	18분40초(비정상인 경우(Max측정시간, ERROR 04 Please restart the test with a new cartridge!), = 15분(900초) + 1분(60초) + 1분(60초) + 1분40초(100초, Washing이 제대로 되었는지 체크하는 최대 시간))
				cf)	Washing이 제대로 되었는지 재 측정 최대 회수는 10회로 Baseline delay(M)이 default 값인 5라면
						-> 최대 100초간을 Washing이 제대로 됐는지 체크 함(100초 = ((5초(Baseline delay(M)) + 5초(측정시간)) X 10회)
				cf)	CE심사 대응 측정시간
						Ex) 설정된 측정시간 : 900이라면 17분~ 20분의 측정시간 소요
								(=15분+2분(Washing delay)+0분~3분(Washing check))

		cf)	Prime analyzer -> Setting -> Meter Setting -> Test mode -> Auto에서 Manual로 변경하면
			상기 1)번 -> 가)~사) Step중에서 A 시간만 ID-chip에 설정된 값을 무시되어 900초 -> 0초로 변경시키고 나머지는 동일하게 적용되어서 진행 됨




2.	PRIME 측정기, 센서코드식 생성 및 아이디칩과의 상관 관계 & 아이디칩만으로 센서코드식 적용 가능성 분석

1)	개념
가)	우선, PSA마커에 대한 센서코드식은 아래와 같으며
PSA
1.P2_1 < 20000; (농도) = (P2_1 - 194.42) / 9775.2
2.P2_1 >= 20000; (농도) = (P2_2 - 125.52) / 1385.5
->	본, 센서코드식을 아래와 같이 수정하면 PRIME측정기 F/W상에 센서코드식이 들어가지 않고
	아이디칩만으로 센서코드식을 변경/적용할 수 있을 것으로 보입니다.
	본, 사항은 협의 및 테스트 후 다시 보고 드리도록하겠습니다.
	PSA
	1.P2_1 < 20000; (농도) = (P2_1 - 0) / 1
    2.P2_1 >= 20000; (농도) = (P2_2 - 0) / 1

나)	본, 센서코드식이 만들어진 엑셀자료는
->	첨부파일 "PSA센서코드식수식이나와있는엑셀문서.xlsx"문서의 노란색배경의 빨간글씨 부분을 참고 하시기 바라며

다)	이렇게 해서 만들어진 수식이
->	첨부파일 "20160622 Prime_프로그램 수식변경.docx"문서 -> 3페이지 -> PSA관련 코드식으로 기입되어 있으며
	본 센서코드식이 PRIME 측정기 F/W상에 저장되게 됩니다.
	cf) 아이디칩에는 본 센서코드식을 기본으로 해서 보상해 주는 정보가 들어가서 최종 결과값이 나오게 됩니다.

2)	실제구현방법
	아이디칩만으로 센서코드식 구현 방법

	2017년 8월 1일 1차 결론
	기존 5개 판매되는 마커는 기존 F/W상의 센서코드식 그대로 적용하고
	그 이외의 마커는 아래와 같은 아이디칩만으로 센서코드식 구현 방법을 적용해서 F/W상에 집어 넣고
	만약 High와 Low Gain상의 관계를(ex, 7.055359)알 수 없는 경우는 Default로 7.055359을 1로 잡아서 적용 함

1	=(HighValue-194.42)/9775.2				
	=0.0001023HighValue - 0.019889	=0.0001023HighValue
2	=(LowValue-125.52)/1385.5				
	=0.000721761LowValue - 0.09059	=0.000721761LowValue
3	=2/1 	=0.000721761/0.0001023	7.055359076		
4	Prime F/W상의 센서코드식				
	1) HighValue < 20000인 경우	=HighValue			
	2) HighValue >= 20000인 경우	=7.055359LowValue			
5	아이디칩센서코드식				
	=0.0001023RawValue(상기4번에서나온측정값)				
	=최종결과값=(RawValue - Q5)/Q2, cf) Q5/Q2자리수 : XXXX.XXX				
	-> Q5 = 0, Q2 = 1/0.0001023 = 	9775.20
6	예제
	y = 0.2395x - 2484.1 상관관계함수는 기존 실측된 HighValue값과 LowValue값을 가지고 엑셀 추세선을 만들어서 구한 함수임
	HighValue	LowValue				RawValue	최종결과값
				y = 0.2395x - 2484.1	HighValue/10000(HighValue < 20000인 경우)			=1/9775.20*RawValue
										7.055360LowValue/10000(HighValue >= 20000인 경우)	

	0									0.00 												0.00 
	1000								1000.00 											0.10 
	2000								2000.00 											0.20 
	3000								3000.00 											0.31 
	4000								4000.00 											0.41 
	5000								5000.00 											0.51 
	6000								6000.00 											0.61 
	7000								7000.00 											0.72 
	8000								8000.00 											0.82 
	9000								9000.00 											0.92 
	10000								10000.00 											1.02 
	11000								11000.00 											1.13 
	12000								12000.00 											1.23 
	13000								13000.00 											1.33 
	14000								14000.00 											1.43 
	15000								15000.00 											1.53 
	16000								16000.00 											1.64 
	17000								17000.00 											1.74 
	18000								18000.00 											1.84 
	19000								19000.00										 	1.94 
	20000		2305.90 				16268.95 											1.66 
	21000		2545.40 				17958.71 											1.84 
	22000		2784.90 				19648.47 											2.01 
	23000		3024.40 				21338.23 											2.18 
	24000		3263.90 				23027.99 											2.36 
	25000		3503.40 				24717.74 											2.53 
	26000		3742.90 				26407.50 											2.70 
	27000		3982.40 				28097.26 											2.87 
	28000		4221.90 				29787.02 											3.05 
	29000		4461.40 				31476.78 											3.22 
	30000		4700.90 				33166.54 											3.39 
	31000		4940.40 				34856.30 											3.57 
	32000		5179.90 				36546.05 											3.74 
	33000		5419.40 				38235.81 											3.91 
	34000		5658.90 				39925.57 											4.08 
	35000		5898.40 				41615.33 											4.26 
	36000		6137.90 				43305.09 											4.43 
	37000		6377.40 				44994.85 											4.60 
	38000		6616.90 				46684.61 											4.78 
	39000		6856.40 				48374.36 											4.95 
	40000		7095.90 				50064.12 											5.12 
	41000		7335.40 				51753.88 											5.29 
	42000		7574.90 				53443.64 											5.47 
	43000		7814.40 				55133.40 											5.64 
	44000		8053.90 				56823.16 											5.81 
	45000		8293.40 				58512.91 											5.99 
	46000		8532.90 				60202.67 											6.16 
	47000		8772.40 				61892.43 											6.33 
	48000		9011.90 				63582.19 											6.50 
	49000		9251.40 				65271.95 											6.68 
	50000		9490.90 				66961.71 											6.85 

3.	Prime(16.08.20) 프로그램 상에서 Read ID-Chip 데이터 설명(Calibration 용 ID-Chip)
3-1.센서코드식 설정 방법 및 ID-Chip 등록 방법 설명
1)	Prime측정기RAW값(본 값은 Prime 윈도우 프로그램을 통해서 받음, P2: value)을
 "IF(Q27<30000,((Q27-367.84)/17542),((Q28+117.48)/2576.9))"




과 PathFast 값과의 상관계수 공식에서 나온
 




ITEM#_T001
DATA_17:05:24						P2	P1	P3			->	ex)	cardiac TCM의 경우 P1/P2/P3가 CK-MB/cTnI/Myo로 실제 스트립상에 배열되어 있고 raw data도 이렇게 나오지만(F/W상의 센서코드식 적용 전)
																PRIME 윈도우 프로그램상의 Q1/Q2 아이디칩센서코드식 적용의 경우는 P2/P1으로 서로 엇갈려서 적용되어 있음
A_:0001.000  0001.000  0001.000	(	Q1	Q2	Q3	)		->	농도보정(최종Prime측정기LCD창표시값) = (농도(Prime측정기RAW값)-Q5)/Q2
B_:0000.000  0000.000  0000.000	(	Q4	Q5	Q6	)		->	Q2와 Q5는 P1 pulse에 대한 ID-Chip 센서보정식
T_:0001.000  
B_T:01.00
B_C:01.00
B_M:01.00
P_V:02.00
S_V:01.50
aV:000001
bV:000001
g1:4
g2:2
E1:001 E2:001 
M:0002
U:100 V1:080000
V2:080000

양산 TCM ID-chip data
ITEM#_3006
DATA_17:08:28
A_:0000.370  0000.210  0001.610  
B_:0000.000  0000.000  0000.000  
T_:0001.000  
B_T:01.75
B_C:01.81
B_M:01.00
P_V:01.27
S_V:01.00
aV:000900
bV:000010
g1:4
g2:2
E1:060 E2:060 
M:0005
U:100 V1:080000
V2:080000

SB-ME-01-01 기준미터기 Reader data
G1:255 G2:009 	
G3:255 G4:079 	
D1:105 D2:100 	
S062 R461 	
C001 N050 	
O005 P005 	
F1:220 F2:260 	->	본 F1/F2 값은 Auto mode에서 측정시간 15분 경과 후 Step1/Step2에서 Piston이 Washing Buffer 통을 밀어주는 길이를 뜻하며 본 값을 변경 시키면 Washing Buffer 통을 밀어주는 길이가 실제로 변경 됨
					cf)	F1은 Step1 과정에서의 피스톤 밀어주는 길이이며 F2는 Step2 과정에서의 피스톤 밀어주는 길이이며 F2를 299로 변경하면 실제로 Step2 피스톤 밀어주는 길이가 늘어남
						또한 F2를 299로 설정하면 Step2 과정에서 피스톤 더 밀어주고서 1분 기다려주는 과정이 -> 피스톤 더 밀어주고서 0초로 기다려 주지 않고 곧바로 최종 Step으로 변경되기 때문에 측정값이 감소하는 현상이 당연히 일어날 수 밖에 없음
						실제 TCM마커를 RealSample로 측정 결과 F2를 260으로 설정할 때 보다 F2를 299로 설정하면
						CK-MB는 측정값이 대략 40% 줄어들고 TroponinI 나 Myoglobin은 별다른 변화 없는 테스트 결과가 나옴 또한 이때 Background도 F2를 299로 설정하면 더 많이 발생함
G1:255 G2:005 	
G3:255 G4:053 	
D1:100 D2:093 	
S061 R460 	
C001 N050 	
O100 P100 		->	이렇게 O/P값을 100%로 변경하면 Washing이 제대로 이뤄졌는지 체크하는 Background 체크를 수행하지 않고 한번에 본 과정을 통과함
F1:220 F2:260 	


4.	Calibration 구현 방법(최종결정)
	P1과 P3_2로만 Calibration을 구현하자
	이유)	기존은 P1과 P2의 평균값과 P3_2와 Control(P4_2)의 평균값으로
			Excel상에서 Gain값을 설정했는데 이방식은
			이도 저도 아닌 결과를 나타낼 수 밖에 없음 이유는
			ex)	P1과 P2의 평균값의 경우 P1, P2 측정값이 기준값에서 각각 틀어져 있는 경우
				P1을 기준으로 맞출 수도 없고 P2를 기준으로 맞출 수도 없는 상황이 발생하기 때문에
				P1 농도에서도 Bias 편차가 발생할 수 밖에 없고 P2 농도에서도 Bias 편차가 발생할 수 밖에 없기 때문에
				차라리 P1 농도 1포인트 만을 기준으로 Calibration하는 것이 P1 농도만이라도 Bias편차를 줄일 수 있다
	이유)	저농도에서 Bias편차가 발생하지 않는 것이 중요하기 때문에 P1을 기준으로 잡고
			고농도(Myoglobin)도 Bias편차가 발생하면 안되기 때문에 P3_2를 기준으로 잡음
	cf)		P1(저농도) / P3_2(고농도) 1포인트만을 각각 Calibration point로 잡았고 미터기 코드식 자체가 PRIME측정기 상에 없기 때문에
			본 P1과 P3_2 농도에서는 Bias편차가 별로 없지만 나머지 P2(중농도) 등의 농도에서는 Bias편차가 발생하는 것은 어쩔 수 없는 현상 임
			cf)	미터기 코드식도 없는 상태에서 Gain 1개로 모든 구간의 Bias편차를 없애는 방법은 없음 
	cf)		본 방식으로 Calibration 수행 속도
			평균) 하루 25대 수행 = 25/8 = 3 = 1시간에 3대 수행
			cf) 직접사원 1분에게 본 방식 교육 이후 직접사원 혼자서 Calibration 수행한 결과

4+1.기준카트리지로 Calibration된 미터기가 Real sample(혈액)로 측정하면 미터기 편차가 일어나는 원인 분석
	현상)	1번(기준미터기)과 기준카트리지를 가지고 미터기들을 Calibration한 다음
			기준카트리지를 가지고 미터기 측정값 편차가 일어나는지 확인하면
			결론적으로 모든 미터기가 1번미터기와 동일한 파형과 측정값으로 출력된다.
			그런데 Real sample(혈액)로 측정하면 1번 미터기를 제외한 나머지 미터기들의 측정값이 15%정도 감소하며
			미터기간의 측정값 편차도 크게 일어 나며 파형도 제각각이고 Base line의 높이도 미터기간에 크게는 800정도 차이가 난다.
	원인분석)
			본 현상이 일어나는 원인은(2017년8월22일)
			PRIME Analyzer의 광학설계가 잘못 되어서 Laser로 부터 나오는 680nm파장의 광원이 수신부로 들어가기 때문에
			(cf, 형광으로 부터 나오는 680nm파장의 빛만 수신부로 들어가야 하고 Laser광원으로 나오는 680nm파장의 빛은 절대 수신부로 들어가면 안됨)
			이런 Laser -> 680nm -> 수신부로 들어가는 미터기 마다의 특성으로(많고 적음) 인해
			Base line의 높이가 제각각인 것임
			cf)	기준카트리지의 경우는 이런 현상이 일어나지 않고 Real sample만 이런 현상이 일어나는 이유는
				기준카트리지는 Back ground 색상이 남색이기 때문에 Laser -> 680nm 잡광을 모두 흡수하고
				Real sample의 경우는 Membrane색상이 흰색이기 때문에 Laser -> 680nm 잡광이 수신부로 들어가기 때문임
	해결방안)
			기준카트리지 Back ground 색상을 남색에서 회색으로 변경하니
			Real sample로 측정할 때 처럼 미터기 마다 측정파형이 제각각이고 Base line의 높이도 제각각으로 틀려지는 현상 발생함
			이에, Back ground 색상이 회색인 기준카트리지로 미터기들을 다시 Calibration할 것이며
			최종 Real sample로 측정시 1번 미터기와 나머지 미터기 측정값 편차가 줄어들고
			파형과 Base line 높이도 동일한지 확인 예정 임
			->	실제 리얼검체로 확인 결과 남색 보다는 회색 배경의 기준카트리지가 리얼검체 측정 시 1번 기준미터기와의 측정값 편차가 줄어드는 것으로 확인 됨
				cf)	회색배경의 기준카트리지가 Laser광원이 수신부로 들어가는 요인을(문제점) 더 크게 적용시켜서 Calibration 해 주기 때문에
					리얼검체 측정시 1번 기준미터기와의 측정값 편차가 더 줄어드는 것으로 보임
				cf)	이렇게 회색 배경의 기준카트리지로 Calibration 해도 10%정도(1개/10개)의 확률로 1번 기준미터기 측정값 보다 43% 적게 나오는 문제가 발생하며
					이경우 특색은 리얼검체로 측정시 Background(Y절편)가 유달리 낮게 나오는 현상 발생 함(이경우:60digit, cf)정상:500digit)
					따라서 본 문제되는 미터기를 걸러내기 위해서 반드시 Calibration이 끝난 미터기를 리얼검체로 전수검사해서
					이와 같이 유달리 Background Y절편값이 적고 측정값이 적게나오는 미터기는 출고시키지 말아야겠다.


5.	MSP430 MCU
1)	외부에서 BSL (BootStrip Loader이였던가? 아님 말구)를 이용해서 플래쉬를 라이팅할 수 있다.
특정 포트를 이용해서 칩내에 미리 기록된 BSL 프로토콜에 의하여 PC나 기타 장치에서 이 칩의 펌웨어를 라이팅할 수 있습니다.
하지만 그 프로토콜이 고정되어 있고 일반 UART포트가 아니라 특정 포트를 활용하는 점,
 그리고 BSL모드로 진입하기 위해서 몇개의 라인을 컨트롤 해주어야 하는 점에서 좀 불편한 부분이 많습니다만 어째튼 이런게 가능은 합니다.

6.	현(2017년8월7일) PRIME 측정기, F/W Version을 변경하면 Offset값이 초기화 됨
cf)	라이트메트릭스에서 아래와 같은 답변이 왔음
3) Prime analyzer, F/W를 Upgrade해도 기존에 사용하던 Marker(ex, cTnl, CK-MB, Myo, ..)를 아무 문제 없이 계속 사용할 수 있는지?
   cf) F/W를 Upgrade한 경우 혹시, 기존 PRIME에 저장되어 있던 Gain & Offset 등의 코드식 값이 지워지지는 않는지?
->	갱 라이터 장비에서 메인 메모리 영역만 쓰기로 설정해서 하시면 됩니다.
	cf)	MSP-GANG Programmer -> Memory option -> Main Memory only




7.	Prime측정기 Washing 단계를 넘어가지 못하는 오류 발생 시 대처
	PRIME윈도우프로그램상의 하기 값을 조절하면 본 에러 넘어갈 수 있음

	cf)	[POCT] SmartMedi Prime, Washing 판단 기준을 송부 드립니다.
			-> 결론적으로:	SmartMedi Prime가 측정파형을 분석 임의의 base line 을 계산하고 본 기준값에서 아래 Min value(%), Max value(%) 값을 벗어나면
											Washing이 제대로 되지 않았다고 판단 재 측정을 시도 함
											(재 측정 최대 회수는 10회로 Baseline delay(M)이 default 값인 5라면
											-> 최대 100초간을 Washing이 제대로 됐는지 체크 함(100초 = ((5초(Baseline delay(M)) + 5초(측정시간)) X 10회)

	1)	Base value(N)	: 50(default)		cf) Base line 기준값 50 -> 500을 뜻함
	2)	Min value(%)(O)	: 5(default)	cf)	Prime 측정기가 파형을 분석 임의의 Base line을 계산하고 본 계산된 Base line을 기준으로 최소허용값(%)
																				측정파형 base line 부근 값들이 본 최소값 이하이면 Washing이 제대로 되지 않았다고 판단 재측정을 시도 함
																		cf)	상기 1) Base line(N) 값이 기준이 아님
	3)	Max value(%)(P)	: 5(default)	cf)	Prime 측정기가 파형을 분석 임의의 Base line을 계산하고 본 계산된 Base line을 기준으로 최대허용값(%)
																				측정파형 base line 부근 값들이 본 최대값 이상이면 Washing이 제대로 되지 않았다고 판단 재측정을 시도 함
																		cf)	상기 1) Base line(N) 값이 기준이 아님
	


8.	테스트 밴드 위치가 좌/우 편차 발생한 경우 측정값 영향주는지 확인
	테스트결과 : 밴드가 좌/우로 치우치게 이동시킨 다음 측정했으며 측정결과 Bias : Max 3.95%이내로 거의 측정값 편차 없음 확인
	cf)	PRIME 측정기는 Control band 위치를 파악한 다음 상대적으로 P1/P2/P3 위치를 파악해서 측정결과를 도출하는 기능을 구현하고 있음을 입증하는 결과 임


9.	라이트메트릭스 대응 방안
	1)	기존 제품 소스/HW/BOM 필요 이유
		인증 대응을 위해서 본 사항이 필요 함
	2)	신규개발 방향
		신규제품에 대한 광학구조 설계 요청
	3)	기존제품 추가구입(100대)


10.	실제 병원 방문 느낌
	1)	중규모병원(ex, 서대구병원)인 경우 중앙장비(기준장비) Cobas312(?)가 이미 있지만
		POCT장비(나노엔텍 -> 세종바이오메드)를 사용하는 이유는
		단가 등의 문제 때문이 아닌가 생각 됨
		중앙장비 카트리지 단가 보다 POCT 카트리지 단가가 더 싸기 때문에
		성능 상의 차이가 없다면 POCT 카트리지를 사용하는 것이 더 이문이 많이 남을 것으로 보임
	2)	나노엔텍 제품의 경우 측정값 CV가 안 좋은 문제도 있지만
		실제 병원에서 가장 불만은 측정Fail이 일어나서 새로운 스트립으로 재측정 해야 하는 것이 가장 큰 불만으로 보임


11.	Prime 측정기 Set -> Test Setting -> Cut off range 구현 관련
	1)	TCM ID-Chip을 넣고서 본 셋팅 모드에 들어가면 TroponinI / CK-MB / Myoglobin 각각 모두에 대한
		Cut off 값을 변경할 수 있으며
	2)	본 모드에서 해당 마커 Cut off 값을 변경하면 측정값 표시(Data -> Patient Data)에서
		본 Cut off 이하인 경우는 녹색(정상) 측정값으로 표시하고 -> ex) 글자색이 녹색인 100 ng/mL [Normal]
		본 Cut off 이상인 경우는 적색(비정상) 측정값으로 표시 함 -> ex) 글자색이 적색인 100 ng/mL [Abnormal]
	3)	본 Cut off 변경 사항은 저장된 측정값을 변경하는 것은 아니고 (Data -> Patient Data) 에서 측정값을 보여줄 때
		녹색/적색으로 글자색만을 변경시켜서 보여 줌
	4)	본 Cut off 변경 사항은 또한 PC로 측정값을 전송하는 PC Program상의 측정값 Data에 영향을 주지 않음
		단, Thermal printer로 출력시에는 상기 2)번 ex)에 적용된 사항이 그대로 적용되어서 프린트 됨
		ex) 비정상인 경우 100 ng/mL [Abnormal](검정색바탕)


12.	Prime 측정기 측정값 저장 관련
	1)	측정값은 총 200개가 저장되며 200개가 저장되어 있는 상태에서 새로운 측정값이 저장되면
		가장오래된 측정값이 자동으로 지워지고 신규 측정값이 저장 됨 확인 완료
	2)	측정값 리스트 중간에 있는 측정값을 임의로 지울 수 있으며 이 경우 정상적으로 삭제됨 확인 완료


13.	Prime cartridge 만의 특징인 Washing 처리 기능의 유용성 평가
	1)	피스톤을 밀어서 washing 통에서 washing 용액이 나와서 washing 처리를 해 주고 있으며
		본 기능을 수행하지 않으면 얼룩덜룩 Background가 생성되어서 실제 Photodiode 측정파형의 그래프 높이가
		얼룩덜룩 생성된 것을 깨끗하게 제거시켜 주지 않아서 최종 측정값에 영향을 줌 확인 완료
		ex) washing 용액을 기존 400 -> 200으로 줄이니 얼룩덜룩 생성된 Background를 깨끗이 제거시켜주지 않아서
			측정파형 background 가 얼룩덜룩 형성되어서 측정값에 심각하게 영향을 줌 확인 완료


14.	Prime 측정기 문제점
	1)	Expired date 확인
		ID-chip 날짜를 ex) 10:01:01로(2010년) 변경시켜서 측정해도 미터기 상에서 에러가 발생되지 않고 정상적으로 측정 함


15.	Prime 측정기 판매 시장 & 영업
	1)	동남아시아
	2)	아랍국가(미국과 적대 국가)
	3)	아프리카
	4)	중국
	
	cf)	한국 -> 대구(진텍)의 경우 Prime 측정기 판매 거절 됨
		이유)	성능이 어느정도 나오는 것 같은데 측정할 수 있는 아이템이 너무 없다.
				최소, 심장질환 & 염증성질환 측정은 가능해야 된다
				-	심장질환	: TroponinI, CK-MB, Myoglobin, NT-proBNP, D-dimer
				-	염증성질환	: CRP
				cf)	BNP가 NT-proBNP 보다 측정하기 더 어렵다(분자 구조가 더 작기 때문)

16.	Prime 측정기 RAW Data 순서
	cf)	바코드스티커 부분과 측정창 부분의 raw data 출력 순서가 서로 반대 임
	1)	바코드스티커 Data
		바코드스티커 상단 -> 하단 순서로 raw data가 출력
	2)	측정창(membrane)
		Testline1 + Testline2 + Testline3 + Controlline 순서로 raw data가 출력

17.	신규(ROHS적용) Prime 미터기 부팅 안되는 에러 해결
	1)	미터기실험실(추움, 17도)에 있던 HP1711013 & HP1711004 미터기 STM32F105 와 MSP430F MCU 모두
		최신 F/W로 ReWriting해도 부팅 안되는 에러는 해결되지 않음
	2)	단, HP1711013 & HP1711004 미터기 모두 추운(17도) 곳에 있던 것을 따뜻한 곳(25도)에 5분 정도 놓아두니
		부팅 안되던 것이 부팅이 됨
	3)	1차, 부팅 문제 없는 것으로 파악된 신규 미터기 5대를	저온실(10도)에 12시간 정도 방치한 다음 켜보니
		5대 중에서 1대(HP1711009 미터기)에서 부팅이 되지 않는 에러 발생 함
		이에, HP1711009 미터기를 실온(25도)에 15분 정도 놔두고서 다시 켜보니 이때는 정상적으로 부팅 됨

18.	S1P(골다공증, 골밀도 진단 마커)
	1)	S1P ELISA 방식
		가)	측정시간은 3시간
		나)	사용자가 총 3시간 측정 시간 중 틈틈이 수작업으로 처리를 해줘야 함 -> 19.	ELISA ( Enzyme Linked Immunosorbent assay) -> 2)	ELISA 원리
			따라서 ELISA 방식은 POCT처럼 시간만 지나면 자동으로 알아서 측정값이 나오는 방식하고는 다르게
			측정값이 나오기까지 사용자가 매 시간마다 신경을 써서 처리해줘야지만 정확한 측정값을 도출할 수 있음
			한마디로 ELISA 방식은 POCT 대비 사용하기 어렵고 귀찮으며 시간을 잘 맞춰서 처리해 주지 않으면 측정편차도 상당히 커짐
		다)	ELISA 시약을 측정하는 기기 마다 측정 편차가 존재하기 때문에
			Control 시약을 동시에 측정해서 상대적으로 측정값을 유도해야 하며
			Excel을 사용해서 측정값을 계산
		라)	S1P는 골다공증 확인용 마커 중에 하나이며
			S1P 하나만 가지고 골다공증 진단 불가
			cf)	대부분 X-ray를 찍어서 골다공증 진단을 하며
				이때 X-ray로 골다공증 진단 정확도가 50%(?) 정도로 낮기 때문에
				다른 바이오마커 진단을 추가해서 확진 정확도를 높이고자 하는 것이며
				이때 사용하는 바이오마코 중에 하나가 S1P임
		마)	S1P 진단의 최종 목표는 ELISA -> POCT 진단이며
			참고로, S1P POCT 진단의 경우 현, 정부과제로 진행 중에 있음
		바)	S1P와 골다공증 관계에 대한 입증/인증 자료가 전무하기 때문에(세계 최초(?))
			S1P ELISA 등을 우리가 판매하고자 한다면 본 사항을 임상을 통해서 우리가 입증해야 함(현, 아산병원과 협업 중)
		사)	S1P ELISA Kit를 개발해서 판매하고 있는 회사가 이미 한군데 있으며
			독과점이기 때문에 96wall(ELISA 기본 키트 개수), 1kit에 백만원 이상 고가로 판매하고 있다
			이것을 우리가 사와서 비교군으로 사용중에 있음
			cf)	연구용이 아닌 실제 병원에서 본 키트를 구매해서 사용하고 있는지 확인 불가이며(우리만 연구용이기 때문에 사오고 있고 병원등에서는 실제 구매하고 있는지 확인 불가)
			cf)	본 키트의 경우 특허가 걸려 있었는데 요번에 공주대에서 본 특허를 회피한 키트를 개발했으며
				당사에서 판매하고자 한다면 본 특허를 회피한 키트를 판매할 예정 임
		
		cf)	DMSO
			공주대에서 받아 오는 S1P 원액은 고체 상태이며
			이를 녹이기 위해 DMS0 용매를 사용한다.
			cf)	신수성이면 녹이기 위해서 물을 용매로 사용 가능하지만, 유기합성 등은 물로 녹지 않기 때문에 DMS0를 사용해서 녹임
			cf)	DMSO라는 약어로 표기하며 극성이 강하며 흡습성도 높은 편이다. 산업에서는 유기합성의 용매로 사용되며 의학적 용도로는 국소 소염제, 동물성 의약품에 사용된다.
		cf)	S1P ELISA 키트는 소비자에게 판매 할때 고체가 아닌 ELISA 키트에 용액 상태로 넣어서 판매한다.

	2)	골다공증 진단
		가)	진단
			골밀도 검사를 통해 진단한다. 골밀도의 정도는 같은 인종, 같은 성(性)별의 젊은 사람의 평균 골밀도에서 위, 아래 표준편차를 나타내는 T값으로 표시하며, T값이 -2.5 미만일 경우 골다공증으로 진단한다.
		나)	검사
			골밀도 검사 방법으로는 이중에너지 X선 흡수계측법(dual energy X-ray absorptiometry; DXA), 초음파, 정량 전산화단층촬영술(quantitative CT) 등이 있다. 이 중 DXA가 대부분의 병원에서 이용되는 표준화된 방법이다.
			초음파의 경우 기계의 이동이 쉽기 때문에 보통 선별검사에 많이 쓰이지만, 종종 DXA법에 의한 결과와 상이하게 나타날 수 있다. 정량 전산화단층촬영술의 경우 요추(lumbar spine), 팔뚝(forearm)이나 정강이뼈(tibia)를 측정하는데, 
			3차원적으로 재구성하여 실제 밀도를 알 수 있다는 장점이 있지만 방사선 노출량이 많다.
		다)	X선 흡수계측법으로 골다공증 진단 정확도
			본인이 신청하든가 의사가 권유를 했을 때에 의료보험이 안 되는 부분도 있단 걸 말씀을 드립니다.
			그런데 그러면 골다공증 검사는 아마 해보신 분도 많을 건데, 병원에 가면 몇 가지 검사 중 하나를 선택해서 검사하는데, 
			우리가 가장 많이 하는 게 말이 조금 어렵습니다만, 이중에너지 X선 흡수개척법이라고 해서 누워서 차근차근 컴퓨터로 검사하는 방법이 하나 있고요. 
			초음파를 통해서 검사할 수도 있겠고, 우리가 잘 아시는 컴퓨터 단층 촬영, CT라고 그러죠. 그걸 통해서 검사를, 골다공증 진단을 하실 수 있는데, 
			흔히 많이 하는 게 X선 흡수개척법, 병원에 가면 흔히 이걸 검사를 많이 하는데 이게 정확도가 아주 높은 검사입니다. 
			이게 검사를 해보면 허리하고 대퇴골, 허벅지 뼈를 기준으로 그걸 영상자료로 해서 컴퓨터에 입력해서 수치를 재는데, 왜 허리하고 허벅지 뼈를 기준으로 하냐면 
			이게 골다공증이 가장 잘 생기고 잘 부러지고, 그다음에 위험도가 높기 때문에, 몸의 뼈는 머리에서부터 발끝까지 다 있는데 이 뼈 두 개를 기준으로 합니다. 
			그래서 이 뼈의 수치가 나오는 걸 정상 젊은이들, 정상 20~30대의 젊은이의 수치와 비교해서 값을 내서 골다공증이다 아니다 판별하게 됩니다.
		라)	S1P
			골다공증·골관절염 원인 국내 연구진이 밝혔다 
			기사입력 2006-11-26 15:35 | 최종수정 2006-11-26 15:35 

			염증이나 칼슘 소실 등으로 인해 뼈가 약해져 쉽게 부러지는 원인을 규명하는 열쇠를 국내 연구진이 찾았다. 			
			서울대 치대 김홍희(사진)·류지윤 박사팀은 파골세포 (Osteoclast)의 분화 과정 중 만들어진 ‘스핑고신-1-포스페이트(S1P)’라는 생리활성 지질 성분이 뼈의 대사에 중요한 역할을 한다는 사실을 처음으로 규명했다고 26일 밝혔다.			
			인체의 뼈는 매일 조금씩 분해되고,분해된 양만큼 새로운 뼈로 채워짐으로써 항상성을 유지한다. 골다공증과 골관절염 같은 뼈질환은 뼈를 분해하는 파골세포와 뼈를 재생하는 조골세포 중 하나에 이상이 생겼다는 뜻이다. 
			뼈를 흡수하는 파골세포의 활성이 증가하면 뼈가 얇아지고 쉽게 부러지는 골다공증이 촉진된다. 반대로 조골세포의 활성이 증가하면,골밀도가 증가해 뼈의 기형이나 골석화증이 일어나게 된다. 			
			김 교수팀은 골밀도를 정상적으로 유지하는 데 필요한 이 두 세포의 상호작용에 S1P가 중요한 역할을 한다는 것을 이번에 밝혀냈다. 따라서 S1P 변화를 관찰하면 각종 뼈질환이 생길 가능성을 예측할 수 있다는 것이 김 교수팀의 주장.			
			김 교수는 “골 대사과정에서 파골세포가 뼈를 흡수하면 조골세포가 새로운 뼈를 만들어 빈 자리를 채우는 역할을 하는 것”이라며 
			“앞으로 이들 두 세포간의 상호작용을 인위적으로 조절할 수 있는 방법을 개발하면 골다공증을 비롯한 각종 뼈질환을 좀더 쉽게 치료할 수 있는 길이 열리게 될 것”이라고 말했다.
			
			이기수 전문기자			
			<GoodNews paper ⓒ 국민일보. 무단전재 및 재배포금지>
			
	3)	S1P 측정 이유
		골다공증 환자의 Monitoring을 위해 매번 X-ray 검사를 하는 방법 대신
		S1P마커를 사용하면 혈액 채취만으로 정량적으로 골다공증의 진행 정도를 측정할 수 있기 때문
		하지만, S1P가 골다공증/골밀도와 정확한 상관성이 있다고 입증된 것은 아니며
		S1P만 측정해서 골밀도를 Monitoring할 수는 없음 
	
	


19.	ELISA ( Enzyme Linked Immunosorbent assay)
1)	엘라이자 실험 순서 좀 알려주세요.. 
2016.04.04 15:20 

실험준비
1. ELISA well plate 준비 : 실험계획에 따라 필요한 수량의 well plate 를 준비한다.
* 개봉 후 사용하지 않은 well strip 은 깨끗하고 건조한 상태로 상온 보관하였다가 다음 실험에 사용한다.
* 주의 : well strip 이 습기나 이물질에 오염되면 실험 결과에 나쁜 영향을 미칠 수 있다.
2. Washing solution : PBS powder pouch 1 개를 D.W. 에 녹여 1liter 를 맞춘 후 50% Tween-20 1ml (1 vial)을 섞어 준비한다 (PBST : 0.05% Tween-20).
3. 측정할 시료 sample, standard 와 2’ Antibody (2’Ab)는 PBS (또는 PBST 나 Blocking solution)에 희석하여준비한다. 실험 직전에 PBS 에 희석하여 사용하며, 만일 미리 희석하여 하루 이상 보관 후 사용할 경우Blocking solution 에 희석한다.
4. TMB solution & Substrate (H2O2) Solution : 필요량 만큼 사용 직전에 덜어내어 상온에서 warm up 시킨후 사용한다. 낮은 온도는 발색 반응을 저해한다.
* 사용 직전에 TMB solution 과 Substrate (H2O2) Solution 을 1:2 (V/V)로 섞어 TMB Substrate Mixture 를 만든다.
* 두 시약을 섞은 용액의 보존기간은 4ºC 에서 1 주일 이내 이다.
실험방법
1. Coating : 항원 (단백질) 또는 항체를 Coating buffer 에 1 ㎍/ml (1-10 ㎍/ml) 농도로 녹여 well 당 100 ㎕씩 (50-200 ㎕까지 사용자마다 차이 있음) 분주하여 4ºC 에서 overnight incubation 하여 coating 시킨다.
2. Washing : Washing solution (PBST)을 well 에 채운 후 버리는 방식으로 3-5 회 반복한다. (ELISA Washer사용권장)
3. Blocking : Blocking solution 을 well 당 200 ㎕씩 분주한 후 상온 (또는 37ºC)에서 1 시간동안 incubation 한다. (이후의 모든 반응은 상온 또는 37ºC 에서 반응시키며 상온 (25ºC)을 권장)
4. Washing : Washing solution (PBST)을 well 에 채운 후 버리는 방식으로 3-5 회 반복한다. (ELISA Washer 사용권장)

5. Sample 처리 : 실험조건에 따라 희석된 sample 또는 standard 를 각각의 well 에 100 ㎕씩 (coating 과 동일량) 분주하고 상온에서 1-2 시간 incubation 한다.
6. Washing : Washing solution (PBST)을 well 에 채운 후 버리는 방식으로 3-5 회 반복한다. (ELISA Washer 사용권장)
7. Primary Antibody (1’Ab) : 희석된 1’Ab 를 각 well 에 100 ㎕씩 (coating 과 동일량) 분주한 후 상온에서 1-2시간 incubation 한다. 단, 측정하려는 시료가 항원이 아닌 1’Ab 일 경우 바로 2’Ab 처리로 (9. Secondary Antibody) 넘어간다.
8. Washing : Washing Solution (PBST)을 well 에 채운 후 버리는 방식으로 3-5 회 반복한다. (ELISA washer 사용권장)
9. Secondary Antibody (2’Ab) : 희석된 2’Ab 를 각 well 에 100 ㎕씩 (coating 과 동일량) 분주한 후 상온에서 1-2 시간 incubation 한다.
10. Washing : Washing Solution (PBST)을 well 에 채운 후 버리는 방식으로 3-5 회 반복한다. (ELISA washer 사용권장)
11. 발색 반응 (Color Reaction) : TMB Substrate mixture 를 100 ㎕씩 분주하고 부드럽게 흔들어 섞어 발색반응을 일으킨다.
12. 반응 정지 : 반응 시작 후 5 분 정도 관찰하여 적절한 수준으로 발색 되었을 때 Stop Solution 을 100 ㎕씩 첨가하여 반응을 정지시킨다. 반응 시간은 온도나 실험실 조건, 사용자의 기준에 따라 차이가 나며 반응 시간을 더 늘리거나 줄일 수 있다. 
	일반적으로 standard 가 충분히 발색 되었을 때 또는 negative control 에서 발색의 변화가 나타나기 시작할 때 정지 시킨다.
13. ELISA Reader에서 450nm 파장 흡광도를 측정하여 결과를 분석한다.

주의사항.
1. 개봉한 well plate 는 깨끗하고 건조한 상온에 보관한다.
2. 각 시약 및 Solution 들은 필요량만큼 덜어서 사용하고 반드시 4ºC 에 보관한다. 특히 오염이 되지 않도록 주의한다.
3. 사용하려고 덜어낸 Solution 들은 미리 상온에서 warm up 시켜 반응에 사용한다.
4. sample, standard, 항원, 항체 등은 완전히 용해 시켜서 사용해야 한다. 균일하게 용해되지 않으면 오차 발생의 요인이 된다.
5. 각 well 에 시약 등을 분주할 때 내용물이 다른 well 로 오염되지 않도록 주의한다. 소량의 오염도 실험결과에 큰 오차를 일으킬 수 있다.
6. Stop Solution (2M H2SO4)에는 유독성 물질인 H2SO4 가 들어있으므로 피부나 눈에 닿지 않도록 주의 한다.
7. Blocking buffer 에는 보존재로 유독성 물질인 Thimerosal 이 0.01% 첨가 되어있으므로 피부나 눈에닿지 않도록 주의한다.

2)	ELISA 원리
	cf)	항체 이미지 : Y자, 항원 이미지 : 동그란원
	cf)	ELISA 원리 동영상 : https://www.youtube.com/watch?v=6Ue1Hd3dyaQ

	1)	항체가 이미 바닥에 붙어 있는 Plate(용기) 사용
	2)	Buffer 집어 넣음
	3)	샘플(항원) 투입하고서 잘 붙도록 기다림
	4)	Washing 시켜서 항체와 붙지 않은 항원 씻어 버림
	5)	Buffer 집어 넣음
	6)	"HRP가 붙어 있는 항체" 집어 넣어서 남아 있는 "기존항체와 붙어 있는 항원"과 서로 붙게 함 & 잘 붙도록 기다림
	7)	Washing 시켜서 "기존항체와 붙어 있는 항원"과 붙지 않은 "HRP가 붙어 있는 항체" 씻어 버림
	8)	Buffer 집어 넣음
	9)	TMB를 집어 넣음(TMB 발색하지 않은 기본 색상은 노란색)
		이때, 기존 HRP와 서로 만난 TMB만 자체 발색 하고(푸른빛)
		만나지 않은 TMB는 발색하지 않음
		ex)	남아 있는 HRP가 많을 수록 발색이 많이 되며
			본 푸른빛의(ex, 450nm) 세기를 측정기로 측정해서 항원의 농도를 정량적으로 파악 함
	10)	30분(?)이 지나면 발색이 모두 끝나고 노란색으로 변함
	
	cf)	ELISA 측정 방식은 사람이 수작업으로 하는 것이기 때문에
		상기 Step 시간을 잘 맞추지 않으면 측정 편차가 상당히 커짐
		cf)	본 ELISA측정을 자동으로 측정해주는 기기가 있기는 한데 상당히 고가 임	

3)	ELISA, Control / 정량값 환산/계산 방법
	아래 기술 내용은 다른 사람의 설명을 내가 이해하고 적은 사항이기 때문에 정확하지 않음
	가)	ELISA Kit 판매 시 Control 8 종류(농도별 8종류이며 각각의 기준값(고정)을 같이 알려 줌)를 같이 주며
	나)	ELISA Kit 임의의 구간(8개 walls)에 Control 8 종류를 Loading 해서 ELISA 반응 시킴
	다)	ELISA 반응 이후 ELISA Reader로 읽어 들인 Control 8 종류에 대한 raw 값과 가)항에서 알려준 기준값(고정) 과의 상관식을 계산해서
		"ELISA 코드식"을 생성 함
	라)	다)항에서 만든 "ELISA 코드식"을 Control 이외의 Target ELISA 측정 raw값에 적용시켜서 최종 정량값을 환산/계산 함
	
	cf)	가)~라) 항을 제대로 수행했다면 작업자 작은 실수 & 반응시간 오차 등으로 인해서 Target ELISA 측정 raw값이 틀어져도
		가)~라) 항에서 만들어진 "ELISA 코드식"이 제대로 적용되었다면 제대로/정확한 보정된 정량값이 도출되게 되어 있음
		이때, 상기 가)항에서 소비자에게 준 "8개 Control 기준값(고정)"이 "실제 Real 검체 vs Control 반응 특성"을 완벽하게 적용시킨 값이라면
		최종 정량값은 제대로 보정된 값이 도출될 수 밖에 없지만, 제대�� "실제 Real 검체 vs Control 반응 특성"이 적용된
		"8개 Control 기준값(고정)"이 아니라면 최종 정량값은 제대로 보정되지 않은 값이 도출될 수 있음

20.	Real sample / 리얼샘플 측정 자료(실제 Cartridge에 Real sample을 넣어서 Prime Analyzer로 측정한 결과 자료)
1.	NT-proBNP
	U:\세종바이오메드\07_개발\IDx_POCT\IPI-CP01\문태석

2.	NT-proBNP 가 TnI 보다 CV 등의 성능이 안 좋을 수 밖에 없는 이유
		
		TnI					Raw값							30119
								측정값(환산농도)	1.69		ng/mL
								비율(%)						0.00561
		CK-MB				Raw값							16134
								측정값(환산농도)	10.98		ng/mL
								비율(%)						0.06808
1항	CK-MB비율/Tnl비율(%)					1213.09(12배)		->	CK-MB마커가 TnI마커 보다 Raw값을 측정값으로 환산하는 정도가 1213% 더 높기 때문에 CV등의 측정성능이 나쁠	수 밖에 없음

		TnI					Raw값							30119
								측정값(환산농도)	1.69		ng/mL
								비율(%)						0.00561
		NT-proBNP		Raw값							19422
								측정값(환산농도)	3007.87	pg/mL
								비율(%)						15.4869
2항	NT-proBNP비율/Tnl비율(%)			275973(275배)		->	NT-proBNP마커가 TnI마커 보다 Raw값을 측정값으로 환산하는 정도가 275973% 더 높기 때문에 CV등의 측정성능이 나쁠	수 밖에 없음
																											cf)	성능이 좋지 않은 CK-MB 보다 도 227배나 더 높기 때문에 CK-MB 보다도 CV가 227배나 더 안 좋을 수 밖에 없음
3항	2항/1항												227.497					->	해결방안 : NT-proBNP의 Peak를(면적을) 275배는 올려야 TnI 정도의 성능/CV가 나올 수 있음
																											Peak를 올린다는 것은 그냥 Y절편값을 올리는 것이 아닌 저농도에서 고농도 까지의 Raw값 크기 뿐만 아니라 변별력 차이도 크게 증가시키는 것을 의미함(기울기를 올려야 함)
																									cf)	TnI의 경우도 이전 보다 현재 Peak가 1/2정도 낮아 졌으며 이에, CV 등의 성능도 기존 보다 좋지 않음
																									cf)	중간 Washing buffer 흡수PAD의 경우 Membrane에 떨어져 있던 것을 물리적으로 붙이는 등 기구적으로 변화가 있기 때문에
																											CV 등에 안 좋은 영향을 줄 수 밖에 없음

다름이 아니고, 올해 2월에 보낸 문서를 재 송부 드립니다.

"NT-proBNP가 TnI 보다 CV 등의 성능이 안 좋을 수 밖에 없는 이유"에 대한 문서이며

1.	다시 한번 참고 부탁 드립니다.
2.	이유
		1)	TnI는 Raw값 30119에서 최종값 1.69로 표시되며
		2)	NT-proBNP는 Raw값 19422에서 최종값 3007.87로 표시되고 있습니다.
		3)	상기 1), 2)항 모두 Raw값이 동일하다고 해도 NT-proBNP가 1800배나 더 부풀려져서 최종값으로 표시되고 있는 것 입니다.
		4)	이는, NT-proBNP Raw값을 약간만 늘리는 것이 아닌 최소 2배는 늘려야지만 TnI 같은 성능이 나올 수 있다는 뜻입니다.
				1.69/30119 = 0.000056, 3.00/19422 = 0.000154 -> 0.000154/0.000056= 2.75(NT-proBNP 단위를 pg/ml -> ng/ml로 TnI와 같이 변경한 다음 연산된 배율)
		5)	참고로, 현 NT-proBNP가 중/고농도에서는 CV등 성능이 어느정도 나오지만 저농도에서만 성능이 나오지 않고 있는 현상과 동일한 결과를 나타내고 있습니다.
				Cf) 중/고농도는 Raw값이 그나마 높아서 성능이 나오지만 저농도는 워낙 Raw값이 적기 때문에 성능이 나오지 않음
				Cf) 타사도 이런 문제로 인해서 NT-proBNP 제품 개발이 쉽지 않을 것으로 보임

본 가설이 틀릴 수도 있지만 근본적인 문제의 원인일 수도 있습니다.



3.	그 밖의 측정마커 자료(QC Data)
	U:\세종바이오메드\06_생산\POCT\QC 
	
21.	Prime 측정기 비밀번호 : 1234
	미터기 Set -> Test Setting -> R% -> 1234 비밀번호 입력 -> R%값 수정

22.	Prime 측정기 -> 설정 -> R% 의미
	1)	R% 기본값은 1이며 이를 변경하면 변경한 값이 최종 결과값에 곱해져서 결과값이 나옴
	2)	TCM 상의 T/C/M 각각의 R%를 따로 변경할 수 있으며
		가)	본 변경 사항은 해당 마커의 LOT이 변경되어도 계속 유지됨
		나)	또한 TCM상에서 변경된 R%는 Single T, Single C, Single M에도 그대로 적용됨
			이와 반대의 경우도 성립(Single T의 R%를 변경하면 TCM상의 T의 R%도 변경됨)
		다)	R% 변경값은 Patient Test에서만 적용되며
			Control Solution Test에서는 적용되지 않음
			ex)	R%를 4로 변경시켰어도 Control Solution Test에서는 R%가 1로(기본값) 적용되어 최종측정값이 나옴
	3)	예제
	가)	테스트1	
		Patient Test		
		R%	TCM
		1	T = 1.15
		1	C = 5.38
		1	M = 204
	나)	테스트2	
		Patient Test		
		R%	TCM
		3	T = 3.41
		1	C = 5.48
		0	M = <10
	다)	테스트3	
		Control Solution Test		
		R%	TCM
		3	T = 1.17
		1	C = 5.59
		0	M = 204
	라)	테스트4	
		Patient Test		
		R%	T(Single)
		3	T = 3.52
		
		R%	C(Single)
		1	T = 5.38
		
		R%	M(Single)
		0	M = <10

23.	SmartMedi Prime F/W 수정 요청의 건(유효기간 문제 등 수정 요청의 건)(버그, Bug)
1.	ID chip 유효기간 처리 문제 수정
1)	현 상황
가)	SmartMedi Prime 셋팅 날짜 : 2018.04.09
나)	ID chip 날짜 : 2017.03.10 -> Expiry Date 에러 없이 동작 함
다)	ID chip 날짜 : 2017.04.09 -> Expiry Date 에러 발생
라)	ID chip 날짜 : 2017.04.10 -> Expiry Date 에러 없이 동작 함
?	상기 문제점은
다),라)는 정상 동작이지만
나)의 경우는 다)보다도 유효기간이 1달 더 지났음에도 불구하고 Expiry Date 에러가 발생하지 않습니다.
2)	이에, 차라리 아래와 같이 수정 부탁 드립니다.
가)	ID chip 날짜(그림1, Time set)를 기준으로 SmartMedi Prime 셋팅 날짜가 지났으면 Expiry Date 에러 발생
Ex) ID chip 날짜 : 2018.04.09
    SmartMedi Prime 셋팅 날짜 : 2018.04.10
?	Expiry Date 에러 발생
나)	ID chip 날짜(그림1, Time set)를 기준으로 SmartMedi Prime 셋팅 날짜가 지나지 않았으면 Expiry Date 에러 발생하지 않고 정상 동작
Ex1) ID chip 날짜 : 2018.04.09
    SmartMedi Prime 셋팅 날짜 : 2018.04.09
?	Expiry Date 에러 발생하지 않음
Ex2) ID chip 날짜 : 2018.04.09
    SmartMedi Prime 셋팅 날짜 : 2017.04.09
?	Expiry Date 에러 발생하지 않음

->	최종적으로 Ver 2.0.0 F/W는
	ID chip 날짜를 제조일자로 등록해야지만 정상 동작 함
	cf)	상기에서는 ID chip 날짜를 Expire date로 등록하는 것으로 요청 했지만
		Ver 2.0.0 F/W상에서는 미터기 날짜가 ID chip 날짜 + 1년(?) 이 넘으면 Expire error가 발생하도록 되어 있음

 
그림1) ID chip, Time set 설정화면

2.	마커 측정범위 수정 요청
　마커	기존	변경	비고
cTnI	0.05~30	0.1~30	Single 뿐만 아니라 Cardiac TC,TCM등 모든 cTnI 수정 
CK-MB	2~200	1.0~200	Single 뿐만 아니라 Cardiac TC,TCM등 모든 CK-MB 수정
Cf) CK-MB의 경우는 기존에 측정값이 2보다 작은 경우 LCD상에 <2.0으로 표시되는 것이 아닌 <2.0.2로 표시되는 경우 등이
발생 했으며(버그로 추정) 이런 사항 요번에 수정 부탁드립니다.
Cf) 첨부파일,  변경된 20180409 ID chip 품목별 약어 설정(Cutoff, Range).xlsx 파일 참고

3.	Check Device Test 의 경우 Expiry Error 발생하지 않음

4.	Auto power off : 한번만 변경되고 그 다음 부터는 설정값이 변경되지 않음



24.	SmartMedi Prime 에러 처리 확인

Please check that the cartridge is not used (실제 본 에러 발생 확인)(설명서 기입)
-	사용한 카트리지를 삽입하고서 Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Check the ID-CHIP or cartridge ! (실제 본 에러 발생 확인)(설명서 기입)
-	해당 카트리지 ID chip이 아닌 다른 ID chip을 측정기에 삽입한 다음 
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Check the cartridge is in a correct position! (실제 본 에러 발생 확인)(설명서 기입)
-	카트리지에 바코드 스티커를 붙이지 않고
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Please restart the test with a new cartridge! (실제 본 에러 발생 확인)(설명서 기입)
-	카트리지에 세척용액을 넣지 않고 Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Check the sample is correctly adjusted ! (실제 본 에러 발생 확인)(설명서 기입)
-	샘플을 투입하지 않고 Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Insert a test ID Chip (실제 본 에러 발생 확인)(설명서 기입)
- test ID Chip을 삽입하지 않고 Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Scan ID (실제 본 에러 발생 확인)(설명서 기입)(설명서 기입)
-	Setup에서 Barcode reader를 Active로
설정한 다음 Barcode scan없이 Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Insert Chip and Scan ID (실제 본 에러 발생 확인)(설명서 기입)
-	Setup에서 Barcode reader를 Active로
설정한 다음 ID chip도 삽입하지 않고 
Barcode scan도 실행하지 않은 상태에서
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Expiry Date	(실제 본 에러 발생 확인)(설명서 기입)
-	유효기간이 지난 카트리지를 삽입한 다음
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Insert a Check Device ID Chip (실제 본 에러 발생 확인)(설명서 기입)
-	Check Device Test 실행 시
Check Device ID chip을 삽입하지 않고
일반 test ID Chip 을 삽입한 다음 측정한
경우 본 에러가 발생하는지 점검

Low LED light intensity (본 에러 자체가 아예 없음, 인증용을 위해서 임시 추가 -> 2018년 최종 삭제 함)
-	LED광량을 최대로 어둡게 한 상태로
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

High LED light intensity (본 에러 자체가 아예 없음, 인증용을 위해서 임시 추가 -> 2018년 최종 삭제 함)
-	LED광량을 최대로 밝게 한 상태로
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Failure of Tray sensor (본 에러 자체가 아예 없음, 인증용을 위해서 임시 추가 -> 2018년 최종 삭제 함)
-	트레이 센서 연결선을 OFF시킨 상황에서
Patient Test측정을 실행 하면 본 에러가 발생하는지 점검

Check Device Test is failed
Refer to the instruction Manual (실제 본 에러 발생 확인)(설명서기입)
-	오염된 체크 디바이스 카트리지를 사용해서    Check Device Test를 실행한 경우 본 에러가 
발생하는지 점검

25.	Cartridge
		Prime 측정기 카트리지에서 사용하는 membrane은
		millipore, nc membrane 임
		-. Membrane : Hi-flow plus membrane(NC membrane)
		-. 모델명 : HF090
		
		cf)	인도 membrane 제조 업체
				nupore

###	cf)	sartorius
				UniSart Lateral Flow membrane에 Membrane상으로 Multi-channel을 만들어서 한번에 여러개 측정가능한 membrane이 있음
				Membrane상으로 여러 channel을 만들어 놓았기 때문에 기구적으로 본 membrane이 들어갈 공간만 만들어 주면 됨
				본 membrane의 장점은
				Membrane상으로 Multi-channel을 만들어 놓았기 때문에 카트리지 기구적으로 별다른 처리 없이 Multi 측정이 가능 합니다.




[93+1]	Prime / POCT 신규개발
1.	인증관련 부분
1)	카트리지 변경하지 않고 미터기만 외관/내부만 변경하는 경우
	가)	인증부분
		카트리지의 경우, 카트리지가 기존 미터기 대비 신규 미터기에서 측정 성능이 동일하다는 측정성능 비교 분석 자료를 작성해서
		각각 변경허가만 받으면 된다.
	나)	임상부분
		미터기(만) 변경 했다고 임상을 다시 받을 필요는 없다.

2.	형광측정 광학구조
1) 신규 카메라로 형광이미지 측정 환경 구축
 가) 형광측정용 S/W Tuning 및 광학 설계
    - FF01-630/38-25 BandpassFilter가 장착된 647nm Laser 2개
    - FF01-694/44-25 BandpassFilter가 장착된 신규카메라 1개
    - 형광이미지를 최대한 증폭시켜서 볼 수 있도록 카메라 S/W Tuning 1차 완료
    - Camera Lens, 적외선차단Filter가 없는 신규, 수동 Lens로 교체
      이유) 기존 자동Lens는 Lens밝기가 어둡고 적외선차단Filter를 장착하고 있는 것으로 보여
             적외선차단Filter가 없는 수동 Lens로 교체
      결과) 그림1 -> 그림2와 같이 기존 대비 형광이미지를 대략 3배 정도 밝게 측정할 수
             있는 효과 얻음 -> 본 Lens로 교체 확정
 나) 카메라/ Camera register setting
 		5.4 raw gamma
		The main purpose of the Gamma (GMA) function is to compensate for the non-linear characteristics of the sensor. GMA
		converts the pixel values according to the Gamma curve to compensate the sensor output under different light strengths.
		The non-linear gamma curve is approximately constructed with different linear functions. Raw gamma compensates the
		image in the RAW domain.

		참고)
			address 	register name		default value	R/W 	description
			0x5000 		ISP CONTROL 00 		0x06 			RW		Bit[5]: Raw gamma enable
																		0: Disable GMA
																		1: Enable GMA
			0x5001 		ISP CONTROL 01 		0x01 			RW		Bit[7]: Special digital effect enable
																		0: Disable
																		1: Enable
			0x5480 		GAMMA CONTROL00 	0x00 			RW		Bit[7:2]: Debug mode
																	Bit[1]: YSLP15 manual enable
																	Bit[0]: BIAS plus on
			0x5481 		GAMMA YST00 		0x26 			RW 		Bit[7:0]: Y yst 00
			0x5482 		GAMMA YST01 		0x35 			RW 		Bit[7:0]: Y yst 01
			0x5483 		GAMMA YST02 		0x48 			RW 		Bit[7:0]: Y yst 02
			0x5484 		GAMMA YST03 		0x57 			RW 		Bit[7:0]: Y yst 03
			0x5485 		GAMMA YST04 		0x63 			RW 		Bit[7:0]: Y yst 04
			0x5486 		GAMMA YST05 		0x6E 			RW 		Bit[7:0]: Y yst 05
			0x5487 		GAMMA YST06 		0x77 			RW 		Bit[7:0]: Y yst 06
			0x5488 		GAMMA YST07 		0x80 			RW 		Bit[7:0]: Y yst 07
			0x5489 		GAMMA YST08 		0x88 			RW 		Bit[7:0]: Y yst 08
			0x548A 		GAMMA YST09 		0x96 			RW 		Bit[7:0]: Y yst 09
			0x548B 		GAMMA YST0A 		0xA3 			RW 		Bit[7:0]: Y yst 0A
			0x548C 		GAMMA YST0B 		0xAF 			RW 		Bit[7:0]: Y yst 0B
			0x548D 		GAMMA YST0C 		0xC5 			RW 		Bit[7:0]: Y yst 0C
			0x548E 		GAMMA YST0D 		0xD7 			RW 		Bit[7:0]: Y yst 0D
			0x548F 		GAMMA YST0E 		0xE8 			RW 		Bit[7:0]: Y yst 0E
			0x5490 		GAMMA YST0F 		0x0F 			RW 		Bit[7:0]: Y yst 0F

###		아주중요)	실제테스트 결과
			0x5481 ~ 0x5484 GAMMA 값을 0x00으로 변경하니
			기존 검붉은색 background에 붉은색 형광Dye가 보이던 형광이미지가
			검붉은색 background는 검정색으로 완전히 변경되고 기존 붉은색 형광Dye는 감소없이 보이는 형광이미지로 변경 됨
		이유)	GAMMA 조절은 이미지 상 각 Pixel에 보상을 해줄 때 일정하게 보상을 해주는 것��� 아닌
			일정구간 마다(0x5481 ~ 0x5490 / YST00 ~ YST0F) 보상 비율을 manual / 비선형으로 지정해 줄 수 있는 것으로
			이로 인해 일정 광량 구간은 아예 제거 시킬 수 있는 장점을 가지고 있는 것으로 보임
 다) 광학설계
###		LED & 피사체 & 수신부(카메라)가 중심선(좌/우)을 기준으로 어느 한쪽으로 기울어짐 없이(상/하방향)
###		일직선을 이뤄야지만 Background 현상이 최소화 됨 테스트를 통해 확인 완료(약간만 기울어져도 검체 물기로 인해 난반사 많아짐 -> 이에 Background 상당히 증가)
###		-	Laser앞단에 BandpassFilter를 설치하면 Background가 40% 줄어듦 테스트를 통해 확인 완료

 라) Real sample 측정 -> Background 증가 현상
###			마른 Membrane에 형광dye가 그어져 있는 것을 카메라로 측정하면 Background 가 거의 없지만
###			마른 Membrane에 real sample을 투입해서 Membrane에 물기가 있으면 Background가 엄청나게 증가해서 Background와 Target형광을 구분하지 못하는 심각한 문제가 발생 함
			->	이유
###				물기가 형광Dye 파장shift 와 비슷한 현상을 일으키기 때문에 Backgroud가 엄청나게 생기는 것임
				-	LED광원이 형광Dye와 만나서 energy 준위가 낮은 파장이(파장이 길어짐) 방출하는 것과 유사하게
				-	LED광원이 Membrane에 있는 물기와 만나면 물기가 LED광원 energy를 흡수해서 energy를 읽게 되어 energy 준위가 낮은 파장이(파장이 길어짐) 방출하게 되며 이런 현상이 형광dye 파장shift 현상과 거의 유사한 반응이기 때문
			->	해결방법
###				최대한 LED파장 대와 형광Dye방출파장 대가 큰 차이가 벌어지도록 해서 물기로 인한 파장shift 현상으로 방출되는 파장은 수신부로 들어가지 못하도록 해야 함

###			cf)	Prime이 Background 현상 적은 이유
###				Laser 광원이 피사체에 노출되는 영역이 작은 직사각형(직선)으로 최대한 적은 면적으로 노출시키면서 Membrane을 PhotoDiode로 읽어 나가기 때문에
###				물기 -> 잡광/난반사로 인해 Background 영향을 적게 받을 수 밖에 없음(카메라 방식의 경우 Laser 조명을 Membrane 전 영역에 노출 시키기 때문에 Prime 광학 구조 보다 잡광/난방사 영향을 더 많이 받을 수 밖에 없음)

			->	최종결론1
###			1)	Auto white balance (AWB) 를 Disable 시키자
				이유)	Auto white balance (AWB) 를 Disable시키면 R/G/B가 제대로 구현되지 않고 녹색으로 saturation이 많이 일어나지만
					Auto white balance (AWB) 를 Enable시키고 AWB gain manual 경우에는 Camera Preview 상태에서 image가 밝아졌다 어두워졌다 하는 현상이
					Auto white balance (AWB) 를 Disable시킨 경우 보다 더 많이 일어나가기 때문에 측정값 CV를 고려하면 Auto white balance (AWB) 를 Disable 시킨것이 오히려 낫기 때문
###			2)	Contrast를 최대로 높이고 Bright를 최대로 어둡게 해서 명암비를 최대로 높이자(ex, 밝은색은 더 밝아지고 어두운색은 더 어두워지게 변함)
###			3)	또한 "Auto white balance (AWB) 를 Disable" 시키고 "Saturation을 0으로" setting한 경우
				녹색으로 saturation이(Green image로 분석) 더 많이 되기는 하지만 이 경우 오히려
###				Real sample 측정 -> membrane 물기에 의해 발생하는 Background 발색 현상과 Target 형광 발색을 구분해 내는 능력이 더 높아지는 장점 있음
###				cf)	Green image로 분석하는 경우 수신부 BandpassFilter 종류를 달리 하면 아래와 같이 형광/Background를 더 잘 구분하는 것으로 확인 됨
###					이유)	물기에 의한 파장 shift 현상 보다 형광에 의한 파장 shift 현상이 더 큰 것으로 보이며(더 대역폭이 큰 것으로 보이며)
###						이에, BandpassFilter 파장 대를 더 장 파장으로 사용하면 형광에 의한 파장 만을 읽을 확률이 높기 때문
###					Prime filter < 694nm/44 filter < 809nm/81 filter	-> 809nm/81 filter가 가장 잘 구분함
				cf)	Green image로 분석하면 물기에 의한 Background와 형광을 더 잘 구분하는 것은
					아마도 R/G/B중 G sensor가 R/B sensor 보다 분해능이 높아서 그런 것 아닌가 하는 생각이 듦 
###				ex)	Backround 발색 현상은 줄어들면서도 형광Target 발색은 어느 정도 발생해서 대비를 이뤄주는 아주 큰 장점 있음
					이렇게 하지 않으면 Backround 발색 현상에 의해서 형광Target 발색이 묻혀 버려서 측정할 수 없는 아주 큰 문제 발생 함
				

			->	최종결론2
###			1)	Auto white balance (AWB) 를 Enable 시키고 AWB gain manual으로 설정한 상태에서
###				0x3400 에서 0x3405 값을 변경시켜 각각의 R/G/B Gain 을 조절하자
				-> 이렇게 하면 AWB Auto로 작동하는 것이 아닌 Manual white balance 로 작동하게 되는 것이 맞음 테스트를 통해 최종 확인 완료
				이유)
###				가)	최종결론1 -> 1)항에서 image가 밝아졌다 어두워졌다 하는 것은 Auto white balance (AWB)를 Enable시켜서 발생하는 것인 아닌
					어두운 이미지를 보기 위해서 너무 노출계수를 증가시켜서 발생하는 것임
###				나)	최종결론1 -> 3)항과 같이 해서 Green image로 분석 형광Target과 Background를 구분하는 것은
					Auto white balance (AWB) 를 Enable 시키고 AWB gain manual으로 설정한 상태에서
					0x3400 에서 0x3405 값을 조절해서도 동일하게 얻을 수 있음				
###			2)	Contrast를 최대로 높이고 Bright를 최대로 어둡게 해서 명암비를 최대로 높이자(ex, 밝은색은 더 밝아지고 어두운색은 더 어두워지게 변함)	
			3)	Green image로 형광 분석 불가
				이유)	Green image로 647nm형광을 분석하면 background는 감소할 수 있어도 저농도 부근 변별력이 없기 때문에(저농도 부근 아예 보이지 않음) 측정 불가 함  
###			4)	Background 증가 현상 개선 확인(확실하게 흰분홍색으로 환하게 발생하던 background가 거의 검정색으로 상당히 많아 사라짐 확인 완료)
				Real검체 -> 물기 -> 광산란에 의한 Background 증가 현상이 하기와 같이 변경하면 Background 현상이 확실히 감소됨 확인 완료
###				-	Laser 광원 앞에 불투명스카치테이프를 붙이면 광산란 감소 -> Background 감소(감소율 : 30%)
					cf) 직사광선 보다 간접 조명이 광산란을 억제 시킴
###				-	Camera Gain을 최소화 하고 노출시간을 최대로 하면 광산란에 의한 Background는 감소하면서 형광Target은 더 잘 보임 확인 완료
					실제테스트 결과 가)항이 나)항 보다 30%정도 Background 어둡고 형광Target은 더 잘 보임 확인 완료(좀 더 부드럽고 매끄러운 이미지로 측정 됨)
					가)	0x380c = 0x1f & 0x350b = 0x25(노출계수 최대 & Gain 최소)
					나)	0x380c = 0x10 & 0x350b = 0x50(노출계수 최소 & Gain 최대)				
				-	검정색 Backing card 사용
###					기존 투명 Backing card 대신 -> 검정색 Backing card 사용하면 확실하게 Background 감소(감소율 : 70%)
				-	Membrane 주면이 아닌 외곽(카메라 렌즈를 중심으로 도너츠 모양의 외곽)에 심하게 발생하는 Background는
###					Catridge에 붙어 있는 흰색스티커 때문에 발생하는 것임(흰색스티커 제거하는 본 현상 없어짐)
					cf)	추후 양산 시에는 암실을 만들어 membrane 주면 만을 촬영하도록 만들 것이기 때문에 문제되지 않음
###				-	수신부 BandpassFilter는 적당히 Background/형광Target을 구분시켜 주면서 저농도도 측정할 수 있는 694/44nm filter를 사용하자.
###					이유)	716/40nm filter의 경우 694/44nm 보다 Background를 감소시켜 주기는 하지만 형광 저농도 intensity도 감소시키기 때문에 저농도를 측정할 수 없는 문제 발생하기 때문
###					이유)	기존 Prime filter의 경우 너무 빛을 많이 받아들이기 때문에 Background(물기)와 형광Target을 아예 구분시켜주지 못하는 문제 발생함			


[94]	분자진단분석프로그램 개요
1.	Bio-Rad CFX 에서 기본으로 제공해 주는 프로그램은 Data Analysis - melt curve primer이며
	본 프로그램은 측정raw data를 그래프로 표시해 주고 excel data로 export해주는 기능과
	(Tools -> Export All Data Sheets to Excel)
	각각의 well Sample 파형을 분석해서	Negative / Positive를 판단해 주는 기능이 있다.
	
2.	Seegene Viewer의 경우는 상기 1번 기능 이외에
	환자정보/형광Dye/등의 정보를 Bio-Rad 프로그램 처럼 사용자가 일일이 입력해 주지 않고
	병원에서 제공해 주는 Excel data(환자정보/형광Dye/등의 정보가 이미 입력되어 있음)
	를 Loading만 해주면 자동으로 입력시켜주는 기능을 포함하고 있다.
	1)	실행방법
		가)	D:\Program\SJ\SW\Molecular Diagnosis Program\문서\data\Seegene\Seegene Viewer for Real time Instruments V2.0\Seegene Viewer for Real time Instruments.exe 실행
		나)	Anyplex MTB/NTM Real-time Detection v1.1 선택
		다)	File -> Open -> 파일종류:CFX96 Export Data -> D:\Program\SJ\SW\Molecular Diagnosis Program\문서\data\Seegene\TB 423-448 11-JULY-2013\TB 423-448  11-JULY-2013 -  Quantitation Ct Results.xlsx 선택
		라)	WELL PLATE 내부에 있는 각각의 WELL을 선택하면 해당하는 WELL의 그래프와 결과를 보여 줌
		cf)	File -> Open -> 파일종류:CFX96 Export Data -> D:\Program\SJ\SW\Molecular Diagnosis Program\문서\data\Seegene\TB 423-448 11-JULY-2013\TB 423-448  11-JULY-2013 -  Quantitation Amplification Results.xlsx 파일의
			각각의 WELL에 대한 측정파형이 있으며
			프로그램상 -> WELL GRAPH -> []FAM []Cal Red 610 []Quasar 670 선택에 대한 각각의 DATA는 엑셀파일 내부에 있는 시트탭(FAM / Cal Red 610 / Quasar 670) 각각에 들어 있는 DATA이며
			A2(A행 2열) DATA는 엑셀파일 A2열의 DATA를 뜻함
		cf)	Seegene Viewer
			->	Option -> Instrument -> CFX96 으로 선택
			-> 장비명을 Anyplex II HPV28 Detection (96 plate)로 설정하면 Bio-Rad CFX Data를 읽어들여서 볼 수 있음

3.	Bio-Rad Export data 설명
	1)	ex)	170911_plate1_tail test_2017-09-11 11-07-29_CC015836_4045 -  Melt Curve RFU Results.xlsx Data를 미분시킨 파일이
		ex)	170911_plate1_tail test_2017-09-11 11-07-29_CC015836_4045 -  Melt Curve Derivative Results.xlsx 임


[95]	Windows10 / 윈도우10
1.	윈도우10 시작 메뉴 프로그램/폴더 및 단축아이콘 편집 경로
C:\ProgramData\Microsoft\Windows\Start Menu\Programs
2.	윈도우10 로그인 화면 저장 위치
1)	C:\Users\user\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets 에 위치해 있으며
2)	해당 폴더를 다른 곳은 복사한 다음 커맨드창에서 하기 명령을 실행하면 이미지를 볼 수 있음
	cmd /c "ren *.* *.jpg"




[96]	SM32Pro for USB
1.	Find Peak 기능은 Dark Scan 기능을 먼저 수행해야지만 사용할 수 있다.




[97]	Visual Studio 2017
1-1	Visual Studio 2017 사용방법 소개 사이트
https://docs.microsoft.com/ko-kr/visualstudio/ide/visual-studio-ide
https://msdn.microsoft.com/ko-kr/library/dd492132.aspx

1	.NET Framework
1)	c# 하고 C++ 의 차이가 뭔가요?
	상세히 말하자면 C#이 있고 C++.NET 이 있고 C++이 있습니다. C++은 일반적인 C++이고 C++.NET은 C++을 .NET 위에 돌리기위해 MS에서 개조한 언어입니다. C#은 JAVA와 비슷한 객체지향성을 강조한 형태의 언어입니다.
	그리하여 보통 C++의 경우 객체지향이긴 해도 C와 비슷한 문법이지만 C#은 JAVA와 비슷한 문법을 가집니다.
2)	c# 닷넷하고 그냥 c#의 차이는 뭔가요?
	C# .net이 아닌 그냥 C# 입니다. C#은 애초에 .net 프레임워크상에서만 돌아가는 언어입니다 그래서 C#으로 그냥 불립니다.
3)	닷넷이라는게 프레임워크라고하던데 그냥 개발환경을 지원하는 틀을 말하는건가요?
	프레임워크는 개발자들에게 정형화된 개발환경을 제공하는 툴이 아닌 그냥 기반입니다. 가상의 머신같은거죠
4)	닷넷으로 만든 프로그램을 배포하면 닷넷프레임워크가 깔려있어야만 실행이 되는건가요?
	만약그렇다면 왜 그렇게 불편하게 만들었나요?
	네 C++.net 또는 C# 및 VB.NET 등 .net 프레임 워크 기반 언어들은 실행을 위해선 해당 프레임워크가 필요하며 또한 개발시 프레임워크 버전또한 같아야 됩니다.
	프레임워크에 가장 큰 제약조건이긴 하지만 대신 개발 효율이 극대화 되기 때문입니다. 가령 일반 C++로 윈도우 폼 등을 개발할려하면 일일이 다 코딩해야 하니 오랜 시간이 걸리게 되겟지만 
	C++.net 의 경우 .net 프레임워크상에 존재하는 System.Windows.Forms 라이브러리를 이용해 쉽게 개발 할 수 있으므로 시간이 단축됩니다. 이런 환경은 JAVA도 동일 합니다. 
	JAVA 또한 개발을 쉽지만 다만 실행할려면 실행하고자 하는 컴퓨터에 JDK 가 설치되어 있어야 됩니다. 다만 이 JDK 가 여러 OS 기반으로 각각 개발되어 있으므로 여러 컴퓨터에 이식율이 좋은 겁니다. 
	그에 비해 .net 은 Windows 환경내에서만 개발되어있는데에다 또한 XP 이하에서는 64bit 32bit 가 개별적으로 .net을 사용해야하다보니 이식율이 떨어지죠
5)	자바랑 큰차이는 뭘까요?
	자바랑 기본적으로 객체지향언어이기에 큰 차이는 없으나 가장 큰 차이는 C#의 경우 JAVA의 객체지향 개념에 VB 같은 IDE 개념이 같이 공존하고 또한 동적프로그래밍 능력이 결합된 형태로 객체 지향형태로 개발하면서도 
	VB 같이 쉽게 폼개발이 가능하고 C++처럼 동적처리를 이용해 컴파일러 개발 등에도 지원을 할수있는 능력을 가졌습니다.
6)	.NET Framework의 버전 호환성
	이전 버전과의 호환성은 특정 버전의 플랫폼용으로 개발된 앱이 해당 플랫폼의 다음 버전에서도 실행되는 것을 의미합니다. 
	.NET Framework에서는 이전 버전과의 호환성을 최대한 지원하려고 합니다. 한 버전의 .NET Framework용으로 작성된 소스 코드는 다음 버전의 
	.NET Framework에서 컴파일되어야 하며 한 버전의 .NET Framework에서 실행되는 이진 파일은 다음 버전의 .NET Framework에서 동일하게 작동해야 합니다.

2.	Windows 버전별 .NET Framework 기본 사양

Windows XP Media Center Edition?(Windows XP SP1) includes the?.NET Framework 1.0 + SP2?as an OS component
Windows XP Media Center Edition?(Windows XP SP2 and higher) includes the?.NET Framework 1.0 + SP3?as an OS component.? On Windows XP Media Center Edition, the only way to get the .NET Framework 1.0 SP3 is to install Windows XP SP2 or higher.? There is not?a standalone 1.0 SP3 installer for this edition of Windows XP.
Windows XP Tablet PC Edition?(Windows XP SP1) includes the?.NET Framework 1.0 + SP2?as an OS component
Windows XP Tablet PC Edition?(Windows XP SP2 and higher) includes the?.NET Framework 1.0 + SP3?as an OS component.? On Windows XP Tablet PC Edition, the only way to get the .NET Framework 1.0 SP3 is to install Windows XP SP2 or higher.? There is not?a standalone 1.0 SP3 installer for this edition of Windows XP.
Windows Server 2003?(all x86 editions)?includes the?.NET Framework 1.1?as an OS component; 64-bit versions of Windows Server 2003 do not include a version of the .NET Framework as an OS component
Windows Vista?(all editions)?includes the?.NET Framework 2.0 and 3.0?as OS components? 3.0 can be added or removed via the Programs and Fatures control panel.
Windows Vista SP1?(all editions)?includes the?.NET Framework 2.0 SP1 and 3.0 SP1?as OS components.? 3.0 SP1 can be added or removed via the Programs and Features control panel.
Windows Server 2008 and Windows Server 2008 SP1?(all editions)?includes the?.NET Framework 2.0 SP1 and 3.0 SP1?as OS components.? The .NET Framework 3.0 SP1?is not installed by default and must be added via the Programs and Features control panel though.
Windows Server 2008 SP2?(all editions)?includes the?.NET Framework 2.0 SP2 and 3.0 SP2?as OS components.? The .NET Framework 3.0 SP2?is not installed by default and must be added via the Programs and Features control panel though.
Windows Server 2008 R2?(all editions)?includes the?.NET Framework 3.5.1?as an OS component.? This means you will get the.NET Framework 2.0 SP2, 3.0 SP2 and 3.5 SP1?plus a few post 3.5 SP1 bug fixes.? 3.0 SP2 and 3.5 SP1 can be added or removed via the Programs and Features control panel.

Windows 7?(all editions)?includes the?.NET Framework 3.5.1?as an OS component.? 
This means you will get the?.NET Framework 2.0 SP2, 3.0 SP2 and 3.5 SP1?plus a few post 3.5 SP1 bug fixes.? 
3.0 SP2 and 3.5 SP1 can be added or removed via the Programs and Features control panel.
cf)	.NET Framework 3.5의 경우 Windows 10에서 사용하려면 제어판 -> Windows 기능 -> .NET Framework 3.5(.NET 2.0 및 3.0 포함) 확인란을
	선택해야지만(기본 셋팅은 disable) 사용할 수 있다

Windows 8 (all editions)?includes the .NET Framework 4.5 as an OS component, and it is installed by default.? It also includes the .NET Framework 3.5 SP1 as an OS component that is not installed by default.? The .NET Framework 3.5 SP1 can be added or removed via the Programs and Features control panel.
Windows 8.1 (all editions)?includes the .NET Framework 4.5.1 as an OS component, and it is installed by default.? It also includes the .NET Framework 3.5 SP1 as an OS component that is not installed by default.? The .NET Framework 3.5 SP1 can be added or removed via the Programs and Features control panel.
Windows Server 2012 (all editions)?includes the .NET Framework 4.5 as an OS component, and it is installed by default except in the Server Core configuration.? It also includes the .NET Framework 3.5 SP1 as an OS component that is not installed by default.? The .NET Framework 3.5 SP1 can be added or removed via the Server Manager.
Windows Server 2012 R2?(all editions)?includes the .NET Framework 4.5.1 as an OS component, and it is installed by default except in the Server Core configuration.? It also includes the .NET Framework 3.5 SP1 as an OS component that is not installed by default.? The .NET Framework 3.5 SP1 can be added or removed via the Server Manager.

Windows 10 (all editions)?includes the .NET Framework 4.6 as an OS component, and it is installed by default.? 
It also includes the .NET Framework 3.5 SP1 as an OS component that is not installed by default.? 
The .NET Framework 3.5 SP1 can be added or removed via the Programs and Features control panel.

 윈도우 버전	.NET Framework 버전 
 윈도우 7		.NET Framework 3.5
 윈도우 8		.NET Framework 4.5
 윈도우 8.1		.NET Framework 4.5.1
 윈도우 10		.NET Framework 4.6

->	C# 코딩 시 .NET Framework 4.5.2를 기본으로 사용하자
	이유는, .NET Framework 4.5.2의 경우 Visual Studio 2017 -> 게시 -> 필수구성요소에서 선택할 수 있고
	만약 .NET Framework 4.5.2가 기본으로 깔려 있지 않은 Windows 7의 경우에도 아래 3.게시 -> "게시 프로그램 내부 파일로 .NET Framework을 설치"하는 방법을 참고해서
	게시하면 자동으로 .NET Framework 4.5.2가 설치되기 때문
	
3.	게시
1)	개발된 프로그램을 고객이 설치해서 사용할 수 있도록 setup.exe 프로그램으로 변경시켜주는 과정
2)	게시는 별다른 어려움이 없으며 아래 과정을 실행하면 setup.exe 프로그램이 만들짐
	가)	프로젝트 속성
		a)	응용 프로그램 -> 대상 프레임워크 선택 -> .NET Framework 4.5
		b)	빌드 -> 플랫폼 대상 -> Any CPU(32bits / 64bits 모두 구동)
	나)	프로젝트 속성 -> 게시
		a)	설치 모드 및 설정 -> 필수 구성 요소 -> .NET Framework 4.5.2 선택
			& 필수 구성 요소의 설치 위치를 지정하세요 -> "구성 요소 공급업체의 웹 사이트에서 필수 구성 요소 다운로드" 선택(인터넷으로 부터 .NET Framework 다운로드)
		b)	옵션 -> 게시자 정보 입력
		c)	지금 게시

	cf)	고객사가 게시 프로그램 실행 중 .NET Framework를 설치해야 할 경우 상기와 같이 인터넷에서 .NET Framework를 다운 받아서 설치하는 것이 아닌
		게시 프로그램 내부 파일로 .NET Framework을 설치하는 방법
	1.	Visual Studio 2017의 경우 게시 -> 필수구성요소 -> .NET Framework 4.5.2 를 선택할 수 있기 때문에
		필수구성요소 -> .NET Framework 4.5.2로 선택
	2.	.NET Framework 4.5.2 를 다운 받아서 아래 폴더에 복사
		1)	NDP452-KB2901907-x86-x64-AllOS-ENU.exe 파일은
			C:\Program Files (x86)\Microsoft SDKs\ClickOnce Bootstrapper\Packages\DotNetFX452 폴더에 복사
		2)	NDP452-KB2901907-x86-x64-AllOS-KOR.exe 파일은
			C:\Program Files (x86)\Microsoft SDKs\ClickOnce Bootstrapper\Packages\DotNetFX452\ko 폴더에 복사
	3.	Visual Studio 2017 -> 게시 -> 필수구성요소 -> 필수 구성 요소의 설치 위치 -> "내 응용 프로그램과 동일한 위치에서 필수 구성 요소 다운로드" 선택
		이후 "지금 게시"누름
3)	만들어진 setup.exe 프로그램을 고객사 컴퓨터에서 실행하면 자동으로 프로그램이 설치 됨
	cf)	해당하는 .NET Framework가 설치되어 있지 않으면 자동으로 해당 .NET Framework를 먼저 설치하는 과정이 실행될 것으로 보임
		ex)	게시 -> 필수 구성 요소 선택을 .NET Framework 3.5로 선택했고
			고객사 PC에 본 .NET Framework 3.5가 설치되어 있지 않은 경우 자동으로
			본 .NET Framework 3.5를 먼저 설치하며(단, 인터넷으로 부터 다운 받아서 실행되기 때문에 인터넷이 연결되어 있어야 함)
			이후 해당 프로그램이 설치 될 것으로 보임
	cf)	setup.exe를 실행시켜서 생성된 프로그램은 아래 폴더에 저장 됨
		ex) C:\Users\user\AppData\Local\Apps\2.0\0LP4OHPK.06T\QO1PMZGJ.CQ4\myte..tion_eafa10d526079282_0001.0000_ba63fb340dfe42f3

4.	다른 프로젝트 파일 추가
1)	해당프로젝트 -> 오른쪽마우스버튼클릭 -> 추가 -> 기존항목 -> 원하는 파일 추가

5.	"'Microsoft' 네임스페이스에 'Office' 형식 또는 네임스페이스 이름이 없습니다. 어셈블리 참조가 있는지 확인하세요." 에러 해결
1)	프로젝트 -> 참조 -> 참조추가 -> 어셈블리 -> 확장 -> Microsoft.Office.Interop.Excel 선택

6.	"'Microsoft.CSharp.RuntimeBinder.Binder.Convert' 멤버가 필요한 컴파일러가 없습니다.	에러 해결
1)	프로젝트 -> 참조 -> 참조추가 -> 어셈블리 -> 프레임워크 -> Microsoft.CSharp 선택

7.	Event 추가
	ex)	버튼 눌렀을 때 click event가 발생하게 하고 싶다면
		1)	디자인 화면에서 해당 버튼(UI) 선택
		2)	속성 -> 이벤트(번개표) 선택
		3)	작업 -> Click -> button1_Click 등 원하는 메서드명 기입
		4)	Visual Studio에서 자동으로 해당 버튼 눌렀을 때 button1_Click 메서드가 실행되도록 등록시켜주며
			button1_Click 메서드가 자동으로 S/W적으로 생성됨
	ex)	FormClosed
		FormClosed 이 이벤트는 사용자 또는 폼이 닫힌 후 발생는 Close 메서드 또는 Exit 의 메서드 Application 클래스입니다.
		폼을 닫지 않도록 하는 처리를 하려면 FormClosing 이벤트를 사용하면 됨
8.	Form x버튼 누를 때, Form 종료 시
	사용자가 폼의 x 버튼을 누르거나 프로그램에서 Close()가 호출된다면
	FormClosing();
	Close();
	FormClosed();
	의 순서로 호출 된다고 생각해도 된단다.

9.	Visual C#
	1)	새 프로젝트
		가)	Windows 유니버설
		->	중요) OS : Windows 10에서만 제대로 동작하며 하위 OS에서는 기본적으로 실행되기 어려움
			물리적 컴퓨터는 Windows 8.1(x64) Professional Edition 이상을 실행하고 클라이언트 Hyper-V 및 SLAT(두 번째 수준 주소 변환)를 지원하는 프로세서가 있어야 합니다.
		->	결론 : 호환성을 위해 사용하지 말자

		UWP(유니버설 Windows 플랫폼) 앱이란?
		UWP(유니버설 Windows 플랫폼)는 Windows 10용 앱 플랫폼입니다. 하나의 API 집합과 하나의 앱 패키지, 그리고 하나의 스토어만을 사용해 UWP용 앱을 개발하여 
		PC, 태블릿, 휴대폰, Xbox, HoloLens, Surface Hub 등의 모든 Windows 10 디바이스에서 사용할 수 있습니다. 다양한 화면 크기뿐만 아니라 터치, 마우스 및 키보드, 게임 컨트롤러, 펜 등 다양한 조작 모델을 손쉽게 지원합니다. 
		UWP 앱의 핵심은 사용자가 자신의 모든 장치에서 모바일 환경을 원하고 작업에 가장 편리하거나 생산적인 장치를 사용하기를 원한다는 개념입니다.
		또한 UWP는 유연합니다. 원치 않을 경우 C# 및 XAML을 사용할 필요가 없습니다. Unity 또는 MonoGame으로 개발해도 됩니다. JavaScript로 개발해도 됩니다. 
		원하는 것을 사용하면 됩니다. UWP 기능으로 확장하고 스토어에서 판매하려는 C++ 데스크톱 앱이 있나요? 그것도 가능합니다. 
		결론: 하나의 프로젝트에서 친숙한 프로그래밍 언어, 프레임워크 및 API를 모두 사용하여 작업을 수행하고, 현존하는 다양한 Windows 하드웨어에서 동일한 코드를 실행할 수 있습니다. 
		UWP 앱을 작성한 후에는 전 세계의 사람들이 볼 수 있도록 스토어에 게시할 수 있습니다.
		
		cf)	UWP(유니버설 Windows 플랫폼)용 앱 개발
		유니버설 Windows 플랫폼과 단일 Windows 코어를 사용하여 휴대폰에서 데스크톱에 이르는 모든 Windows 10 장치에서 동일한 앱을 실행할 수 있습니다. 
		Visual Studio 2015 및 유니버설 Windows 앱 개발 도구를 사용하여 이러한 유니버설 Windows 앱을 만듭니다.

		Windows 10 Phone, Windows 10 데스크톱 또는 Xbox에서 이 앱을 실행합니다. 동일한 앱 패키지입니다. Windows 10 단일 통합 코어가 도입되면서 하나의 앱 패키지를 모든 플랫폼에서 실행할 수 있습니다. 
		일부 플랫폼에는 플랫폼 특정 동작을 활용하기 위해 앱에 추가할 수 있는 확장 SDK가 있습니다. 예를 들어 모바일용 SDK 확장은 Windows Phone에서 뒤로 단추를 누르는 동작을 처리합니다. 
		프로젝트에서 확장 SDK를 참조하는 경우 런타임 검사를 추가하여 해당 플랫폼에서 SDK를 사용할 수 있는지 테스트하면 됩니다. 이런 방식으로 각 플랫폼에 동일한 앱 패키지를 사용할 수 있습니다.

		Windows Core란 무엇인가요?
		처음으로 Windows가 모든 Windows 10 플랫폼에서 공통 코어를 사용하도록 리팩터링되었습니다. 하나의 공통 소스, 하나의 공통 Windows 커널, 하나의 파일 I/O 스택 및 하나의 앱 모델이 있습니다.
		UI의 경우 하나의 XAML UI 프레임워크와 하나의 HTML UI 프레임워크가 있습니다. 따라서 다양한 Windows 10 장치에서 앱을 쉽게 실행할 수 있으므로 뛰어난 앱을 개발하는 데만 집중할 수 있습니다.
		
		유니버설 Windows 플랫폼이란 정확히 무엇인가요?
		단순히 계약 및 버전 컬렉션입니다. 앱을 실행할 수 있는 대상을 지정하는 데 사용됩니다. 더 이상 운영 체제를 대상으로 지정하지 않습니다.
		이제 하나 이상의 장치 제품군을 앱의 대상으로 지정합니다. 자세한 내용은 이 플랫폼 가이드를 참조하세요.
		
		요구 사항
		유니버설 Windows 앱 개발 도구에는 여러 다른 장치에서의 앱 모양을 확인하는 데 사용할 수 있는 에뮬레이터가 제공됩니다. 
		이러한 에뮬레이터를 사용하려는 경우 물리적 컴퓨터에서 이 소프트웨어를 설치해야 합니다. 
		물리적 컴퓨터는 Windows 8.1(x64) Professional Edition 이상을 실행하고 클라이언트 Hyper-V 및 SLAT(두 번째 수준 주소 변환)를 지원하는 프로세서가 있어야 합니다. 
		Visual Studio가 가상 컴퓨터에 설치된 경우에는 에뮬레이터를 사용할 수 없습니다.

		필요한 소프트웨어 목록은 다음과 같습니다.
		Windows 10
		Visual Studio 2015. 유니버설 Windows 앱 개발 도구가 선택적 기능 목록에서 선택되었는지 확인합니다. 이러한 도구가 없으면 유니버설 앱을 만들 수 없습니다.
		
		이 소프트웨어를 설치한 후에 개발에 대해 Windows 10 장치를 사용하도록 설정(영문)해야 합니다. 각 Windows 10 장치에 대한 개발자 라이선스는 더 이상 필요하지 않습니다.
		
		Windows 8.1 및 Windows 7 지원
		Windows 10 이외의 플랫폼에서 Visual Studio 2015를 사용하여 유니버설 Windows 앱을 개발하기로 선택한 경우 다음과 같은 제한 사항이 적용됩니다.
		Windows 8.1: 앱을 로컬로 실행할 수 없습니다(원격 Windows 10 장치에서만). Visual Studio에서 에뮬레이터를 사용할 수 있지만 시뮬레이터는 사용할 수 없습니다.
		Windows 7: 앱을 로컬로 실행할 수 없습니다(원격 Windows 10 장치에서만). Visual Studio에서 에뮬레이터나 시뮬레이터 중 하나만 사용할 수 있습니다.
		개발 플랫폼이 Windows 10인 경우에만 XAML 디자이너를 사용할 수 있습니다.

		유니버설 Windows 앱
		C#, Visual Basic, C++ 또는 JavaScript에서 기본 설정 개발 언어를 선택하여 Windows 10 장치용 유니버설 Windows 앱을 만드세요. 또는 이 시작 동영상을 시청하세요.
		기존 Windows 스토어 8.1 앱, Windows Phone 8.1 앱 또는 Visual Studio 2015 RC를 사용하여 만든 유니버설 Windows 앱이 있으면 이러한 기존 앱을 포팅하여 최신 유니버설 Windows 플랫폼을 사용합니다.
		유니버설 Windows 앱을 만든 후 앱을 패키지하여 Windows 10 장치에 설치하거나 Windows 스토어에 제출해야 합니다.
		
		나)	Windows 클래식 바탕 화면 -> 본 항목을 주로 사용하자(가장 보편적)
			a)	Windows Forms 앱 -> 주로 선택하는 항목(본 선택과 동시에 .NET Framework는 .NET Framework 4.5를 선택하자)
				콘솔 타입(CMD)의 소프트웨어와 달리 마우스의 이용확 더불어 버튼, 체크박스 등 시각적인 요소들을
				중심으로 개발할 수 있는 GUI 기반의 프로젝트 유형을 말함
	2)	Image Button 구현하기1(본 방식을 사용하자)
		가)	윈폼의 Button 컨트롤은 버튼 안에 텍스트 혹은 이미지 넣을 수 있으며, 텍스트와 이미지를 모두 넣을 수도 있다.
			이미지를 넣기 위해서는 ToolBox에서 ImageList 를 드래그하여 폼에 끌어다 두고, 하단에 표시된 ImageList를 클릭하여 속성창에서 Images에 이미지들을 넣으면 됩니다. 
			또한 ImageList의 속성창에서 ImageSize를 변경하여 크기를 조정한다. ImageList가 완성되었으면, Button 속성창에서 ImageList를 지정하고, ImageList 안에 포함된 이미지의 인덱스를 ImageIndex에 지정하면 된다. 
		나)	가)와 같이 구현하면 해당 버튼 근처로 마우스를 이동시키면 버튼 배경색이 하늘색으로 변하며
		다)	버튼 눌렀을 때 이미지를 변경시키려면 아래와 같이 구현하면 됨
			private void Button_A1_Click(object sender, EventArgs e)
			{
				this.button1.ImageIndex = 1;            // cf) this.button1.ImageIndex = 1; 이 imageList1의 0번째가 아닌 1번째 등록된 이미지를 뜻함			
//				this.button1.BackColor = Color.Red;
			}		
			
	3)	Image Button 구현하기2	
		가)	해당 프로젝트 -> Resources 폴더에 Normal/Press 이미지 파일 복사(ex, 이름 : Button_Normal, Button_Press)
		나)	솔루션탐색기 -> Properties -> Resources.resx 더블클릭
			-> 리소스추가(바로 옆 작은아래화살표 클릭) -> 기존파일추가 -> 가)항에서 복사해 놓은 파일 선택해서 추가
		다)	해당버튼 -> 속성 -> Image -> 나)항에서 추가한 이미지 선택(Normal image, Button_Normal 선택)
		라)	해당버튼 -> 이벤트(번개표) -> Click -> 메서드추가 -> 아래와 같이 해당 버튼 이미지 변경(Press image, Button_Press)
			private void Button_A1_Click(object sender, EventArgs e)
			{
				this.button1.Image = global::MolecularDiagnosis.Properties.Resources.Button_Press;
			}

	3)	Image Button 구현하기3
		가)	해당 프로젝트 -> Resources 폴더에 Normal 이미지 파일 복사(ex, 이름 : Button_Normal)
		나)	솔루션탐색기 -> Properties -> Resources.resx 더블클릭
			-> 리소스추가(바로 옆 작은아래화살표 클릭) -> 기존파일추가 -> 가)항에서 복사해 놓은 파일 선택해서 추가
		다)	해당버튼 -> 속성 -> Image -> 나)항에서 추가한 이미지 선택(Normal image, Button_Normal 선택)
		라)	해당버튼 -> 이벤트(번개표) -> Click -> 메서드추가 -> 아래와 같이 해당 버튼 이미지 변경(Press image, ex) 버튼 배경색만 빨간색으로 변경)
			단, 본 경우 Normal image 파일 사이즈가 버튼 사이즈 보다 작아야 버튼 배경색이 변경되는 것이 보임
			private void Button_A1_Click(object sender, EventArgs e)
			{
				this.button1.BackColor = Color.Red;
			}
	
	4)	Dynamic Tab은 C#에서 구현하기 어려움
		가)	Tab을 사용자 임의대로 추가/삭제하는 기능은 구현하기 어려움
		나)	https://www.codeproject.com/Articles/493538/Add-Remove-Tabs-Dynamically-in-WPF 에
			Add/Remove Tabs Dynamically in WPF 이 있기는 하지만 "Windows Forms 앱" 형식이 아닌 WPF 형식임
			cf)	WPF란?
				2002년 정식으로 출시된 .NET Framework 1.0에서 Windows Forms이라는 좋은 기술이 등장했지만 사용자들의 눈높이가 높아지면서 Window Application에서 풍부한 비디오와 다양한 컨텐츠를 요구하기 시작했고, 
				미디어, 애니메이션, 2D 3D그래픽 등을 사용할 수 있기를 원하게 되었습니다. 또한 기존의 주요 윈도우 플랫폼(User32/GDI32, Ruby, Windows Forms)은 사용자들의 요구를 상당부분 만족시켜 주었지만 
				모두 각각 독립된 기술들로 분산되어 있었습니다. 만약 윈도우 환경하에서 위에서 나열한 모든 기능을 포함하는 프로그램을 만들어야 한다면 개발자들은 여러 가지 다른 기술에 대한 이해가 있어야만 
				만들 수 있을 것이며 각각의 기술들을 이해하기위해 많은 노력이 필요로 하였을 것입니다.
				그래서 하나의 기술의 범위에서 위의 모든 기능을 구현할 수 있도록  각각의 기술들을 광범위하게 연결하고 통합하도록 하는 기술이 필요하였고 
				그래서 만들어진 기술이 바로 WPF(Windows Presentation Foundation)인 것 입니다.  
				WPF는 .NET Framework 3.0부터 추가된 기술로 2008년 초에 출시된 비주얼 스튜디오 2008(한글판의 경우 2008년 초, 영문은 2007년 11월)에서 사용하는 
				.NET Framework 3.5를 살펴보면 Windows® Communication Foundation (WCF), Windows® Workflow Foundation (WF) 그리고 Windows CardSpace™ (WCS)등의 4가지 기술이 포함된 것을 볼 수 있습니다.
				
				WPF는 .NET Framework 3.x에 추가된 새로운 기술중 하나로, Windows Vista의 새로운 UX를 제공하기 위해 탄생되었습니다. 
				WPF에서는 그 핵심이 UX에 있다보니 기존 Window 프로그래밍과 다르게 디자인적인 측면이 많이 요구되어 디자이너와 협업을 하여 작업을 해야 합니다.
				이 때 개발자와 디자이너가 소통할 수 있는 중간언어를 사용해서 디자인과 코딩 작업을 병행할 수 있다면 커뮤니케이션 면, 
				생산성 면에서 좋은 효과를 거둘 수 있을 것입니다. 이를 위해 Microsoft사는XAML(Extensible Application Markup Language)이라고 하는 새로운 MarkUp Language를 발표하여 UI를 표현하기 위한
				XAML언어를 이용하여 개발자와 디자이너가 모두 사용 가능한 형태의 중간 언어를 제공하게 되었습니다.

				정리를 하자면 WPF는 Windows vista의 새로운 UX(User Experience:사용자 경험)를 제공하기 위해 탄생되었으며 이를 위해 개발자와 디자이너의 
				협업을 위한 XAML이라는 MarkUp Language로 개발자와 디자이너가 공동으로 작업할 수 있는 환경이 만들어지게 된것 입니다.
				
	5)	Data Grid View
		엑셀 형식으로 data 표시
		
		가) 예제
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace ex_dataGridView2
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            SetupDataGridView();
            PopulateDataGridView();
        }

        /*
         * SetupDataGridView()
         * DataGridView의 기본적인 설정을 합니다.
         */
        private void SetupDataGridView()
        {
            this.Controls.Add(dataGridView1);

            // DataGridView의 컬럼 갯수를 5개로 설정합니다.
            dataGridView1.ColumnCount = 5;

            // DataGridView에 컬럼을 추가합니다.
            dataGridView1.Columns[0].Name = "Release Date";
            dataGridView1.Columns[1].Name = "Track";
            dataGridView1.Columns[2].Name = "Title";
            dataGridView1.Columns[3].Name = "Artist";
            dataGridView1.Columns[4].Name = "Album";
        }
        
        /*
         * PopulateDataGridView()
         * DataGridView에 데이터를 삽입합니다.
         */
        private void PopulateDataGridView()
        {
            // DataGridView에 삽입할 데이터를 설정합니다.
            string[] row0 = { "11/22/1968", "29", "Revolution 9", "Beatles", "The Beatles [White Album]" };
            string[] row1 = { "1960", "6", "Fools Rush In", "Frank Sinatra", "Nice 'N' Easy" };
            string[] row2 = { "11/11/1971", "1", "One of These Days", "Pink Floyd", "Meddle" };
            string[] row3 = { "1988", "7", "Where Is My Mind?", "Pixies", "Surfer Rosa" };
            string[] row4 = { "5/1981", "9", "Can't Find My Mind", "Cramps", "Psychedelic Jungle" };
            string[] row5 = { "6/10/2003", "13", "Scatterbrain. (As Dead As Leaves.)", "Radiohead", "Hail to the Thief" };
            string[] row6 = { "6/30/1992", "3", "Dress", "P J Harvey", "Dry" };

            // DataGridView에 한 줄씩 삽입합니다.
            dataGridView1.Rows.Add(row0);
            dataGridView1.Rows.Add(row1);
            dataGridView1.Rows.Add(row2);
            dataGridView1.Rows.Add(row3);
            dataGridView1.Rows.Add(row4);
            dataGridView1.Rows.Add(row5);
            dataGridView1.Rows.Add(row6);

            // DataGridView에 들어갈 컬럼의 순서를 지정합니다.
            dataGridView1.Columns[0].DisplayIndex = 3;
            dataGridView1.Columns[1].DisplayIndex = 4;
            dataGridView1.Columns[2].DisplayIndex = 0;
            dataGridView1.Columns[3].DisplayIndex = 1;
            dataGridView1.Columns[4].DisplayIndex = 2;
        }
    }
}
		나)	//데이터 그리드 뷰를 입맛에 맞게 바꾸는 작업
		
			cf)	dataGridView -> 속성 -> 동작 -> AllowUserToAddRows = False로 변경하면 행 추가 표시 기능이 보이지 않는다

public static void DataGridViewDesignSet(DataGridView dgv)
{
    //init
    dgv.SelectionMode = DataGridViewSelectionMode.FullRowSelect; // row 로 선택하기
    dgv.ReadOnly = true;
    dgv.RowHeadersVisible = false; // 왼쪽 화살표 안보이게
    dgv.AllowUserToAddRows = false; //맨 아래 로그 가리기
    dgv.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.None; //row size 막기
    dgv.AllowUserToResizeRows = false; //row size 막기
    dgv.AllowUserToResizeColumns = false; //column size 막기
    dgv.MultiSelect = false;
    dgv.Columns.Cast<DataGridViewColumn>().ToList().ForEach(f =>
    {
        f.SortMode = DataGridViewColumnSortMode.NotSortable; // sort 막기
        f.HeaderCell.Style.Alignment = DataGridViewContentAlignment.MiddleCenter; //헤더텍스트 센터 정렬
        f.HeaderCell.Style.Font = new Font("Arial", 12F, FontStyle.Bold, GraphicsUnit.Pixel); // 폰트 사이트 및 크기 조정
    });
    //even Row에 대하서 색상 칠하기
    dgv.Rows.Cast<DataGridViewRow>().Where((x, i) => i % 2 != 0).ToList().ForEach(r => r.DefaultCellStyle.BackColor = Color.AliceBlue);

}


//데이터그리드뷰에 새로운 데이터를 넣고 리프레쉬 하는 작업
private BindingSource _bsPreview = new BindingSource();
dgvPreView.DataSource = _bsPreview;
 
//dgvPreView.DataSource = typeof(DataTable);
//dgvPreView.DataSource = dt;
//dgvPreView.Refresh();
 
_bsPreview.DataSource = typeof(DataTable);
_bsPreview.DataSource = dt;

dgvPreView.Refresh();


// column 속성 추가
dgv.Columns[0].HeaderText = "번호";
dgv.Columns[0].Width = 55;
dgv.Columns[0].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;
 
dgv.Columns[1].HeaderText = "분석대상";
dgv.Columns[1].Width = 80;
dgv.Columns[1].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;
 
dgv.Columns[2].HeaderText = "분석구역";
dgv.Columns[2].AutoSizeMode = DataGridViewAutoSizeColumnMode.Fill;
dgv.Columns[2].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;
 
dgv.Columns[3].HeaderText = "분석일";
dgv.Columns[3].Width = 140;

dgv.Columns[3].DefaultCellStyle.Alignment = DataGridViewContentAlignment.MiddleCenter;

	6)	옵션 -> 탭 관련
		가)	붙여넣기하면 메서드명과 주석사이의 탭이 공백으로 바뀌는 현상 제거(아래 옵션 선택하지 않으면 제거 됨)
			옵션 -> 텍스트 편집기 -> C# -> 코드 스타일 -> 서식 -> []붙여넣을 때 서식 자동 지정

10.	Visual studio 2017 상에서 Git 사용
	1)	프로젝트 -> 솔루션탐색기 -> 마우스 오른쪽 버튼 -> 소스 제어에 솔루션 추가
	2)	혼자서만 사용하는 경우
		가) 소스 수정 후
		나)	팀 탐색기로 이동해서 -> 변경내용 -> 커밋 메시지 입력 후 -> 모두커밋 누름
		다)	변경 사항 확인은 
			팀 탐색기로 이동해서 -> 변경내용 -> 작업 -> 기록보기
			-> 예전으로 돌아가고 싶으면 좌측(커밋정보) -> 되돌리기 누름(최종 되돌리게되는 대상은 왼쪽창의 내용 임)
			cf)	되돌리기 중 충돌 메시지가 나오면 -> 파일비교를 눌러서 해당 사항을 확인하고
				-> 소스(편집된 위치:소스|Diff|소스사용) / 대상(편집된 위치:대상|Diff|대상유지) 중 하나를 선택
				-> 해당 대상 선택하고 -> 되돌리기커밋 누름 ->  커밋 메시지 입력 후 -> 스테이징된 항목 커밋 누름
				-> 해당 대상으로 변경 됨
			cf)	잘못 실행한 경우 -> 팀 탐색기 바로 밑 -> 왼쪽 화살표 누름
		라)	Git 삭제
			-	Git 로컬저장소 삭제 -> .git folder
			-	.gitattributes, .gitignore 파일 삭제

11.	Visual Studio 무료 평가 버전인 Community 버전 -> 평가기간 만료 해결 방법
지난번 윈도우 프로그램 개발을 위해 VIsual Studio 무료 평가 버전인 Community 버전 설치에 대해서 알아봤습니다.
얼마전에 알았지만 이 평가버전은 30일이라는 사용기간이 정해져 있더군요 
그래서 설치후 30일이 지난 뒤에 Visual Studio를 실행시키면 아래와 같은 화면이 팝업됩니다. 
그리고 Visual Studio를 사용할수 없습니다. 
이 팝업창이 표시되는 이유는 평가기간이 끝났다는 것을 알려주기 위해서 표시가 되는 것인데요.
그렇지만 평가기간이 끝났다고 해서 Visual Studio를 계속 사용하지 못하는 것이 아닙니다 ^^

팝업창이 표시가 안되고 계속 사용하기 위해 어떻게 해야하는지 방법을 알려드리겠습니다.
Visual Studio를 계속 사용하기 위해서는 먼저 MicroSoft 계정이 있어야 합니다.
계정이 없는 분들은 MS 홈페이지에 접속하여 상단에 빨간색으로 표시된 부분을 클릭하여 계정을 만들어 주시기 바랍니다.
로그인 ID 입력창 하단에 "계정을 만드세요!" 를 클릭하여 회원가입을 할수 있습니다!
회원가입을 마쳤다면 팝업창에 로그인 버튼을 클릭하여 Visual Studio에 로그인해주시기 바랍니다.

로그인이 완료되면 팝업창 하단에 닫기 버튼을 클릭하여 Visual Studio를 사용하면 되겠습니다.
처음 사용기간 만료 팝업창이 발생하여 앞으로는 사용하지 못하나 생각을 했었는데 로그인만 하면 사용이 가능하기 때문에 다행이었습니다. (돈없는 개발자라..)
자료조사중에 알게된 사실인데 저 팝업창이 표시가 될때마다 다시 로그인을 해주면 사용이 가능하다고 하니 참고하시기 바랍니다.
이상 마블랑이었습니다.
읽어주셔서 고맙습니다~


[98]	차량
1.	블랙박스
	S-BOX(S1) 주)디엠시스, 주)해동특수정밀, www.idmsys.co.kr
	1)	블랙박스 F/W Update 방법
		상기 사이트로 부터 받은 F/W를
		블랙박스 SD-memory -> UPDATE 폴더에 저장한 다음
		블랙박스 전원을 ON시키고 -> UPDATE 확인 버튼을 누르면 자동으로 F/W가 Upgrade 됨
		cf)	현 S-BOX(S1) F/W Version : Ver4.9
		cf)	F/W Version 별 수정 사항
			v4.3 : 주차모드 진입 수정
			v4.4 : 주차모드 진입 수정
			v4.5 : 미배포
			v4.6 : 이벤트 저장 30초 변경
			v4.7 : 주차모드 램프 설정 추가
			v4.8 : 버그수정
			v4.9 : 저전압 설정 상향 조정(저전압 설정을 기존 12.1V -> 12.4V로 상향 조정할 수 있음)




[99]	증권사 매도대금담보대출 자격조건

말이 담보대출이지 그냥 제 통장에 있는 돈을 몇 일 앞당겨 쓴다고 보시면 되는데요, 저도 몇일전에 한번 이용해 본 적이 있는데 생각보다 간단하고
유용하게 사용하여 위기상황을 넘긴적이 있었죠. 갑자기 급전이 필요해서 ㅋㅋㅋ

하지만 의외로 주식 좀 한다고 하시는 분들도 이 기능을 모르시는 분들이 상당히 많던데 아마 주식 중수 이상되시는 분들정도는 되야 이러한 편리한
기능이 있다는것을 알고 계실겁니다. 저도 주식한지가 대략 5년 정도는 넘은 것 같은데 지금에서야 알았으니 저도 중수 정도는 되나요? ㅋㅋㅋ

주식판때기에서 오래있으면 오래있을수록 보고 듣는것이 많으니 자연스레 알게되는것이겠죠. ㅋ

하지만 매도대금담보대출을 이용할 때 꼭 알아야 할 사항들이 있는데 이것들은 꼭 알고 계셔야 시행착오가 없으실 겁니다. 저도 처음에 몰랐다 당황;;;


매도대금담보대출의 자격조건을 말씀드리자면,

①내국인 개인계좌를 이용해야 합니다.
②대출한도는 매도금액의 98%이내 10억원이하 1만원 단위로 가능합니다.
③3일이상 보유한 주식을 매도시 당일대출이 가능합니다.
④대출당일 주식을 매수한 금액은 매도금액에서 제외한 98% 이내에서 대출이 가능합니다. 


여기서 3번과 4번을 유의해야 하는게 주식은 아시다시피 당일매수를 했다면 3일뒤에 제 계좌로 들어오게되는데 당일 매매하는것은 단지 현금으로만
거래를 하게 되는것입니다.

매도대금담보대출이란것이 보유한주식을 매도하여 대출을 받는것이기 때문에 당일매수한 종목을 당일매도했다고 대출을 받을 수 있는것이 아니라
완전히 제 계좌로 주식이 들어온 후 매도하여야 대출이 가능합니다. 바로 이 기간이 3일이기 때문에 단타매매하시는 분들은 당일대출받기 어렵습니다.

그리고 4번의 경우는 3일동안 보유한 주식을 매도하여 당일대출을 받으려고 하는데, 당일날 내가 어떤주식이 마음에 들어서 매수를 하게 되었습니다.
예를들어, 1000만원을 매도한 후 타주식 500만원을 당일 매수하였다면 당일매수한 500만원은 제외하고 남은 500만원에서 대출을 받을 수 있습니다.

3번과 4번은 헷갈릴 수 있으니 꼭 기억해두셔야 합니다.	


[100]	PhotoShop / 포토샵
1.	배경색 투명하게 변경하기
	1)	도구 중 "자동 지우개 도구"를 선택해서 해당 배경을 클릭하면 해당 배경색이 투명하게 지워짐
	2)	저장할 때 포맷�� 반듯이 GIF or PNG로 선택해야지 투명한 배경색이 그대로 적용되며
		cf)	추후 나오는 옵션에서 인터레이스를 인터레이스로 선택하면 웹상에서 이미지를 볼 때 로딩속도가 약간 빨라진다고 함
		cf) BMP로 저장하면 배경색을 투명으로 변경해서 저장했어도 배경색이 흰색으로 적용되어서 저장 됨

[101]	Acrobat Pro
1.	작성되어 있는 텍스트 변경
	1)	TouchUp 텍스트 도구로 변경하면 되며
	2)	현재 선택한 글꼴을 사용하며 텍스트를 추가하거나 삭제할 수 없습니다.라는 에러가 발생하며
		텍스트 수정이 불가한 경우는 해당 글꼴이 존재하지 않아서 발생하는 경우이며
		가)	인터넷에서 해당 글꼴을 다운 받아서 -> C:\Windows\Fonts 폴더에 복사한 다음 실행하면 에러가 제거 됨
		나)	단, 다운 받은 글꼴이 동일한 것이 아닌 유사 글꼴인 경우 일부분 텍스트를 지우려면
			지우고자하는 일부분 글자를 마우스로 Drag 한 다음 -> TouchUp -> 속성 -> 채우기(흰색)로 설정해서 지우면 됨
			cf)	전체행을 모두 다 지우려면 -> TouchUp 개체 도구로 지우면 됨
	3)	TouchUp 개체 도구를 사용하면
		텍스트 전체행 / 그림 등을 모두 지울수 있음
2.	Acrobat 문서 내부 이미지 복사 & 붙여넣을 때 검정색 배경/테두리 없애기
	1)	Acrobat Pro -> 해당이미지 -> TouchUp 개체 도구 -> 오른쪽마우스 -> 이미지 편집 -> PhotoShop 으로 연결





		
[102]	이미지 분석 프로그램 (Image analyzer)
1.	ImageJ
	https://imagej.nih.gov/ij/download.html 사이트에서 프로그램(Free ware)과 소스(자바)를 받을 수 있으며
	1)	X/Y축 Density graph가 생성
		방법1)
		가)	이미지를 불러들인 다음
			cf)	만약 Image data가 ex) Red 만의 Image data라면
				Image -> Color -> Split channels 를 선택해서 R/G/B 각각의 Image 로 분리한  다음 -> 이중 Red Image 만을 선택해서 분석해야 함
			cf)	만약 ex) Red 만의 Image data 인데도 상기 Split channels 를 실행하지 않으면
				R/G/B 합산에 대한 평균값으로 처리해서 1/3 값으로 값이 줄어들어서 처리되는 것 같다
				가)	아래 Plot Profile 의 경우는 Y축 최대값이 Split channels 를 실행하지 않으면 255 -> 60으로 줄어들고
				나)	아래 Text Image의 경우는 픽셀당 최대값이 255-> 60으로 줄어들어서 최종적으로 ex) Y:640인 경우는
					SUM된 Y축 최대값이 25000 -> 9000으로 줄어듦
		나)	라인/영역(Rectangular)을 선택하고서
		다)	Analyze -> Plot Profile 을 선택하면
			해당 선택에 대한 X/Y축 Density graph가 생성된다.
		방법2)
		가)	이미지를 불러들인 다음
			cf)	만약 Image data가 ex) Red 만의 Image data라면
				Image -> Color -> Split channels 를 선택해서 R/G/B 각각의 Image 로 분리한  다음 -> 이중 Red Image 만을 선택해서 분석해야 함
			cf)	만약 ex) Red 만의 Image data 인데도 상기 Split channels 를 실행하지 않으면
				R/G/B 합산에 대한 평균값으로 처리해서 1/3 값으로 값이 줄어들어서 처리되는 것 같다
				가)	상기 Plot Profile 의 경우는 Y축 최대값이 Split channels 를 실행하지 않으면 255 -> 60으로 줄어들고
				나)	아래 Text Image의 경우는 픽셀당 최대값이 255-> 60으로 줄어들어서 최종적으로 ex) Y:640인 경우는
					SUM된 Y축 최대값이 25000 -> 9000으로 줄어듦
		나)	라인/영역(Rectangular)을 선택하고서
		다)	File -> Save As -> Text Image 를 선택하면
			Gray값(0~255)에 대한 X/Y축(ex, X:480 x Y:640) Matrix Text 파일로 저장된다.
		라)	이를 Excel 프로그램으로 읽어들여서 차트로 변환하면 X/Y축 Density graph를 생성할 수 있음

		이밖에도 이미지 분석을 위한 많은 기능이 포함되어 있는 아주 좋은 프로그램이다.

	

[103]	센서 / 스트립 / 카트리지
1.	현, 카트리지(형광측정방식) NTproBNP의 경우 저/중/고농도 모두의 구간에서 튀는 현상이 발생하고 있는데
		아마도 중합체PAD(형광Dye + 항체; cf,Gold측정방식에서 샘플PAD 다음 분홍색PAD를 뜻함) 내부 조성의 양이 일정하지 않아서 발생하는 것 같음
		1)	현, 중합체PAD에 "형광Dye + 항체"가 녹아 있는 액체를 Pipet을 사용해서 사람이 손으로 뿌리고 있는데
				사람이 뿌리다 보니 본 "형광Dye + 항체"양이 일정하게 중합체PAD에 흡수되지 못하며 이에 튀는 현상이 발생하는 것 같음
		2)	본 1)방식을 Dispenser를 사용해서 "형광Dye + 항체"를 일정하게 뿌려주면 본 튀는 현상이 줄어들 것으로 보임


[104]	CE인증문서 작성 Tip
1.	위험관리(FMEA)에서 심각성은 개선 후에도 변경하면 안 되고 발생가능성만 낮춰서 위험도를 낮춰야 함

			

[105]	python (파이썬)


3.  python 문법
		0-4)들여쓰기
			파이썬에서 공백은 중요한 역할을 합니다. 사실, 한 행의 앞에 붙어있는 공백이 정말 중요합니다.
			이것을 _들여쓰기_라 부릅니다. 한 논리적 명령행의 앞에 붙어있는 공백 (빈 칸 혹은 탭)은 논리적
			명령행의 들여쓰기 단계를 의미하며, 이것은 한 명령의 범위를 구분하는 데 사용됩니다.
			이것은 같은 들여쓰기 단계에 있는 명령들은 반드시 같은 들여쓰기를 사용해야 함을 의미합니다.
			이러한 같은 들여쓰기를 사용하고 있는 명령들의 집합을 블록(block) 이라고 부릅니다. 뒷장에서
			예제를 통해 블록에 대해 다루게 될 것입니다.
			지금 여러분이 기억하셔야 할 것은 잘못된 들여쓰기는 오류를 일으킨다는 것입니다. 다음 예제를
			봅시다.

			i = 5
			# 다음 행에서 오류가 발생합니다! 행 앞에 잘못된 공백이 한 칸 있습니다.
			 print 'Value is ', i
			print 'I repeat, the value is ', i
			
			위 예제를 실행하면 다음과 같이 오류가 발생합니다.
			File "whitespace.py", line 5
			print 'Value is ', i
			^
			IndentationError: unexpected indent

			두번째 행 앞에 공백이 한칸 있다는 점을 확인하세요. 위와 같은 오류는 파이썬이 우리에게 프로그
			램의 문법이 잘못되었음을, 즉 프로그램이 뭔가 잘못 작성되었다는 것을 알려 주는 것입니다. 이
			오류가 의미하는 것은 여러분이 임의로 새 블록을 시작할 수 없음 을 의미합니다. 새 블록을 시작
			할 수 있는 경우에 대해 흐름 제어 챕터에서 다루게 될 것입니다.
			들여쓰기 하는 법들여쓰기를 할 때에는 공백 4개를 이용하세요. 이것은 파이썬 언어에서 공식적으
			로 추천하는 방법입니다. 좋은 편집기들은 이 사항을 자동으로 준수합니다. 또, 들여쓰기를 할 때
			에는 항상 같은 개수의 공백을 사용해야 한다는 점에 유의하시기 바랍니다.

			cf)	파이썬 명령 앞 띄어쓰기는 반드시 space로 줘야 함
					Tab으로 주면 문법오류 발생
					ex) 명령 앞에 띄어쓰기를 할 경우 Tab = 4 로 주면 안되고 공간을 주려면 space = 4 로 space만으로 줘야 함
		0-3)주석
			0)	전체주석처리
					'3개를 붙여서 쓰세요
					'''
					i am comment!
					multiline!!!!
					'''
			1)	일반적주석
					ex) #test
							print 'hello world' # Note that print is a statement
			2)	소스 상석에서 한글주석을 사용하려면
				아래 사항을 소스 맨 상단에 추가시키면 됨
				#-*- coding: utf-8 -*-
				
				cf)	인코딩 설정
					콘솔 입력이나 파일은 유니코드 포인트로 동작하는 것이 아니라 인코딩된 바이트 열로 동작한다. 
					따라서 파이썬이 콘솔로 입력된 코드나 스크립트 코드를 읽을 때는 이 코드가 어떤 방식으로 인코딩되어 있는지 알고 있어야 한다. 
					콘솔 입력이면 환경 변수 PYTHONIOENCODING으로 지정하고, 스크립트(파일)이면 첫 줄에 다음처럼 인코딩 설정 정보를 넣어 주면 된다.
					#-*- coding: utf-8 -*-
		0-2)if 문
			if 문은 조건을 판별할 때 사용됩니다. if (만약) 조건이 참이라면, _if 블록_의 명령문을 실행하며
			else (아니면) _else 블록_의 명령문을 실행합니다. 이 때 else 조건절은 생략이 가능합니다.

			예제 (if.py 로 저장하세요):
			number = 23
			guess = int(raw_input('Enter an integer : '))

			if guess == number:
				# New block starts here
				print 'Congratulations, you guessed it.'
				print '(but you do not win any prizes!)'
				# New block ends here
			elif guess < number:
				# Another block
				print 'No, it is a little higher than that'
				# You can do whatever you want in a block ...
			else:
				print 'No, it is a little lower than that'
				# you must have guessed > number to reach here
			
			print 'Done'
			# This last statement is always executed,
			# after the if statement is executed.

			실행 결과:
			$ python if.py
			Enter an integer : 50
			No, it is a little lower than that
			Done

			$ python if.py
			Enter an integer : 22
			No, it is a little higher than that
			Done

			$ python if.py
			Enter an integer : 23
			Congratulations, you guessed it.
			(but you do not win any prizes!)
			Done

		0-1)파이썬에서는 문자열 만들 때 '' 나 "" 을 이용
				모두 문자열을 표시한다는 것에서는 차이가 없지만 작은 따옴표의 경우 하나의 단위를 표현하는 문자열에
				큰 따옴표는 문법적으로 의미를 두지 않는 문자열을 표현할 대 사용

				if compiler == 'python':
				.......
				else:
					print "Python is Snake"

				예제와 같이 문법적으로 의미를 가지는 단위의 경우 ''를 사용하고
				크게 의미를 가지지 않는 문자열은 ""를 이용합니다.
				하지만 어디까지나 관습이기 때문에 각각의 조직이나 개인별 차이가 있을 수 있습니다.

		0)	print
		    가)	strTemp = 'hoho'
		    		print('args =', strTemp)

				나)	% 기호를 활용하여 변수값을 출력할 수 있다. (오래된 방식)(%d 정수, %f 실수, %s 문자열)
						%5.2f처럼 출력하는 모양을 지정할 수 있다. (총 자릿수 5, 소수점 2자리까지)
						format 함수를 사용하면 좀 더 다양항 방식으로 출력을 할 수 있다.
						(format 함수에 대한 내용은 워낙 방대하여 나중에 따로 글을 쓰겠습니다. 지금은 예문으로만 감상해주세요. 
							설명하자면 긴데 사실 format함수도 쓰는 기능만 주로 쓰기 때문에 꼭 모든 것을 알아야할 필요는 없습니다.)

						예제)
						i = 123				
						f = 3.14				
						s = 'Hello'
						
						print('i: %d, f: %f, s: %s' % (i, f, s))											# i: 123, f: 3.140000, s: Hello
						
						print('i: %9d, f: %5.2f, s: %7s' % (i, f, s))									# i:       123, f:  3.14, s:   Hello
						
						print('i: %09d, f: %05.2f, s: %7s' % (i, f, s))								# i: 000000123, f: 03.14, s:   Hello
						
						print('i: {}, f: {}, s: {}'.format(i, f, s))									# i: 123, f: 3.14, s: Hello
						
						print('f: {1}, i: {0}, s: {2}'.format(i, f, s))								# f: 3.14, i: 123, s: Hello
						
						print('f: {ff}, i: {ii}, s: {ss}'.format(ii=i, ff=f, ss=s))		# f: 3.14, i: 123, s: Hello
						
						a = 'apple'
						
						b = 'banana'
						
						print('a is {0[a]}, b is {0[b]}'.format(locals()))						# a is apple, b is banana
						
						print('a is {a}, b is {b}'.format(**locals()))								# a is apple, b is banana

						print '{0:.3f}'.format(1.0/3)																	# 소수점 이하 셋째 자리까지 부동 소숫점 숫자 표기 (0.333)

						print '{0:_^11}'.format('hello')															# 밑줄(_)로 11칸을 채우고 가운데 정렬(^)하기 (___hello___)

						print '{name} wrote {book}'.format(name='Swaroop',						# 사용자 지정 키워드를 이용해 (Swaroop wrote A Byte of Python) 표기
										book='A Byte of Python')
		1)	as
			except ShortInputException as ex:
				print ('ShortInputException: The input was ' + \
				'{0} long, expected at least {1}')\
				.format(ex.length, ex.atleast)
			이제 except 절에서 as 를 이용하여 해당 오류의 클래스를 좀 더 짧은 이름의 변수로 대신하
			여 사용할 수 있게 해 줍니다
		2)	++/-- 연산자 없음
			iTemp++			-> 에러발생
			iTemp += 1		-> 이렇게 구현해줘야 함
		3)	변수 정의해 주고서 변수 사용해야 함
			iTemp = 0
			while True:
				iTemp += 1
		4)	for
			예제1)
			x = [1, 2, 3]
			y = [4, 5, 6]
			
			for i, j in zip(x, y):
			   print i + " / " + j

			will output
			1 / 4
			2 / 5
			3 / 6

			예제2)
	    sum = 0
	    for i in range(1, 5, 2):			# range(1, 5, 2) -> 1,3 만의 숫자가 range임(1부터 시작해서 2만큼 증가시키며 5미만까지만 포함되기 때문)
	        sum = sum + i
	    print(sum)                    # 4(=1+3)

		5)	numpy
			1.	numpy 패키지
				numpy는 과학 계산을 위한 라이브러리로서 다차원 배열을 처리하는데 필요한 여러 유용한 기능을 제공하고 있다.
				numpy는 pip을 사용하여 아래와 같이 간단히 설치할 수 있다.

				$ pip install numpy
			2.	numpy 배열
				numpy에서 배열은 동일한 타입의 값들을 가지며, 배열의 차원을 rank 라 하고, 각 차원의 크기를 튜플로 표시하는 것을 shape 라 한다. 
				예를 들어, 행이 2이고 열이 3인 2차원 배열에서 rank는 2 이고, shape는 (2, 3) 이 된다.

				numpy 배열을 생성하는 방법은 파이썬 리스트를 사용하는 방법과 numpy에서 제공하는 함수를 사용하는 방법이 있다. 
				아래 예제에서 list1은 4개의 요소를 갖는 리스트인데, 이를 array() 함수에 넣어 numpy 배열을 생성하는데, 
				이 배열의 rank는 1이 되고, shape는 (4, ) 가 된다. 튜플에 하나의 요소만 있으면 문법상 콤마를 뒤에 붙인다. 
				두번째 배열 b는 2x3 배열로서 shape는 (2, 3)이 되는데, 한가지 주의할 점은 array() 안에 하나의 리스트만 들어가므로 리스트의 리스트를 넣어야 한다.

				import numpy as np
				
				list1 = [1, 2, 3, 4]
				a = np.array(list1)
				print(a.shape) # (4, )
				
				b = np.array([[1,2,3],[4,5,6]])
				print(b.shape) # (2, 3)
				print(b[0,0])  # 1    

				numpy에서 제공하는 함수를 사용하여 numpy 배열을 만드는 방법을 살펴보자. 이러한 기능을 제공하는 함수로는 zeros(), ones(), full(), eye() 등이 있는데,
				zeros()는 해당 배열에 모두 0을 집어 넣고, ones()는 모두 1을 집어 넣는다. full()은 배열에 사용자가 지정한 값을 넣는데 사용하고, 
				eye()는 대각선으로는 1이고 나머지는 0인 2차원 배열을 생성한다.
				아래 예제는 이들 함수들을 사용하여 numpy 배열을 생성한 예이다. 그리고 마지막 예는 0부터 n-1 까지의 숫자를 생성하는 range(n) 함수와 배열을 다차원으로 변형하는 
				reshape()를 통해 간단하게 샘플 배열을 생성해 본 것이다.

				import numpy as np
				
				a = np.zeros((2,2))
				print(a)
				# 출력:
				# [[ 0.  0.]
				#  [ 0.  0.]]
				
				a = np.ones((2,3))
				print(a)
				# 출력:
				# [[ 1.  1.  1.]
				#  [ 1.  1.  1.]]
				
				a = np.full((2,3), 5)
				print(a)
				# 출력:
				# [[5 5 5]
				#  [5 5 5]]
				
				a = np.eye(3)
				print(a)
				# 출력:
				# [[ 1.  0.  0.]
				#  [ 0.  1.  0.]
				#  [ 0.  0.  1.]]
				
				a = np.array(range(20)).reshape((4,5))
				print(a)
				# 출력:
				# [[ 0  1  2  3  4]
				#  [ 5  6  7  8  9]
				#  [10 11 12 13 14]
				#  [15 16 17 18 19]]

			3.	numpy 슬라이싱
				import numpy as np
				a = np.array([1, 2, 3, 4, 5])
				print(a)
				print("\n")
				print(a[3:])
				print("\n")
				print(a[1:-1]) 
				print("\n")
				print(a[0:3:2])
				결과
				[1 2 3 4 5]

				[4 5]

				[2 3 4]

				[1 3]
				배열[a:b:c]를 이용하여 배열의 일부를 잘라 표시할 수 있습니다.

				a는 시작값위치, b는 도착값위치(본 값의 위치는 제외), c는 간격을 의미합니다.

				index는 0 ~ len-1까지 존재하며, 아무것도 입력하지 않고 :로 사용할 경우, 모든 행 또는 열을 의미합니다.

				:n으로 사용할 경우 0 ~ n까지의 길이를 의미하며 n:으로 사용할 경우, n ~ len-1까지의 길이를 의미합니다.

				-1을 입력할 경우, 마지막 index-1 (len-2)를 의미합니다.

				import numpy as np
				a = np.array([
					[1, 2, 3],
					[4, 5, 6],
					[7, 8, 9]])
				print(a)
				print("\n")
				print(a[:, 1:])
				print("\n")
				print(a[0:1,0:2]) 
				결과
				[[1 2 3]
				[4 5 6]
				[7 8 9]]

				[[2 3]
				[5 6]
				[8 9]]

				[[1 2]]

				배열[a:b, c:d]를 이용하여 배열의 일부를 잘라 표시할 수 있습니다.
				동일하게 배열[a:b:e, c:d:f]를 이용하여 e와 f를 간격으로 사용할 수 있습니다.
				a ~ b는 표시할 행의 위치를 의미하며, c ~ d는 표시할 열의 위치를 의미합니다.

			cf)			Array(배열) 자료 구조로 표헌
			파이썬 코드에서 사용하기 위해 NumPy 패키지를 추가하는 방법은 아래와 같이 추가해주세요.
			import numpy as np
			
			배열 만들기
			가장 손쉽게 NumPy 배열을 만드는 방법은 파이썬의 리스트 구조를 이용하는 거예요. 리스트 형태로 표시를 하고, 
			그 내용을 array() 함수를 이용해서 변환하면 끝~!
			a1 = np.array([1,2,3, 4, 5,6])
			파이썬 리스트 구조와 동일하게 중간에 공백은 알아서 잘 처리가 되네요. 직접 리스트 표현을 넣는 대신에 리스트 변수를 넣어도 돼요.
			이 방법은 머신러닝에서 *.csv 파일을 읽어서 NumPy 배열로 만들 때 자주 사용되는 방법이죠.
			보통 NumPy 정도를 쓰려면 이야기 드린 것처럼 파일에서 읽어 오는 경우가 많을 텐데요. 그렇지 않고 간단한 규칙의 배열을 직접 만든다면, 
			
			그때그때 리스트 구조로 표시하지 않아도 될 쉬운 방법이 있으면 좋겠죠?! NumPy에서 이러한 니즈를 위해 배열을 생성하는 방법으로
			zeros(), ones(), arange() 함수를 제공하고 있어요. 
			Zeros()와 ones() 함수는 이름에서 쉽게 알 수 있듯이, 원하는 형태로 0과 1로 채워진 배열을 만들어 줘요.
 			a2 = np.zeros(3)
 			a3 = np.ones(3)

			arange() 함수는 일정한 규칙으로 증가하는 형태의 배열을 만들 수 있어요. 아래 예제는 1부터 7 직전까지 1씩 증가하는 배열을 만들어 줘요. 
			결과는 앞서 보여드렸던 리스트 구조를 사용한 array() 함수의 예제와 같은 모양이 되죠.
			a4 = np.arange(1,7,1)
			[출처] 파이썬(python) 공부하기 15 ? NumPy|작성자 EngineerK

		5+1)	열거형
			열거형들은 리스트, 튜플, 문자열 같은 것입니다. 그러면 열거형이란 무엇이고 열거형에서는 무
			엇이 중요할까요?
			열거형의 주요�� 두 가지 기능은 멤버십 테스트 ( in 과 not in 연산)와 열거형의 특정 항목을
			얻어올 수 있는 *인덱싱 연산*입니다.
			또한 리스트, 튜플, 문자열의 세 가지 열거형은 슬라이스 연산 기능을 가지고 있는데, 이것은 열거
			형의 일부분을 잘라낸(slice) 것을 반환하는 연산, 즉 부분 집합을 반환해 주는 연산입니다.

			예제 ( ds_seq.py 로 저장하세요):
			shoplist = ['apple', 'mango', 'carrot', 'banana']
			name = 'swaroop'
			# Indexing or 'Subscription' operation #
			print 'Item 0 is', shoplist[0]
			print 'Item 1 is', shoplist[1]
			print 'Item 2 is', shoplist[2]
			print 'Item 3 is', shoplist[3]
			print 'Item -1 is', shoplist[-1]
			print 'Item -2 is', shoplist[-2]
			print 'Character 0 is', name[0]
			# Slicing on a list #
			print 'Item 1 to 3 is', shoplist[1:3]
			print 'Item 2 to end is', shoplist[2:]
			print 'Item 1 to -1 is', shoplist[1:-1]
			print 'Item start to end is', shoplist[:]
			# Slicing on a string #
			print 'characters 1 to 3 is', name[1:3]
			print 'characters 2 to end is', name[2:]
			print 'characters 1 to -1 is', name[1:-1]
			print 'characters start to end is', name[:]

			실행 결과:
			$ python ds_seq.py
			Item 0 is apple
			자료 구조
			88
			Item 1 is mango
			Item 2 is carrot
			Item 3 is banana
			Item -1 is banana
			Item -2 is carrot
			Character 0 is s
			Item 1 to 3 is ['mango', 'carrot']
			Item 2 to end is ['carrot', 'banana']
			Item 1 to -1 is ['mango', 'carrot']
			Item start to end is ['apple', 'mango', 'carrot', 'banana']
			characters 1 to 3 is wa
			characters 2 to end is aroop
			characters 1 to -1 is waroo
			characters start to end is swaroop

			동작 원리먼저, 열거형의 각 항목을 얻어오기 위해 어떻게 인덱스를 사용하는지 보겠습니다. 이를
			다른 말로 서브스크립션 연산 이라고도 합니다. 위 예제에서 보인 것과 같이 대괄호 내에 특정 숫
			자를 지정해 주면, 파이썬은 열거형에서 해당 숫자의 위치에 있는 항목을 얻어옵니다. 이 때 파이
			썬은 숫자를 0부터 센다는 점을 기억하시기 바랍니다. 따라서 shoplist[0] 과 shoplist[3]
			은 각각 열거형 shoplist 의 첫 번째와 네 번째 항목을 읽어오는 연산을 의미합니다.

			인덱스에는 음수가 지정될 수도 있습니다. 이 경우, 열거형의 마지막부터 위치가 계산됩니다. 따
			라서, shoplist[-1] 은 열거형의 마지막 항목을 의미하며 shoplist[-2] 는 열거형의 마지
			막 항목 바로 뒤의 항목을 의미합니다.

			슬라이스 연산은 대괄호 안에 콜론으로 구분한 숫자들을 입력해 주는 것입니다. 슬라이스 연산은
			앞서 설명한 인덱싱 연산과 굉장히 비슷합니다. 이 경우 숫자는 반드시 지정해 줄 필요는 없지만
			콜론은 반드시 들어가야 합니다.

			슬라이스 연산에서 콜론 앞의 첫 번째 숫자는 슬라이스를 시작할 위치를 의미하며 콜론 뒤의 두 번
			째 숫자는 슬라이스를 멈출 위치를 지정합니다. 만약 첫 번째 숫자가 지정되지 않았을 경우, 파이
			썬은 열거형의 맨 처음부터 슬라이스를 시작합니다. 두 번째 숫자가 지정되지 않았을 경우, 파이썬
			은 열거형의 맨 끝에서 슬라이스를 멈춥니다. 이 때 슬라이스는 시작 위치부터 슬라이스를 시작_
			하며 _끝 위치의 직전까지 수행됩니다. 즉, 시작 위치에 해당하는 항목은 슬라이스에 포함되나 마
			지막 위치에 해당하는 항목은 포함되지 않습니다.

			따라서, shoplist[1:3] 은 위치 1 에 해당하는 항목부터 시작하여 위치 2 에 해당하는 항목을
			포함하지만, 위치 3 에 해당하는 항목은 포함하지 않습니다. 따라서 두 개의 항목의 슬라이스 가
			반환됩니다. 이와 비슷하게, shoplist[:] 는 전체 열거형의 복사본이 반환됩니다.

			슬라이스 숫자로도 음의 위치를 지정해 줄 수 있습니다. 음수는 열거형의 마지막부터 위치를 계산
			하는 것을 의미합니다. 예를 들어, shoplist[:-1] 은 마지막 항목을 제외한 모든 항목을 포함
			하고 있는 슬라이스를 반환해 줍니다.

			슬라이스 숫자에 세 번째 인수를 지정해 줄 수 있는데, 이것은 슬라이스 _스텝_에 해당합니다 (기
			본값은 1 입니다):
			>>> shoplist = ['apple', 'mango', 'carrot', 'banana']
			>>> shoplist[::1]
			['apple', 'mango', 'carrot', 'banana']
			>>> shoplist[::2]
			['apple', 'carrot']
			>>> shoplist[::3]
			['apple', 'banana']
			>>> shoplist[::-1]
			['banana', 'carrot', 'mango', 'apple']
			보시는 바와 같이 스텝이 2일 경우 위치 0, 2, … 에 해당되는 항목들이 반환되며 스텝이 3일 경
			우 0, 3, … 에 해당되는 항목들이 반환됩니다.
			파이썬 인터프리터에서 여러 가능한 슬라이스 숫자의 조합들을 시험해 보시면 그 결과를 곧바로
			확인해 보실 수 있습니다. 이 모든 사항은 모든 열겨형에 적용되므로, 튜플, 리스트, 문자열의 경
			우 모두 동일한 방법을 사용할 수 있습니다!

		5+2)	열거형2
			X = np.array([[1,5],
              [2,6],
              [3,7],
              [4,8]], dtype = np.float32)

	    h = 0.01
	    x_min, x_max = X[:, 0].min()-h, X[:, 0].max()+h
	    y_min, y_max = X[:, 1].min()-h, X[:, 1].max()+h
	
	    print('x_min = {}, x_max = {}\n'.format(x_min, x_max))      # x_min = 0.99, x_max = 4.01
	    print('y_min = {}, y_max = {}\n'.format(y_min, y_max))      # y_min = 4.99, y_max = 8.01

		6)	contour
			1. cv2.boundingRect(contour)
			return 좌상단 꼭지점 좌표와 가로 세로폭
			
			2. cv2.minAreaRect(contour)
			return 좌상단 꼭지점 좌표와 가로 세로폭 사각형이 기울이진 각도
			
			3. cv2.minEnclosingCircle(contour)
			return 중심좌표와 반지름
			
			4. cv2.fitEllipse(contour)
			return 생성된 타원의 Contour
			
			네가지 함수 다 Contour을 인수로 받습니다.
			
			반환되는값은 각각 다르기때문에 좌표값 등을 얻기 위해  아래의 함수도 사용합니다.
			cv2.boxPoints(rect)
			좌표는 float형으로 반환됨.
			그렇다면 이제 코드를 작성해서 알아보겠습니다.
			import cv2
			import numpy as np
			
			def Draw():
			
			    imageFile = "image/thunder.jpg"
			    img = cv2.imread(imageFile)
			
			    imgray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
			
			    ret, thr = cv2.threshold(imgray, 127, 255, 0)
			    contours , _ = cv2.findContours(thr, cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)
			    
			    # 번개모양의 바깥쪽 contour
			    contour = contours[1]
			
			    # 정방향의 사각형 그리기  좌측상단의 x,y 좌표/ width / height 값이 도출됨.
			    x,y,w,h = cv2.boundingRect(contour)
			    # 도출된 값을 가지고 사각형을 그려줌
			    cv2.rectangle(img, (x,y), (x+w,y+h), (0,0,255),3 )
			
			    # 외접하는 가장 작은 원을 그려줌
			    (x,y), r = cv2.minEnclosingCircle(contour)
			    # 리턴된 x,y,r 값은 float 값이기때문에 정수형으로 캐스팅해주어야함
			    center = ( int(x), int(y))
			    r = int(r)
			    cv2.circle(img,center, r, (255,0,0),3)
			
			    # 이미지 객체에 가장 최적화된 타원을 그려줌.
			    ellipse = cv2.fitEllipse(contour)
			    # 반환된 값은 타원그리기 인자로 바로 활용할 수 있음.
			    cv2.ellipse(img, ellipse, (0,255,0), 3)
			
			    # 이미지 객체에 가장작은 사각형을 그려줌.
			    rect = cv2.minAreaRect(contour)
			    # 반환된 값의 값의 좌표를 알기 위해 아래의 함수를 사용
			    box = cv2.boxPoints(rect)
			    box = np.int0(box)
			    cv2.drawContours(img, [box], 0, (255,255,0), 3)
			
			    cv2.imshow("result",img)
			    cv2.waitKey(0)
			    cv2.destroyAllWindows()
			
			Draw()
			[출처] Python OpenCV 시작 (27) - 이미지 Contour ( 외접하는 도형그리기 )|작성자 박원영
		7)	map(f, iterable) 함수
			list 나 dictionary와 같은 iterable 데이터를 인자로 받아
			list안의 개별 item을 함수의 인자로 전달하여 결과를 list 형태로 변환해 주는 함수.
			
			def func(x):
				return x * 2
			
			map(func, [1, 2, 3, 4])
			>> [2, 4, 6, 8]
		8)	define
			STRING_CONSTANT = "hi"
			NUMBER_CONSTANT = 89
		9)	동적리스트
			1. 리스트 (List)
			리스트는 여러 요소들을 갖는 집합(컬렉션)으로 새로운 요소를 추가하거나 갱신, 삭제하는 일이 가능하다. 
			파이썬의 리스트는 동적배열(Dynamic Array)로서 자유롭게 확장할 수 있는 구조를 갖는다. 
			리스트는 그 안의 요소(element)들은 그 값을 자유롭게 변경할 수 있는 Mutable 데이타 타입이다. 			
			리스트의 요소들은 Square bracket([ ])으로 둘러쌓여 컬렉션을 표현하는데, 
			각 요소들은 서로 다른 타입이 될 수 있으며, 컴마(,)로 구분한다. 요소가 없는 빈 리스트는 "[]"와 같이 표현한다. 
			a = []     # 빈 리스트
			a = ["AB", 10, False]

			2. 리스트 인덱싱(Indexing)
			리스트의 특정 한 요소만을 선택하기 위하여 인덱싱(Indexing)을 사용하는데, 
			첫번째요소는 "리스트[0]", 두번째 요소는 "리스트[1]" 처럼 표현한다. 
			즉, 아래 예제에서 처럼 리스트 a 가 있을 때, a[1] 는 두번째 요소 10을 가리킨다. 
			파이썬 인덱싱에서 한가지 특별한 표현은 인덱스에 -1, -2 같은 음수를 사용할 수 있다는 점이다. 
			이 때, -1은 현재 리스트의 마지막 요소를, -2는 뒤에서 두번째 요소를 가리킨다. 
			a = ["AB", 10, False]
			x = a[1]        # a의 두번째 요소 읽기
			a[1] = "Test"   # a의 두번째 요소 변경
			y = a[-1]       # False
			
			3. 리스트 슬라이싱(Slicing)
			리스트에서 일부 부분 요소들을 선택하기 위하여 슬라이스(Slice)를 사용한다. 
			슬라이스는 "리스트[처음인덱스:마지막인덱스]"와 같이 인덱스 표현에서 부분집합의 범위를 지정하는 것이다. 
			인덱스는 0 부터 시작하며, 마지막 인덱스를 원하는 "마지막 요소의 인덱스 + 1"을 의미한다. 
			만약 처음인덱스가 생략되면, 0 부터 시작되며, 마지막 인덱스가 생략되면, 리스트의 끝까지 포함됨을 의미한다. 
			a = [1, 3, 5, 7, 10]
			x = a[1:3]     # [3, 5]
			x = a[:2]      # [1, 3]
			x = a[3:]      # [7, 10]

			4. 리스트 요소 추가,수정,삭제
			리스트에 새로운 요소를 추가하기 위해서는 "리스트.append()"를 사용한다. 
			리스트 요소를 갱신하기 위해서는 리스트 인덱싱을 사용하여 특정요소에 새 값을 넣는다. 
			리스트 요소를 삭제하기 위해서는 "del 요소"와 같이 특정 요소를 지운다. 
			a = ["AB", 10, False]
			a.append(21.5)  # 추가
			a[1] = 11       # 변경
			del a[2]        # 삭제
			print(a)        # ['AB', 11, 21.5]

			5. 리스트 병합과 반복
			두 개의 리스트를 병합하기 위해서는 플러스(+)를 사용한다. 
			이 때 두 리스트는 순서대로 병합된 새로운 하나의 리스트가 된다. 
			하나의 리스트를 N 번 반복하기 위해서는 "리스트 * N"와 같이 표현할 수 있다. 이는 동일한 리스트를 계속 반복한 새 리스트를 만들게 된다. 

			# 병합
			a = [1, 2]
			b = [3, 4, 5]
			c = a + b
			print(c)   # [1, 2, 3, 4, 5]
			 
			# 반복
			d = a * 3
			print(d)   # [1, 2, 1, 2, 1, 2]

			6. 리스트 검색
			리스트 안에 특정 요소를 검색하기 위해서 index() 메서드를 사용한다. 또한 특정 요소가 몇 개 있는지 체크하기 위해서 count() 메서드를 사용할 수 있다. 
			mylist = "This is a book That is a pencil".split()
			i = mylist.index('book')  # i = 3
			n = mylist.count('is')    # n = 2
			print(i, n)

			7. List Comprehension
			리스트의 [...] 괄호 안에 for 루프를 사용하여 반복적으로 표현식(expression)을 실행해서 리스트 요소들을 정의하는 특별한 용법이 있는데, 
			이를 List Comprehension 이라 부른다. 이는 아래와 같은 문법으로 컬렉션으로부터 요소를 하나씩 가져와 표현식을 실행하여 
			그 결과를 리스트에 담는 방식이다. 여기서 if 조건식은 옵션으로 추가될 수 있는데 for 루프에서 이 조건식에 맞는 요소만 표현식을 실행하게 된다. 
			
			[표현식 for 요소 in 컬렉션 [if 조건식]]
			아래 예제는 0부터 9까지 숫자들중 3으로 나눈 나머지가 0인 숫자에 대해 그 제곱에 대한 리스트를 구한 예이다. 
			list = [n ** 2 for n in range(10) if n % 3 == 0]			 
			print(list)
			# 출력: [0, 9, 36, 81]
		10)	.ravel	->	행렬을 1차원 벡터로 만들어줌
			import numpy
	
			a = numpy.arange(10).reshape((2,5))
			print('a :\n' + str(a))

			print()
			print('ravel_a :\n' + str(a.ravel()))

			a :
			[[0 1 2 3 4]
			 [5 6 7 8 9]]

			ravel_a :
			[0 1 2 3 4 5 6 7 8 9]
		11)	.reshape	->	차원과 크기 변경하기

			1)	1차원 -> 2차원으로 변형
					array1 = np.arange(10)
					print(array1)
					print('---')
					print(array1.reshape(2,5))
					
					# 결과
					[0 1 2 3 4 5 6 7 8 9]
					---
					[[0 1 2 3 4]
					 [5 6 7 8 9]]
  
			2)	차원을 크기에 맞지 않게 수정하면 에러를 낸다
					0~9 까지 값이 10개인 것을 3,3 차원으로 바꾸면 다음과 같은 에러가 발생한다.
					array1 = np.arange(10)
					print(array1)
					print('---')
					print(array1.reshape(3,3))
					
					# 결과
					---------------------------------------------------------------------------
					ValueError                                Traceback (most recent call last)
					<ipython-input-17-3f231a1aa789> in <module>
					----> 1 array1.reshape(3,3)
					
					ValueError: cannot reshape array of size 10 into shape (3,3)

			3)	설정에 -1을 넣으면 자동으로 변환한다
					가)	array1 = np.arange(10)
							print(array1)
							print('---')
							print(array1.reshape(-1,5))
		
							# reshape(2, 5)와 같은 형태로 변형
							# 결과
							[[0 1 2 3 4]
							 [5 6 7 8 9]]
  				
					나)	array1 = np.arange(10)
							print(array1)
							print('---')
							print(array1.reshape(-1,2))

							# 결과
							[[0 1]
							 [2 3]
							 [4 5]
							 [6 7]
							 [8 9]]

					다)	1차원으로 변형
            	n차원의 수를 1차원으로 변형한다

					    array1 = np.arange(10)
					    print(array1)
					    print('---')
					    array1_test = array1.reshape(-1, 2)
					    print(array1_test)
							print('---')

							# 결과
							[0 1 2 3 4 5 6 7 8 9]
							---
							[[0 1]
							 [2 3]
							 [4 5]
							 [6 7]
							 [8 9]]
							---
						
							# 1차원으로 변경
					    print(array1_test.reshape(-1,))
							# 결과
							[0 1 2 3 4 5 6 7 8 9]
			4)	다차원
					sample = np.float32(np.c_[xx.ravel(), yy.ravel()])
					# sample: array([[-0.01, -0.01],\n
					#  [0:10404] : [array([-0.01, -0.01]...e=float32),
					#    001: array([-0.01, -0.01], dtype=float32)
					#    002: array([ 0.  , -0.01], dtype=float32)
					#    003: array([ 0.01, -0.01], dtype=float32)
					#    .............................................
					
					sample = sample.reshape((-1, 1, 1,  2)) 
					# sample: array([[[[-0.01, -0.01]]],\n\n\n
					#  [0:10404] : [array([[[-0.01, -0.0...e=float32),
					#    001: array([[[-0.01, -0.01]]], dtype=float32)
					#    002: array([[[ 0.  , -0.01]]], dtype=float32)
					#    003: array([[[ 0.01, -0.01]]], dtype=float32)
					#    .............................................

		12)	argmax	->	최대값이 어떤자리에 있는지 알려주는 함수
		    a = [9,93,221,100000,10,3,54,4,4,23,3]
		
		    b = np.array(a)
		    print('b =', b)
		
		    c = b.argmax()
		    print('c =', c)
		    print('b[', c, '] =', b[c])
		
		
		    a2 = [0.26894316, 0.7310568 ]
		
		    b2 = np.array(a2)
		    print('b2 =', b2)
		
		    c2 = b2.argmax()
		    print('c2 =', c2)
		    print('b2[', c2, '] =', b2[c2])
		
				결과)
				b = [     9     93    221 100000     10      3     54      4      4     23	3]
				c = 3
				b[ 3 ] = 100000

				b2 = [0.26894316 0.7310568 ]
				c2 = 1
				b2[ 1 ] = 0.7310568

		13)	변수 다중 할당 (Multiple Assignment):
				-	파이썬은 동시에 여러 변수에 하나의 값을 할당 할 수 있다.
					소스
					a = b = c = 1

				-	여러 변수에 여러 개체를 할당 할 수 있다.
					소스
					a, b, c = 1, 2, "홍길동"

		14)	산술 연산자
		#   a=3, b=10, c=2                      # 에러 발생
		    a, b, c = 3, 10, 2
		    print('a =', a, ', b =', b, ', c =', c)
		    print('----------------')
		    print('a + b =', a + b)
		    print('b - a =', b - a)
		    print('a - b =', a - b)
		    print('a * b =', a * b)
		    print('b / a =', b / a)             # 나누기 / 몫(실수)
		    print('b % a =', b % a)             # 나누기 / 나머지
		    print('b // a =', b // a)           # 나누기 / 몫(정수)
		    print('a ** c =', a ** c)

				-> 실행결과
				a = 3 , b = 10 , c = 2
				----------------
				a + b = 13
				b - a = 7
				a - b = -7
				a * b = 30
				b / a = 3.3333333333333335
				b % a = 1
				b // a = 3
				a ** c = 9

		15)	with 문
				try 블록에서 시스템 자원을 가져오고 finally 문에서 이를 해제하여 주는 것은 공통된 패턴
				입니다. 그렇지만, with 문을 이용하면 이것을 좀 더 깔끔하게 작성해 줄 수 있습니다.

		    with open('./data/test2.txt') as f:
    	    for strline in f.readlines():
            print(strline)
#       	print(f.readline())

				동작 원리
				위 예제는 이전의 예제와 동일한 결과를 출력합니다. 차이점은 open 함수를 사용할 때
				with 문을 사용하였다는 것입니다. 그러면 파일을 직접 닫아 주지 않아도 with open 이 자동
				으로 파일을 닫아 줍니다.

				그러면 with 문은 어떻게 자동으로 이러한 것들을 처리해 주는 것일까요? 우선 with 문은 open
				문이 반환해 주는 객체를 받아 오는데, 일단 여기서는 이것을 "thefile" 이라고 해 봅시다.

				with 문은 항상 thefile.enter 함수를 호출한 뒤 해당 블록의 코드를 실행하며, 실행이 끝난
				후에는 항상 thefile.exit 가 호출됩니다.

				따라서 finally 블록에 써 준 코드가 exit 메소드에 의해 자동적으로 다루어져야 할 경우에만
				이를 사용할 수 있을 것입니다. 이런 경우, 위 방법대로 하면 매번 try..finally 문을 명시적으
				로 쓰지 않고도 같은 일을 할 수 있습니다.

		15+1)try - except == with , 파일 에러 처리 예제
				아래 예제는 전형적인 파일 에러 처리를 보여주는 코드이다. 파일을 오픈할 때 에러가 발생하면, except IOError 블록을 실행한다. 
				파일오픈을 성공하면, try 블럭을 실행하고, finally 블럭에서 파일을 닫게 된다. 

				try:
				   fp = open("test.txt", "r")
				   try:
				      lines = fp.readlines()
				      print(lines)
				   finally:
				      fp.close()
				except IOError:
				   print('파일에러')
 
				참고로 다음은 with 문을 써서 해당 블럭이 끝나면 자동으로 파일을 닫는 코드의 예이다.(상기 try - except 명령과 동일한 동작을 구현)
				Python의 with 문은 C#의 using 문과 비슷한 것으로 with 블럭이 끝날 때 자동으로 리소스를 해제하는 역활을 하는데, 
				특히 주목할 점은 with 블럭 내에서 어떤 Exception이 발생하더라도 반드시 리소스를 해제한다는 점이다. 

				with open('test.txt', 'r') as fp:
			    lines = fp.readlines()
			    print(lines)

		16)	예외처리(try - except - finally)
				프로그램에서 에러가 발생했을 때, 에러를 핸들링하는 기능으로 try...except 문을 사용할 수 있다. 
				즉, try 블럭 내의 어느 문장에서 에러가 발생하면, except 문으로 이동하고 예외 처리를 할 수 있다. 
				try 문은 또한 finally 문을 가질 수도 있는데, finally 블럭은 try 블럭이 정상적으로 실행되든, 
				에러가 발생하여 except 블럭이 실행되든 상관없�� 항상 마지막에 실행된다. 

				try:
				  문장1
				  문장2
				except:
				  예외처리
				finally:
				  마지막에 항상 수행
 
				위의 except 문은 except 뒤에 아무것도 쓰지 않았는데, 이는 어떤 에러이든 발생하면 해당 except 블럭을 수행하라는 의미이다. 
				except 뒤에 "에러타입"을 적거나 "에러타입 as 에러변수"를 적을 수가 있는데, 이는 특정한 타입의 에러가 발생했을 때만 해당 except 블럭을 실행하라는 뜻이다. 
				에러변수까지 지정했으면, 해당 에러변수를 excep 블럭 안에서 사용할 수 있다. 
				아래 예제를 보면, except가 2개 있는데, 첫번째는 IndexError가 발생했을 때만 그 블럭을 실행하며, 
				두번째는 일반적인 모든 Exception 이 발생했을 때 해당 블럭을 실행하라는 의미이다. 
				즉, 먼저 IndexError 인지 검사하고, 아니면 다음 except를 계속 순차적으로 체크하게 된다. 
				except가 여러 개인 경우는 범위가 좁은 특별한 에러타입을 앞에 쓰고 보다 일반적인 에러타입을 뒤에 쓰게 된다. 

				def calc(values):
				    sum = None
				    # try...except...else
				    try:
				       sum = values[0] + values[1] + values[2]
				    except IndexError as err:
				        print('인덱스에러')
				    except Exception as err:
				        print(str(err))
				    else:
				        print('에러없음')
				    finally:
				        print(sum)

				# 테스트
				calc([1, 2, 3, 6]) # 출력: 에러없음 6
				calc([1, 2])       # 출력: 인덱스에러 None

				또한, 위의 예제에서 else문 있는데, 이는 에러가 발생하지 않을 때 실행하게 되는 블럭이다. 그리고 finally 블럭은 항상 마지막에 실행되는 코드 블럭이다. 
				만약 복수 Exception들이 동일한 except 블럭을 갖는다면, 아래와 같이 이들 Expception들을 하나의 except 문에 묶어서 쓸 수도 있다. 

				def calc(values):
				    sum = None
				    try:
				       sum = values[0] + values[1] + values[2]
				    except (IndexError, ValueError):
			         print('오류발생')
					 
					  print(sum)

		17)	findContours -> boundingRect로 구한 영역을 가지고 이미지 따냄

		def find_objects(sub_mat):
		    contours, hierarchy = cv2.findContours(sub_mat, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
		#    print('len(contours)=', len(contours))
		
		    for i, cnt in enumerate(contours):
		        rect = x, y, width, height = cv2.boundingRect(cnt)          # 검출 객체 사각형
		        area = cv2.contourArea(cnt)
		#        print('area=', area)
		
		        if (width / height) > 0.9:                                  # 객체 종횡비(객체의 종횡비가 0.9보다 크면 객체로 저장하지 않는다. -> OCR 문자 종횡비가 아니기 때문)(ex, 숫자5 : W:39 / H:59 = 0.66)
		            print('Error, width / height =', width / height)
		            continue
		        elif area > AREA_RECT_TH:                                   # 문자로 인식한 Rect 영역의 면적이 일정크기 이상이면 문자로 처리함, 442=17x26(ex, 숫자1이 정상적인 Rect로 인식될 최소 면적 크기)
		            big = max(x, y)                                         # max : 가장 큰 값을 return
		
		            if width < height:                                      # 문자, 가로 보다 세로가 긴 경우
		                iStart = x + (width / 2) - (big / 2)                # X좌표 Start 값만 재 정의하면 됨(x중심점에서 big/2를 빼면 big(x)크기의 x시작점이 됨)
		                if iStart < 0:
		                    iStart = 0                                      # 예외처리
		                x = iStart
		                width = big
		                height = big
		
		                return rect
		            else:       																						# 문자, 가로 보다 세로가 짧은 경우
		                iStart = y + (height / 2) - (big / 2)               # Y좌표 Start 값만 재 정의하면 됨(y중심점에서 big/2를 빼면 big(y)크기의 y시작점이 됨)
		                if iStart < 0:
		                    iStart = 0                                      # 예외처리
		                y = iStart
		                width = big
		                height = big
		
		                return rect
		        else:
		            print('Error, area =', area)


    rect = find_objects(~img3)                      # 문자 영역 검출(OCR 이미지 중에서 문자들을 검출해서 해당 영역을 obejct_rects에 저장함.)
																										# cv::findContours() 함수의 경우 흰색 화소(255)를 객체로 인식하기 때문에 번호판 영상을 ~연산자로 반전시켜 입력 함(검정색 바탕에 흰색 글자)
																										# 단, 본 find_objects에서만 검정색 바탕에 흰색 글자 이미지를 가지고 처리하며 아래 명령 등 다른 함수에서는 흰색 바탕에 검정색 글자를 가지고 처리 함

    img4 = img2[rect[1]:rect[1]+rect[3], rect[0]:rect[0]+rect[2]]   # find_objects에서 검출한 문자 영역 정보를 가지고 img2 이미지에서 따냄

 
4.	anaconda

		How To Train an Object Detection Classifier for Multiple Objects Using TensorFlow (GPU) on Windows 10

		activate tensorflow1
		conda install tensorflow-gpu			->	본 명령 꼭 실행해야 함, 하지 않으면 에러 발생
		set PYTHONPATH=E:\Program\Python\tensorflow1\models;E:\Program\Python\tensorflow1\models\research;E:\Program\Python\tensorflow1\models\research\slim
		set PATH=%PATH%;PYTHONPATH
		protoc --python_out=. .\object_detection\protos\anchor_generator.proto .\object_detection\protos\argmax_matcher.proto .\object_detection\protos\bipartite_matcher.proto .\object_detection\protos\box_coder.proto .\object_detection\protos\box_predictor.proto .\object_detection\protos\eval.proto .\object_detection\protos\faster_rcnn.proto .\object_detection\protos\faster_rcnn_box_coder.proto .\object_detection\protos\grid_anchor_generator.proto .\object_detection\protos\hyperparams.proto .\object_detection\protos\image_resizer.proto .\object_detection\protos\input_reader.proto .\object_detection\protos\losses.proto .\object_detection\protos\matcher.proto .\object_detection\protos\mean_stddev_box_coder.proto .\object_detection\protos\model.proto .\object_detection\protos\optimizer.proto .\object_detection\protos\pipeline.proto .\object_detection\protos\post_processing.proto .\object_detection\protos\preprocessor.proto .\object_detection\protos\region_similarity_calculator.proto .\object_detection\protos\square_box_coder.proto .\object_detection\protos\ssd.proto .\object_detection\protos\ssd_anchor_generator.proto .\object_detection\protos\string_int_label_map.proto .\object_detection\protos\train.proto .\object_detection\protos\keypoint_box_coder.proto .\object_detection\protos\multiscale_anchor_generator.proto .\object_detection\protos\graph_rewriter.proto
		(tensorflow1) C:\tensorflow1\models\research> python setup.py build
		(tensorflow1) C:\tensorflow1\models\research> python setup.py install
		
		cd Program\Python\tensorflow1\models\research\object_detection

5.	윈도우 환경에서 *.ipynb 파일을 실행시키는 방법이다.
	1)	명령프롬프트 실행 (cmd)
	2)	테스트 하고자 하는 폴더 경로로 이동 (C:\testing/python)
	3)	ipython notebook 입력 후 엔터
	4)	실행된 Jupyter 에서 실행하고자 하는 *.ipynb 클릭하여 Run (demo.ipynb)
	출처: https://eehoeskrap.tistory.com/141 [Enough is not enough]


[106]	위변조 원리
106_-9.	신규 이미지& QR 태그 구현 방안
1.	이미지태그 무늬 위에 QR을 인쇄
		1)	단, 이미지태그 무늬가 QR 위로 올라오기 때문에
				인식이 잘 안되는 문제 발생(어두운 곳)
		2)	이를 해결하기 위해
				이미지태그 가운데에 흰여백을 줘서 이미지태그 무늬 인쇄
				(QR인쇄편차감안해서QR인쇄가약간먹고들어가게가운데흰여백주면QR인식 확실히 잘됨)
2.	일반QR리더앱으로 찍으면 해당 고객사로 넘어가게 처리
		1)	QR DATA에 : 당사서버주소&(고객사주소)+ 트릴코드 정보+ LOT Number
				가 들어가며
		2)	당사서버로 진입해서 고객사주소로 넘어갈 수 있도록 처리 해줌
3.	일반 2D(QR) 바코드 리더기로 찍으면 맨 마지막에 LOT Number가 표시되기 때문에 물류관리 가능
4.	정품인증App으로 찍으면
		1)	QR을 읽어들에서 트릴코드 정보를 알아냄(QR DATA에 트릴코드 정보까지 들어있기 때문에 이미지태그에 트릴코드는 존재하지 않음)
		2)	QR외곽 이미지태그 무늬를 파악해서 정품/가품 구별함

106_-8.	신규 이미지태그 규격(네모인사이트)
  1) 이미지 매칭
  2) 특정부분 CMYK / 별색 구분
  3) 특정부분 점 추가
  4) 마이크로텍스트 추가
     (위조 업자 Fake 용도, 고객사 영업용)
  5) 복사방지 pattern
  6) 안쪽 테두리 복잡한 선
  7) 숫자 pattern

106_-7.	위조하기 어려운 이미지태그는
-> ex) 깃털 등 아주미세한 패턴으로 인쇄되어 있는 것을 정밀카메라로 캡쳐해서 인쇄시켜도
   육안으로 봤을 때 원본과는 차이가 발생하는 경우
cf)	다양한 디자인 패턴은 https://www.pinterest.co.kr 사이트 가보면 상당히 많이 있음
cf)	깃털을 CMYK가 아닌 별색으로만 찍으면 CMYK로 인쇄한 것 보다 해상도가 올라갈 것으로 보임
		->	맞는 얘기 임
				실제 별색 & CMYK조합으로 각각 인쇄해서 인쇄품질을 살펴보니
				->	중요) 별색(무늬가 없는 인쇄) vs  CMYK조합(동그라미무늬가가 포함된 인쇄)
						별색이 CMYK조합 보다 무늬가 없고 색상이 일정하기 때문에
						해상도 면에서 별색이 CMYK보다 우수함 


106_-6.	정품/가품 구별로 호피무늬를 사용하자
	이유)	거의 1년이 지난 현 시점(2019.09) 에서도 위조업자가 호피무늬를 가장 위조하지 못하고 있음
				이에, 호피무늬를 위조 판별 요소로 사용하는 것이 좋겠다.

106_-5.	정품인증app QR 해킹 위험성
위조업자가 정품인증app QR과 완전히 동일한 모양의 WebPage를 다른주소로 만들고
QR도 해당 다른주소로 접속하도록 만들어서 유통시키면
->	소비자/유통업자가 위조된QR -> 위조된 WebPage로 접속해서 정품인증을 해도 이것이 위조인지 아닌지 알 방법이 없음
->	단, 위쳇/미니프로 등에서는 본 위조 방법을 위조업자가 적용할 수 없음
	이유)	위쳇/미니프로그램 모두 App등록 방식이기 때문에 위조업자가 정품인증app QR과 동일한 위조된 QR/WebPage등을 올릴 수 없기 때문
			단, 위쳇/미니프로그램 도 단점도 있음(정품 인증 후 고객사 페이지로 넘어가는 기능 구현 불가 함, 보안 상 문제가 있을 수 있기 때문에 위쳇/미니프로그램에서 구현을 불허 한다고 함)
->	일반적인 QR방식인 경우
	1)	위조업자가 QR서버로 계속 접속을 시도해서 정품QR리스트를 목록을 빼낼 수도 있다
		-	순차적으로 가변QR뒤 번호를 증가시켜가면서 정품QR리스트를 해킹 함
		-	가변QR과 함께 가변시리얼번호(Security code) 을 추가시키면 해킹이 좀 더 어렵기는 하지만 해킹은 가능 함
	2)	스티커 방식인 경우, 타사도 본 방식이 가능하기 때문에 당사만의 경쟁력은 아님
		이에, 타사도 따라하게되면 나중에는 가격다운, 출혈경쟁을 하게 됨
		cf)	주)배원에서 산 5억짜리 장비는 다이렉트 인쇄방식으로 가변QR & 가변시리얼번호 모두 가능하다고 함

106_-4.	위조/가품유통업자 리스트(UUID)
93B6E8BE-27EB-48AE-9CD9-D8BADF1D6EB7-VI0001


106_-3.	신규 정품인증 방안

TAG 내부의 비표를 사람 싸인 / 유화 / 선의 두께가 가변되면서 휘어지는 선 / 등 위조 업자가 따라하기 힘든 것으로 변경
옵셋 인쇄의 Layer 원리를 적용, 동일 Layer에서는 상대적 위치가 동일한 원리 적용
TAG 인쇄 시 Etching 이미지도 같이 넣어서 위조 업자가 위조하기 어렵도록 개선
Tag 이외의 영역에 신규 비표를 추가해서 인식하는 방법
가변 QR / OCR 문자로 가품 구별, 단) 원가 상승과 인쇄 장비가 고가임
비표2 구현 방법 모색(저가폰에서도/흔들림이 많아도 구분 가능함 방안 모색)
인쇄 오류처럼 보이는 비표 개발
Camera Flash 활용한 정품 인식 기능 개발
비표인식 / 이미지매칭 각각 독립적 구동 방식으로 변환(각각, 카메라 포커스 따로 잡음)
Tag에 StartPoint를 추가시키면 자동으로 위치 파악 해결 가능함, 단 기존 Tag와 호환성 없음
"App 카메라 포커스 가이드, 설명 보완 필요(App 진입단에 포커스 가이드 설명 이미지로 변경)
"
신규 정품/가품 인식 알고리즘 적용
[당사적용] Focus 잘 맞는 정도에 따라서 Focus guide 색상 변경시켜 소비자가 Focus 잘 맞추도록 개선
[당사적용] 위조업자인 경우 -> 해당UUID 막아서 차단시켜버림
[당사적용] App에서 포커스 맞는 경우만 -> 서버로 이미지 전송 -> 서버에서 정품 유/무 판단
당사만의 육안 식별 정품 인증 제품 개발
Android app의 경우 원본이미지 해킹 불가하도록 보안 기능 추가
최종, Core단에서 OCR인식으로 변경 예정
OCR 읽을 때 Check sum 기능을 추가시켜 정확하게 OCR문자 읽었는지 확인 기능 필요
아이폰/Core/서버 소스 분석 필요
[당사적용] 소비자가 정품 인증 잘 못하면 무작위로 아래 문구 표기
- ""초점이 잘 잡히도록 앞뒤로 천천히 움직여주세요""
- ""너무 어둡거나 밝은 장소에서는 정품인식이 잘 되지 않습니다."""
[당사적용] "정품 구매하기" -> 고객사 제품 소개 및 소비자가 곧바로 구매할 수 있도록 함
QR 정품 인식의 경우 Key-in 입력 기능이 없는 제품군도 필요해 보임
Tag 인쇄 규격서(?) 제대로 인쇄사에 정립 필요
Tag 감리의 경우 고정으로 감리할 사람이 1명은 있어야 함(감리자가 여러명일 경우 감리자 간에도 감리 기준이 다르기 때문)
계속해서 생산되는 양산 제품 누적 관리/보관 필요
지속적 경쟁사 시장 동향 진행
지속적 BrainStorming 실시

106_-2.	정품인증app Android app, Camera1에서는 QR 잘 인식하고 Camera2에서는 QR 인식하지 못하는 문제 원인 파악
	1)	정품인증app Android app 상에서
		가)	Camera2는 일반 정품Tag(비표) 인식은 convertyuv422tonv21 함수를 사용해서 NV21로 변경해서 처리하며
			QR인식 때는 YUV422신호를 그대로 줘서 인식시켰고
		나)	Camera1은 정품Tag(비표) 인식, QR인식 모두 NV21 신호를 그대로 보내줘서 처리했었음
		다)	따라서, Camera1 때는 QR인식이 잘되고 Camera2 때는 QR인식이 안 된다는 것은
			아래와 같은 사항 때문에 발생하는 것으로 보임
			a)	가정, QR인식 알고리즘이 옛날 소스이기 때문에 NV21 Format으로만 처리
			b)	따라서, Camera1의 경우는 NV21로만 처리하기 때문에 QR인식 정상
			c)	Camera2 경우는 YUV422 신호를 QR인식 알고리즘에 던져 주기 때문에 인식하지 못한 것임
106_-1.	OCR인식
	1)	안드로이드/아이폰 모두
		가)	표준양식(BQCELL)의 경우에도
			-	위에서아래로 사선으로 찍거나 OCR인쇄가 약간 불량한 경우(약간 드문드문 인쇄가 된 경우) 
				엉뚱한 값으로 인식하는 경우 발생(ex. QB1901001 -> QB1301001로 인식)
		나)	표준양식(BQCELL) 보다 OCR인식 영역이 좁은 용지 & OCR문자 두께도 약간 얇은 경우
			-	안드로이드 폰의 경우 ex. MS49492023 -> MS49492023___ 등으로 인식하는 문제 발생
			-	이경우도 안드로이드/아이폰 모두 아래 현상 발생 확률 높음
				위에서아래로 사선으로 찍거나 OCR인쇄가 약간 불량한 경우(약간 드문드문 인쇄가 된 경우) 
				엉뚱한 값으로 인식하는 경우 발생(ex. QB1901001 -> QB1301001로 인식)
106-0.	정품 인식 알고리즘 아이디어
	1)	Contrast 최대로 올려서 이미지 통 비교
	2)	DPC 큰 문자 영역만 이미지 통 비교
	3)	normalize(sorce, target, 50, 255, NORM_MINMAX)로 Target이미지 탈색시켜서 이미지 통 비교
		->	먹색(검정색)과 별색(검정색)간의 검정색 농도 자체가 확연하게 차이 나지 않기 때문에 본 명령 사용해도 확연하게 별색은 탈색되고 먹색만 표시되게 할 수 없음
	4)	먹색점을 별색 구간에 (숨겨서) 집어 넣고 먹색 기준점과의 상대 위치를 파악(정확하게 똑같아야 함) 정품 선별
	5)	1차, 전체 유사도 먼저 체크해서 통과하면
		2차, 전체 영역을 Y축으로 5등분 나눈 각각의 이미지의 유사도를 각각 체크해서 각각 통과하면 정품으로 인정
106-1.    홀로그램 Tag가 PC화면과 실촬영화면을 구분하는 방법
    1)    사용자가 정품App 구동시 카메라가 약간씩 흔들릴 수 밖에 없으며
        이에 카메라에서 받아들이는 화면도 약간씩 변화가 있을 수 밖에 없음
        (홀로그램은 보는 각도에 따라서 화면이미지가 다르게 보임)
    2)    하지만 PC화면은 카메라가 흔들려도 화면의 변화가 없음
    ->    따라서, 본 1)/2) 현상 차이를 이용해서 PC화면과 실촬영화면을 구분하는 것임
    cf)    홀로그램 대신 일정영역에 pearl을 줘도(반짝이) 상기 1)번 효과를 얻을 수 있음 -> 단가 비쌈
    cf)    홀로그램 대신 일정영역에 Etching을 줘도(난반사발생) 상기 1)번 효과를 얻을 수 있음 -> 단가 pearl 보다 상대적으로 저렴

106-2.	Packet 전송 암호화
	cf)	현 서버에서 App으로 비표 정보등을(비표위치) 보낼 때 암호화 없이 전송하고 있어서
		위변조 업자가 본 전송 data를 Hacking 하면 비표 정보 등을 알 수 있음
		-> 아님, 아래와 같이 AES 암호화를 해서 보내고 있음
	1)	일반적으로 아래와 같이 특정 비트문자로 XOR 해서 송신하고
		수신부에서 동일한 비트문자로 XOR을 다시 해서 복호화 시킴
	원본		1010 0101	1100 0011
	XOR(암호화)	1101 0110	0111 1001			// 결론적으로, 1로 XOR하면 대상비트 반전, 0으로 XOR하면 대상비트 변경 없음
	송신		0111 0011	1011 1010
	
	수신		0111 0011	1011 1010
	XOR(복호화)	1101 0110	0111 1001
	최종본		1010 0101	1100 0011	->	원본과 동일
	2)	상기 XOR 암호화 하고 비트반전을 추가로 실행하자
		송신부 : XOR + 비트반전
		수신부 : 비트반전 + XOR
	3)	현, Android App은 AES 복호화
	
	    /**
     * 로딩 페이지로 이동
     */
    public void goNext() {
        Intent intent = new Intent(AcceptTermsActivity.this, SplashActivity.class);
        startActivity(intent);
        finish();
    }
    
	    /**
     * 약관동의 체크 및 메인 화면으로 이동
     */
    public void goNext() {
        // 앱 리소스 데이타 호출 및 설정
        UtilRetrofit.create().articleAgreement(ApiCommonData.getMap()).enqueue(
                new MyCall<Map<String, String>>() {
                    @Override
                    public void data(Map<String, String> data) {
                        if (null != data) {
                            // 동의 이력 있는지 체크, 없으면 약관 화면으로 이동
//                             if ("N".equals(data.get("article_1st")) || "N".equals(data.get("article_2nd"))) {
                            if ("N".equals(data.get("article_1st"))) {
                                Intent intent = new Intent(SplashActivity.this, AcceptTermsActivity.class);
                                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                                startActivity(intent);
                                finish();
                            } else {
                                // 약관동의 하였으면 리소스 다운
                                getResource();
                            }
                        }
                    }
	
	
	 /**
     * 앱 리소스 데이타 호출 및 설정
     */
    public void getResource() {
        UtilRetrofit.create().tag_resources(ApiCommonData.getMap()).enqueue(
                new MyCall<List<String>>() {
                    @Override
                    public void data(List<String> data) {
                        if(!data.isEmpty())
                        {
                            try {
                                List<String> resources = new ArrayList<String>();
                                for (String resource : data) {
                                    resources.add(AES.getInstance().AES_Decode(resource));
                                }
                                ApiCommonData.RESOURCE = resources;
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                    }


    //암호화
    public String AES_Encode(String str) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] keyData = secretKey.getBytes();

        SecretKey secureKey = new SecretKeySpec(keyData, "AES");

        Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
        c.init(Cipher.ENCRYPT_MODE, secureKey, new IvParameterSpec(IV.getBytes()));

        byte[] encrypted = c.doFinal(str.getBytes("UTF-8"));
        String enStr = new String(Base64.encodeBytes(encrypted));

        return enStr;
    }

    //복호화
    public String AES_Decode(String str) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] keyData = secretKey.getBytes();
        SecretKey secureKey = new SecretKeySpec(keyData, "AES");
        Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
        c.init(Cipher.DECRYPT_MODE, secureKey, new IvParameterSpec(IV.getBytes("UTF-8")));

//        byte[] byteStr = Base64.decodeBase64(str.getBytes());
        try {
            //byte[] byteStr = Base64.decode(str.getBytes());
            //byte[] byteStr = Base64.decode(str, android.util.Base64.NO_WRAP);

            //String str1 = URLDecoder.decode(str, "UTF-8");
            //String str2 = URLDecoder.decode(str1, "UTF-8");

            byte[] byteStr = android.util.Base64.decode(str, 0);

            return new String(c.doFinal(byteStr), "UTF-8");
        } catch (Exception e) {
            return "";
        }
    }
    
    JNIEXPORT jstring JNICALL
	Java_app_camera_DataProc_ReturnKey(
	        JNIEnv* env, jobject thiz)
	{
	
		/*	string ^= key 등을 시키면 회사사이트주소(?) 등 회사와 관련된 문구로 변함
			참고로, 이곳에서 본 key로 복호화 과정을 거치고
			서버에서는 본 key로 암호화 과정을 거침	*/
	    char string[] =  "HmQWD$nIGn+YQHOJ";		
	    char key[] = "!@#2%@@*(@@+=!!!";
	
	    int n = 0;
	    int i = 0;
	
	    n = strlen(string);
	    for( i = 0; i < n; i++){
	
	        string[i] ^= key[i];
	    }
	
	    jstring temp = env->NewStringUTF((const char*)string);
	
	    return temp;
	}


		상기 함수에서 복호화해서 CORE쪽으로 넘겨줌
	
	4)	JAVA AES 예제
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Encryptor {
    public static String encrypt(String key, String initVector, String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println("encrypted string: "
                    + Base64.encodeBase64String(encrypted));

            return Base64.encodeBase64String(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static String decrypt(String key, String initVector, String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes("UTF-8"), "AES");

            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5PADDING");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static void main(String[] args) {
        String key = "Bar12345Bar12345"; // 128 bit key
        String initVector = "RandomInitVector"; // 16 bytes IV

        System.out.println(decrypt(key, initVector,
                encrypt(key, initVector, "Hello World")));
    }
}
	5)	Android, 파일 AES 예제
private static final String algorithm = "AES";
private static final String transformation = algorithm + "/ECB/PKCS5Padding"0;
private Key key;

public FileCoder(Key key) {
	this.key = key;
}

public void encrypt(File source, File dest) throws Exception
{
	crypt(Cipher.ENCRYPT_MODE, source, dest);
}

private void crypt(int mode, File source, File dest) throws Exception
{
	Cipher cipher = Cipher.getInstance(transformation);
	cipher.init(mode, key);
	InputStream input = null;
	OutputStream output = null;
	
	try
	{
		input = new BufferedInputStream(new FileInputStream(source));
		output = new BufferedOutputStream(new FileOutputStream(dest));

		byte[] buffer = new byte[1024];
		int read = -1;
		
		while ((read = input.read(buffer)) != -1)
		{
			output.write(cipher.update(buffer, 0, read));
		}

		output.write(cipher.doFinal());
	}
	finally
	{
		if (output != null) {
			try { output.close(); } catch(IOException ie) {}
		}

		if (input != null) {
			try { input.close(); } catch(IOException ie) {}
		}
	}

	public static void main(String[] args) throws Exception
	{
		// 128비트의 키
		SecretKeySpec key = new SecretKeySpec(toBytes("key값을 넣어요~~", 16), algorithm);
		FileCoder coder = new FileCoder(key);
		coder.encrypt(new File("D:/a.jpg"), new File("D:/aa.jpg"));
	}
	출처: https://it77.tistory.com/45 [시원한물냉의 사람사는 이야기]

	6)	Android, 이미지파일 AES 암호화/복호화 예제
		실제, 아래와 같이 코딩해서 사용하면 이미지파일이 AES로 암호화 되었다가 복호화된다.

AES_Lib.java
package com.example.aes_imagefile;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AES_Lib
{
	private static final String algorithm = "AES";
	private static final String transformation = algorithm + "/ECB/PKCS5Padding";

	public void crypt(int mode, String strKey, String initVector, File source, File dest) throws Exception
	{
		IvParameterSpec iv = new IvParameterSpec(initVector.getBytes("UTF-8"));
		SecretKeySpec sKeySpec = new SecretKeySpec(strKey.getBytes("UTF-8"), "AES");

		Cipher cipher = Cipher.getInstance(transformation);
		cipher.init(mode, sKeySpec);

		InputStream input = null;
		OutputStream output = null;

		try
		{
			input = new BufferedInputStream(new FileInputStream(source));
			output = new BufferedOutputStream(new FileOutputStream(dest));

			byte[] buffer = new byte[1024];
			int read = -1;

			while ((read = input.read(buffer)) != -1) {
				output.write(cipher.update(buffer, 0, read));
			}

			output.write(cipher.doFinal());
		}
		finally
		{
			if (output != null) {
				try { output.close(); } catch(IOException ie) {}
			}

			if (input != null) {
				try { input.close(); } catch(IOException ie) {}
			}
		}
	}
}

MainActivity.java
package com.example.aes_imagefile;

import android.os.Bundle;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.Toolbar;
import android.util.Log;
import android.view.View;
import android.view.Menu;
import android.view.MenuItem;

import java.io.File;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;



public class MainActivity extends AppCompatActivity {
	private static final String TAG = "AES_imagefile";

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);
		Toolbar toolbar = findViewById(R.id.toolbar);
		setSupportActionBar(toolbar);

		FloatingActionButton fab = findViewById(R.id.fab);
		fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
			Snackbar.make(view, "Replace with your own action", Snackbar.LENGTH_LONG)
						.setAction("Action", null).show();
			}
		});

		// add
		AES_Lib cAES_Lib = new AES_Lib();

		String strKey = "Bar12345Bar12345";                     // 128 bit key
		String initVector = "RandomInitVector";                 // 16 bytes IV

		//--    AES 파일 암호화  --//
		try {
			cAES_Lib.crypt(Cipher.ENCRYPT_MODE, strKey, initVector, new File(getFilesDir(), "source.jpg"), new File(getFilesDir(), "encrypt.jpg"));
		}
		catch (Exception e)
		{
			Log.d(TAG, "Error of ENCRYPT_MODE");
		}

		//--    AES 파일 복호화  --//
		try {
			cAES_Lib.crypt(Cipher.DECRYPT_MODE, strKey, initVector, new File(getFilesDir(), "encrypt.jpg"), new File(getFilesDir(), "decrypt.jpg"));
		}
		catch (Exception e)
		{
			Log.d(TAG, "Error of DECRYPT_MODE");
		}
		// add
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.menu_main, menu);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		// Handle action bar item clicks here. The action bar will
		// automatically handle clicks on the Home/Up button, so long
		// as you specify a parent activity in AndroidManifest.xml.
		int id = item.getItemId();

		//noinspection SimplifiableIfStatement
		if (id == R.id.action_settings) {
			return true;
		}

		return super.onOptionsItemSelected(item);
	}
}


106-3.	App upgrade(안드로이드 + 아이폰)
	현, 서버에 App upgrade 버전을 올려 놓으면
	사용자는 무조건 App이 하위버전인 경우 업그레이드 해야지만 정품인증App을 사용할 수 있다.
	1)	App 디버깅 시
			"업데이트 후 이용 하세요" message가 발생하는 경우
			가)	안드로이드 app 경우
					Android studio -> Find in path ->
					a)	versionCode 1						->	versionCode 3				(cf, 서버 버전보다 높게 설정, 본 값으로 app version 이 높은지 아닌지 판단 함, 최소 서버 버전 보다 같거나 높아야 함)
							VERSION_CODE = 1				->	VERSION_CODE = 3
					b)	versionName "1.0.1"			->	versionName "1.0.3"	(cf, 앱상에서 보여주기만 하는 버전값 임)
							VERSION_NAME = "1.0.1"	->	VERSION_NAME = "1.0.3"
	
106-4.	타사제품, "acwell" Tag 의 분석 결과
1.	QR Code는 일반적인 정품인증 방법으로 파악 되며
	1)	QR Code 내부에 해당 "인터넷주소" + "Security Key" 정보가 들어가 있고
	2)	QR Code 를 스캔하면 -> 해당 인터넷으로 접속 -> 상기 "Security Key" 정보를 가지고 정품 유/무를 판별
2.	"acwell" Tag에 들어가 있는 G-Tag 인증방법은
	아래 그림2) 처럼 Camera Flash를 켜고 비스듬히 보면 QR Code 내부에 있는 비표가 보임니다
	->	작동원리 : 반달(비표, 진한검정) 을 제외한 전 영역에 난반사 코팅을 입혀서
		Camera Flash를 켜면 반달 부분(비표, 진한검정)을 제외한 전 영역이 뿌옇게 보이도록 하는 원리로 보임

106-5.	현 정품인증app MFC Source 문제점
1.	Tag 이외의 인쇄물에 선등이 보이면 Contour를 제대로 잡지 못하는 문제 확실히 있음
	ex)
		Tag 밖 인쇄물 배경색상이 확실하게 직선으로 변해서 Threshold 처리하면 선으로 보이는 경우
		Tag 가 박스 모서리 쪽에 근접해 있어서 Threshold 처리하면 선으로 보이는 경우
	
2.	원본/Target 이미지 통비교 알고리즘 적용 수정 사항
	1)	define.h
	2)	D:\Work\app\src\main\assets\tessdata 에 0318_Origin.jpg 파일 추가
	3)	native-lib.cpp

106-6.	무광포장지 보다 유광포장지에 붙어 있는 정품태그가 인식이 잘 안되는 이유
-> 결론
    그림1) -> 그림2)와 같이 유광포장지가 난반사 일어날 확률 높고
    이에, 어두운 이미지로 촬영될 확률이 높기 때문에 정품인식하기 어려움

    cf) 신규 코어/알고리즘 자체에서 어두운 이미지는 자동으로 밝게 맞춰서 정품 인식하도록 하는 기능을 추가했으며
        1차 테스트 결과, 그림2)와 같이 어두운 경우 정품인식률이 기존 보다 높아짐 확인 완료
    cf) 카메라/App 자체에서 ISO/Shutter speed를 수동으로 변경시켜서 카메라 원본 이미지 자체의 밝기를 적정하게 변경하는 방법도
        있으나, 이는 카메라 자체가 지원을 해줘야지(Device driver 수동 조절) 가능하며
        이런 카메라 자체가 많지 않기 때문에 현, App에서 본 기능을 처리하기는 거의 불가능 함

	그림1) 유광포장지에 난반사 거의 없는 경우(무광포장지와 비슷한 환경)
	         1) 카메라로 들어오는 광원의(이미지전체) 평균치가 보통이기 때문에
	         2) 카메라가 밝기(ISO,ShutterSpeed)를 높이지 않고 보통으로 설정
	         -> 최종 : 촬영된 이미지 자체가 어둡지 않고 적정한 밝기 이미지로 촬영
	                      -> 정품인식하기 쉬움
	그림2) 유광포장지에 난반사 많이 일어나는 경우
	         1) 카메라로 들어오는 광원의(이미지전체) 평균치가 높기 때문에
	         2) 카메라가 밝기(ISO,ShutterSpeed)를 자동으로 낮춤
	         -> 최종 : 촬영된 이미지 자체가 어두워짐
	                      -> 정품인식 하기 어려움

106+7.	안드로이드 app, 실서버/개발서버로 연결 방법
	->	하기 초기값을 변경하면 무조건 해당 서버로 연결 됨
	
public class SplashActivity extends BaseActivity {

    @BindView(R.id.iv_intro_logo)
    ImageView iv_intro_logo;

    private String resultMsg;
    private CustomDialog cDialog;

    public static String _URL = "https://adm..com/";
    public static String DEV_URL = "https://dev..co.kr:8444/";
//    public static String DEV_URL_TEMP = "http://182.162.136.42/";
//    public static String DEV_URL = "http://192.168.1.53/";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_splash);
        ButterKnife.bind(this);

        // 로고 이미지 애니메이션 시작
        ((AnimationDrawable) iv_intro_logo.getBackground()).start();

        // 초기 값 설정
//      ContextUtil.url = _URL;       // 실서버로 연결됨
        ContextUtil.url = DEV_URL;          // 개발서버로 연결됨

106+8.	홀로그램 잉크 / 반사 잉크
홀로그램 잉크 : https://cafe.naver.com/adhesive/252739
반사 잉크 : http://hossan.kr.ec21.com/GC00047126/CA00047148/%EC%B9%BC%EB%9D%BC%EB%B0%98%EC%82%AC%EC%9E%89%ED%81%AC.html
홀로그램 기술 : http://gdsn.co.kr/?page_id=3499

106+8+1. 홀로그램스티커 원리(내생각)

원판에 각종 홀로그램 문양을 프레스로 찍어냄
이때, 홀로그램이 생기는 이유는 확대된 그림과 같이 홀로그램 문양을
아주작은톱니형상 구조로 문양을 만들기 때문에 빛이 들어오면 
아주작은톱니형상과 만나는 각도에 따라서 반사된 빛으로 
여러가지 빛(무지개 색상)으로 해당 문양이 보이게 되는 것임
cf) 여러채널의 홀로그램 문양을 넣는 것은
상기 톱니모양홀로그램 문양 만들 때 기울기를 줘서 해당 기울기로 빛이 들어오는
경우만 홀로그램이 보이도록 하는 것 같음

106+8+2. 홀로그램박
1)	홀로그램박 + 열로 찍어 붙임 + 동판비 추가로 들음
	가)	홀로그램패턴이 잘 보임(조명이 어둡거나 밝거나 관계 없이) 
	나)	홀로그램박을 사용하기 때문에 일정한패턴을 일정한 위치에 반복시킬 수 없음, cf) 벽지 문양
2)	홀로그램박 + 실크전사(액체로 전사) + 동판비 추가로 들지 않음
	가)	홀로그램패턴이 상기 1)번 보다 잘 보이지 않음, cf) 에칭보다는 패턴이 잘 보임 
	나) 홀로그램박을 사용하기 때문에 일정한패턴을 일정한 위치에 반복시킬 수 없음, cf) 벽지 문양
3)	홀로그램박 형상 & 인쇄업체 작업
	가) 홀로그램박 형상은 얇은 비닐제질로
		이것을 인쇄물 위에 올리고서 열로 붙인다고 함
	나)	홀로그램박 원판 사이즈는
		1000mm폭 이상 롤로 말려있는 원단을 저희가 필요한 폭으로 슬레트 쳐서 사용한다고 함

106+8+2. 수무늬(Threshold) 원리
- 미세한 점(내부비어있는 O모양의 점)
  을 연속으로 인쇄해서 문양을 만들기 때문에
cf)	스프리트인쇄
    : 점을 일일이 찍은 것이 아닌 색이 빠진 별색으로 인쇄한 것임
	  보이기에는 점으로 인쇄한 것 처럼 보이는 것임

- 육안으로는 거의 형태가 보이지 않고(내부가 비어
  있는 O모양이기 때문)
- Threshold 처리하면 내부비어 있는 O이 반대로
  내부채워져있는 O으로 변경되기 때문에(점)
  확실하게 점으로 보이게 되어
  연속된 점의 문양을 잘 볼 수 있게 되는 것임

106+8+3. VOID 스티커 원리
1)	VOID 스티커 하단에 접착제를 전면 도포하기 전에 유막으로 VOID 문양을 먼저 인쇄한 후
	접착제를 전면 도포해서
2)	이렇게 처리된 스티커를 종이에 붙인 다음 띠면
	유막으로 처리된 부분만 스티커에 붙지 않고 떨어져 나가서(유막으로 처리되었기 때문에 접착 성능이 떨어져 스티커에 붙지 않고 떨어져 나감) VOID 문양을 만드는 것 같음

106+9.	위변조 방지 디자인 / 참고사이트
http://w.cocotickets.co.kr/spec/page2.php

정품인증 참고사이트
NanoMatriX
spsy.com
essentra.com -> security
microtrace solution 
https://alpvision.com/


[107]	아이폰 문법(iOS)
0.	메서드 인수 설명
/*	메서드 인수 설명
	ex1)
	1.	ret = [self findHiddenCode : TAG_TYPE_IMAGE nModeThreshold:nModeThreshold];
	2.	- (int) findHiddenCode: (int) nTagType nModeThreshold:(int) nModeThreshold
	->	(int) nTagType	 						->	인수변수가 (int) nTagType 이며 TAG_TYPE_IMAGE를 인수값으로 던져줌
	->	nModeThreshold:(int) nModeThreshold		->	인수변수가 nModeThreshold 이며 nModeThreshold를 인수값으로 던져줌	

	ex2)
	1.	[self SaveDebugImage : tempGray text:@"Red" color:Scalar(0, 0, 0)];
	2.	-(void) SaveDebugImage : (Mat) img text:(NSString*) text color:(Scalar) color
	->	(Mat) img								->	인수변수가 (Mat) img 이며 tempGray를 인수값으로 던져줌
	->	text:(NSString*) text					->	인수변수가 text 이며 @"Red"를 인수값으로 던져줌
	->	color:(Scalar) color					->	인수변수가 color 이며 Scalar(0, 0, 0)를 인수값으로 던져줌
	->	-(void) SaveDebugImage : (Mat) img text:(NSString*) text color:(Scalar) color
		{
		    if(m_bDebugMode == false)
		        return;
		    
		    //if(m_nDebugImageCnt > 0)
		    //    return;
		    
		    Mat result = img.clone();
		    NSString* num = [NSString stringWithFormat:@"%02d ", m_nDebugImageCnt];
		    
		    cv::putText(result, [num UTF8String], cv::Point(1, 1), FONT_HERSHEY_SIMPLEX, 1.0, color);
		    cv::putText(result, [text UTF8String], cv::Point(60, 1), FONT_HERSHEY_SIMPLEX, 1.0, color);
		    UIImage* uiImage = [self UIImageFromCVMat:result];
		    
		    //UIImageWriteToSavedPhotosAlbum(uiImage, nil, nil, nil);
		    //UIImageWriteToSavedPhotosAlbum(uiImage, self, @selector(image:didFinishSavingWithError:contextInfo:), nil);
		    m_nDebugImageCnt++;
		}	*/
		

            if (strcmp(m_strTrillCodeCompanyOfTag, "0302") == 0 && strcmp(m_strTrillCodeBrandOfTag, "09") == 0 && strcmp(m_strTrillCodeProductOfTag, "07") == 0)
            {
                UIImage* img = [UIImage imageNamed:@"ReAll"];
                Mat matReall;
                
                UIImageToMat(img, matReall ,true);
                
                cvtColor(matReall, matReall, COLOR_BGR2GRAY);
                
                double min, max;
                cv::Point left_top;
                cv::Rect rect;
                Mat matMatchingResult = Mat(m_srcTagImageGrayPerspective.cols - matReall.cols + 1, m_srcTagImageGrayPerspective.rows - matReall.rows + 1, CV_32F, Scalar::all(0));
                Mat matMatchingRect = Mat(m_srcTagImageGrayPerspective.cols - matReall.cols + 1, m_srcTagImageGrayPerspective.rows - matReall.rows + 1, CV_8UC3, Scalar::all(0));
                
                matchTemplate(m_srcTagImageGrayPerspective, matReall, matMatchingResult, CV_TM_CCOEFF_NORMED); // 상관계수를 구하여 C에 그린다.
                minMaxLoc(matMatchingResult, &min, &max, NULL, &left_top); // 상관계수가 최대값을 값는 위치 찾기
                
                if (max < 0.6f)    // 매칭확률 60% 미만이면 브로셔라고 판단
                {
                    strncpy(m_strTrillCodeCompanyOfTag, "0123", 4);    // 브로셔 TrillCode로 대체
                    strncpy(m_strTrillCodeBrandOfTag, "02", 2);
                    strncpy(m_strTrillCodeProductOfTag, "10", 2);
                }
            }

1.	Xcode 설명
	1)	해당프로젝트명을 더블클릭하면
		해당프로젝트 build 환경이 나오며
		가)	General -> Signing(Debug/Release) -> Provisioning Profile
			->	_DEV 로 변경하면 개발/디버깅 환경으로 구동시킬 수 있으며
				(아이폰을 PC와 아이폰cable로 연결시킨 다음Xcode -> Product -> Run 하면 해당 build 된 app이 아이폰으로 넘어가서 실행됨)
			->	_DIS 로 변경하면 app배포 환경으로 변경 됨
	2)	Product -> Run -> Debug/Release 동작 선택은
		Product -> Scheme -> Edit Scheme -> Info -> Build Configuration -> Debug/Relase 로 선택하면 됨
		
	3)	셋팅
		base SDK : 라이브러리, 프레임워크 기반을 의미. maximum 버전으로 생각하면 됨. 
		Deployment target : 어느 버전까지 지원가능한지 버전. minimum 버전 으로 생각하면 됨. 

2.	[iphone] iPhone Configuration Utility 를 이용한 AdHoc 배포.
1)	복사 https://blog.naver.com/hana_815/60130301851  

	아이폰 앱 개발을 완료 하고 나서, QA 를 위해서 주변 지인 분들이나, 사내 QA 팀에 앱을 배포해야 할 때가 있습니다. 
	이때 많이 사용하는 방법이 앱을 AdHoc 방법으로 배포를 하는 것입니다. (AdHoc 배포 파일을 만드는 방법은 여러 다른 분들께서 설명을 많이 해 주셨으니,
	이번 포스팅에선 넘어갑니다. ) 그런데 이 AdHoc 배포가 여간 불편한게 아닙니다. 
	저도 그동안 AdHoc 파일을 iPhone 에 설치 하기 위하여 아래 와 같은 절차를 밟았습니다.
	 
	1.AdHoc 파일을 다운로드 받는다. 
	2.아이폰과 동기화 되어 있는 iTunes에 설치한다. 
	3.아이폰과 동기화 한다. 
	
	위 절차가 번거로운 이유는 2번 때문입니다. 꼭 동기화 되어 있는 iTunes 가 필요하기 때문이지요. 
	하지만, 이번에 소개하는 툴을 사용하면 iTunes 동기화 없이도 AdHoc 파일을 아이폰에 설치 할 수 있습니다. 
	
	iPhone Configuration Utility
	위 툴이 언제 생겼는지는 저도 잘 모르겠네요. :) 위 툴 덕분에 AdHoc 파일을 설치하기가 너무 간편해 졌습니다. 
	또한, 각종 아이폰과 관련된 설정들을 간편하게 조작할 수도 있습니다. 
	
	일단 위 링크로 따라 들어가서 해당 프로그램을 다운로드 받아서 설치 합니다. 
	설치를 하면 Application의  Utility 디렉토리에 설치가 됩니다. 실행하시면 다음과 같은 화면을 볼 수 있습니다. 
	
	AdHoc 파일을 설치하고 싶은 아이폰을 USB  로 연결 하시면 DEVICE 섹션에 나타납니다. :)
	
	그리고, Application 부분을 선택하고 (빨간색 네모) 오른쪽 리스트 나오는 부분에 설치하려는 AdHoc 파일을 던져 넣습니다. (Drag & Drop) 
	
	급하게 준비하느라, 위 그림엔 빠져 있지만, AdHoc 파일을 던져 넣으면 설치할 앱 이름이 보입니다. 그러면 설치 준비는 끝입니다. 
	
	Application  에 등록이 되었다면, DEVICE 의 연결된 아이폰을 선택 합니다. 
	
	그럼 위와 같은 화면을 볼 수 있습니다. 오른쪽에는 해당 디바이스와 관련된 설정들을 볼 수 있는 화면이 나타납니다. 그중에서 Application 탭을 선택 합니다. 
	
	Application 탭을 선택하면 현재 아이폰에 인스톨 되어 있는 앱들의 목록이 나타납니다. 
	각각의 앱  오른쪽에는 uninstall 버튼이 자리잡고 있고, 스크롤을 내리다가 보면 AdHoc 배포 앱의 이름과 버튼이 install 이라고 나타나있는것이 보입니다.
	
	install 버튼을 살며시 눌러 주세요. 그럼 설치 끝.
	
	iTunes 를 이용해서 동기화 하는 방법 보다는 훨씬 깔끔한거 같네요. :)

2)	개발중인 iOS(iPhone, iPad) 앱 쉽게 배포하기 
	개발중인 앱을 쉽게 배포하자
	iOS 앱을 개발하면서 하루에도 몇번씩 변경되는 앱을 팀원, 테스터에게 배포하는것은 귀찮은 작업입니다. 

	개발단계에서 iOS 기기에 앱을 설치해주는 방법은 3가지가 있습니다. 
	1. USB로 연결후 Xcode 에서 빌드하여 설치 
	2. USB로 연결후 iPhone Conficuration Utility를 이용해 설치 
	3. 각 사용자의 기기에서 웹사이트에 접속해 설치 
	
	이외에도 AdHoc 기능을 이용해 배포하는것이 있다고 알고 있지만 AdHoc 배포를 위해서는 개인개발자 계정이 아닌 
	좀더 비싼 기업용 개발자 프로그램을 구매해야 합니다. 본 포스트에서는 개인개발자 계정인 경우를 기준으로 설명합니다. 

	본 포스트에서 설명하고자 하는것은 3번째 방법인 웹을 이용한 배포 및 설치입니다. 
	내부 배포용 앱 실행파일(ipa) 만들기
	웹을 이용한 배포를 위해서는 앱 실행 파일인 ipa 확장자를 가진 파일이 필요합니다. 본인이 개발자가 아닌경우 지인이나 개발자로부터 
	ipa파일을 받게 되는데 이런 상황인경우 아래쪽의 "ipa 파일을 이용해 웹에서 앱을 설치하기"로 바로 넘어가시면 됩니다. 
	
	1. ipa 파일을 만들기 위해서 Xcode 에서 Scheme를 시뮬레이터가 아닌 Device 로 선택합니다. 이때 기기는 연결되어 있지 않아도 됩니다. 
	2. Build Setting 에서 'Code Signing Identity' 의 Release 에 설정된 프로파일을 배포용 프로파일이 아닌 개발용 프로파일로 변경합니다. 
	추후 앱스토어 배포할때는 다시 배포용 프로파일로 변경해야 합니다. 
	주의 : 개발용 프로파일에 설정된 UDID를 가진 기기에서만 실행할 수 있으므로 배포하고자 하는 대상의 UDID가 개발용 프로파일에 포함되어 있는지 확인해야 합니다
	.(Xcode를 이용해 자동으로 개발 프로파일이 관리되는 경우 Xcode > Orgarnizer 에서 대상 기기를 USB로 연결후 'Use Develop' 버튼을 클릭하고 
	개발용 프로파일 새로고침을 하면 개발 프로파일에  해당 기기의 UDID가 등록 됩니다.) 
	3. 메뉴 > Product > Archive 를 클릭하여 배포용으로 앱을 빌드합니다. 
	4. 빌드완료후 실행되는 Archives 하단 빌드 목록중 방금 생성한 항목을 선택하고 오른쪽 상단의 "Distribute..." 버튼을 클릭합니다. 
	5. "Save for Enterprise or Ad-Hoc Deployment" 를 선택하고 "Next" 버튼을 클릭합니다. 
	6. Code Signing Identity 에서는 앞서 2번에서 설정한 개발용 프로파일을 선택하고 "Next" 버튼을 클릭합니다. 
	7. ipa 파일을 저장할 위치를 물어보는 팝업이 노출되면 적절한 폴더를 선택하고 "Save" 버튼을 클릭합니다. 
	
	저장이 완료되어도 별도의 메시지는 없습니다. 순식간에 저장되므로 지정한 위치에 ipa 파일이 생성되어 있다면 ipa 파일의 생성은 완료된것입니다. 
	
	IPA 파일을 이용해 웹에서 앱을 설치하기
	ipa 파일을 가지고 있다면 이를 이용해 다른 사용자들이 웹에서 쉽게 설치할 수 있습니다. 물론 개발자 프로파일에 등록된 기기만 설치 가능합니다. 
	
	Beta Builder for iOS
	웹을 이용한 설치를 위해서는 Beta Builder for iOS 프로그램이 필요한데 이 프로그램은 Mac App Store 에서 $1.99에 다운로드 받을수 있습니다. 
	유료라서 부담이 된다면 개발자가 직접 공개한 소스코드를 GitHub에서 다운로드 받아 Xcode로 빌드해 사용해도 됩니다.
	(iOS 개발을 한다면 유용한 툴임에 분명하기에 유료로 구매하시는것을 제안합니다. 커피반잔보다 못한 가격입니다.) 
	
	1. Beta Builder 를 실행후 "Archive IPA File" 항목의 "Choose IPA..." 버튼을 클릭하거나 생성된 ipa 파일을 드래그하여 입력창으로 드랍합니다. 
		ipa 파일을 선택하면 Bundle Identifier 등의 정보는 모두 자동으로 입력됩니다. 
	2. "Full Web Deployment Path" 에는 해당 앱을 배포할 웹사이트 주소를 입력합니다. 
	
	드랍박스 이용하기 
	배포할때 Dropbox를 이용하는것을 추천하는데 이유는 별도로 웹서버에 배포할 필요없기 때문입니다.
	(2013. 2. 7 추가 : Google Drive 도 비슷한 기능을 제공하기 시작했습니다. 공유 옵션중 Public Share 를 사용하면 됩니다. 
	Dropbox 와는 달리 아무 폴더나 설정가능합니다.) 
	
	Dropbox의 Public 폴더는 항상 외부에 오픈되어 있어 누구나 접속가능한 폴더입니다. 
	
	ipa 파일을 Dropbox/Public/diffweather 폴더에 저장했을 경우 "Full Web Deploymemt Path"는 http://dl.dropbox.com/u/xxxx/diffweather/ 이와 같은 경로가 됩니다
	. (여기서 xxxx는 사용자마다의 고유의 값입니다.) 
	
	고유의 값은 Dropbox/Public 하위의 파일(폴더아님)을 선택하고 마우스 오른쪽 버튼을 누른후 "Copy Public Link"를 클릭하면 클립보드에 저장된 값으로 
	알 수 있습니다.
	Dropbox 에 업로드된 데이터의 동기화가 모두 종료되었다면 이제 다른 기기에서 웹으로 접속해 앱을 설치 할 수 있습니다. 
	
	주의 : 기기에서 접속하는 설치 URL에는 "Full Web Deploymemt Path"에서 입력한 주소뒤에 "/index.html"을 붙여주어야 합니다. 
	위의 경우 http://dl.dropbox.com/u/xxxx/diffweather/index.html 을 사용자에게 메시지나 메일을 통해 알려주면 됩니다. 
	
	3. 사파리 브라우저에  URL을 입력하면 다음과 같은 화면이 보이는데 여기서 iOS 4.0 이상 사용자는 위쪽의 파란 박스, 
	이하 사용자는 아래쪽의 파란박스를 클릭하여 설치를 진행하면 됩니다. 설치가 진행되면 바탕화면에서 앱이 다운로드 되는것을 확인할 수 있습니다. 
	
	URL 주소 줄이기
	
	사용자에게 http://dl.dropbox.com/u/xxxx/diffweather/index.html 와 같은 긴 주소를 알려주면 입력하기도 힘들고 오타가 날 수 있으므로 
	URL 주소를 줄여주는 서비스를 이용해보도록 하겠습니다. 
	
	https://bitly.com/ 서비스에 접속후 배포할 웹주소를 입력후 "Shorten" 버튼을 클릭합니다. (ex http://dl.dropbox.com/u/xxxx/diffweather/index.html) 
	줄여진 주소도 사실 복잡한 문자열로 이루어져 있어 기억하기 쉽지 않습니다. 
	줄여진 주소를 임의로 수정하려면 bit.ly 서비스에 무료로 가입해야 합니다. 무료로 가입한경우 다음과 같이 줄여진 URL을 얻을수 있습니다. 
	
	좀더 쉬운 방법
	
	Beta Builder for iOS를 이용해 파일을 생성하고 Dropbox에 올리는 작업이 번거롭다면 이 작업을 대행해주는 서비스를 이용하는것도 좋습니다. 	
	TestFlight 같은경우 생성된 ipa 파일을 업로드하면 자동으로 주소도 만들어 주고 다른 데이터도 제공하는데 자세한 내용은 홈페이지를 참고 하시기 바랍니다. 
	
	참고자료
	- "7 Tools for Over-the-Air iOS Beta Testing" 	
	- "Beta Builder for iOS 공식 홈페이지"

3.	아이폰App 배포
	1)	Xcode -> _DEV에서 _DIS로 변경
		Build 버전 한단계 올려줌
	2)	Xcode -> Archive -> Submit to the iOS App Store
	3)	https://developer.apple.com 에 들어가보면(id dev.@gmail.com, pw Gl911532) -> TestFlight
		에서 등록한 아이폰 휴대폰은 곧바로 신규Build한 신규App을 업로드할 수 있음
		cf)	Xcode 버전이 낮아서 신규 아이폰(높은 Xcode 버전 요구)으로 Xcode -> Run 불가능한 경우에도
			본 단계에서는 iOS버전이 높은 신규 아이폰도 신규App으로 업로드 가능
	4)	https://developer.apple.com -> App Store -> "심사를 위해 제출"  버튼 누름
	5)	https://developer.apple.com 에서 심사(1~2일 정도 소요)하며 심사 통과되면
	6)	https://developer.apple.com -> App Store -> "이버전 출시" 로 바뀜
	7)	https://developer.apple.com -> App Store -> "이버전 출시"  버튼 누르면 2시간 정도 후에
		https://developer.apple.com -> App Store -> 에 신규App이 올라와 있음
	8)	http://adm./admin/AM/confirm/main(ID = admin, PW = wlsWkahffk!(진짜몰라!))
		-> 어플 관리 -> 아이폰 공용/아이폰 6s 이전 -> 버전 -> 신규App 버전으로 올려줘야 함
	9)	이후, 아이폰 App() 실행해 보면 강제적으로 Update 과정 실행하게 되고
		Update된 신규App()으로 실행하게 됨

4.	아이폰 id / pw
	안드로이드
	Id dev.@gmail.com
	Pw gls911532
	Google play  https://play.google.com/apps/publish
		
	아이폰(https://developer.apple.com/    아이폰 앱 배포)
	id dev.@gmail.com
	pw Gl911532
	
	단말기계정(개발자아이폰휴대폰)
	Id device.@gmail.com
	Pw Global0056

5.	iOS 개발 관련 tip
0-1)텍스트 편집 복사/붙여넣기 키
	복사 : 윈도우화면버튼 + C			,	윈도우화면버튼(왼쪽Ctrl버튼 바로 오른쪽 버튼)
	붙여넣기 : 윈도우화면버튼 + V

0)	Xcode 실행 시 반드시 *.xcworkspace 파일로 열어서 build 하고 run 등을 실행시켜야 함
		*.xcodeproj 파일로 열면 안 됨  
1)	터미널창에서 pod update 명령 실행하면 하기와 같은 에러 발생하는 경우
	1)	% pod update
			zsh: command not found: pod
	2)	sudo gem install cocoa pods.       명령 실행
	cf)	이후  Podfile 이 들어있는 폴더로 가서
			% pod update 실행하면 Podfile 파일에 들어 있는 여러가지 프로그램이
			자동으로 설치 됨
	cf)	Installing Alamofire 5.0.2 (was 4.9.1)
			Installing AlamofireNetworkActivityIndicator 3.0.1 (was 2.4.0)
			Installing 	AlamofireObjectMapper 6.0.0 (was 5.2.1)
 
2)	Finder 에서 숨김파일 보기
	1)	터미널 창에서 하기 명령 실행
			defaults write com.apple.finder AppleShowAllFiles YES && killall Finder
 
3)	Pop 환경
Analyzing dependencies
Downloading dependencies
Installing Alamofire 5.0.4 (was 4.8.2)
Installing AlamofireNetworkActivityIndicator 3.0.1 (was 2.4.0)
Installing AlamofireObjectMapper 6.0.0 (was 5.2.0)
Installing Crashlytics 3.14.0 (was 3.13.4)
Installing CryptoSwift 1.3.0 (was 1.0.0)
Installing KeychainSwift 19.0.0 (was 16.0.1)
Installing ObjectMapper 3.5.2 (was 3.5.1)
Installing SnapKit 5.0.1 (was 5.0.0)
Generating Pods project
Integrating client project
Pod installation complete! There are 13 dependencies from the Podfile and 14 total pods installed.

4)	Xcode build error
	1)	/Users/nemoinsight/Documents/Project/ImageTag_iOS/Program/nemoin/Pods/AlamofireObjectMapper/
			AlamofireObjectMapper/AlamofireObjectMapper.swift:132:190: Generic type 'DataResponse' specialized with
			too few type parameters (got 1, but expected 2) 에러 발생의 경우
			->	대처방법
					Podfile을 하기와 같이 수정 해서 library version을 swift 버전에 맞춤

					platform :ios, ’10.0’
					use_frameworks!

					target 'nemoin' do
					    pod 'SwiftGifOrigin', '~> 1.7.0'
					    pod 'AlamofireObjectMapper', '~> 5.2.0'
					    pod 'AlamofireNetworkActivityIndicator', '~> 2.4.0'
					    pod 'TesseractOCRiOS'
					    pod 'CryptoSwift', '~> 1.0.0'
					    pod 'OpenCV', '3.4.2'
					    pod 'Alamofire', '~> 4.8.2'
					    pod 'SnapKit', '~> 5.0.0'
					    pod 'MRProgress'
					    pod 'KeychainSwift', '~> 16.0.1'
					    pod 'GestureRecognizerClosures'

					    pod 'Fabric'
					    pod 'Crashlytics', '~> 3.13.4'
					end
	2)	: error: /Users/nemoinsight/Documents/Project/ImageTag_iOS/Program/nemoin/build/Debug-iphoneos/CryptoSwift/CryptoSwift.framework: No such file or directory 에러 발생의 경우
			-> 대처방법
  3): error: /Users/nemoinsight/Documents/Project/Library/Developer/Xcode/DerivedData/hkosyuzdwrdbfzasbvgwjlwqmspz/Build/Products/Debug-iphonesimulator/AlamofireNetworkActivityIndicator/AlamofireNetworkActivityIndicator.framework: No such file or directory
			-> 대처방법 -> 프로젝트이름 -> TARGETS -> Build Phases -> Link binary with libraries 
			-> AlamofireNetworkActivityIndicator.framework -> 오른쪽마우스 -> Reveal in project navigator 
			-> 정확한 path로 바꿔줌

5)	example
image_feature_detector / ios / Classes / OpenCVWrapper.mm 
1 // 
2 //  OpenCVWrapper.m 
3 //  image_feature_detector 
4 // 
5 //  Created by Marco Tschannett on 17.04.19. 
6 // 
7 
 
8 #import "OpenCVWrapper.h" 
9 #import <opencv2/opencv.hpp> 
10 #include "opencv2/imgcodecs.hpp" 
11 #include "opencv2/highgui/highgui.hpp" 
12 #include "opencv2/imgproc/imgproc.hpp" 
13 #import "ImageHelper.h" 
14 #import "PointsHelper.h" 
15 #include "math.h" 
16 
 
17 using namespace cv; 
18 using namespace std; 
19 
 
20 class Contour { 
21 public: string point; 
22 }; 
23 
 
24 @implementation OpenCVWrapper 
25 + (NSString *)getVersionString { 
26     return [NSString stringWithFormat:@"OpenCV Version %s",  CV_VERSION]; 
27 } 
28 
 
29 + (NSString *) getBuildInformation { 
30     return @"Just a placeholder"; 
31 } 
32 
 
33 + (NSString *) detectAndTransformRectangleInImage: (NSString *) path { 
34     Mat source = [OpenCVWrapper _loadImage: path]; 
35      
36     vector<cv::Point> maxApprox = [OpenCVWrapper findContourInImage:source]; 
37      
38     if (maxApprox.empty()) { 
39         return NULL; 
40     } 
41      
42     vector<cv::Point> temp = maxApprox; 
43     cv::Point2f src[4], dest[4]; 
44      
45     [PointsHelper sortPoints:temp withList:src]; 
46      
47     cv::Point2f tl = src[0]; 
48     cv::Point2f tr = src[1]; 
49     cv::Point2f br = src[2]; 
50     cv::Point2f bl = src[3]; 
51      
52      
53     double widthA = sqrt(pow((br.x - bl.x), 2) + pow(br.y - bl.y, 2)); 
54     double widthB = sqrt(pow(tr.x - tl.y, 2) + pow(tr.y - tl.y, 2)); 
55     int maxWidth = (int)fmax(widthA, widthB); 
56      
57     double heightA = sqrt(pow(tr.x - br.x, 2) + pow(tr.y - br.y, 2)); 
58     double heightB = sqrt(pow(tl.x - bl.x, 2) + pow(tl.y - bl.y, 2));; 
59     int maxHeight = (int)fmax(heightA, heightB); 
60      
61     dest[0] = cv::Point2f(0, 0); 
62      
63     dest[1] = cv::Point2f(maxWidth -1, 0); 
64     dest[2] = cv::Point2f(maxWidth -1, maxHeight -1); 
65     dest[3] = cv::Point2f(0, maxHeight -1); 
66      
67     Mat matrix = getPerspectiveTransform(src, dest); 
68     Mat destination = cv::Mat(maxWidth, maxHeight, CV_8UC4); 
69     warpPerspective(source, destination, matrix, cv::Size(maxWidth, maxHeight)); 
70      
71     NSNumber *timestamp = [NSNumber numberWithDouble:[[NSDate date] timeIntervalSince1970]]; 
72     NSString *fileName = [NSString stringWithFormat: @"transformed-image%@.png", timestamp]; 
73      
74     NSString *outputPath = [[path stringByDeletingLastPathComponent] stringByAppendingPathComponent: fileName]; 
75     UIImage *image = [OpenCVWrapper _matToImage:destination]; 
76     NSData *binaryImageData = UIImagePNGRepresentation(image); 
77      
78     [binaryImageData writeToFile:outputPath atomically:YES]; 
79      
80     NSMutableDictionary *resultData = [[NSMutableDictionary alloc] init]; 
81     resultData[@"filePath"] = outputPath; 
82     resultData[@"foundFeatures"] = [OpenCVWrapper serializeContour:maxApprox image:source]; 
83      
84     NSError *err; 
85     NSData *jsonData = [NSJSONSerialization dataWithJSONObject:resultData options:NSJSONWritingPrettyPrinted error:&err]; 
86      
87     return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; 
88 } 
89 
 
90 + (NSString *)  findImageContour:(NSString *) path { 
91     cv::Mat source =[OpenCVWrapper _loadImage:path]; 
92 
 
93     vector<cv::Point> maxApprox = [OpenCVWrapper findContourInImage:source]; 
94      
95     if (maxApprox.empty()) { 
96         return NULL; 
97     } 
98      
99     NSDictionary *contour =  [OpenCVWrapper serializeContour:maxApprox image:source]; 
100      
101     NSError *err; 
102     NSData *jsonData = [NSJSONSerialization dataWithJSONObject: contour options:NSJSONWritingPrettyPrinted error:&err]; 
103      
104     return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; 
105 } 
106 
 
107 + (std::vector<cv::Point>) findContourInImage: (cv::Mat)source { 
108     cv::Mat s = source; 
109     s = [self _grayScale:s]; 
110     s = [self _transformSobel:s]; 
111     s = [self _cannyEdgeDetect:s]; 
112     s = [self _gaussianBlur:s]; 
113      
114     vector<vector<cv::Point>> contours; 
115     vector<Vec4i> hierarchy; 
116      
117     findContours(s, contours, hierarchy, cv::RETR_TREE, CHAIN_APPROX_SIMPLE); 
118      
119     double maxArea = 0; 
120     vector<cv::Point> maxContour; 
121     vector<cv::Point> maxApprox; 
122      
123     for(size_t i = 0; i < contours.size(); i++) { 
124         vector<cv::Point> approx; 
125         double peri = arcLength(contours[i], true); 
126          
127         approxPolyDP(contours[i], approx, 0.04 * peri, true); 
128         if (approx.size() == 4) { 
129              
130             double area = contourArea(contours[i]); 
131              
132             if (area > maxArea) { 
133                 maxArea = area; 
134                 maxContour = contours[i]; 
135                 maxApprox = approx; 
136             } 
137         } 
138     } 
139      
140     return maxApprox; 
141 } 
142 
 
143 + (NSMutableDictionary*) serializeContour: (std::vector<cv::Point>) maxApprox image:(cv::Mat) source { 
144     NSMutableArray<NSMutableDictionary*> *points = [[NSMutableArray alloc] init]; 
145      
146     for(size_t j = 0; j < maxApprox.size(); j++) { 
147         cv::Point p = maxApprox[j]; 
148         NSMutableDictionary *point = [[NSMutableDictionary alloc] init]; 
149         double relativeX = (double)p.x / (double)source.cols; 
150         double relativeY = (double)p.y / (double)source.rows; 
151         point[@"x"] = [[NSNumber alloc] initWithDouble: relativeX]; 
152         point[@"y"] = [[NSNumber alloc] initWithDouble: relativeY]; 
153          
154         [points addObject: point]; 
155     } 
156      
157     NSMutableDictionary *contour = [[NSMutableDictionary alloc] init]; 
158     [contour setObject:points forKey: @"contour"]; 
159      
160     NSMutableDictionary *dimensions = [[NSMutableDictionary alloc] init]; 
161     [dimensions setObject: [NSNumber numberWithInteger: source.cols] forKey:@"width"]; 
162     [dimensions setObject: [NSNumber numberWithInteger:source.rows] forKey: @"height"]; 
163      
164     [contour setObject:dimensions forKey: @"dimensions"]; 
165      
166     return contour; 
167 } 
168 
 
169 + (cv::Mat) _grayScale:(cv::Mat)source { 
170     Mat result = Mat(source.rows, source.cols, CV_8UC1); 
171      
172     cvtColor(source, result, COLOR_BGR2GRAY); 
173      
174     return result; 
175 } 
176 
 
177 + (cv::Mat) _loadImage:(NSString *) path { 
178     UIImage *source = [UIImage imageWithContentsOfFile: path]; 
179      
180     source = [ImageHelper adjustImageOrientationWithExif:source]; 
181      
182     if (source == nil) { 
183         NSException *exception = [NSException 
184                                   exceptionWithName:@"File Not Found" 
185                                   reason: @"Image seems to be empty or not existent" 
186                                   userInfo: nil]; 
187          
188         @throw exception; 
189     } 
190      
191     CGColorSpaceRef colorSpace = CGImageGetColorSpace(source.CGImage); 
192     CGFloat cols = source.size.width; 
193     CGFloat rows = source.size.height; 
194      
195     Mat result(rows, cols, CV_8UC4); 
196      
197     CGContextRef contextRef = CGBitmapContextCreate(result.data, cols, rows, 8, result.step[0], colorSpace, kCGImageAlphaNoneSkipLast | kCGBitmapByteOrderDefault); 
198      
199     CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), source.CGImage); 
200     CGContextRelease(contextRef); 
201      
202     return result; 
203 } 
204 
 
205 + (UIImage *) _matToImage:(cv::Mat) source { 
206     NSData *data = [NSData dataWithBytes:source.data length:source.elemSize() * source.total()]; 
207     CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data); 
208      
209     CGBitmapInfo bitmapFlags = kCGImageAlphaNone | kCGBitmapByteOrderDefault; 
210     size_t bitsPerComponent = 8; 
211     size_t bytesPerRow = source.step[0]; 
212     CGColorSpaceRef colorSpace = (source.elemSize() == 1 ? CGColorSpaceCreateDeviceGray() : CGColorSpaceCreateDeviceRGB()); 
213      
214     CGImageRef image = CGImageCreate(source.cols 
215                                      , source.rows, bitsPerComponent, bitsPerComponent * source.elemSize(), bytesPerRow, colorSpace, bitmapFlags, provider, NULL, false, kCGRenderingIntentDefault); 
216      
217     UIImage *result = [UIImage imageWithCGImage:image]; 
218      
219     CGImageRelease(image); 
220     CGDataProviderRelease(provider); 
221     CGColorSpaceRelease(colorSpace); 
222      
223     return result; 
224 } 
225 
 
226 + (cv::Mat) _transformSobel:(cv::Mat)source { 
227     int width = source.cols; 
228     int height = source.rows; 
229      
230     Mat destination = Mat(width, height, CV_8UC1); 
231      
232     Mat sobelX  =Mat(width, height, CV_8UC1); 
233     Mat sobelY = Mat(width, height, CV_8UC1); 
234     Mat absSobelX = Mat(width, height, CV_8UC1); 
235     Mat absSobelY = Mat(width, height, CV_8UC1); 
236      
237     Sobel(source, sobelX, CV_16S, 1, 0); 
238     Sobel(source, sobelY, CV_16S, 0, 1); 
239      
240     convertScaleAbs(sobelX, absSobelX); 
241     convertScaleAbs(sobelY, absSobelY); 
242      
243     addWeighted(absSobelX, 0.5, absSobelY, 0.5, 0, destination); 
244      
245     return destination; 
246 } 
247 
 
248 + (cv::Mat) _gaussianBlur:(Mat)source { 
249     Mat result = Mat(source.rows, source.cols, CV_8UC1); 
250     cv::Size s = cv::Size(3, 3); 
251      
252     GaussianBlur(source, result, s , 0); 
253      
254     return result; 
255 } 
256 
 
257 + (cv::Mat) _adaptiveThreshold:(Mat)source { 
258     Mat result = Mat(source.rows, source.cols, CV_8UC1); 
259      
260     adaptiveThreshold(source, result,255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 15, 2); 
261     return result; 
262 } 
263 
 
264 + (Mat) _cannyEdgeDetect:(Mat) source { 
265     Mat result = Mat(source.rows, source.cols, CV_8UC1); 
266      
267     Canny(source, result, 10, 100); 
268      
269     return result; 
270 } 
271 @end 

6)	[iOS] 사운드 나 동영상 소재를 Asset Catalog에서 관리
본 기사에서는 Asset Catalog에서 사운드 소재와 동영상 자료를 관리하는 방법을 소개합니다.

검증 환경
Xcode Version 8.2.1
iPhone 6s, iOS 10.2.1
소재를 Asset Catalog에 추가
이미지를 추가하는 것과 같은 방법으로 사운드 소재와 동영상 자료를 Asset Catalog에 추가 할 수 있습니다.

소재를 코드에서 사용하는

사운드 소재의 경우
iOS 9.0에서 추가 된 NSDataAsset 를 통해 Asset Catalog의 자료에 액세스 할 수 있습니다. NSDataAsset는 Asset Catalog에서 데이터 세트 이름 (이번 경우에는 "movie"또는 "sound")을 지정하여 만들 수 있습니다.
NSDataAsset의 data 속성을 사용하면 소재의 원시 데이터 (Data 형)에 액세스 할 수 있습니다.
데이터와 함께 AVAudioPlayer를 작성하면 사운드 소재를 재생할 수 있습니다.

@IBAction func didTapPlaySoundButton(_ sender: Any) {
    let asset = NSDataAsset(name:"sound")
    player = try! AVAudioPlayer(data:asset!.data,
                                fileTypeHint:"m4a")
    player!.play()
}

동영상 소재의 경우
동영상의 경우도 NSDataAsset을 통해 소재의 원시 데이터를 얻을 수 있습니다.
그러나 Data 형의 데이터를 받아들이는 동영상 플레이어 클래스는 없을 것 같아서 (이번 조사 한) 임시 파일에 저장하고 파일의 URL을 플레이어에게 전달할 필요가 있다고 생각합니다.

let asset = NSDataAsset(name:"movie")

let videoUrl = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("movie.mp4")
try! asset!.data.write(to: videoUrl)

let item = AVPlayerItem(url: videoUrl)
destination.player = AVPlayer(playerItem: item)

최후에
Asset Catalog에서 사운드 소재와 동영상 자료를 관리 코드에서 사용하는 방법을 소개했습니다.
사운드와 동영상 소재를 많이 사용하는 응용 프로그램 등의 경우에 유용 것 같다라고 생각했습니다!
이번 해설 한 샘플 코드는 다음 저장소에 공개하고 있습니다.
hirayaCM / AudioAndVideoPlayFromAssetCatalogSample

7)	iOS/ Creating UIImage
Example
1)	With local image
Swift
#
let image = UIImage(named: "imageFromBundleOrAsset")

Objective-C
#
UIImage *image = [UIImage imageNamed:@"imageFromBundleOrAsset"];

Note
The method imageNamed caches the image's contents to memory. Loading many large images that way can cause low memory warnings which can lead the app to be terminated. 
This can be fixed by utilising the method imageWithContentsOfFile of UIImage, which doesn't use caching.

2)	With NSData
Swift
#
let imageData = Data(base64Encoded: imageString, options: Data.Base64DecodingOptions.ignoreUnknownCharacters)

let image = UIImage(data: imageData!)

3)	With UIColor
Swift
#
let color = UIColor.red
let size = CGSize(width: 200, height: 200)
    
UIGraphicsBeginImageContextWithOptions(size, false, 0.0)
UIGraphicsGetCurrentContext()!.setFillColor(color.cgColor)
UIGraphicsGetCurrentContext()!.fill(CGRect(origin: .zero, size: size))
let colorImage = UIGraphicsGetImageFromCurrentImageContext()
UIGraphicsEndImageContext()

Objective-C
#
UIColor *color=[UIColor redColor];
CGRect frame = CGRectMake(0, 0, 80, 100);
UIGraphicsBeginImageContext(frame.size);
CGContextRef context = UIGraphicsGetCurrentContext();
CGContextSetFillColorWithColor(context, [color CGColor]);
CGContextFillRect(context, frame);
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

4)	With file content
Objective-C
Example:
UIImage *image = [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:[cellCountry objectForKey:@"Country_Flag"] ofType:nil]];

Using Array:
Example:
NSMutableArray *imageArray = [[NSMutableArray alloc] init];

for (int imageNumber = 1; self.myPhoto != nil; imageNumber++) {
    NSString *fileName = [NSString stringWithFormat:@"%@.jpg", self.myPhoto];

    // check if a file exists
    if ([UIImage imageNamed:fileName]) {
        // if it exists, add it to the array
        [imageArray addObject:[UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:[NSString stringWithFormat:@"%@", fileName] ofType:@""]]];
    } else {
        break;
    }
}

//Using image array for animations here:
self.myImageView.animationImages = imageArray;

cf)	UIImage *img = [UIImage imageNamed@"aImageName"];
cf)	NSDataAsset *asset = [[NSDataAsset alloc] initWithName:@"funny"]; 
	self.gifImageView.image = [UIImage sd_animatedGIFWithData:asset.data]; 
cf)	NSData *data = [[[NSDataAsset alloc]initWithName:fontName] data];
	CGDataProviderRef fontProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);
	CGFontRef cgFont = CGFontCreateWithDataProvider(fontProvider);
cf)	if let asset = NSDataAsset(name: "animation") {
		let gifData = asset.data
		let gif = FLAnimatedImage(animatedGIFData: gifData)
		imageView.animatedImage = gif
	}

8)	Adding Image Assets
Example 1: Using the image set programmatically
To access images in the Asset Catalog programmatically, create UIImages using the imageNamed: method as shown in the snippet below.

Swift
var chat = UIImage(named: "Chat")
var chatImageView = UIImageView(image: chat)

ObjectiveC
UIImage *chat = [UIImage imageNamed:@"Chat"];
UIImageView *chatImageView = [[UIImageView alloc] initWithImage:chat];

9)  iOS & TensorFlow
### 중요)	xcode project 폴더에 복사한 lib_ocr.pb 파일을 학습모델로 읽어들이는 예제(제대로 동작함)
    NSString *path = [[NSBundle mainBundle] pathForResource:@"lib_ocr" ofType:@"pb"];
    Net net = readNet(path.fileSystemRepresentation); 

cf)	TensorFlow-iOS-Example-master 예제
- (void)viewDidLoad {
	[super viewDidLoad];

	NSString *path = [[NSBundle mainBundle] pathForResource:@"inference" ofType:@"pb"];

	if ([self loadGraphFromPath:path] && [self createSession]) {
		[self predict:maleExample];
		[self predict:femaleExample];
		session->Close();
	}
}

- (BOOL)loadGraphFromPath:(NSString *)path
{
	auto status = ReadBinaryProto(tensorflow::Env::Default(), path.fileSystemRepresentation, &graph);
	if (!status.ok()) {
		NSLog(@"Error reading graph: %s", status.error_message().c_str());
		return NO;
	}

	// This prints out the names of the nodes in the graph.
	auto nodeCount = graph.node_size();
	NSLog(@"Node count: %d", nodeCount);
	for (auto i = 0; i < nodeCount; ++i) {
		auto node = graph.node(i);
		NSLog(@"Node %d: %s '%s'", i, node.op().c_str(), node.name().c_str());
	}

	return YES;
}

cf)	로컬 모델 구성
모델을 앱과 번들로 묶은 경우에는 TensorFlow Lite 모델의 파일 이름을 지정하여 CustomLocalModel 객체를 만듭니다.
Swift
Objective-C
NSString *modelPath = [NSBundle.mainBundle pathForResource:@"your_model"
                                                    ofType:@"tflite"
                                               inDirectory:@"your_model_directory"];
FIRCustomLocalModel *localModel =
    [[FIRCustomLocalModel alloc] initWithModelPath:modelPath];

6.	윈도우 VirtualBox에서 macOS Sierra 설치하기(아래와 같이 진행해서 성공적으로 macOS를 설치 함)
1)	https://www.geekrar.com/download-macos-high-sierra-iso-for-vmware-virtualbox/ 사이트에서
	macOS High Sierra Final ISO by Geekrar (One Full —  Google Drive) 파일을 다운로드 받아서
	VirtualBox 광학디스크로 추가해 준다.
	cf, Mac App Store 파일을 다운로드 받은 것을 사용하면 '설치 응용프로그램의 복사본이 손상되었기 때문에 macOS 를 설치하는데 사용할 수 없습니다.' 에러가
		무조건 발생하며 별별 방법을 다 사용해도 본 에러를 제거할 수 없음
		cf)	별별 방법 들
			'설치 응용프로그램의 복사본이 손상되었기 때문에 macOS 를 설치하는데 사용할 수 없습니다.' 에러 발생 시
			macOS Sierra 설치 화면 -> 유틸리티 -> 터미널 에서 하단 명령 실행시켜 날짜를 과거 시점으로 변경
			date 010312012012

			cf)	sudo spctl --master-disable
				or spctl --master-disable

				정상적으로 설치 이후 아래 명령을 실행 다시 보안을 강화시킴

				sudo spctl --master-enable
				or spctl --master-enable

2)	아래 명령을 윈도우 명령프롬프트(관리자권한)에서 실행시켜야지만 macOS 설치 시 무한반복되는 에러가 없어짐
Virtualbox 5.x.x 버전인 경우
가)	
cd "C:\Program Files\Oracle\Virtualbox"

나)	
VBoxManage.exe modifyvm "macOS 10.13 High Sierra (64-bit)" --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" "VBoxInternal/Devices/efi/0/Config/DmiSystemProduct" "iMac11,3"
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" "VBoxInternal/Devices/efi/0/Config/DmiSystemVersion" "1.0"
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" "VBoxInternal/Devices/efi/0/Config/DmiBoardProduct" "Iloveapple"
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" "VBoxInternal/Devices/smc/0/Config/DeviceKey" "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc"
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" "VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC" 1

cf)
VBoxManage.exe modifyvm "macOS 10.15 Catalina (64-bit)" --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff 
VBoxManage setextradata "macOS 10.15 Catalina (64-bit)" "VBoxInternal/Devices/efi/0/Config/DmiSystemProduct" "iMac11,3" 
VBoxManage setextradata "macOS 10.15 Catalina (64-bit)" "VBoxInternal/Devices/efi/0/Config/DmiSystemVersion" "1.0" 
VBoxManage setextradata "macOS 10.15 Catalina (64-bit)" "VBoxInternal/Devices/efi/0/Config/DmiBoardProduct" "Iloveapple" 
VBoxManage setextradata "macOS 10.15 Catalina (64-bit)" "VBoxInternal/Devices/smc/0/Config/DeviceKey" "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc" 
VBoxManage setextradata "macOS 10.15 Catalina (64-bit)" "VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC" 1
출처: https://jeongchul.tistory.com/635 [Jeongchul]

cf)
VBoxManage.exe modifyvm "가상머신이름" --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff
VBoxManage setextradata "가상머신이름" "VBoxInternal/Devices/efi/0/Config/DmiSystemProduct" "iMac11,3"
VBoxManage setextradata "가상머신이름" "VBoxInternal/Devices/efi/0/Config/DmiSystemVersion" "1.0"
VBoxManage setextradata "가상머신이름" "VBoxInternal/Devices/efi/0/Config/DmiBoardProduct" "Iloveapple"
VBoxManage setextradata "가상머신이름" "VBoxInternal/Devices/smc/0/Config/DeviceKey" "ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc"
VBoxManage setextradata "가상머신이름" "VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC" 1

다)
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" VBoxInternal2/EfiGopMode 5
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" VBoxInternal2/EfiGopMode 1920x1080
VBoxManage setextradata "macOS 10.13 High Sierra (64-bit)" VBoxInternal2/EfiGraphicsResolution 1920x1080		-> 본 명령만 제대로 동작 함
VBoxManage setextradata "macOS 10.15 Catalina (64-bit)" VBoxInternal2/EfiGraphicsResolution 1920x1080

cf)
•0 : 640×480
•1 : 800×600
•2 : 1024×768
•3 : 1280×1024
•4 : 1440×900
•5 : 1900×1200
VBoxManage setextradata "가상머신이름" VBoxInternal2/EfiGopMode N

라)	macOS Sierra 설치 -> macOS Utilities 화면에서 -> Disk Utility 선택하고
	a)	View -> Show All Devices 선택해서
	b)	VBOX HARDDISK Media가 보이도록 한 다음
	c)	VBOX HARDDISK Media 선택하고 Erase 버튼 누름
	d)	Name : macOS 10.13 High Sierra (64-bit) 입력하고(cf, 가상머신이름)
		Erase 실행 시킴

마)	Disk Utility 에서 빠져나온 다음 Install macOS 선택해서 설치를 계속 진행 함


[108]	Web 프로그램
1.	TTS(Text To Speech with Google Drive)
		http://drivetts.ehubsoft.net/


[109]	일러스트레이터

-1.
클립아트코리아 ID/PW
아이디 : nemoin
패스워드 : spahdls1104! (한글로 네모인)

샘플인쇄시에는 상관없지만 프린팅라이센스는 없어서 최종패턴이나 상용화 이전에는 원본그대로 사용하시지 마시고 수정해서 사용하세요

0.	선택된 항목 중 일부 항목 제외 : Shift+Alt
1.	이미지자르기
		1)	자르고 싶은 이미지에 사각형상자등으로 도형을 만든다음
		2)	사각형상자와 자르고 싶은 대상을 모두 선택하고서
				오른쪽마우스버튼 -> 클리핑 마스크 만들기 선택하면 
				cf)	오른쪽마우스버튼 눌렀을 때 "클리핑 마스크 만들기" 가 보이지 않는다면
						가)	Layer에서 Path를 자르고 싶은 이미지보다 위에 위치시키고
						나)	"Ungroup"을 눌러서 Group을 풀면 "클리핑 마스크 만들기"가 보이게 됨
		3)	해당이미지가 사각형상자 모양으로 잘려짐
				이때, 해당이미자가 Clipping Path속성으로 합쳐져서 자른이미지로 보이는 것이며
				Layer속성 중에서 Clipping Path속성을 해제하면 원래 자르기 전 이미지로 보여지게 됨
2.	일러스트레이터, Guilloche(길로쉐) pattern plug-in
		https://www.youtube.com/watch?v=OhLIWWBaymA
		1)	Spiral Tool로 도형 만들고
				만든 도형을 복사 -> 대칭시켜서 -> 붙여넣음
		2)	복사된 두 도형을 모두 선택하고
		3)	Effect -> Distort & Transform -> Transform Effect 선택하고
				가)	[v] Preview
				나)	[] [] []
						[] [] []
						[] [v] []
				다)	[v] Scale Strokes & Effects
						[v] Transform Objects
						[v] Transform Patterns
				라) Scale -> Horizontal : 80%
						Scale -> Vertical : 80%
				마)	Copies : 100
				바) OK
3.	그림이미지 -> 벡터이미지로 변경
		1)	그림이미지 선택
		2)	Object -> Image trace(Windows -> Image trace 선택)
				-> Mode : Black and White, Threshold로 적당한 범위 선택
				-> Expand 아이콘 눌러서 최종 완료
4.	특정색상 변경
		1)	전체영역 모든 동일 색상 변경
				가)	특정색상 이미지 일부 선택
				나)	Select -> Same -> Fill Color 로 모두 선택
				다)	Eyedropper -> 원하는 색상 선택
		2)	일부영역 모든 동일 색상 변경
				가)	특정색상 이미지 전체 선택
						(Layer -> 해당 Group 메뉴 -> 맨 오른쪽 동그라미 마우스로 눌러
							이중 동그라미로 변경되도록 함)
				나)	전체 선택된 이미지 -> 마우스 오른쪽 버튼 누름
						-> 	Isolated Selected Group 누름 -> 해당 영역만 선택됨
				다)	특정색상 이미지 일부 선택
				라)	Select -> Same -> Fill Color 로 모두 선택
				마)	Eyedropper -> 원하는 색상 선택
				바)	색상이 변경되었으면
						최상단 영점조절 바로 옆에 새로 생성된 아이콘 중 -> '<-'버튼을 계속 눌러서 빠져나옴
5.	파일 사이즈 줄이는 방법
	1)	이미지파일 등을 붙여 넣으면 원본사이즈를 줄여서 저장해도 일러스트파일에서 줄이기 전 원본사이즈를 그대로 저장하기 때문에 파일 사이즈가 상당히 많이 증가 함
	2)	이에 이를 제거하려면 하기와 같이 Rasterize를 실행하면 됨
		이미지파일 -> Object -> Rasterize -> Resolution : Other : 1000 ppi (해상도를 올려야지만 이미지가 깨지지 않으면서 파일 용량 줄일 수 있음)
		-> Background White/Transparent -> OK


[110]	딥러닝/머신러닝
1-3.딥러닝 종류
2013년 즈음부터 현재까지 가장 주목받고 있는 머신러닝 알고리즘이다.
아래 '종류'라는 건 한 프로그램에 하나만 쓰이는 것이 아니다. 가령 이미지 처리와 언어 처리를 동시에 하기 위해 CNN과 RNN을 동시에 사용할 수도 있다.

1.1.Perceptron
	Perceptron은 위에서 설명한 뉴런의 수학적 모델을 일컫는 용어이기도 하고, 최초로 제안된 신경망 프로그램 알고리즘 (1957)이기도 하다. 
	이 알고리즘은 이름 그대로 하나의 뉴런을 사용하며 학습 데이터를 가장 잘 설명할 수 있는 최적의 패러미터( w,bw, bw,b )값을 찾는다.
	학습은 학습 데이터를 넣은 후 결과가 원하던 결과보다 크면 결과가 작아지게 패러미터를 조정하고 원하던 결과보다 작으면 커지게 
	패러미터를 조정하는 것을 반복한다. 이것으로 학습이 가능하다는 것은 ?perceptron convergence theorem이란 이름으로 증명이 되어 있다.
	그러나 비선형함수를 학습할 수 없기에 이 방법이 사장됐다. 입력층과 출력층만 있는 퍼셉트론으로는 XOR 문제도 해결할 수 없다. 
	그 결과 MLP가 나오게 된다.
1.1.1.Multi Layer Perceptron (MLP)
	말그대로 여러개의 Perceptron을 연결시켜 층(Layer)을 만들고, 이 층들을 중첩시켜 다층 (Multi Layer)으로 만든 것이다.
	여러개의 Perceptron이 하나의 층(Layer)을 구성하며, 일반적으로 3~6개 정도의 층을 두며, 
	이들을 각각 입력층(Input layer), 은닉층(Hidden layer), 출력층(Output layer) 으로 구분하여 부른다. 
	필요이상으로 많은 층을 두는 것은 오히려 성능이 떨어진다고 알려져있다. 
	처음에는 중간에 존재하는 은닉층을 학습시킬 방법이 없기에 사장되었지만, 해결할 방법을 꾸준히 연구한 결과 
	역전파(backpropagation) 알고리즘 (1986)이 발명되어 사용할 수 있게 되었다. 신경망계통 알고리즘답게 초창기에 반짝하며 
	신드롬을 일으킬정도로 관심을 받았다. 그러나 사라지는 경사 문제 [2], 과적합 문제 등이 있었고 
	당시 연산능력의 한계가 심했기 때문에 금새 사장되고 만다.

1.2.심층학습(Deep Learning)
1.2.1. Convolutional Neural Network
	1989년 인간의 시신경 구조를 모방해 만들어진 인공신경망 알고리즘. 
	다수의 Convolutional Layer(이떄의 작은 행렬을 필터라 부른다)으로 부터 특징맵(Feature map)을 추출하고 
	서브샘플링(Subsampling)을 통해 차원을 축소하여 이미지를 단순화 시킨 후 마지막 레이어에 완전 연결 계층 (Fully connected Layer)으로
	이전 레이어의 처리결과를 연결하여 이미지를 분류한다. 이미지 분류에 유용하며, 이미지 외에도 사용할 수 있다.
1.2.2. Recurrent Neural Network
	뉴런의 출력이 다시 입력으로 feedback되는 재귀적인 연결 구조를 갖는 신경망. 
	다층 퍼셉트론 신경망은 입력이 출력 방향으로만 활성화되고 은닉 뉴런이 과거의 정보를 기억하지 못한다는 단점이 있다. 
	이러면 입력이 들어온 문맥을 기억할 수 없다. 이런 단점은 시계열분석[3] 관련 문제에서 매우 해롭다. RNN은 이런 단점을 해결했다. 
	앞에서 무슨 단어가 나왔는지의 문맥이 다음에 나올 단어를 예측(prediction)하는 문제를 푸는 데 유용하다. 
	이런 문제에는 음성 인식, 필기체 인식, 텍스처 인식이 있다. 또 분류에도 유용하다. 
	언어 모델은 말뭉치를 이용한 기계 번역에 도움이 되었다.

	기존의 DNN(Deep Neural Networks)의 경우 각 layer마다 parameter들이 독립적이었으나, 
	RNN은 이를 공유하고 있다. 따라서 현재의 출력 결과는 이전 time step의 결과에 영향을 받으며, 
	hidden layer는 일종의 메모리 역할을 하게 된다.

	RNN의 기본적 작동원리는 ht = g1 ( xtU + Wh(t-1) + bx), ot = g2 (Vh(t)+bh) 이다. 
	g1 g2 : 비선형 활성화 함수 (Sigmoid, tanh 등)
	xt: 입력값
	ht: t(시간)단계의 은닉변수 (hidden state)
	ot: t(시간)단계의 출력값 
	b: 편향 (bias) 
	UVW: xt ht ht-1의 가중치 (weight)
	위 식에서 입력 X = (x1 , x2 , x3 , ... , xn)이 입력되면 ot가 출력된다.

	변종으로 Bi-directional RNN이 있다. 이 모델은 과거 및 미래 상태도 반영한다. 언어 모델링을 할 때 앞뒤 단어를 모두 고려하게 되므로 
	정확성이 높아진다. 하지만 학습이 오랫동안 진행지면서 초기 학습이 잊혀질 단점이 있다.
	하지만 전통적인 RNN 모형 및 Bi-directional RNN의 경우 Vanishing gradient problem을 지닌다. [4]
	이 해결책으로 제시되고 있는 것이 다음 알고리즘들이다.
	-	LSTM
	-	elman NN: RNN에 context layer가 추가되어 있어 vanishing gradient problem을 어느 정도 해결했다. 
		context layer는 hidden layer에서 나온 결과 중 기억하고 싶은 부분을 저장해 두었다가 필요할 때 꺼내올 수 있는 피드백 신호 역할을 한다.
1.2.2.1. Long Short Term Memory
	1997년 나온 RNN의 개선판. 학습이 오래 지속될 경우 초기 학습한 내용이 잊혀진다는 단점이 있는데 
	이를 개선한 architecture이다. RNN의 입력, forget, 출력 부분에 Gate라는 셀들을 붙여 값을 조절한다. 
	Forget gate는 이전 상태 정보를 저장할지를 결정하고, input gate는 입력되는 새로운 정보를 저장할지 결정하고, output gate는 갱신된 cell의 출력값을 제어한다.

	망각 게이트 (forget gate)는 기존의 소자변수를 얼마나 잊어버릴지 결정한다. ft = σ (Uf xt + Wf ht-1 + bf)이다.
	Uf xt + Wf ht-1 + bf는 xt, ht-1 , b의 가중합이다. ft는 이 가중합에 sigmoid함수(σ)를 씌운 것이다. 
	1은 모두 기억하겠다는 뜻이고 0은 모두 잊어버린다는 뜻이다.

1.5. 혼합모델
1.5.1. 오토인코더
자기부호화기 (Autoencoder)
이미지 같은 복잡한 데이터는 높은 차원에 존재한다. 복잡한 데이터를 저차원으로 표현하면 처리가 간단해질 수 있다. 
이 때문에 데이터의 차원을 축소하려는 노력들이 있어 왔다. 그 예로 Singular Value Decomposition (SVD) 혹은 주성분 분석 (PCA)이 있다. 
RNN 역시 시계열 데이터를 직접적으로 이용하는 것이 아니라 은닉 상태를 추론하여 문제를 풀어 나간다. 이렇게 차원을 축소하면 분류도 쉬워진다.

정보를 압축하는 인코더와 압축된 정보를 바탕으로 데이터를 복원하는 디코더를 만들 수 있다. 
오토인코더는 데이터의 효율적인 인코딩을 찾는 방법이다.[5] 인공신경망에서 입력 레이어의 뉴런과 출력 레이어의 뉴런을 같은 개수로 두고, 
입력과 출력이 같은 값이 되게끔 신경망을 학습시키게 된다. 이렇게 하고 은닉층에 있는 뉴런의 개수를 입력층의 뉴런의 개수보다 적게 하여 신경망을 구성하면, 
입력층에서 은닉층으로 가는 과정은 인코딩 과정이 되고, 은닉층에서 출력층으로 가는 과정은 디코딩 과정이 된다. 이 때 은닉층의 각 뉴런의 활성화 정도는 
입력 데이터의 새로운 코드가 된다. 선형 뉴런을 사용하면 오토인코더의 결과는 PCA와 거의 유사한 결과를 갖게 된다. 
따라서 선형 뉴런 대신 시그모이드 뉴런을 사용함으로써 비선형적인 코딩을 얻을 수 있게 된다. 

오토인코더를 한 번 사용하여 데이터를 한 번에 인코딩하는 방법으로 신경망을 구성할 수도 있지만, 
뉴런의 개수가 크게 줄어들게 되면 신경망의 학습이 이루어지기 어렵고, 신경망의 표현 능력도 떨어지게 된다. 
신경망의 표현 능력을 향상시키기 위하여 오토인코더를 쌓아 올리게 되는데 각각의 오토인코더는 입력 데이터를 표현할 수 있는 조금 더 좋은 코드를 찾게 되고 
최상위 오토인코더는 매우 적은 수의 코드로 처음 주어진 입력값을 표현할 수 있게 된다.

단, 쌓아 올린 오토인코더는 일반적인 역전파(back propagation) 방법으로는 학습이 잘 되지 않는데 이를 극복하기 위해서 
RBM(Restricted Boltzmann Machine)을 이용해 오토인코더를 미리 학습시키고, 미리 학습된 결과를 초기 추측으로 사용하여 역전파 방법으로 튜닝하면 쌓아 올린 
오토인코더를 제대로 학습할 수 있게 된다.

반대로, 오토인코더의 디코더를 이용하면 축소된 공간에서 임의의 점에 해당하는 가상의 데이터를 원공간에서 생성해낼 수 있다. 
결함 데이터가 일반적으로 부족한 고장진단 분야의 경우 (데이터 불평형 문제), 축소된 공간에서의 고장분포를 파악하여 이에 해당하는 다양한 
고장데이터를 가상으로 생성할 때 사용할 수 있다. 이밖에도 정보를 압축하고 복원하는 구조로 Convolutional layer 를 통한 오토인코더 방법
(Convolutional Autoencoder), 베이지안적 사고를 바탕으로 신경망을 최적화시키는 방법 (Variational Autoencoder) 등이 제안되었다.

구체적인 방법은 다음과 같다. 입력 값 x가 주어지면 인코더를 통해 압축된 데이터 y로 변환하고 디코더를 통해 압축된 데이터 y를 z로 풀어낸다.
y = fθ(x) = s (Wx+b) 
z = gθ(y) = s (W'y + b')

1.5.2. GAN
generative adversarial networks
2014.6 제안된 방식. 
Classification (분류) 문제는 접근법을 discriminative 모델과 generative model로 나눌 수 있다.
-	discriminative model (지도학습의 일종): 입력 x에서 출력 y로 가는 관계인 조건부확률 p(y|x)를 추정하려고 시도한다. 
	클래스를 분류하려 한다. 다중 회귀분석, 나이브 베이지안 분류기 등.
-	generative model (비지도학습의 일종): p (x,y)을 추정하려고 한다. 
	분류 경계선 (decision boundary)을 만들려고 한다. 우도 (likelihood)나 사후확률 (posterior probability)를 사용한다. 밀도 기반 추정법들.

GAN은 두 모형을 함께 사용하고 서로 경쟁시킴으로써 정확도를 향상시키고자 한다.

위 식에서 G는 생성 모델, D는 분류 모델을 가리킨다. 좌변은 생성자가 구분자의 정확도를 최소화시키면서 구분자는 자신의 정확도를 최대화시키는 
minimax 최적화 문제를 의미한다. 이 값은 0~1로 주어진다.

우변은 두 개의 항으로 나뉘어 있는데 이는 정보이론 (수학)에서 엔트로피를 최소화하는 것과 같다.
[6] 우변 첫번째 항인 E x~Pdata(x) (log D(x))은 실제 데이터 x를 입력받았을 때 올바르게 '실제데이터'(D=1)라고 판단할 경우 최대화된다. 
우변 두번째 항인 Ez~Pz(z) (log (1-D(G(z)))은 가상데이터 (z)를 입력받았을 때 올바르게 '가상데이터' (D=0)라는 것을 구분할 경우 최대화된다. 
생성자는 그럴듯한 가상 데이터를 생성함으로써 두 번째 항을 최소화시키려고 노력한다.

오토인코더에는 단순히 데이터를 생성한다는 개념만 있었다. 하지만 GAN에는 경쟁이라는 요소가 들어간다. GAN이 오토인코더에 비해 양질의 데이터를 생성할 수 있다.

GAN에도 단점이 있다. 생성자가 그럴듯한 가상 데이터를 학습 초반부터 생성하기 힘들기 때문에 모델이 학습되지 않는 현상이 발생한다. 
그리고 오토인코더가 주어진 데이터의 잠재 변수 (latent variable)를 추론할 수 있는 데 비해 GAN은 차원 축소의 개념이 존재하지 않는다. 

1.5.2.1. DCGAN
위에서 설명한 딥 CNN과 GAN을 통합한 개념. 

각 레이어에 Convolution layer를 사용한다. 단, CNN과 달리 Pooling layer, Fully connected layer는 사용하지 않는다. 
레이어 계산 결과에 Batch Normalization를 사용한다. 활성 함수(Activation function)으로 ReLU 대신 LeakyReLU를 사용한다.

Generator는 랜덤 입력 ‘z’가 의미있는 잠재 특징 (latent feature)이 되도록 학습한다. 이 랜덤 입력의 의미가 무엇인지 우리는 알 수 없다. 


1-2.딥러닝 명령
1)	relu(Rectified Linear Unit의 줄임말)
		0보다 작으면 비활성화시키고 0보다 클 때 그 값에 비례한 값을 내놓는 것이다.
		ReLU의 구현도 max(0, x)의 형식으로 간단하게 쓸 수 있다.
		cf)	시그모이드 함수는 입력값이 무엇이 주어지든 결과가 1보다 작은 양수가 나오므로 곱해지면서 점점 0으로 더 가까이 간다는 
				문제점이 있었다. 그래서 1보다 작아지지 않게 하려고 만든 것이 ReLU 함수임

1)	relu
		0보다 크면 그 값을 그대로 쓰고 0보다 작으면 0을 사용하는 활성화 함수.
		max(0,x) 입력이 음수인 경우 계속 0이 되어 dying Relu 가 발생한다.

2)	softmax
		주로 output을 0~1 사이 값으로 정규화하여 주로 확률값으로 나타내는 경우에 사용하는 활성화 함수.
		1) 입력을 0에서 1사이의 값으로 변환
		2) 변환된 결과에 대해 합계가 1이 되도록 만들어 줌

3)	def conv2d(inputs,
                filters,
                kernel_size,
                strides=(1, 1),
                padding='valid',
                data_format='channels_last',
                dilation_rate=(1, 1),
                activation=None,
                use_bias=True,
                kernel_initializer=None,
                bias_initializer=init_ops.zeros_initializer(),
                kernel_regularizer=None,
                bias_regularizer=None,
                activity_regularizer=None,
                kernel_constraint=None,
                bias_constraint=None,
                trainable=True,
                name=None,
                reuse=None):
		ex) net = tf.layers.conv2d(X, 20, 3, (2, 2), padding='same', activation=tf.nn.relu)
				- X이미지를 입력으로 받음
				- 크기가 3x3(3번째인자 3) 커널로 구성된 필터가 20개이며, 가로/세로 2칸씩 이동하면서(4번째인자 (2, 2)) convolution 연산을 수행

		# Conv2D(1, (2, 2), padding='valid', input_shape=(3, 3, 1))
		# - 입력이미지는 채널 수가 1, 너비가 3pixels, 높이가 3pixels 임
		# - 크기가 2x2 커널로 구성된 필터가 1개인 경우


1-1.딥러닝 실행 시 에러 수정 방법
1)	Cannot import scipy.misc.imread 에러 발생 시
		pip install scipy==1.1.0 				# scipy version 문제로 발생하는 에러로 보이며 본 명령 실행하면 문제 해결 됨
2)	ValueError: Object arrays cannot be loaded when allow_pickle=False  에러 발생 시
		pip install numpy==1.16.1
3)	파이썬 텐서플로의 No module named 'tensorflow.examples.tutorials' 오류 해결하는 방법
		가)	C:\Users\user\AppData\Local\Programs\Python\Python37\Lib\site-packages\tensorflow_core\examples 폴더 내부에
				tutorials 폴더가 존재하지 않는 다면
		나)	https://github.com/tensorflow/tensorflow 접속 -> Clone or download -> Download ZIP 으로 압축되어 있는 tensorflow 관련 자료를 다운 받고 압축을 풀어
		다)	~\tensorflow-master\tensorflow-master\tensorflow\examples 폴더 내부에 있는 tutorials 폴더를
				C:\Users\user\AppData\Local\Programs\Python\Python37\Lib\site-packages\tensorflow_core\examples 폴더에 복사 시킴
4)	module 'tensorflow' has no attribute 'logging' 에러 발생 시
		가)	#tf.logging.set_verbosity(tf.logging.ERROR)
				# fix, tensorflow 2.0
				tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
				# fix
		나)	pip install tensorflow==1.13.1 실행시킴
5)	module 'tensorflow' has no attribute 'placeholder' 에러 발생 시
		pip install tensorflow==1.13.1 실행시킴
6)	>>> import tensorflow as tf
		.......................................................
		ImportError: DLL load failed: 지정된 모듈을 찾을 수 없습니다. 에러 발생 시
		가)	pip uninstall tensorflow
				pip uninstall tensorflow-gpu
		나)	pip install tensorflow==1.13.1		
7)	prob is not in graph




	
1.	딥러닝 예제를 정상적으로 쉽게 실행시키기 위한 개발환경
	1)	OpenCV 4.0.1			cf)	하위버전 설치하면 제대로 딥러닝 프로그램 구현 안됨
	2)	Python 3.7.4
	3)	tensorflow 1.13.1 		cf)	pip install tensorflow==1.13.1 or pip install --upgrade --force-reinstall tensorflow-gpu==1.13.1
		상기 tensorflow 1.13.1로 제대로 인스톨 되었는지 확인 방법
		가)	cmd
		나)	python
		다)	import tensorflow as tf
		라)	sess=tf.Session()		->	본 명령 실행 시 제대로 동작하면 제대로 tensorflow 1.13.1이 설치된 것임

1+1.패키지 설치
	pip install 패키지명
	패키지 삭제
	pip uninstall 패키지명
	
	cf) python 환경에서 opencv 구동을 위한 프로그램 설치(실제 테스트 결과 정상적으로 동작함)
	pip install "numpy-1.15.4+mkl-cp37-cp37m-win_amd64.whl"
	pip install matplotlib-3.0.2-cp37-cp37m-win_amd64.whl
	pip install opencv-python
	pip install tensorflow==1.13.1          // pip install tensorflow 을 실행하면 tensorflow-2.0.1이 설치되며
	                                        // 이경우 버전이 높아 많은 에러가 발생하며, 이에 이와같이 1.13.1버전으로 downgrade시켜 설치시켜야 함
	pip install jupyter
	pip install opencv-contrib-python

	cf)	tensorflow 버전 확인
			$ python			
			> import tensorflow as tf			
			> tf.__version__			
			'1.13.1'

	cf)	tensorflow 업데이트
			//cpu 버전 update 방법
			pip install --upgrade tensorflow
			//gpu 버전 update 방법
			pip install --upgrade tensorflow-gpu

	cf)	tensorflow uninstall
			- CPU의 경우: pip uninstall tensorflow
			- GPU의 경우: pip uninstall tensorflow-gpu

	cf)	CUDA toolkit 설치 실패
			Visual Studio Integration 설치 중...
     	예외 unknown software exception (0xc002000a)이(가) ~ 이라는 에러발생하면 아래와 같이 설치 함
			->	설치 -> 설치옵션 -> 사용자 정의 설치 -> []Visual Studio Integration 선택 제외 -> 다음

	cf)	윈도우 NVIDIA CUDA 설치하기
			CUDA Toolkit 과 cuDNN SDK 설치 
			
			https://www.tensorflow.org/install/gpu 
			에서 보면 소프트웨어 요구사항 항목에서  
			
			CUDA Toolkit 다운로드 경로 
			https://developer.nvidia.com/cuda-toolkit-archive 
			
			cuDNN SDK 다운경로 경로 
			회원가입후 사용가능 
			https://developer.nvidia.com/rdp/cudnn-download 
			
			CUDA Toolkit 와 cuDNN SDK 는 버전에 맞게 다운 받아준다. 
			예)  
			CUDA Toolkit 10.1 
			Download cuDNN v7.6.2 (July 22, 2019), for CUDA 10.1 
			
			설치순서 
			1. CUDA Toolkit 설치 
			설치위치 기억하고 있음 
			예)  
			C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.1 
			
			2. cuDNN SDK 압축을 풀면  
			bin, include, lib 폴더가 있음
			이를, 상기 CUDA Toolkit이 설치된 폴더 위치에다가 덮어씌움 
						
			확인방법  
			anaconda env 생성  			
			conda create -n env이름 python=3.7 			
			activate env이름 			

			pip install tensorflow-gpu 
		
			python
			import tensorflow as tf 
			a=tf.constant(3) 
			sess = tf.Session() 
			으로 확인 

	cf)	tensorflow-gpu / cuDNN 으로 구동 시 'failed to create cublas handle: CUBLAS_STATUS_ALLOC_FAILED' 에러 발생 해결 방법
			포토샵등을 구동중에 있으면 포토샵을 끄면 본 에러 없어짐

	cf)	Tensorflow 관련 버전 문제
		UserWarning: h5py is running against HDF5 1.10.5 when it was built against 1.10.4
		위와 같은 에러가 발생하신다면 Terminal 창을 열어서

		Pip uninstall h5py && Pip install h5py
		위의 명령어를 통해 h5py 라이브러리를 재설치 해주시기 바랍니다.

		ImportError: Keras requires TensorFlow 2.2 or higher. Install TensorFlow via pip install tensorflow
		위와 같은 에러가 발생하신다면 Terminal 창을 열어서

		pip uninstall tensorflow && pip install tensorflow==2.3.0
		위의 명령어를 통해 tensorflow 라이브러리를 재설치 해주시기 바랍니다.

		AttributeError: module 'tensorflow.python.framework.ops' has no attribute '_TensorLike'
		위와 같은 에러가 발생하신다면 Terminal 창을 열어서

		pip show keras 명령어를 통해 keras 라이브러리의 버전을 확인한 후 아래와 같이 version 2.4.3 이하일 경우

		Name: Keras
		Version: 2.3.1
		Summary: Deep Learning for humans
		Home-page: https://github.com/keras-team/keras
		Author: Francois Chollet
		Author-email: francois.chollet@gmail.com
		License: MIT
		Location: c:\users\timepercent\anaconda3\envs\py37_64\lib\site-packages
		Requires: pyyaml, numpy, h5py, scipy, keras-preprocessing, six, keras-applications
		Required-by:
		pip uninstall keras && pip install keras==2.4.3
		위의 명령어를 통해 keras 라이브러리를 재설치 해주시기 바랍니다.

2.	Visual studio code 상에서 python 명령어 Debug(Start Debugging) 실행시 파일 path를 찾지 못해서 발생하는 에러 해결 방법
	ex) OSError: ./data.csv not found. 에러 발생하는 경우 해결 방법
	1)	launch.json 파일에 "cwd": "${fileDirname}", 명령 추가 시킴
		.vscode\launch.json
		{
		    // Use IntelliSense to learn about possible attributes.
		    // Hover to view descriptions of existing attributes.
		    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
		    "version": "0.2.0",
		    "configurations": [
		
		        {
		            "name": "Python: Current File",
		            "type": "python",
		            "request": "launch",
		            "program": "${file}",
		            "cwd": "${fileDirname}",
		            "console": "integratedTerminal"
		        }
		    ]
		}

	2)	Visual studio code 한글 깨짐 해결
		가)	우측/맨하단 -> "UTF-8" 누름 -> 인코딩하여 다시 열기 -> Korean(EUC-KR) 선택
	
	3)	Visual studio code, 문자 선택 & Highlight 색상 변경 방법
		가)	Visual studio code, settings.json 파일에 하기 사항 추가
				cf)	Visual studio code, settings.json 파일 위치
						C:\Users\user\AppData\Roaming\Code\User\settings.json
				{
				    "C_Cpp.updateChannel": "Insiders",
				    "files.autoGuessEncoding": true,
				    "files.autoSave": "afterDelay",
				    "color-highlight.matchWords": true,
				    // add
				    "workbench.colorCustomizations": {
				        "editor.selectionBackground": "#f00", // red color hexadecimal code
				//        "editor.selectionHighlightBackground": "#fff" // white hex code
				        "editor.selectionHighlightBackground": "#00f" // blue hex code
				    },
				    // add
				}

3.	케라스
https://tensorflow.blog/%EC%BC%80%EB%9D%BC%EC%8A%A4-%EB%94%A5%EB%9F%AC%EB%8B%9D/3-2-%EC%BC%80%EB%9D%BC%EC%8A%A4-%EC%86%8C%EA%B0%9C/

3-1.케라스 소개
이 책에서는 코드 예제를 위해 케라스(https://keras.io)7를 사용합니다. 케라스는 거의 모든 종류의 딥러닝 모델을 간편하게 만들고 훈련시킬 수 있는 파이썬을 위한 
딥러닝 프레임워크입니다. 처음에 케라스는 신속하게 실험을 해야 하는 연구자들을 위해 개발되었습니다.

케라스의 특징은 다음과 같습니다.
-	동일한 코드로 CPU와 GPU에서 실행할 수 있습니다.
-	사용하기 쉬운 API를 가지고 있어 딥러닝 모델의 프로토타입을 빠르게 만들 수 있습니다.
-	(컴퓨터 비전을 위한) 합성곱 신경망, (시퀀스 처리를 위한) 순환 신경망을 지원하며 이 둘을 자유롭게 조합하여 사용할 수 있습니다.
-	다중 입력이나 다중 출력 모델, 층의 공유, 모델 공유 등 어떤 네트워크 구조도 만들 수 있습니다. 
	이 말은 적대적 생성 신경망Generative Adversarial Network, GAN부터 뉴럴 튜링 머신Neural Turing Machine까지 케라스는 기본적으로 어떤 딥러닝 모델에도 적합하다는 뜻입니다.

케라스는 MIT 라이선스를 따르므로 상업적인 프로젝트에도 자유롭게 사용할 수 있습니다. ( 2018년 중반 현재) 파이썬 2.7에서 3.6까지의 어떤 버전과도 호환됩니다.
학술적인 연구원이나 스타���업과 대기업의 기술자에서 대학���생과 아마추어 연구자까지 20만 명의 사람들이 케라스를 사용합니다. 
구글, 넷플릭스Netflix, 우버Uber, 썬CERN, 옐프Yelp, 스퀘어Square 그리고 다양한 분야의 스타트업 수백 개가 케라스를 사용합니다. 
머신 러닝 경연 웹 사이트인 캐글Kaggle에서도 케라스의 인기가 높습니다. 최근에 거의 모든 딥러닝 경연 대회의 우승자들이 케라스 모델을 사용하고 있습니다.

3.2.1 케라스, 텐서플로, 씨아노, CNTK
케라스는 딥러닝 모델을 만들기 위한 고수준의 구성 요소를 제공하는 모델 수준의 라이브러리입니다. 
텐서 조작이나 미분 같은 저수준의 연산을 다루지 않습니다. 그 대신 케라스의 백엔드 엔진backend engine에서 제공하는 최적화되고 특화된 
텐서 라이브러리를 사용합니다. 케라스는 하나의 텐서 라이브러리에 국한하여 구현되어 있지 않고 모듈 구조로 구성되어 있습니다(그림 3?3 참고).
여러 가지 백엔드 엔진이 케라스와 매끄럽게 연동됩니다. 현재는 텐서플로, 씨아노, 마이크로소프트 코그니티브 툴킷Microsoft Cognitive Toolkit, CNTK 3개를
백엔드 엔진으로 사용할 수 있습니다. 향후에는 더 많은 딥러닝 엔진을 케라스에서 사용할 수 있을 것입니다.

텐서플로, CNTK, 씨아노는 딥러닝을 위한 주요 플랫폼 중 하나입니다. 
씨아노(http://deeplearning.net/software/theano)는 몬트리올 대학 MILA 연구소에서 개발했고
텐서플로(https://www.tensorflow.org)는 구글에서 개발했으며,
CNTK(http://github.com/Microsoft/CNTK)는 마이크로소프트에서 개발했습니다. 
케라스로 작성한 모든 코드는 아무런 변경 없이 이런 백엔드 중 하나를 선택해서 실행시킬 수 있습니다. 
개발하는 중간에 하나의 백엔드가 특정 작업에 더 빠르다고 판단되면 언제든지 백엔드를 바꿀 수 있어 아주 유용합니다. 
가장 널리 사용되고 확장성이 뛰어나며 상용 제품에 쓸 수 있기 때문에 대부분의 딥러닝 작업에 텐서플로 백엔드가 기본으로 권장됩니다.

텐서플로(또는 씨아노나 CNTK)를 사용하기 때문에 케라스는 CPU와 GPU에서 모두 작동할 수 있습니다. 
CPU에서 실행될 때 텐서플로는 Eigen(http://eigen.tuxfamily.org)이라고 불리는 저수준 텐서 연산 라이브러리를 이용합니다. 
GPU에서는 NVIDIA CUDA 심층 신경망 라이브러리cuDNN라고 불리는 고도로 최적화된 딥러닝 연산 라이브러리를 이용합니다.

3.2.2 케라스를 사용한 개발: 빠르게 둘러보기
이미 케라스 모델의 예로 MNIST 예제를 보았습니다. 전형적인 케라스 작업 흐름은 이 예제와 비슷합니다.
1.입력 텐서와 타깃 텐서로 이루어진 훈련 데이터를 정의합니다.
2.입력과 타깃을 매핑하는 층으로 이루어진 네트워크(또는 모델)를 정의합니다.
3.손실 함수, 옵티마이저, 모니터링하기 위한 측정 지표를 선택하여 학습 과정을 설정합니다.
4.훈련 데이터에 대해 모델의 fit() 메서드를 반복적으로 호출합니다.

모델을 정의하는 방법은 두 가지인데, Sequential 클래스(가장 자주 사용하는 구조인 층을 순서대로 쌓아 올린 네트워크입니다)
또는 함수형 API(완전히 임의의 구조를 만들 수 있는 비순환 유향 그래프를 만듭니다)를 사용합니다.

Sequential 클래스를 사용하여 정의한 2개의 층으로 된 모델을 다시 보겠습니다(첫 번째 층에 입력 데이터의 크기가 전달된 점을 주목하세요).
from keras import models
from keras import layers

model = models.Sequential()
model.add(layers.Dense(32, activation='relu', input_shape=(784,)))
model.add(layers.Dense(10, activation='softmax'))

같은 모델을 함수형 API를 사용하여 만들어 보겠습니다.
input_tensor = layers.Input(shape=(784,))
x = layers.Dense(32, activation='relu')(input_tensor)
output_tensor = layers.Dense(10, activation='softmax')(x)

model = models.Model(inputs=input_tensor, outputs=output_tensor)

함수형 API를 사용하면 모델이 처리할 데이터 텐서를 만들고 마치 함수처럼 이 텐서에 층을 적용합니다.
노트_ 함수형 API에 대한 자세한 가이드는 7장에 있습니다. 7장까지는 Sequential 클래스를 사용하여 예제를 만듭니다.

모델 구조가 정의된 후에는 Sequential 모델을 사용했는지 함수형 API를 사용했는지는 상관없습니다. 이후 단계는 동일합니다.

컴파일 단계에서 학습 과정이 설정됩니다. 여기에서 모델이 사용할 옵티마이저와 손실 함수, 훈련하는 동안 모니터링하기 위해 필요한 측정 지표를 지정합니다. 
다음이 하나의 손실 함수를 사용하는 가장 흔한 경우의 예입니다.
from keras import optimizers

model.compile(optimizer=optimizers.RMSprop(lr=0.001),
              loss='mse',
              metrics=['accuracy'])

마지막으로 입력 데이터의 넘파이 배열을 (그리고 이에 상응하는 타깃 데이터를) 모델의 fit() 메서드에 전달함으로써 학습 과정이 이루어집니다. 
이는 사이킷런Scikit-Learn이나 몇몇 다른 머신 러닝 라이브러리에서 하는 방식과 비슷합니다.
model.fit(input_tensor, target_tensor, batch_size=128, epochs=10)

다음 몇 개의 장에서 여러 네트워크 구조가 각기 다른 문제에 어떻게 적용되는지, 
어떻게 적합한 학습 설정을 선택하는지, 만족할 만한 결과를 얻기 위해 어떻게 모델을 수정하는지 설명하겠습니다. 
3.4절, 3.5절, 3.6절에서 이진 분류, 다중 분류, 회귀에 대한 기초적인 세 가지 예를 살펴보겠습니다.

3-2.케라스 모델 저장하고 불러오기
케라스에서는 save() 함수 하나로 모델 아키텍쳐와 모델 가중치를 h5 파일 형식으로 모두 저장할 수 있다.

모델 저장 소스코드 (MNIST DATA)
# 0. 사용할 패키지 불러오기
from tensorflow.python.keras.utils import np_utils
from tensorflow.python.keras.datasets import mnist
from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense,Activation
import numpy as np
from numpy import argmax

# 1. 데이터셋 준비하기

# Training set과 Test set 불러오기
(x_train,y_train),(x_test,y_test) = mnist.load_data()

# Dataset Preprocessing
x_train = x_train.reshape(60000,784).astype('float32') / 255.0
x_test = x_test.reshape(10000,784).astype('float32') / 255.0

# Label data one-hot encoding
y_train = np_utils.to_categorical(y_train)
y_test = np_utils.to_categorical(y_test)

# Training set과 Validation set 분리
x_val = x_train[:42000]
y_val = y_train[:42000]
x_train = x_train[42000:] #훈련 셋의 30%를 검증 셋으로 사용
y_train = y_train[42000:]

# 2. 모델 구성하기
model = Sequential()
model.add(Dense(units=64,input_dim=28*28,activation='relu'))
model.add(Dense(units=10,activation='softmax'))

# 3. 모델 학습과정 설정하기
model.compile(loss='categorical_crossentropy',optimizer = 'sgd',metrics=['accuracy'])

# 4. 모델 학습시키기
from tensorflow.python.keras.callbacks import EarlyStopping
early_stopping = EarlyStopping(patience=20)
hist = model.fit(x_train,y_train,epochs=1000, batch_size=10, validation_data=(x_val,y_val),callbacks=[early_stopping])

# 5. 학습 과정 살펴보기
%matplotlib inline
import matplotlib.pyplot as plt

fig, loss_ax = plt.subplots()

acc_ax = loss_ax.twinx()

loss_ax.plot(hist.history['loss'],'y',label='train loss')
loss_ax.plot(hist.history['val_loss'],'r',label='val loss')
acc_ax.plot(hist.history['acc'],'b',label='train acc')
acc_ax.plot(hist.history['val_acc'],'g',label='val acc')

loss_ax.set_xlabel('epoch')
loss_ax.set_ylabel('loss')
acc_ax.set_ylabel('accuracy')

loss_ax.legend(loc='upper left')
acc_ax.legend(loc='lower left')
plt.show()

# 6. 모델 평가하기
loss_and_metrics = model.evaluate(x_test,y_test,batch_size=32)

print('##### Test Result #####')
print('loss : ',str(loss_and_metrics[0]))
print('Accuracy : ',str(loss_and_metrics[1]))

# 7. 모델 저장하기
from tensorflow.python.keras.models import load_model
model.save('mnist_mlp_model.h5')


위 코드를 돌리고 나면 파일"mnist_mlp_model.h5"(0.41MB)이 생성된다.
저장된 파일은 아래의 정보를 담고 있다.
- 나중에 모델을 재구성하기 위한 모델의 구성 정보
- 모델을 구성하는 각 뉴런들의 가중치
- 손실함수, 최적화하기 등의 학습 설정
- 재학습을 할 수 있도록 마지막 학습 상태

해당 모델의 아키텍쳐를 보려면 model_to_dot() 함수를 이용하면 가시화할 수 있다.
from IPython.display import SVG
from tensorflow.python.keras.utils.vis_utils import model_to_dot

%matplotlib inline

SVG(model_to_dot(model,show_shapes=True).create(prog='dot',format='svg'))


저장된 모델을 불러와 test하는 코드 )
# 0. 사용할 패키지 불러오기
from tensorflow.python.keras.utils import np_utils
from tensorflow.python.keras.datasets import mnist
from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense, Activation
import numpy as np
from numpy import argmax

# 1. 실무에 사용할 데이터 준비하기
(x_train,y_train),(x_test,y_test)=mnist.load_data()
x_test = x_test.reshape(10000,784).astype('float32') / 255.0
y_test = np_utils.to_categorical(y_test)
xhat_idx = np.random.choice(x_test.shape[0],5)
xhat = x_test[xhat_idx]

# 2. Model 불러오기
from tensorflow.python.keras.models import load_model
model = load_model('mnist_mlp_model.h5')

# 3. Model 사용하기
yhat = model.predict_classes(xhat)

for i in range(5):
    print('True : ',str(argmax(y_test[xhat_idx[i]])),', Predict : ',str(yhat[i]))

위 코드를 실행하면 파일로부터 모델 아키텍쳐와 모델 가중치를 재구성한 모델의 결과가 잘 나오는 것을 확인 할 수 있다.
* predict_classes함수는 Sequential 기반 모델에서만 사용가능하다. 

3-3.케라스 C++로 구현
cf)	머신러닝/딥러닝을 쉽게 실행해보기 위해서는 라이브러리의 도움을 받아야 한다. 
라이브러리란 편하게 쓰라고 미리 만들어 놓은 함수들의 집합이다. 
머신러닝/딥러닝을 위한 라이브러리에는 텐서플로, 토치, 케라스, 카페, MXNet, 체이너, CNTK 등이 있다. 
그 중에서 최근 딥러닝 라이브러리 선호도 1, 2위가 바로 텐서플로(TensorFlow)와 케라스(Keras)라 칸다. 
텐서플로는 구글에서 만든 머신러닝 라이브러리다. 많은 사람들이 특히 텐서플로 라이브러리 좋아하는 이유는 늘 북적거리는 커뮤니티 덕분이라고. 
커뮤니티가 활발한 라이브러리는 실무에 적용했을 때 생기는 문제점 해결이나, 라이브러리 자체 버그에 대한 빠른 수정 등에 유리하다. 
한국의 텐서플로 커뮤니티에는 페이스북의 ‘TensorFlow KR’ 이 있다.

텐서플로 자체는 c++로 작성되었지만 다양한 언어를 지원한다. 
다만 파이썬(Python)을 최우선으로 지원, 대다수의 편의 기능이 파이썬 라이브러리로만 구현되어 있으므로 파이썬으로 개발하는 것이 가장 편리하다. 
케라스는 그 자체가 파이썬으로 구현된 라이브러리니 말할 것도 없다. 
텐서플로는 라이브러리들 중에서 가장 안정적인 성능을 보이고, 케라스는 가장 쉽다. 
애초에 케라스는 인공지능 엔진인 시애노를 편리하게 사용하려고 개발된 것이며, 이후 사용할 수 있는 엔진이 텐서플로, CNTK 등으로 늘어난 거라고 한다. 
케라스의 기본 엔진은 텐서플로. 이 책이 라이브러리로 케라스와 텐서플로를 선택한 이유를 이쯤 되면 누구나 알 수 있다. 
구구절절한 설명이 제일 적게 필요하면서 쓰기는 겁나 편하니까! 
저자는 딥러닝 프로젝트를 ‘비행’으로 표현하면서, 텐서플로를 목적지까지 빠르게 이동시켜주는 ‘비행기’, 
케라스를 비행기의 이륙시키고 정확한 지점까지의 도착을 책임지는 ‘파일럿’에 비유한다. 
라이브러리의 역할에 대한 이런 두리뭉술한 비유가 직관적으로 이해하는데 꽤 도움이 되었다.  
cf)	케라스로 만든 코드를 C++에서 쓸 수 있나요?
파이썬의 케라스로 학습을 실행한 다음 학습된 모델을
C++에서 불러와서 사용 할 수 있을까요?

파이썬에서 "*.h5"로 저장해서 이를 함수화 한 것을 C++에서
로드 한다면 다양하게 활용할 수 있을 것 같은데 어렵네요...

저도 해보지는 않았는데 가능하다고 들었습니다. 케라스 모델을 텐서플로로 변환하고, 텐서플로 C++ 버전으로 실행을 하는 것 같습니다.
답변 감사드립니다! C++ 버전이 있군요. 공부해 봐야겠네요. 감사합니다.


Input CatDogCNN::AddConvLayer(string idx, Scope scope, int in_channels, int out_channels, int filter_side, Input input)
{
	TensorShape sp({filter_side, filter_side, in_channels, out_channels});
	m_vars["W"+idx] = Variable(scope.WithOpName("W"), sp, DT_FLOAT);
	m_shapes["W"+idx] = sp;
	m_assigns["W"+idx+"_assign"] = Assign(scope.WithOpName("W_assign"), m_vars["W"+idx], XavierInit(scope, in_channels, out_channels, filter_side));
	sp = {out_channels};m_vars["B"+idx] = Variable(scope.WithOpName("B"), sp, DT_FLOAT);
	m_shapes["B"+idx] = sp;m_assigns["B"+idx+"_assign"] = Assign(scope.WithOpName("B_assign"), m_vars["B"+idx], Input::Initializer(0.f, sp));
	auto conv = Conv2D(scope.WithOpName("Conv"), input, m_vars["W"+idx], {1, 1, 1, 1}, "SAME");
	auto bias = BiasAdd(scope.WithOpName("Bias"), conv, m_vars["B"+idx]);
	auto relu = Relu(scope.WithOpName("Relu"), bias);return MaxPool(scope.WithOpName("Pool"), relu, {1, 2, 2, 1}, {1, 2, 2, 1}, "SAME");
}

3-4.OCR 숫자를 학습된 MNIST(mnist.hdf5) 데이터로 인식 시키기
결론 부터 말씀 드리면, 당황스럽지만 다소 재미있는 결과가 나왔습니다.
숫자 폰트를 기반으로 만든 이미지 문자(약 71%)를 대부분 맞출 것이라 생각했는데 결과는 예상 밖으로 
손으로 대충 적은 문자(약 98%)을 더 잘 예측했습니다. 깨끗하게 적은 숫자 데이터를 이 정도로 인식하지 못한다는 것은 굉장히 이상한 일입니다. 
그리고 실행 결과를 보면 8 그리고 9라는 글씨를 가장 많이 제대로 인식하지 못했습니다. 
아무래도 손글씨 8, 9과 폰트 8, 9이 잘 맞지 않는 모양입니다. 그럼 처음부터 폰트로 그린 이미지로 학습시켜보는 것은 어떨까요?
-> 실제 OCR폰트로 학습시키면 92%로 정확도가 올라감
cf)	OCR 숫자를 최신 Tesseract를(tesseract-ocr-w64-setup-v5.0.0-alpha.20200223.exe (64 bit) resp.)를 설치해서
		실행해 보아도 기존 하위버전 Tesseract 설치 환경에서 인식하는 것과 별반 차이 없음 확인
		ex)	GL00098213(깨끗한화면) 의 경우 ~6L00098213 으로 인식
				GL00098213(그림자가 진 화면) 의 경우 아예 인식하지 못함

###3-5.케라스 OCR인식(숫자) 예제(자신만의 숫자 이미지를 가지고 OCR(숫자) 을 인식시킴)
1)	결과:	실제 테스트 결과, 거의 100% 수준의 정확한 인식률 보임
		1)	아래 가) Train샘플유형을 가지고 Train 시킨 경우
				아래 샘플 이외의 아래 유형의 다른 이미지를 가지고(아래 유형처럼 다른 숫자 이미지가 약간 들어가 있는 경우) 
				Test해도 정확하게 OCR을 인식 함 
				가)	Train샘플유형 : 그림자가 진 숫자, 숫자 하단에 경계선이 보이는 경우, 숫자 이미지 내부에 다른 숫자 이미지가 약간 들어가 있는 경우 등

2)	Train 이미지 준비
		1)	cnn_sample3 폴더 내부에 0~9와 Test 폴더를 만들고
		2)	0 폴더에는 숫자 0에 대한 Train 이미지를 10개 넣음(이미지 사이즈가 서로 틀려도 상관 없음, 가급적 28x28pixels 보다 큰 이미지)
				..........................................................................................................................
				9 폴더에는 숫자 9에 대한 Train 이미지를 10개 넣음(이미지 사이즈가 서로 틀려도 상관 없음, 가급적 28x28pixels 보다 큰 이미지)
				cf)	0~9 폴더 각각에 들어가 있는 숫자 이미지 개수는 10이상으로 많으면 많을 수록 좋음
						단) 0~9 폴더 각각에 들어가는 숫자 이미지 개수는 동일해야 함
		3)	Test 폴더에는 0~9 폴더에 들어있는 숫자 이미지 말고 다른 숫자 이미지를 아무거나 저장 시킴

3)	makeimg_tranCNN2.py
import os, re, glob
import cv2
import numpy as np
from sklearn.model_selection import train_test_split  

groups_folder_path = './cnn_sample3/'
#categories = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
#              "A", "C", "D", "E", "F", "H", "J","K", "L", "M",
#              "N", "R", "S", "T", "X", "Y", "Z"] 
categories = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] 

num_classes = len(categories)  

image_w = 28
image_h = 28

X = []
Y = []  

for idex, categorie in enumerate(categories):
    label = [0 for i in range(num_classes)]
    label[idex] = 1
    image_dir = groups_folder_path + categorie + '/'  

    for top, dir, f in os.walk(image_dir):
        for filename in f:
            print(image_dir+filename)
            img = cv2.imread(image_dir+filename)                                            # 본 명령 실행 후 shape: (69, 71, 3), 69(행/Y축/높이), 71(열/X축/너비)
            img = cv2.resize(img, None, fx=image_w/img.shape[1], fy=image_h/img.shape[0])   # 본 명령 실행 후 shape: (28, 28, 3), ex)28/71 = 0.39(기존 너비 71인 것을 0.39를 곱해서 28로 변경함)
            X.append(img/256)
            Y.append(label) 

X = np.array(X)
Y = np.array(Y) 

X_train, X_test, Y_train, Y_test = train_test_split(X,Y)                    # train_test_split 의미 : X/Y에 들어 있는 데이터를 동일한 비율의 train / test로 자동으로 나눠줌 
#X_train, X_test, Y_train, Y_test = train_test_split(X,Y,test_size=0.1)
xy = (X_train, X_test, Y_train, Y_test) 

np.save("./img_data.npy", xy)



from keras.models import Sequential
from keras.layers import Dropout, Activation, Dense
from keras.layers import Flatten, Convolution2D, MaxPooling2D
from keras.models import load_model
import cv2 

X_train, X_test, Y_train, Y_test = np.load('./img_data.npy') 

model = Sequential()
model = Sequential()
#model.add(Convolution2D(16, 3, 3, border_mode='same', activation='relu', 
#                        input_shape=X_train.shape[1:])) 
##--    아래와 같이 설정해야지만 보다 더 정확한 모델이 만들어짐     --#
# fix
model.add(Convolution2D(32, 5, 5, border_mode='same', activation='relu', 
                        input_shape=X_train.shape[1:])) 
# fix
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))  

model.add(Convolution2D(64, 3, 3,  activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25)) 

model.add(Convolution2D(64, 3, 3))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))  

model.add(Flatten())
model.add(Dense(256, activation = 'relu'))
model.add(Dropout(0.5))
model.add(Dense(num_classes,activation = 'softmax'))  

model.compile(loss='binary_crossentropy',optimizer='Adam',metrics=['accuracy'])
model.fit(X_train, Y_train, batch_size=32, nb_epoch=100) 

model.save('Gersang.h5')
		
4)	loadModel_testModel2.py						
import os, re, glob
import cv2
import numpy as np
import shutil
from numpy import argmax
from keras.models import load_model 

#categories = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
#              "A", "C", "D", "E", "F", "H", "J","K", "L", "M",
#              "N", "R", "S", "T", "X", "Y", "Z"] 
categories = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] 

def Dataization(img_path):
    image_w = 28
    image_h = 28
    img = cv2.imread(img_path)
    img = cv2.resize(img, None, fx=image_w/img.shape[1], fy=image_h/img.shape[0])
    return (img/256) 

src = []
name = []
test = []
#image_dir = "C:\\Users\\JSY\\Desktop\\python\\image\\num\\"
image_dir = './cnn_sample3/Test/'
for file in os.listdir(image_dir):
    if (file.find('.png') is not -1):
        src.append(image_dir + file)
        name.append(file)
        test.append(Dataization(image_dir + file)) 

test = np.array(test)
model = load_model('Gersang.h5')
predict = model.predict_classes(test) 

for i in range(len(test)):
    print(name[i] + " : , Predict : "+ str(categories[predict[i]]))

3-6.케라스 모델 Tensorflow에서 사용(How to export Keras .h5 to tensorflow .pb?)
1)	방법1(원본보완, 정상동작확인)
		cf)	아래 방법1(원본설명) 설명 방법을 참고해서 내가 수정해서 정상적으로 동작하는 방법
가)	First, add after your Keras code model.fit(...) and train your model: 
		# Keras model 생성 소스 최하단에 아래 명령을 추가시켜서 'keras_model.ckpt' 파일을 만듬

from keras import backend as K
import tensorflow as tf
print(model.output.op.name)
saver = tf.train.Saver()
saver.save(K.get_session(), 'keras_model.ckpt')

나)	C:\Users\user\AppData\Local\Programs\Python\Python37\Lib\site-packages\tensorflow\python\tools 폴더에 있는 freeze_graph.py 파일을 
		가)항 소스가 있는 폴더로 복사

다)	가)항 소스가 있는 폴더 -> Terminal 창에서 아래 명령 실행
		cf)	"dense_2/Softmax" 문구는 상기 가)항 실행시 출력된 문구(cf, print(model.output.op.name))
		python .\freeze_graph.py --input_meta_graph=.\keras_model.ckpt.meta --input_checkpoint=.\keras_model.ckpt --output_graph=.\keras_frozen.pb --output_node_names="dense_2/Softmax" --input_binary=true

cf)	방법1(원본설명)
The freeze_session method works fine. But compared to saving to a checkpoint file then using the freeze_graph tool 
that comes with TensorFlow seems simpler to me, as it's easier to maintain. All you need to do is the following two steps:

First, add after your Keras code model.fit(...) and train your model:
from keras import backend as K
import tensorflow as tf
print(model.output.op.name)
saver = tf.train.Saver()
saver.save(K.get_session(), '/tmp/keras_model.ckpt')

Then cd to your TensorFlow root directory, run:

python tensorflow/python/tools/freeze_graph.py \
--input_meta_graph=/tmp/keras_model.ckpt.meta \
--input_checkpoint=/tmp/keras_model.ckpt \
--output_graph=/tmp/keras_frozen.pb \
--output_node_names="<output_node_name_printed_in_step_1>" \
--input_binary=true

2)	방법2
Keras does not include by itself any means to export a TensorFlow graph as a protocol buffers file, 
but you can do it using regular TensorFlow utilities. 
Here is a blog post explaining how to do it using the utility script freeze_graph.py included in TensorFlow, which is the "typical" way it is done.

However, I personally find a nuisance having to make a checkpoint and then run an external script to obtain a model, 
and instead prefer to do it from my own Python code, so I use a function like this:

def freeze_session(session, keep_var_names=None, output_names=None, clear_devices=True):
    """
    Freezes the state of a session into a pruned computation graph.

    Creates a new computation graph where variable nodes are replaced by
    constants taking their current value in the session. The new graph will be
    pruned so subgraphs that are not necessary to compute the requested
    outputs are removed.
    @param session The TensorFlow session to be frozen.
    @param keep_var_names A list of variable names that should not be frozen,
                          or None to freeze all the variables in the graph.
    @param output_names Names of the relevant graph outputs.
    @param clear_devices Remove the device directives from the graph for better portability.
    @return The frozen graph definition.
    """
    graph = session.graph
    with graph.as_default():
        freeze_var_names = list(set(v.op.name for v in tf.global_variables()).difference(keep_var_names or []))
        output_names = output_names or []
        output_names += [v.op.name for v in tf.global_variables()]
        input_graph_def = graph.as_graph_def()
        if clear_devices:
            for node in input_graph_def.node:
                node.device = ""
        frozen_graph = tf.graph_util.convert_variables_to_constants(
            session, input_graph_def, output_names, freeze_var_names)
        return frozen_graph

Which is inspired in the implementation of freeze_graph.py. 
The parameters are similar to the script too. session is the TensorFlow session object. 
keep_var_names is only needed if you want to keep some variable not frozen (e.g. for stateful models), 
so generally not. output_names is a list with the names of the operations that produce the outputs that you want. 
clear_devices just removes any device directives to make the graph more portable. So, for a typical Keras model with one output, you would do something like:

from keras import backend as K

# Create, compile and train model...

frozen_graph = freeze_session(K.get_session(),
                              output_names=[out.op.name for out in model.outputs])

Then you can write the graph to a file as usual with tf.train.write_graph:
tf.train.write_graph(frozen_graph, "some_directory", "my_model.pb", as_text=False)

3)	방법3
The following simple example (XOR example) shows how to export Keras models (in both h5 format and pb format), and using the model in Python and C++:

가)	train.py:
import numpy as np
import tensorflow as tf

def freeze_session(session, keep_var_names=None, output_names=None, clear_devices=True):
    """
    Freezes the state of a session into a pruned computation graph.

    Creates a new computation graph where variable nodes are replaced by
    constants taking their current value in the session. The new graph will be
    pruned so subgraphs that are not necessary to compute the requested
    outputs are removed.
    @param session The TensorFlow session to be frozen.
    @param keep_var_names A list of variable names that should not be frozen,
                          or None to freeze all the variables in the graph.
    @param output_names Names of the relevant graph outputs.
    @param clear_devices Remove the device directives from the graph for better portability.
    @return The frozen graph definition.
    """
    graph = session.graph
    with graph.as_default():
        freeze_var_names = list(set(v.op.name for v in tf.global_variables()).difference(keep_var_names or []))
        output_names = output_names or []
        output_names += [v.op.name for v in tf.global_variables()]
        input_graph_def = graph.as_graph_def()
        if clear_devices:
            for node in input_graph_def.node:
                node.device = ''
        frozen_graph = tf.graph_util.convert_variables_to_constants(
            session, input_graph_def, output_names, freeze_var_names)
        return frozen_graph

X = np.array([[0,0], [0,1], [1,0], [1,1]], 'float32')
Y = np.array([[0], [1], [1], [0]], 'float32')

model = tf.keras.models.Sequential()
model.add(tf.keras.layers.Dense(64, input_dim=2, activation='relu'))
model.add(tf.keras.layers.Dense(64, activation='relu'))
model.add(tf.keras.layers.Dense(64, activation='relu'))
model.add(tf.keras.layers.Dense(64, activation='relu'))
model.add(tf.keras.layers.Dense(1, activation='sigmoid'))

model.compile(loss='mean_squared_error', optimizer='adam', metrics=['binary_accuracy'])

model.fit(X, Y, batch_size=1, nb_epoch=100, verbose=0)

# inputs:  ['dense_input']
print('inputs: ', [input.op.name for input in model.inputs])

# outputs:  ['dense_4/Sigmoid']
print('outputs: ', [output.op.name for output in model.outputs])

model.save('./xor.h5')

frozen_graph = freeze_session(tf.keras.backend.get_session(), output_names=[out.op.name for out in model.outputs])
tf.train.write_graph(frozen_graph, './', 'xor.pbtxt', as_text=True)
tf.train.write_graph(frozen_graph, './', 'xor.pb', as_text=False)

나)	predict.py:
import numpy as np
import tensorflow as tf

model = tf.keras.models.load_model('./xor.h5')

# 0 ^ 0 =  [[0.01974997]]
print('0 ^ 0 = ', model.predict(np.array([[0, 0]])))

# 0 ^ 1 =  [[0.99141496]]
print('0 ^ 1 = ', model.predict(np.array([[0, 1]])))

# 1 ^ 0 =  [[0.9897714]]
print('1 ^ 0 = ', model.predict(np.array([[1, 0]])))

# 1 ^ 1 =  [[0.00406971]]
print('1 ^ 1 = ', model.predict(np.array([[1, 1]])))

다)	opencv-predict.py:
import numpy as np
import cv2 as cv

model = cv.dnn.readNetFromTensorflow('./xor.pb')

# 0 ^ 0 =  [[0.01974997]]
model.setInput(np.array([[0, 0]]), name='dense_input')
print('0 ^ 0 = ', model.forward(outputName='dense_4/Sigmoid'))

# 0 ^ 1 =  [[0.99141496]]
model.setInput(np.array([[0, 1]]), name='dense_input')
print('0 ^ 1 = ', model.forward(outputName='dense_4/Sigmoid'))

# 1 ^ 0 =  [[0.9897714]]
model.setInput(np.array([[1, 0]]), name='dense_input')
print('1 ^ 0 = ', model.forward(outputName='dense_4/Sigmoid'))

# 1 ^ 1 =  [[0.00406971]]
model.setInput(np.array([[1, 1]]), name='dense_input')
print('1 ^ 1 = ', model.forward(outputName='dense_4/Sigmoid'))

라)	predict.cpp:
#include <cstdlib>
#include <iostream>
#include <opencv2/opencv.hpp>

int main(int argc, char **argv)
{
    cv::dnn::Net net;

    net = cv::dnn::readNetFromTensorflow("./xor.pb");

    // 0 ^ 0 = [0.018541215]
    float x0[] = { 0, 0 };
    net.setInput(cv::Mat(1, 2, CV_32F, x0), "dense_input");
    std::cout << "0 ^ 0 = " << net.forward("dense_4/Sigmoid") << std::endl;

    // 0 ^ 1 = [0.98295897]
    float x1[] = { 0, 1 };
    net.setInput(cv::Mat(1, 2, CV_32F, x1), "dense_input");
    std::cout << "0 ^ 1 = " << net.forward("dense_4/Sigmoid") << std::endl;

    // 1 ^ 0 = [0.98810625]
    float x2[] = { 1, 0 };
    net.setInput(cv::Mat(1, 2, CV_32F, x2), "dense_input");
    std::cout << "1 ^ 0 = " << net.forward("dense_4/Sigmoid") << std::endl;

    // 1 ^ 1 = [0.010002014]
    float x3[] = { 1, 1 };
    net.setInput(cv::Mat(1, 2, CV_32F, x3), "dense_input");
    std::cout << "1 ^ 1 = " << net.forward("dense_4/Sigmoid") << std::endl;

    return EXIT_SUCCESS;
}

3-7.케라스 에러 해결 방법
1.	RuntimeError: Variable += value not supported. Use variable.assign_add(value) to modify the variable value and 
	variable = variable + value to get a new Tensor object.
	에러 발생하는 경우
	1)	해결방법
		loss += content_weight * content_loss(target_image_features, combination_features) 를
		loss = loss + content_weight * content_loss(target_image_features, combination_features) 와 같이 변경


4.	딥러닝예제
1.	표면 불량 검출 딥러닝 예제
	Deep-Learning-Approach-for-Surface-Defect-Detection-master
	1)	Windows OS에 파이썬 / Tensorflow 등이 설치된 환경에서
		https://github.com/Wslsdx/Deep-Learning-Approach-for-Surface-Defect-Detection 에서
		"Clone or download"로소스 파일 다운로드 받아서 "~\Deep-Learning-Approach-for-Surface-Defect-Detection-master" 폴더에 압축 품
	2)	https://www.vicos.si/Downloads/KolektorSDD -> DOWNLOAD로 KolektorSDD.zip 파일 다운 받아서
		"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\Datasets\KolektorSDD" 폴더에 압축 품
	3)	run.py 파일 수정
		DefaultParam = {
		....................................................
		#"data_dir": "../Datasets/KolektorSDD",  # ?据路?
		"data_dir": "./Datasets/KolektorSDD",  # ?据路?
		....................................................
	4)	"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\visualization\test" 내부 파일 모두 지움
	5)	"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master" 폴더상에서 CMD.EXE ->
		python run.py --test을 실행시켜서 표면불량검출 딥러닝 TEST 실행
		또는 run.py -> def main(): 함수를 아래와 같이 변경한 다음 Debug -> Start Debugging 을 실행시켜서 TEST 실행
		def main():
	    """
	
	    """
	    #?入默???
	    param=DefaultParam
	    #?命令行更新??
	    args = parse_arguments()
	    # temp, manual change
	    args.test = True
	#   args.train_segment = True
	#   args.train_decision = True
	    # temp
	    print('args =', args)
    
    
	6)	최종 불량검출 결과가
		"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\Log" 폴더와		
		"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\visualization\test" 폴더에 생성됨

		~log.txt
		->	"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\Datasets\KolektorSDD" 폴더상에서 
			"kos31"에서 "kos50" 폴더까지 총 20개 폴더 160개 파일(20개폴더 X 8개파일)에 대한 테스트 결과이며
			불량이 22개, 합격이 138개임
		[INFO]   2019-11-22 14:04:38,833    start testing
		[INFO]   2019-11-22 14:19:54,124     total number of samples = 160
		[INFO]   2019-11-22 14:19:54,124    positive = 22
		[INFO]   2019-11-22 14:19:54,124    negative = 138
		[INFO]   2019-11-22 14:19:54,124    TP = 21		(진정한 불량(Positive))
		[INFO]   2019-11-22 14:19:54,124    FP = 0
		[INFO]   2019-11-22 14:19:54,124    TN = 138	(진정한 정품(Negative))
		[INFO]   2019-11-22 14:19:54,124    FN = 1
		[INFO]   2019-11-22 14:19:54,155    the visualization saved in ./visualization/test
		
		cf)	"~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\Datasets\KolektorSDD" kos31~kos50 폴더상의 
			ex)	정상 이미지 파일인 Part2.jpg Part2_label.bmp 파일 모두를 오염시킨 이미지로 바꿔서 실행하면
				정상으로 출력되던 것이 불량으로 변경된 결과가 나옴
			cf)	def test(self):
				.................................................................
				if label_batch[i] == 1 and output_batch[i] == 1:    	# ex)	~Datasets/KolektorSDD/kos31 폴더 내부 Part1.jpg & Part1_label.bmp 파일 모두 결과가 1인 경우
					count_TP += 1		# 불량									- label_batch[i] == 1(Part1_label.bmp 파일 결과 1), output_batch[i] == 1(Part1.jpg 파일 결과 1)
					print("불량, count_TP={}, file_name={}".format(count_TP, file_name_batch))
				elif label_batch[i] == 1:
					count_FN += 1		# 약간불량
					print("약간불량, count_FN={}, file_name={}".format(count_FN, file_name_batch))
				elif output_batch[i] == 1:
					count_FP += 1		# 약간정상
					print("약간정상, count_FP={}, file_name={}".format(count_FP, file_name_batch))
				else:
					count_TN += 1		# 정상
					print("정상, count_TN={}, file_name={}".format(count_TN, file_name_batch))
				.................................................................

	7)	training the KolektorSDD, 학습훈련시 불량과 합격을 미리 알려주는 파일
		config.py 파일이며
		IMAGE_SIZE=[1280,512]
		#	학습훈련을 위해 표면불량 파일을(시료) 미리 알려주는 배열로
		#	-	제일 첫번째 ['5']의 뜻은 "~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\Datasets\KolektorSDD" 폴더의
		#		"kos01" 폴더 내부파일 중 Part5.jpg 파일이 불량이라는 뜻임
		#	-	4행9열 ['6', '7']의 뜻은 "~\Deep-Learning-Approach-for-Surface-Defect-Detection-master\Datasets\KolektorSDD" 폴더의
		#		"kos39" 폴더 내부파일 중 Part6.jpg & Part7.jpg 파일이 불량이라는 뜻임
		POSITIVE_KolektorSDD=[['5'], ['6'], ['2'], ['3'], ['5'], ['7'], ['1'], ['2'], ['6'], ['3'],
							  ['4'], ['5'], ['3'], ['7'], ['3'], ['5'], ['5'], ['3'], ['5'], ['4'],
						  	  ['5'], ['6'], ['6'], ['1'], ['4'], ['5'], ['0'], ['3'], ['0'], ['0'],
						 	  ['1'], ['2'], ['6'], ['0'], ['5'], ['3'], ['0'], ['0', '1'], ['6', '7'],['5'],
							  ['7'], ['3'], ['1'], ['6'], ['3'], ['7'], ['2'], ['5',], ['2'],['4']]

	8)	python run.py --train_segment
		python run.py --train_decision
		python run.py --train_total			# train_total = train_segment + train_decision

5.	knn 알고리즘의 장단점
				장점													단점
단순하고 효율적이다					모델을 생성하지 않아 특징과 클래스 간의
														관계를 이해하는 능력이 제약된다

기저 데이터 분포에 대한			적절한 k의 선택이 필요하다(하드코딩)
가정을 하지 않는다

훈련 단계가 빠르다					분류 단계가 느리다

														명목 특징 및 누락 데이터를 위한 추가
														처리가 필요하다

6.	dnn 알고리즘 C++ 예제
#include <opencv2/dnn.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui.hpp>

using namespace cv;
using namespace cv::dnn;

#include <iostream>
#include <cstdlib>
using namespace std;

const size_t inWidth = 300;
const size_t inHeight = 300;
const double inScaleFactor = 1.0;
const Scalar meanVal(104.0, 177.0, 123.0);

const char* about = "This sample uses Single-Shot Detector "
                    "(https://arxiv.org/abs/1512.02325) "
                    "with ResNet-10 architecture to detect faces on camera/video/image.\n"
                    "More information about the training is available here: "
                    "<OPENCV_SRC_DIR>/samples/dnn/face_detector/how_to_train_face_detector.txt\n"
                    ".caffemodel model's file is available here: "
                    "<OPENCV_SRC_DIR>/samples/dnn/face_detector/res10_300x300_ssd_iter_140000.caffemodel\n"
                    ".prototxt file is available here: "
                    "<OPENCV_SRC_DIR>/samples/dnn/face_detector/deploy.prototxt\n";

const char* params
    = "{ help           | false | print usage          }"
      "{ proto          |       | model configuration (deploy.prototxt) }"
      "{ model          |       | model weights (res10_300x300_ssd_iter_140000.caffemodel) }"
      "{ camera_device  | 0     | camera device number }"
      "{ video          |       | video or image for detection }"
      "{ min_confidence | 0.5   | min confidence       }";

int main(int argc, char** argv)
{
    CommandLineParser parser(argc, argv, params);

    if (parser.get<bool>("help"))
    {
        cout << about << endl;
        parser.printMessage();
        return 0;
    }

    String modelConfiguration = parser.get<string>("proto");
    String modelBinary = parser.get<string>("model");

    //! [Initialize network]
    dnn::Net net = readNetFromCaffe(modelConfiguration, modelBinary);
    //! [Initialize network]

    if (net.empty())
    {
        cerr << "Can't load network by using the following files: " << endl;
        cerr << "prototxt:   " << modelConfiguration << endl;
        cerr << "caffemodel: " << modelBinary << endl;
        cerr << "Models are available here:" << endl;
        cerr << "<OPENCV_SRC_DIR>/samples/dnn/face_detector" << endl;
        cerr << "or here:" << endl;
        cerr << "https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector" << endl;
        exit(-1);
    }

    VideoCapture cap;
    if (parser.get<String>("video").empty())
    {
        int cameraDevice = parser.get<int>("camera_device");
        cap = VideoCapture(cameraDevice);
        if(!cap.isOpened())
        {
            cout << "Couldn't find camera: " << cameraDevice << endl;
            return -1;
        }
    }
    else
    {
        cap.open(parser.get<String>("video"));
        if(!cap.isOpened())
        {
            cout << "Couldn't open image or video: " << parser.get<String>("video") << endl;
            return -1;
        }
    }

    for(;;)
    {
        Mat frame;
        cap >> frame; // get a new frame from camera/video or read image

        if (frame.empty())
        {
            waitKey();
            break;
        }

        if (frame.channels() == 4)
            cvtColor(frame, frame, COLOR_BGRA2BGR);

        //! [Prepare blob]
        Mat inputBlob = blobFromImage(frame, inScaleFactor,
                                      Size(inWidth, inHeight), meanVal, false, false); //Convert Mat to batch of images
        //! [Prepare blob]

        //! [Set input blob]
        net.setInput(inputBlob, "data"); //set the network input
        //! [Set input blob]

        //! [Make forward pass]
        Mat detection = net.forward("detection_out"); //compute output
        //! [Make forward pass]

        vector<double> layersTimings;
        double freq = getTickFrequency() / 1000;
        double time = net.getPerfProfile(layersTimings) / freq;

        Mat detectionMat(detection.size[2], detection.size[3], CV_32F, detection.ptr<float>());

        ostringstream ss;
        ss << "FPS: " << 1000/time << " ; time: " << time << " ms";
        putText(frame, ss.str(), Point(20,20), 0, 0.5, Scalar(0,0,255));

        float confidenceThreshold = parser.get<float>("min_confidence");
        for(int i = 0; i < detectionMat.rows; i++)
        {
            float confidence = detectionMat.at<float>(i, 2);

            if(confidence > confidenceThreshold)
            {
                int xLeftBottom = static_cast<int>(detectionMat.at<float>(i, 3) * frame.cols);
                int yLeftBottom = static_cast<int>(detectionMat.at<float>(i, 4) * frame.rows);
                int xRightTop = static_cast<int>(detectionMat.at<float>(i, 5) * frame.cols);
                int yRightTop = static_cast<int>(detectionMat.at<float>(i, 6) * frame.rows);

                Rect object((int)xLeftBottom, (int)yLeftBottom,
                            (int)(xRightTop - xLeftBottom),
                            (int)(yRightTop - yLeftBottom));

                rectangle(frame, object, Scalar(0, 255, 0));

                ss.str("");
                ss << confidence;
                String conf(ss.str());
                String label = "Face: " + conf;
                int baseLine = 0;
                Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &baseLine);
                rectangle(frame, Rect(Point(xLeftBottom, yLeftBottom - labelSize.height),
                                      Size(labelSize.width, labelSize.height + baseLine)),
                          Scalar(255, 255, 255), CV_FILLED);
                putText(frame, label, Point(xLeftBottom, yLeftBottom),
                        FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0,0,0));
            }
        }

        imshow("detections", frame);
        if (waitKey(1) >= 0) break;
    }

    return 0;
} // main

7.	Tensorflow 예제
0)	*.pb 파일로 export 하기
--------------------------------------------------------------------------------
학습된 Graph, 와 Weight 를 포함한 모델파일을 export 할 수 있습니다.

python ./runner.py --mode=export --ckpt=/tmp/MyClassifier

이렇게 하고나면, frozon.pb 와 optimized.pb 파일 두 개가 나옵니다.

optimized.pb 를 사용하시면 됩니다.

출처: https://crystalcube.co.kr/194 [유리상자 속 이야기]

1)	Tensorflow model 저장/불러오기
In (and after) TensorFlow version 0.11.0RC1

Save the model
w1 = tf.Variable(tf.truncated_normal(shape=[10]), name='w1')
w2 = tf.Variable(tf.truncated_normal(shape=[20]), name='w2')
tf.add_to_collection('vars', w1)
tf.add_to_collection('vars', w2)
saver = tf.train.Saver()
sess = tf.Session()
sess.run(tf.global_variables_initializer())
saver.save(sess, 'my-model')
# `save` method will call `export_meta_graph` implicitly.
# you will get saved graph files:my-model.meta

Restore the model
sess = tf.Session()
new_saver = tf.train.import_meta_graph('my-model.meta')
new_saver.restore(sess, tf.train.latest_checkpoint('./'))
all_vars = tf.get_collection('vars')
for v in all_vars:
    v_ = sess.run(v)
    print(v_)

2)	Tensorflow model 저장/불러오기2
In(and after) Tensorflow version 0.11: 

Save the model:
import tensorflow as tf

#Prepare to feed input, i.e. feed_dict and placeholders
w1 = tf.placeholder("float", name="w1")
w2 = tf.placeholder("float", name="w2")
b1= tf.Variable(2.0,name="bias")
feed_dict ={w1:4,w2:8}

#Define a test operation that we will restore
w3 = tf.add(w1,w2)
w4 = tf.multiply(w3,b1,name="op_to_restore")
sess = tf.Session()
sess.run(tf.global_variables_initializer())

#Create a saver object which will save all the variables
saver = tf.train.Saver()

#Run the operation by feeding input
print sess.run(w4,feed_dict)
#Prints 24 which is sum of (w1+w2)*b1 

#Now, save the graph
saver.save(sess, 'my_test_model',global_step=1000)


Restore the model: 
import tensorflow as tf

sess=tf.Session()    
#First let's load meta graph and restore weights
saver = tf.train.import_meta_graph('my_test_model-1000.meta')
saver.restore(sess,tf.train.latest_checkpoint('./'))


# Access saved Variables directly
print(sess.run('bias:0'))
# This will print 2, which is the value of bias that we saved


# Now, let's access and create placeholders variables and
# create feed-dict to feed new data

graph = tf.get_default_graph()
w1 = graph.get_tensor_by_name("w1:0")
w2 = graph.get_tensor_by_name("w2:0")
feed_dict ={w1:13.0,w2:17.0}

#Now, access the op that you want to run. 
op_to_restore = graph.get_tensor_by_name("op_to_restore:0")

print sess.run(op_to_restore,feed_dict)
#This will print 60 which is calculated 

8.	###Tensorflow CNN 구현하기(자신만의이미지사용)
1)	CNN_Number_Classification.py
''' ### Tensorflow CNN 구현하기(자신만의이미지사용) ###
    1.  MNIST 데이터셋을 사용한 숫자인식이 아닌
        자신만의 숫자샘플 이미지를 가지고 숫자 인식하는 소스 임
    2.  Python상에서 Tensorflow CNN을 가지고 숫자인식Training model을 생성/저장하고
    3.  이를 MFC상에서 cv::dnn을 사용해서 2번에서 생성한 model을 읽어들여서 숫자를 인식하는 소스 임
    4.  최종 테스트 결과, 아래와 같이 완벽한 인식 성능이 나옴
        숫자 0~9, 114개 Test sample 100% 정확하게 맞춘 Model Configuration
        - epoch = 39 , cost_val = 0.000404667
    5.  사용방법
        1)  train 폴더에 -> 0~9 폴더를 각각 만들고 -> 각각의 폴더에 각각의 숫자이미지 샘플을 집어 넣음(각각 10개씩)
        2)  train.txt 문서에 상기1)에서 생성한 이미지에 대한 파일명과 해당하는 label을 기입 함
        3)  CNN_Number_Classification.py을 실행시켜 'mnist_cnn.pb' 파일을 생성시킴(학습 완료된 Training 결과 저장 파일)
        4)  dnnmnist 폴더 안의 MFC 소스를 실행시켜 test폴더 안에 있는 숫자이미지를 제대로 인식하는지 확인
'''
import tensorflow as tf
import numpy as np
import random
import os
import matplotlib.pyplot as plt

import cv2
from tensorflow.python.framework import graph_util
from tensorflow.python.platform import gfile

### define      ###
IMG_H = 50
IMG_W = 50
IMG_C = 1


### Create of trainlist   ###
trainlist = []
with open('train.txt') as f:
    for line in f:
        tmp = line.strip().split()
        trainlist.append([tmp[0], tmp[1]])


### Reading function of sample   ###
def readimg(path):
#   img = plt.imread(path)          # plt.imread -> 0~1 float으로 읽어들임(각 픽셀당 DATA배열 : RGB 순서)
                                    # ex) img:[0:69]:00:[0:71]:00:[0:3]: -> 0: 0.93333334(R), 1:0.9372549(G), 2:0.94509804(B)
                                    #     cf) plt.imread 로 읽어 들인 첫번째 이미지의 경우 Width 71pixels, Height 69pixels 이고
                                    #         첫번째 픽셀(1pixel, 1pixel) 값은  0: 0.93333334(R), 1:0.9372549(G), 2:0.94509804(B) 임
                                    #     cf) 0: 0.93333334(R) = 238/255, 1:0.9372549(G) = 239/255, 2:0.94509804(B) = 241/255
    # Image Color 처리
#   img = cv2.imread(path)          # cv2.imread -> 0~255 integer로 읽어들임(각 픽셀당 DATA배열 : BGR 순서)
                                    # ex) img:[0:69]:00:[0:71]:00:[0:3]: -> 0: 241(B), 1:239(G), 2:238(R)   
                                    #     cf) cv2.imread 로 읽어 들인 첫번째 이미지의 경우 Width 71pixels, Height 69pixels 이고
                                    #         첫번째 픽셀(1pixel, 1pixel) 값은  0: 241(B), 1:239(G), 2:238(R) 임
    # Image Gray 처리
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)

    # resize & normalize 처리
    img2 = cv2.resize(img, dsize=(IMG_W, IMG_H))
    img3 = cv2.normalize(img2, None, 0, 255, cv2.NORM_MINMAX)
#    print('img.shape =',img.shape)      # img.shape = (69, 71, 3),     Image Color 처리 경우
#    print('img3.shape =',img3.shape)    # img2.shape = (50, 50, 3),    Image Color 처리 경우
#    print('img.shape =',img.shape)      # img.shape = (69, 71),     Image Gray 처리 경우
#    print('img3.shape =',img3.shape)    # img2.shape = (50, 50),    Image Gray 처리 경우
#    cv2.imshow('img', img)
#    cv2.imshow('img3', img3)
#    cv2.waitKey()
    # temp

    return img3

def batch(path, batch_size):
    img, label, paths = [], [], []
    for i in range(batch_size):
        # Image Color 처리
#       img.append(readimg(path[0][0])/255.)
        # Image Gray 처리
        img_temp = readimg(path[0][0])/255.
        img_temp2 = img_temp.reshape(IMG_W, IMG_H, 1)      # 가로 : 50, 세로 : 50, 흑백(1) 으로 차원 변경
        img.append(img_temp2)

        label.append(int(path[0][1]))
        path.append(path.pop(0))
        
    return img, label


### Model configuration ###
learning_rate = 0.001
num_class = 10                      # 최종 분류되어질 차원(숫자 0~9를 구별해야 하기 때문에 -> 10)

with tf.Graph().as_default() as g:
    X = tf.placeholder(tf.float32, [None, IMG_H, IMG_W, IMG_C])
    Y = tf.placeholder(tf.int32, [None])
    
    with tf.variable_scope('CNN'):
        '''
        def conv2d(inputs,
            filters,
            kernel_size,
            strides=(1, 1),
            padding='valid',
            data_format='channels_last',
            dilation_rate=(1, 1),
            activation=None,
            use_bias=True,
            kernel_initializer=None,
            bias_initializer=init_ops.zeros_initializer(),
            kernel_regularizer=None,
            bias_regularizer=None,
            activity_regularizer=None,
            kernel_constraint=None,
            bias_constraint=None,
            trainable=True,
            name=None,
            reuse=None):
            - Filter로 특징을 뽑아주는 layer

        ex) net = tf.layers.conv2d(X, 20, 3, (2, 2), padding='same', activation=tf.nn.relu)
            - X이미지를 입력으로 받음
            - 크기가 3x3(3번째인자 3) 커널로 구성된 필터가 20개이며, 가로/세로 2칸씩 이동하면서(4번째인자 (2, 2)) convolution 연산을 수행
            - padding='same'
              padding은 same 혹은 valid 값을 가지며
              same으로 설정하면 입력이미지 가장자리에 0값을 추가해주게 됨(출력이미지 사이즈가 입력이미지 사이즈와 동일)
              valid로 설정하면 패딩없이 원래이미지 그대로 convolution 연산을 수행함(유효한 영역만 출력이되며, 따라서 출력이미지 사이즈는 입력이미지 사이즈 보다 작음)
              중요) same으로 설정 시, 입력 이미지에 경계를 학습시키는 효과가 있음
        
        def max_pooling2d(inputs,
                  pool_size, strides,
                  padding='valid', data_format='channels_last',
                  name=None):
            - 사소한 변화를 무시해 주는 layer
              convolution layer의 출력이미지에서 주요값만 뽑아 작은 출력영상을 만듬
              이것은 지역적인 사소한 변화가 영향을 미치지 않도록 함
            - pool_size : 수직, 수평 축소 비율을 지정, (2, 2)이면 출력영상 크기는 입력영상 크기의 반으로 줄어듬

        def flatten(inputs, name=None, data_format='channels_last'):
            - 영상을 일차원으로 바꿔주는 layer
            - CNN에서 conv2d나 max_pooling2d를 반복적으로 거치면 주요 특징만 추출되고, 추출된 주요 특징은 전결합층에 전달되어 학습됨
              conv2d나 max_pooling2d는 주로 2차원 자료를 다루지만 전결합층에 전달하기 위해선 1차원 자료로 바꿔줘야 함
              이 때 사용되는 것이 flatten layer 임

        relu(Rectified Linear Unit)
            - 0보다 작으면 비활성화시키고 0보다 클 때 그 값에 비례한 값을 내놓는 것이다.
		    - ReLU의 구현도 max(0, x)의 형식으로 간단하게 쓸 수 있다.

        def softmax(logits, axis=None, name=None, dim=None):
            - 주로 output을 0~1 사이 값으로 정규화하여 주로 확률값으로 나타내는 경우에 사용하는 활성화 함수.
		      1) 입력을 0에서 1사이의 값으로 변환
		      2) 변환된 결과에 대해 합계가 1이 되도록 만들어 줌
        '''
        ### 숫자 0~9, 114개 Test sample 100% 정확하게 맞춘 Model Configuration  ###
        # - epoch = 39 , cost_val = 0.000404667
        net = tf.layers.conv2d(X, 32, [6, 6], padding='same', activation=tf.nn.relu)        # kernel_size = [6, 6]
        net = tf.layers.max_pooling2d(net, [2, 2], strides=2, padding='same')
        net = tf.layers.dropout(net, 0.25)

        net = tf.layers.conv2d(net, 64, [3, 3], padding='same', activation=tf.nn.relu)
        net = tf.layers.max_pooling2d(net, [2, 2], strides=2, padding='same')
        net = tf.layers.dropout(net, 0.25)

        # 하단 명령 추가하는 것이 확실히 좋음(ex, cost_val = 0.0012598321 -> cost_val = 0.000404667 으로 확실히 줄어듬)
        net = tf.layers.conv2d(net, 64, [3, 3])
        net = tf.layers.max_pooling2d(net, [2, 2], strides=2)
        net = tf.layers.dropout(net, 0.25)
        #

        net = tf.layers.flatten(net)
        net = tf.layers.dense(net, 256, activation=tf.nn.relu)
        net = tf.layers.dropout(net, 0.25)

        logits = tf.layers.dense(net, num_class, activation=None)
        final_tensor = tf.nn.softmax(logits, name='prob')        
        # fix

    with tf.variable_scope('Loss'):
        loss = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels= Y, logits=logits))

    train = tf.train.AdamOptimizer(learning_rate).minimize(loss)
    saver = tf.train.Saver()
    print('final_tensor.name =',final_tensor.name)        # CNN/prob:0


### Training    ###
batch_size = 100                    # train, 10(숫자0~9) x 10개(각숫자당10개sample)
training_epochs = 40

#with tf.Session() as sess:
with tf.Session(graph=g) as sess:
    sess.run(tf.global_variables_initializer())

    print('Start learning!')
    for epoch in range(training_epochs):
        # trainlist에 있는 정보를 가지고 batch_size 개수 만큼 이미지data와 이미지label을 각각 읽어 들여서 batch_data(각각 이미지 data), batch_label(각각 이미지 label) list에 저장 시킴
        batch_data, batch_label = batch(trainlist, batch_size)

        # Training 시작
        _, cost_val = sess.run([train, loss], feed_dict = {X: batch_data, Y: batch_label})
        
        print('epoch =', epoch, ', cost_val =', cost_val)

    print('Finished learning!') 

    # 학습 완료된 Training 결과 저장, Freeze variables and save pb file
    output_graph_def = graph_util.convert_variables_to_constants(
        sess, sess.graph_def, ['CNN/prob'])
#       sess, sess.graph_def, ['CNN/dense/BiasAdd'])
    with gfile.FastGFile('mnist_cnn.pb', 'wb') as f:
        f.write(output_graph_def.SerializeToString())

    print('Save done of mnist_cnn.pb!')

2)	main.cpp(MFC 소스)
/*	### Tensorflow CNN 구현하기(자신만의이미지사용) ###
	1.  MNIST 데이터셋을 사용한 숫자인식이 아닌
		자신만의 숫자샘플 이미지를 가지고 숫자 인식하는 소스 임
	2.  Python상에서 Tensorflow CNN을 가지고 숫자인식Training model을 생성 / 저장하고
	3.  이를 MFC상에서 cv::dnn을 사용해서 2번에서 생성한 model을 읽어들여서 숫자를 인식하는 소스 임
	4.  최종 테스트 결과, 아래와 같이 완벽한 인식 성능이 나옴
		숫자 0~9, 114개 Test sample 100 % 정확하게 맞춘 Model Configuration
		- epoch = 39, cost_val = 0.000404667
	5.  사용방법
		1)  train 폴더에 -> 0~9 폴더를 각각 만들고->각각의 폴더에 각각의 숫자이미지 샘플을 집어 넣음(각각 10개씩)
		2)  train.txt 문서에 상기1)에서 생성한 이미지에 대한 파일명과 해당하는 label을 기입 함
		3)  CNN_Number_Classification.py을 실행시켜 'mnist_cnn.pb' 파일을 생성시킴(학습 완료된 Training 결과 저장 파일)
		4)  dnnmnist 폴더 안의 MFC 소스를 실행시켜 test폴더 안에 있는 숫자이미지를 제대로 인식하는지 확인	*/

#include "opencv2/opencv.hpp"
#include <iostream>

#define IMG_H	50
#define IMG_W	50

using namespace cv;
using namespace cv::dnn;
using namespace std;


void  print_matInfo(string name, Mat m)   	// 행렬의 정보와 원소 출력 함수
{
	string mat_type;
	if (m.depth() == CV_8U)	 		mat_type = "CV_8U";
	else if (m.depth() == CV_8S)	mat_type = "CV_8S";
	else if (m.depth() == CV_16U) 	mat_type = "CV_16U";
	else if (m.depth() == CV_16S)	mat_type = "CV_16S";
	else if (m.depth() == CV_32S) 	mat_type = "CV_32S";
	else if (m.depth() == CV_32F)	mat_type = "CV_32F";
	else if (m.depth() == CV_64F)	mat_type = "CV_64F";

	cout << name << " 크기 " << m.size() << ", ";
	cout << " 자료형 " << mat_type << "C" << m.channels() << endl;
	cout << m << endl << endl;
}

int main()
{
	Net net = readNet("../mnist_cnn.pb");

	if (net.empty()) {
		cerr << "Network load failed!" << endl;
		return -1;
	}

	Mat img;
	Mat img2;
	vector<cv::String> filenames;
	glob("../test/*.png", filenames, false);

//	vector<Mat> images;
	int count = filenames.size();		// number of png files in images folder

	for (int i = 0; i < count; i++)
	{
//		images.push_back(imread(filenames[i]));
//		img = imread(filenames[i], IMREAD_COLOR);
		img = imread(filenames[i], IMREAD_GRAYSCALE);
		normalize(img, img2, 0, 255, NORM_MINMAX);
//		print_matInfo("img2", img2);										// img 크기[71 x 69], 자료형 CV_8UC3
																			// [241, 239, 238, 240, 238, 237, 240, 238, 237, 240, 238, 237, 240, 238, 237, 240, 238, 237, 240, 238, 237, 240, 238, 237,

		/** @brief Creates 4-dimensional blob from image. Optionally resizes and crops @p image from center,
		 *  subtract @p mean values, scales values by @p scalefactor, swap Blue and Red channels.
		 *  @param image input image (with 1-, 3- or 4-channels).
		 *  @param size spatial size for output image
		 *  @param mean scalar with mean values which are subtracted from channels. Values are intended
		 *  to be in (mean-R, mean-G, mean-B) order if @p image has BGR ordering and @p swapRB is true.
		 *  @param scalefactor multiplier for @p image values.
		 *  @param swapRB flag which indicates that swap first and last channels
		 *  in 3-channel image is necessary.
		 *  @param crop flag which indicates whether image will be cropped after resize or not
		 *  @param ddepth Depth of output blob. Choose CV_32F or CV_8U.
		 *  @details if @p crop is true, input image is resized so one side after resize is equal to corresponding
		 *  dimension in @p size and another one is equal or larger. Then, crop from the center is performed.
		 *  If @p crop is false, direct resize without cropping and preserving aspect ratio is performed.
		 *  @returns 4-dimensional Mat with NCHW dimensions order.
		 *
		 *	CV_EXPORTS_W Mat blobFromImage(InputArray image, double scalefactor = 1.0, const Size & size = Size(),
		 *		const Scalar & mean = Scalar(), bool swapRB = false, bool crop = false,
		 *		int ddepth = CV_32F);	*/
//		Mat blob = blobFromImage(img, 1/255.f, Size(IMG_W, IMG_H), Scalar(), true, true);
		Mat blob = blobFromImage(img2, 1 / 255.f, Size(IMG_W, IMG_H), Scalar(), false, true);
//		cout << "blob =" << endl << blob << endl << endl;

		net.setInput(blob);
		Mat prob = net.forward();

		double maxVal;
		Point maxLoc;
		minMaxLoc(prob, NULL, &maxVal, NULL, &maxLoc);
		int digit = maxLoc.x;

		cout << filenames[i] << ", "<< digit << " (" << maxVal * 100 << "%)" << endl;

		imshow("img", img);
		imshow("img2", img2);
		waitKey(0);
	}

	return 0;
}

9.	###neural-style-transfer / 이미지를 딥러닝이 변환시켜주는 예제
1)	neural-style-transfer.zip 다운로드(https://www.pyimagesearch.com/2018/08/27/neural-style-transfer-with-opencv/)
2)	압축풀기
3)	python .\neural_style_transfer.py --image .\images\giraffe.jpg --model .\models\instance_norm\mosaic.t7 와 같이 프로그램 실행
	cf)	위조방지패턴으로 사용하기 적당
		python .\neural_style_transfer.py --image .\images\img9.png --model .\models\eccv16\the_wave.t7
		python .\neural_style_transfer.py --image .\images\img9.png --model .\models\instance_norm\mosaic.t7


[111]	biscuit pc
1.	Windows 7까지만 지원하고 그 이상의 pc에서는 Blue screen 발생하면서 재부팅되는 에러 발생 함
2.	C:\Program Files (x86)\INTERPARK biscuit\INTERPARK eBook Viewer 폴더 내부
		모든 *.exe 파일 속성을 아래와 같이 변경하면 재부팅되는 에러 발생하지 않음
		1)	호환모드 : Windows7
		2)	설정 : [v] 관리자 권한으로 이 프로그램 실행
		3)	로그인 되어 있으면 로그아웃상태로 만든 다음
				다시 로그인 시켜서 실행시켜야 함


[112]	네모인사이트, NEMOIN
0.	법인카드 결제
		결제방법 -> 법인카드 -> BC카드 -> 페이북 -> 기타결제 -> 등록결제하기 -> ISP선택 : 네모인(4140-***) 
		-> 기업법인카드결제PW : 110400, cf) 기업법인카드PW : 1104
1.	서버
		1)	실서버 id/pw
				https://nemoinsight.com/adm
				ID: admin
				PW: ahfmwl88

				새로운 비밀번호
				spah!ehsRktm88
				한글로
				네모!돈까스88

		2)	개발서버
//				https://172.16.1.94:62/adm/
//				ID: admin
//				PW: ahfmwl88 

				http://172.16.1.93:62/adm
				새로운 비밀번호
				ahfmWlaksdksek!88
				한글로
				모르찌만안다!88

				http://192.168.0.24:62/adm/
				ID: admin
				PW: 네모인싸!88

		3)	실서버 / 개발서버 
				PW: 정품인쯩!77
				    wjdvnadlsWmd!77

		4)	코어리소스 추가
				고객 정보 관리
				상품 관리	->	등록/수정	->	인증 구분	->	NEMO IN 선택	->	오른쪽 "NEMO IN 정보" 항목 활성화	->	"NEMO IN 정보" 항목 누름	->	각 항목 보임(등록/수정)

		cf)	GVC
				GVC 와이파이/ 스캔저장서버주소
				\\172.16.0.20
		
		cf)	서버 원격 접속
			가)	https://anydesk.com 설치
			나)	접속주소(?) : 479146527
			다)	암호 : nemoin1114

1+1.mac Mini(iOS)
	1)	Development
		ID: develop@nemoinsight.com
		PW: Nemo1104
	2)	mac mini
		PW: nemo1114 (키체인 암호)
	3)	VirtualBox
		Pw: 1234

2.	다양한 트릴코드 형식
		http://www.qwertysystem.co.kr/bizdemo12376/04/sub_04.php?com_board_basic=read_form&com_board_idx=3

3.	GVC(서현빌딩)
		1.	발급 아이디 :   C6 / 비밀번호 :   0210  (아이디 대문자!)
		2.	스캔 경우
				1)	스캔할 문서 프린터 상단에 올려 놓음
				2)	스캔 후 공유폴더 선택
				3)	스캔 버튼 누름
				4)	윈도우 실행창
						\\172.16.0.20
						nfsroot 폴더 클릭

3+1.서초지웰타워(사무실 기기 이용안내(프린터,스캔,팩스))
http://192.168.0.24:8990/tutorial
1)	스캔
	가)	스캔종이 올리기
	나)	스캔 버튼 누름
	다)	컴퓨터 버튼 누름
		컴퓨터 선택
	라)	시작 -> 실행
		\\192.168.0.24\Users\nemo\Pictures
		nemo
		nemoin1114

4.	NemoIn 안드로이드 소스 환경 설정
		1)	OpenCV-android-sdk(opencv4.2.0정상동작확인완료).zip 파일을
				E:/Project/OpenCV-android-sdk 폴더에 압축 풀어 놓음
		2)	CMakeLists.txt 수정
				#include_directories(C:/cvwork/OpenCV-android-sdk/sdk/native/jni/include/)
				include_directories(E:/Project/OpenCV-android-sdk/sdk/native/jni/include/)

				# set_target_properties(lib_opencv PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/JniLibs/${ANDROID_ABI}/libopencv_java3.so)
				# fix, opencv 4.2.0
				set_target_properties(lib_opencv PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/src/main/JniLibs/${ANDROID_ABI}/libopencv_java4.so)
				# fix
		3)	build.gradle 수정
				// '-DANDROID_STL=gnustl_static',
				// fix, opencv 4.2.0
				'-DANDROID_STL=c++_shared',
				// fix
		4)	libopencv_java4.so 파일을 아래 폴더 하단에 복사해 놓음
				E:\Project\ImageTag_Android\Program\NemoIn\app\src\main\jniLibs\arm64-v8a
				E:\Project\ImageTag_Android\Program\NemoIn\app\src\main\jniLibs\armeabi-v7a


[113]	Java/Web 개발
Java / Java script / Spring Boot / Spring Data JPA / Vue / MariaDB 개발

0.	Nemo Web source 분석(Vue -> DB Control(Java))
		1)	Nemo/adm/src/views/sys/User.vue
				// 저장
				save () {
				.....................................................................................
						if ('I' === this.inputForm.statu) {
							this.$axios.add(this.url, this.inputForm, this.formError, (result) => {
								this.$message({ type: 'success', message: this.$t('등록 성공') })
								this.dialogFormVisible = false
								this.search()
							})
				.....................................................................................

		2)	Nemo/adm/src/plugins/axios.js
				.....................................................................................
		    /** 추가 */
		    add (url, data, error, fun) {
		        this.showLoading()
		        
		        this.axios_
		            .post(url, data)
		            .then((res) => {
		            	this.axiosres(res, fun, error)
		            })
		            .catch((err) => {
		            	this.closeLoading()
		                console.log(err)
		            })
		    },
				.....................................................................................

		3)	NemoServe/src/main/java/nemo/beans/sys/user/UserCtl.java
				.....................................................................................
				@RestController
				@Transactional
				@RequestMapping("/user")
				public class UserCtl {
				
					public interface JVUserCommon {}
					public interface JVUser extends JVUserCommon, JVRoleCommon, JVBean {}
					
					@Autowired
					private UserSer ser;
					
					@Autowired
					private MngSer mngSer;
					
					@Autowired
					private RoleSer roleSer;
					
					
					/**
					 * 
					 * @param user
					 */
					@PostMapping
					public void post(@Validated({ ValidUser.class, ValidUserPw.class}) @RequestBody User user) {
						user.setPw(new BCryptPasswordEncoder().encode(user.getPw()));
						ser.save(user);				// 여기서 save는 특별하게 만든 메서드가 아닌 이미 Library에서 만들어져 있는 메서드임
					}
				.....................................................................................




		cf)	UserCtl.java -> UserSer.java -> UserRep.java

				UserCtl.java
				package nemo.beans.sys.user;
				
				import java.util.List;
				import java.util.Set;
				
				import javax.transaction.Transactional;
				
				import org.springframework.beans.BeanUtils;
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
				import org.springframework.util.ObjectUtils;
				import org.springframework.validation.annotation.Validated;
				import org.springframework.web.bind.annotation.DeleteMapping;
				import org.springframework.web.bind.annotation.GetMapping;
				import org.springframework.web.bind.annotation.PatchMapping;
				import org.springframework.web.bind.annotation.PathVariable;
				import org.springframework.web.bind.annotation.PostMapping;
				import org.springframework.web.bind.annotation.PutMapping;
				import org.springframework.web.bind.annotation.RequestBody;
				import org.springframework.web.bind.annotation.RequestMapping;
				import org.springframework.web.bind.annotation.RequestParam;
				import org.springframework.web.bind.annotation.RestController;
				
				import com.fasterxml.jackson.annotation.JsonView;
				
				import nemo.beans.Bean.JVBean;
				import nemo.beans.busi.mng.Mng;
				import nemo.beans.busi.mng.MngSer;
				import nemo.beans.sys.role.Role;
				import nemo.beans.sys.role.RoleCtl.JVRoleCommon;
				import nemo.beans.sys.role.RoleSer;
				import nemo.beans.sys.user.User.ValidUser;
				import nemo.beans.sys.user.User.ValidUserPw;
				
				
				/**
				 * 
				 * @author lby
				 *
				 */
				@RestController
				@Transactional
				@RequestMapping("/user")
				public class UserCtl {
				
					public interface JVUserCommon {}
					public interface JVUser extends JVUserCommon, JVRoleCommon, JVBean {}
					
					@Autowired
					private UserSer ser;
					
					@Autowired
					private MngSer mngSer;
					
					@Autowired
					private RoleSer roleSer;
					
					.....................................................................................
					
					/**
					 * 
					 * @param user
					 * @return List<User>
					 */
					@GetMapping
					@JsonView(JVUser.class)
					public List<User> search(User user) {
						return ser.findUserList(user);
					}

					.....................................................................................

				UserSer.java
				package nemo.beans.sys.user;
				
				import java.util.List;
				
				import javax.transaction.Transactional;
				
				import org.springframework.beans.factory.annotation.Autowired;
				import org.springframework.security.core.userdetails.UserDetails;
				import org.springframework.stereotype.Service;
				
				import nemo.beans.BeanSer;
				import nemo.conf.security.IUserSer;
				
				
				/**
				 * 
				 * @author lby
				 *
				 */
				@Service
				@Transactional
				public class UserSer extends BeanSer<User> implements IUserSer {
				
					@Autowired
					private UserRep rep;
					.....................................................................................
					/**
					 * 
					 * @param id
					 * @param nm
					 * @return List<User>
					 */
					public List<User> findUserList(String id) {
						return rep.findUserList(id);
					}
					.....................................................................................

				UserRep.java
				package nemo.beans.sys.user;

				import java.io.Serializable;
				import java.util.List;
				
				import org.springframework.data.jpa.repository.Query;
				import org.springframework.data.repository.query.Param;
				
				import nemo.beans.BeanRep;
				
				
				/**
				 * 
				 * @author lby
				 *
				 */
				public interface UserRep extends BeanRep<User, Serializable> {
					
					.....................................................................................
					/**
					 * 
					 * @param id
					 * @param nm
					 * @return List<User>
					 */
					@Query("SELECT user "
							+ "FROM User user "
							+ "WHERE user.id LIKE %:id% "
							+ "  AND user.nm LIKE %:id% "
							+ "ORDER BY user.nm "
					)
					public List<User> findUserList(
							@Param("id") String id);
					
					
				}
				


0+1.vue.js axios 통신 spring-boot
		jquery에서는 ajax가 있다면		
		vue에서는 axios가 있다고 한다. 
		디비의 데이터를 가져오기 위해 sring boot에서 어떤식으로 통신 해야 하나 멘붕이였는데 해결 함
		
		우선 처음에 시도했던 방식은 store.js에서 가져오려고 했다. 
		지금 시도하면 될 수도 있을 것 같다. 
		일단 나는 통신이 되기만 했으면 하는 바람이 젤 커서 가장 쉬운 방식으로 
		
		<template>
		  <div>
		    <h1>Beer List</h1>
		    <div v-for="test in beer" :key="test.id">
		      <h1>{{ test.title }}</h1>
		      <h2>{{ test.subtitle }}</h2>
		    </div>
		  </div>
		</template>
		
		
		<script>
		import axios from "axios";
		
		export default {
		  data() {
		    return {
		      beer: []
		    };
		  },
		  mounted() {
		    axios.get("http://localhost:8070/beer").then(response => {
		      //서버 돌리고 뷰도 돌려서 뷰쪽으로 들어가야 함
		      this.beer = response.data; //디비 에서 가져온 데이터를 beer 배열에 넣겠다.
		    });
		  }
		};
		</script>
			
		완전 단순하다. 
		mouted에서 axios를 사용해 컨트롤러를 불러 vue의 beer배열에 저장해서 띄우는 방식
		v-for 사용시 :key 안하면 안먹으니까 꼭 하자 
		v-for는 사용할 이름 in 객체 이름 식으로 해서 사용하면 된다. 
		
		디비도 세상 단순했다. 
		user_test
		Data
			test_id	test_title	test_subtitle
		1	1				title1			subsubsubsusbub		
		2	2				title2			여기 무슨 내용인가

		그럼 spring에서는 어떻게 가져왔느냥
		package com.example.naisDashboard.controller;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.http.HttpStatus;
		import org.springframework.http.ResponseEntity;
		import org.springframework.stereotype.Controller;
		import org.springframework.web.bind.annotation.CrossOrigin;
		import org.springframework.web.bind.annotation.RequestMapping;
		import org.springframework.web.bind.annotation.RequestMethod;
		import org.springframework.web.bind.annotation.ResponseBody;
		
		import com.example.naisDashboard.VO.Customer;
		import com.example.naisDashboard.repo.CustomerRepository;
		
		@Controller
		public class HomeController {
		
			@Autowired
			CustomerRepository repository;
		
			static Logger logger = LoggerFactory.getLogger(HomeController.class);
		
			@RequestMapping(value = "/", method = RequestMethod.GET)
			public String home() {
				logger.debug("Callling getAll()");
				return "index";
			}
		
		//추후에 security관련해서 config 파일을 설정해야 한다. 옆집 소쿠리네 봐야지 
			@CrossOrigin(origins = "http://localhost:8080") //이주소로 들어오는애를 허용하겠다는 뜻
			@RequestMapping(value = "/beer", method = RequestMethod.GET)
			@ResponseBody
			public ResponseEntity<List<Customer>> getAll() {
		
				logger.debug("beer?");
		
				List<Customer> list = new ArrayList<>();
				// CrudRepository의 인터페이스를 보면 findAll이라는 메소드가 있음.->모든 레코드 조회
				Iterable<Customer> customers = repository.findAll();
		
				// customers를 돌면서 list에 저장한다.
				customers.forEach(list::add);
		
				// 이 메소드 수행시 list를 body에 넣고 httpStatus메세지로 ok를 보낸다.
				return new ResponseEntity<List<Customer>>(list, HttpStatus.OK);
		
			}
		
		}
				
		컨트롤러인데 
		핵심은 @controller vue를 띄우려면 restcontroller말고 controller를 사용해야 한다고 한다. 
		@autowired도 잊지말자 

		package com.example.naisDashboard.repo;
		
		import java.util.List;
		
		import org.springframework.data.jpa.repository.Query;
		import org.springframework.data.repository.CrudRepository;
		import org.springframework.stereotype.Repository;
		
		import com.example.naisDashboard.VO.Customer;
		
		
		@Repository
		public interface CustomerRepository extends CrudRepository<Customer, Long>{//dao같은녀삭
			
			/*@Query
			List<Customer> findByName(String title);*/
			
			@Query(nativeQuery=true, value="select * from user_test")
			List<Customer> findAll();
			
		}
		repository인데 전부 가져오는 거 밖에 없다. 

		package com.example.naisDashboard.VO;
		
		import java.io.Serializable;
		
		import javax.persistence.Column;
		import javax.persistence.Entity;
		import javax.persistence.GeneratedValue;
		import javax.persistence.GenerationType;
		import javax.persistence.Id;
		import javax.persistence.Table;
		
		
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		import lombok.ToString;
		
		@Getter
		@Setter
		@Entity
		@ToString
		@NoArgsConstructor
		@Table(name="user_test")
		public class Customer implements Serializable{
			
			private static final long serialVersionUID = -3419499508172051782L;
		
			@Id
			@GeneratedValue(strategy = GenerationType.IDENTITY)
			@Column(name="test_id")	
			private Integer id;
			
			
			@Column(name="test_title")
			private String title;
		
			@Column(name="test_subtitle")
			private String subtitle;
			
			
			protected Customer(String title, String subtitle){
				this.title = title;
				this.subtitle = subtitle;
				
			}
		
		}
		
		객체 모델 이유는 모르겠으나 protected로 해야만 에러가 안난다.
		이유 아시면 댓글로 알려주세요.. 호롤로
	
		나는 스프링을 8070포트로 실행시킨후 
		뷰를 8080으로 실행하였다. 

		이제 본격적인 CRUD및 대시보드를 만들어야 겠다 .[출처] vue.js axios 통신 spring-boot|작성자 가삥





1.	요즘추세(가장 많이 사용하고 대기업/여러사람이 프로그램 할 때 독립적으로 개발가능한 방식)
		STS로 아래 사항에 대한 규격을 만들어 놓고
		하기 사항을 각각 프로그래밍 해서 각각 별도 환경에 넣어서 각각 독립적으로 실행 
		-	DB 처리			:	Java
		-	UI 처리			:	Java script
		-	TCP/IP통신	:	HTTP(Java script)

2.	JSP(개발자 혼자서 DB/UI/통신 기능을 JSP 언어 하나로 모두 프로그래밍 가능)
		옛날 개발 언어로 혼자서 모든 것을 다 할 수 있지만
		여러사람이 나눠서 각각 프로그램 할 수 없기 때문에
		요즘에는 거의 사용하지 않음

3.	axios, javascrip plugin
		웹 또는 앱을 개발하다 보면 거의 대부분이 서버가 필요하게 됩니다. 서버에 내용을 저장하고 웹이나 앱에서 서버의 저장된 내용을 불러다가 사용자에게 보여주게 되는데요. 
		이때 javascript에는 axios라는 아주 훌륭한 플러그인이 있습니다. 
		axios는 javascript용 플러그인으로 많이 사용하지만 Vue.js에서도 매우 요긴하게 사용되어 집니다. 
		
		axios는 Promise 기반의 자바스크립트 비동기 처리방식을 사용합니다. 그래서 요청후 .then()으로 결과값을 받아서 처리를 하는 형식으로 구성되어 있습니다. 
		axios.get('/api/data').then(res => {
		  console.log(res.data)
		})
		
		/api/data에서 데이터를 불러옵니다. 불러온 데이터는 .then()의 res에 담아서 처리하는 식입니다. 
		여기서는 간단하게 크롬브라우저의 Console화면에 결과값을 보여주게 처리되어 있습니다. 
		
		Vue.js 프로젝트에 axios 설치하기
		
		여기까지 찾아오셨다면 아마 nodejs는 이미 설치되어 있을 것이고 그러면 npm이나 yarn을 이용하여 axios를 설치하시면 될 것 같습니다. 설치하는 것은 매우 쉽습니다. 
		아래의 3가지 방법중 하나만 설치하거나 설정하면 됩니다. 
		1.npm 으로 설치하는 경우는 아래의 명령어를 Command창에 입력을 하면 됩니다. 
		 > npm install --save axios 
		2.yarn 으로 설치하는 경우는 아래의 명령어를 입력을 하면 됩니다. 
		 > yarn add axios 
		3.직접 웹페이지의 <HEAD></HEAD> 영역 안에 입력을 해도 됩니다. 
		 > <script src="https://unpkg.com/axios/dist/axios.min.js"></script> 
		
		axios 별칭으로 사용하기
		
		axios는 REST을 별칭을 이용해서 쉽게 통신을 할 수 있습니다. 
		?불러오기 : axios.get(url[, config])
		?입력하기 : axios.post(url[, data[, config]])
		?수정하기 : axios.patch(url[, data[, config]])
		?삭제하기 : axios.delete(url[, config])
		
		GET (불러오기)
		
		GET은 서버로 부터 데이터를 가져오는데 사용합니다. 아마도 가장많이 사용하는 명령어 일 것입니다. 
		서버 주소인 /api/data로 부터 값을 불러올 때 사용합니다. 
		axios.get('/api/data')
		  .then(res => {
		    // 불러온 값을 Console에 뿌려줍니다. 
		    console.log(res.data)
		  })
		
		axios 요청 시 파마메터 정보(/api/todos/1)를 같이 입력하여 정보를 얻어 올 수 있습니다. 위의 것이 리스트를 불러온다면 지금 아래의 요청은 하나의 상세정보를 불러온다고 보시면 됩니다. 
		axios.get('/api/data/1')
		  .then(res => {
		    console.log(`status code: ${res.status}`);
		    console.log(`headers: ${res.headers}`)
		    console.log(`data: ${res.data}`)
		  })
		
		axios 요청 시 파라메터 정보가 아니라 메소드의 두 번째 인자인 config 객체로 요청값을 넘길 수 있습니다. 
		axios.get('/api/data', {
		  params: { title: 'vue.js는 조으다.' },
		  headers: { 'X-Api-Key': 'my-api-key' },
		  timeout: 1000 // 1초 이내에 응답이 없으면 에러 처리
		}).then(res => {
		    console.log(res.data)
		  })
		
		POST (값 입력하기)
		
		/api/data에 값을 입력 할 때 사용합니다. 
		서버의 데이터 리스트의 마지막에 지금 넘기는 정보를 추가 합니다. 
		axios.post('/api/data', {title: "vue.js는 조으다."})
		  .then(res => {
		    console.log(res.data)
		  })
		
		PATCH (특정 값 수정하기)
		
		/api/data/3에 값을 입력 할 때 사용합니다. 
		서버의 데이터 리스트 중 3에 해당 하는 값의 title를 수정합니다. 
		axios.patch('/api/data/3', {title: "vue.js는 조으다."})
		  .then(res => {
		    console.log(res.data)
		  })
		
		DELETE (특정 값 삭제하기)
		
		/api/data/3에 값을 삭제 할 때 사용합니다. 
		서버의 데이터 리스트 중 3에 해당 하는 값을 삭제 합니다. 
		axios.delete('/api/data/3')
		  .then(res => {
		    console.log(res.data)
		  })
		
		axios로 파일 업로드 하기
		
		axios로 파일도 업로드 할 수 있습니다. 
		
		먼저 HTML로 아래와 같이 form문을 작성합니다. 
		
		HTML코드
		
		여기에서 ref="photoimage"는 중요한 역할을 하니 빼먹으면 안됩니다. 
		<form method="post" enctype="multipart/form-data" action="/contant/124/photo">
		  <input type="file" name="photo" ref="photoimage"> 
		  <input type="submit">
		</form>
		
		JAVASCRIPT 코드
		
		FormData() 객체를 생성하고 this.$refs.photoimage과 같이 ref옵션을 이용해서 필드에 직접 참조를 하여 이미지파일을 가져오고 업로드를 할 수 있습니다. 
		var data = new FormData();
		var file = this.$refs.photoimage.files[0];
		data.append('photo', file);
		
		axios.post('/api/data/' + this.no + '/photo', data)
		.then((res) => {
		  this.result = res.data;
		})
		.catch((ex) => {
		  console.log('사진업로드 실패', ex);
		});
			
		출처: https://ux.stories.pe.kr/138 [UX 공작소]


4.	스프링 부트란 무엇인가..
일단 나도 공부하고있는 입장이고하니 문제가 있다면 지적 바랍니다.

스프링 부트의 핵심은 메이븐은 pom.xml, 그레이들은 build.gradle 파일 내용에 따라 클래스 패스, 어노테이션, 기타 자바구성클래스를 보고
자동구성하는것입니다.

간혹 스프링부트와 스프링 프레임워크를 별개로 생각하시는분들이 존재하긴 하지만 별개가 아닙니다.

스프링 부트는 스프링이라는 자바 프레임워크의 프로젝트를 말하며 이를 사용하면 쉽게 애플리케이션을 만들 수 있습니다.
스프링 프레임워크는 2003년에 등장한것으로 기억하고 있습니다.
그때 당시만해도 J2EE 기반의 EJB 프로젝트와는 다르게 가볍게 동작하도록 제작된  프레임워크였으나 (경량성을 강조)
현재에 와서는 개발이 활발해지면서 점차 이녀석도 무거워졌습니다.

또한 지원해주는 라이브러리(하위 프로젝트)가 점차 늘어나서 방대해져서 초기 설정시 많은 어려움이 있었습니다.
예를들어 웹애플리케이션을 개발하고자 할때 어느 라이브러리를 추가해줘야하는건가?
초 중급 개발자로써는 너무 방대하기에 일일히 찾아보면서 하기에는 시간이 많이 걸리고 노하우가 필요한작업이였습니다.
유지보수 하기에는 좋은데 초기 개발 환경설정이 너무 힘들었습니다.

즉 스프링 부트는 자주 사용하는 프로젝트 조합을 미리 만들어놓아 스프링을 더욱 쉽고 간단하게 사용하기위해서 만들어졌습니다.

스프링 부트 특징
1. 자주사용하는 프로젝트 조합을 미리 만들어놨습니다.
일일히 라이브러리를 찾으면서 추가해줄필요없이 spring-boot-starter-web을 Maven 설정만해주면 관련라이브러리를 받아옵니다.

2. 설정을 자동으로 수행합니다.
@Enableautoconfiguratio  어노테이션의 같은경우 자동설정해주는 녀석으로 스프링부트의 마법이라고 불리웁니다.
비슷한 어노테이션으로 @SpringBootApplication 이 있는데 
 이것은 // @Configuration + @EnableAutoConfiguration + @ComponentScan 3가지 묶음으로 더욱 강력해진녀석입니다.

설정을 자동으로 수행한다.. 이게 이해가 좀 안가실수도 있는데 예로들자면
ex) @RequestMapping이 달려있는 모양새를 보고 스프링 부트는  spring-boot-starter-web 필요함을 알아채고 자동 설정합니다.

@Enableautoconfiguratio은 필요한 빈을 유추해서 구성하는 어노테이션(클래스) 자동구성 클래스는 클래스패스 및 앱에 정의한 빈에따라 적용여부가 결정되어
 META-INF/spring.factories라는 파일에 프로퍼티 형식으로 열거된 구성 클래스를 읽어 List 로 반환하여 자동 설정해주는 녀석입니다.
기존에 스프링프레임워크에서 필요했던 설정파일이 필요없게 되는거죠.. 

3. 서버를 포함하고 있습니다. 
Tomcat 내장서버를 포함하고 있어 SpringApplication.run(App.class, args); 명령어로 서버를 시작할수 있습니다.
기존에 톰캣을 설치하여 이클립스 연동하는작업이 없어졌습니다.

5.	Spring-Data-JPA란
-	ORM은 "관계형 데이터베이스의 구조화된 데이터와 자바와 같은 객체 지향 언어 간의 구조적 불일치를 어떻게 해소할 수 있을까"라는 질문에서 나온 객체-관계 매핑 프레임워크입니다.
	즉, 객체와 릴레이션을 매핑할 때 생기는 다양한 문제들을 해결할 수 있는 솔루션이라 생각하면 됩니다.

-	JPA은 ORM을 위한 자바 EE 표준이며 Spring-Data-JPA는 JPA를 쉽게 사용하기 위해 스프링에서 제공하고 있는 프레임워크입니다.

-	추상화 정도는 Spring-Data-JPA -> JPA -> Hibernate -> Datasource (왼쪽에서 오른쪽으로 갈수록 구체화) 입니다. 
	참고로, Hibernate는 ORM 프레임워크이며 DataSource는 스프링과 연결된 MySQL, PostgreSQL 같은 DB를 연결한 인터페이스입니다.

6.	Vue.js란
Evan You가 만들었으며, 2014년 릴리즈를 시작으로 꾸준히 발전하고 있는자바스크립트 프레임워크입니다.
컨트롤러 대신 뷰 모델을 가지는 MVVM(Model-View-ViewModel) 패턴을 기반으로 디자인되었으며,
재사용이 가능한 UI들을 묶어서 사용할 수 있습니다.

7.	MariaDB란
MySQL이 오라클로 넘어간 뒤, 불확실한 라이선스 문제를 해결하려고 나온 오픈 소스 DBMS. 2009년에 MySQL AB 출신 개발자들이 따로 나와 
MariaDB 재단을 세워서 개발하고 있다. MySQL이 오픈오피스라면 MariaDB는 리브레오피스 2013년 현재 기능적으로는 MySQL과 동일하며, 성능은 더 낫다. 
오라클로 인수된 뒤 MySQL 기능 추가가 제대로 이뤄지지 않고 있었다고.

구현 언어는 C++이며 2016년 3월 15일 기준 2,098,413줄의 코드로 이뤄져 있다. MariaDB에서 먼저 구현된 기능이 MySQL에도 반영되기도 한다는 듯.

초창기 버전인 MariaDB 5.5 버전은 MySQL 5.5 버전을 기반으로 포크했기 때문에 MySQL 5.5 버전과 거의 모든 기능이 호환된다. 
그 이후 나온 10.0 버전은 MySQL 5.6에서 업데이트된 기능을 반영한 버전이다. 10.1 버전은 MySQL 5.7에서 추가 및 변경된 기능을 반영하여 출시되었다. 
MySQL과의 호환성을 최대한 유지하면서 좀더 나은 성능을 구현하는 것이 주된 개발 방향인 듯하다. 
10.2부터는 MySQL의 개발 속도를 앞서나가서 오히려 이쪽 기능이 MySQL로 역수출되고 있는 실정이다.

예전에는 주요 배포판에서 MariaDB를 잘 사용하지 않아 MariaDB 측에서는 중요 배포본을 중심으로 자체 저장소를 운영하였고 현재도 운영중이다. 
?여기서 저장소를 어떻게 추가하여 설치하는지 알아볼 수 있지만, 현재 우분투, 페도라 등 메이저 배포판은 이미 MariaDB로 갈아탄 경우가 많으므로 
베타버전을 받고 싶은 유저들이 이용하면 좋다. 윈도우는 Download 페이지에 있는 msi 파일을 다운받아서 설치하면 된다.

점차 MySQL을 MariaDB로 대체해 가는 추세 덕분에 점유율은 가파르게 상승하고 있으며, MySQL을 지원하다가 MariaDB로 넘어간 업체들도 점점 많아지고 있다.


[114]	QR 코드
1.QR 오류복원레벨
	QR의 오류복원레벨이 높을수록 QR코드이미지가 더 많이 손상돼도 QR코드를 읽을 수 있음
	ex)  QR 오류복원레벨이 30%인 경우 QR코드이미지가 30% 손상돼도 QR코드를 읽을 수 있음
	      하지만 오류복원레벨이 높아질 수록 QR코드 내부에 들어가는 데이터가 많아지고
	      이는 QR코드 내부 픽셀사이즈가 작아질 수 밖에 없어 인식속도가 느려짐(카메라 성능이 나쁠 수록 QR인식이 안될 확률 높음)
	-> 요약, QR오류복원레벨이 높을수록 QR코드이미지가 많이 손상돼도 QR인식
	     하지만 QR내부 픽셀사이즈가 작아지기 때문에 카메라가 안 좋으면 인식이 안될 확률 높아짐
	-> 결론 : QR오류복원레벨은 일반적인 레벨M(15%)를 사용하자


[115]	Program source / 소스 프로그램 공유
1.	https://www.codeproject.com
	icbm12@hanmail.net
	h~g~

[116]	MATLAB https://kr.mathworks.com
1.	H..2..


[117]	YOLO
0.	YOLO model download
	https://github.com/AlexeyAB/darknet#pre-trained-models

1.	[중요]	아래 페이지는 GPU를 사용해서 deep SORT Tracking 기능이 제대로 구현되는 페이지 임
			여러 사람이 서로 합쳤다가 흩어지는 경우도 제대로 기존 사람 각각을 구분시켜서 분리 시켜 줌
	https://github.com/theAIGuysCode/yolov4-deepsort

	person-2, person-7, person-13, person-15, person-32, truck-5

	1.	상기 프로그램 구동 flow
		https://github.com/theAIGuysCode/yolov4-deepsort
		# Convert darknet weights to tensorflow model (모델 기본 환경 구성)
		python save_model.py --model yolov4 

		# Run yolov4 deep sort object tracker on video (아래 명령을 실행하면 test.mp4 동영상을 가지고 실제 tracking을 동작 시킴)
		python object_tracker.py --video ./data/video/test.mp4 --output ./outputs/demo.avi --model yolov4
		python object_tracker.py --video ./data/video/vtest.avi --output ./outputs/demo.avi --model yolov4

		cf)	SORT(Simple Online and Realtime Tracking) 알고리즘 설명
			https://mickael-k.tistory.com/48
		cf)	object_tracker.py 파일에 하기와 같이 이미 만들어진 mars-small128.pb 모델을 읽어들여서 deep sort tracking 알고리즘을 구동시키는 명령이 들어 있음
			.................................................................................
		    # initialize deep sort
			model_filename = 'model_data/mars-small128.pb'
			encoder = gdet.create_box_encoder(model_filename, batch_size=1)
			# calculate cosine distance metric
			metric = nn_matching.NearestNeighborDistanceMetric("cosine", max_cosine_distance, nn_budget)
			# initialize tracker
			tracker = Tracker(metric)
			.................................................................................
			cf)	mars-small128.pb 모델은 아래 사이트에서 만들어진 모델임			
				https://github.com/nwojke/deep_sort
				a)	Running the tracker
					아래 명령을 실행시켜 이미지파일들(./MOT16/test/MOT16-06) 을 가지고 학습시키며 학습 완료된 파일은 MOT16-06.npy 임
					cf)	이미지파일들(./MOT16/test/MOT16-06)은 아래 사이트에서 down 받음
						https://motchallenge.net/data/MOT16/ -> 맨 아래줄 Download -> Get all data(1.9GB)
					cf)	본 학습의 핵심 알고리즘은 kalman filter predict 이며
						kalman filter predict이 기본 원리는 영상들이 변해가는 것을 noise로 인식하며 본 noise가 어떤 방향성을 가지고 이동하는지 등을
						학습을 통해 쉽게 해결하는 모델을 만들어 냄
					python deep_sort_app.py \
					--sequence_dir=./MOT16/test/MOT16-06 \
					--detection_file=./resources/detections/MOT16_POI_test/MOT16-06.npy \
					--min_confidence=0.3 \
					--nn_budget=100 \
					--display=True

					python deep_sort_app.py --sequence_dir=./MOT16/test/MOT16-06 --detection_file=./resources/detections/MOT16_POI_test/MOT16-06.npy --min_confidence=0.3 --nn_budget=100 --display=True

				b)	Generating detections

					python tools/generate_detections.py \
						--model=resources/networks/mars-small128.pb \
						--mot_dir=./MOT16/train \
						--output_dir=./resources/detections/MOT16_train








	1)	Mutiple Object Tracking Benchmark(다양한 본 benchmark 용도의 동영상 저장되어 있음)
		https://motchallenge.net/data/MOT16/
	2

2.	Yolo_mark-master
가)	yolo-obj.cfg 상에서 아래 anchors 의미
[region]
anchors = 1.08,1.19,  3.42,4.41,  6.63,11.38,  9.42,5.11,  16.62,10.52

YOLO anchor 는 훈련하는 훈련셋 마다 다르게 정해진다. (디폴트 훈련셋은 PASECAL VOC 기반) ground truth 바운딩박스들의 너비와 높이를 정규화(normalize)하고 거기에 k-means 클러스터링을 해서, 5개의 값들을 얻는다.

최종값은 좌표가 아니라, 그리드기준 값이다. YOLO 디폴트 셋은:
anchors = 1.3221, 1.73145, 3.19275, 4.00944, 5.05587, 8.09892, 9.47112, 4.84053, 11.2364, 10.0071

이고, 이걸 다시 보면, 첫번째 anchor 인 [1.3221, 1.73145] 는 그리드셀 하나보다 조금 큰 것이고, 마지막 anchor 인 [11.2364, 10.0071] 는 거의 전체 이미지(13x13)를 차지하는 크기이다

출처: https://daewonyoon.tistory.com/299 [알락블록]

나)	Marking images 당, *.txt 파일에 쓰여 있는 속성 의미
ex)	0 0.429688 0.285417 0.178125 0.270833
	0 				0번째 label
	0.429688		영역으로 지정된 중심점 X좌표값
	0.285417		영역으로 지정된 중심점 Y좌표값
	0.178125		영역으로 지정된 width
	0.270833		영역으로 지정된 height

[118] 비전 vision
1.	COGNEX 계정
	icbm12@daum.net
	대 소 특수 숫자
2.	COGNEX Download
VisionPro 9.X各版本官方下载地址分享
2019-09-14 09:04:49 分类：工业视觉教程 作者：代码狗 阅读（3057）
重要：本文最后更新于2019-09-14 09:04:49，某些文章具有时效性，若有错误或已失效，请在下方留言或联系代码狗。
很多人说找不到在哪里下载VisionPro，官方下载需要注册，所以我把官方提供的9.x所有版本都分享出来，大家自行下载，文件来自康耐视的服务器，放心使用。本来打算一个版本写一篇，方便网友搜索的。但是内容太少了，所以还是一起发吧。

VISIONPRO
VISIONPRO

VisionPro 9.0 64位下载地址：

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_0_64-bit.zip

VisionPro 9.0 32位下载地址：

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_0_32-bit.zip

VisionPro 9.1 64位下载地址：

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_1_SR1_64-bit.zip

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_1_SR1_CR2_64-bit.zip

VisionPro 9.1 32位下载地址：

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_1_SR1_32-bit.zip

VisionPro 9.2 64位下载地址：


 
http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_2_CR1_64-bit.zip

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_2_SR1_64-bit.zip

VisionPro 9.3 64位下载地址：

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_3_SR1_64-bit.zip

VisionPro 9.5 64位下载地址：

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_5_64-bit.zip

http://www.cognex.com/support/downloads/ns/3/16/140/VisionPro_9_5_SR1_64-bit.zip

这些都是目前康耐视提供下载的VisionPro，如果你需要低版本如8.3请看：VisionPro8.3官方原版下载地址、Vision Pro8.2版官方原版下载无需加密狗

更早的版本好像已经不提供下载了。


[118]	C# OpenCV
1.	Data 변환
Mat -> System.Drawing.Bitmap
Mat mat = new Mat("foobar.jpg", LoadMode.Color);
Bitmap bitmap = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(mat);

System.Drawing.Bitmap -> Mat
Bitmap bitmap = new Bitmap("foobar.jpg");
Mat mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(bitmap);

Mat -> byte[]
Mat mat = new Mat("foobar.jpg", LoadMode.Color); 
byte[] bytes1 = mat.ToBytes(".png"); 
byte[] bytes2; 
Cv2.ImEncode(".jpg", mat, out bytes2);

byte[] -> Mat
byte[] imageData = System.IO.File.ReadAllBytes("foobar.jpg"); 
Mat colorMat = Mat.FromImageData(imageData, LoadMode.Color); 
Mat grayscaleMat = Mat.FromImageData(imageData, LoadMode.GrayScale); 
Mat alt = Cv2.ImDecode(imageData, LoadMode.GrayScale);


[119]	GitHub & Jira
1.	GitHub
- icbm12
- ~@naver.com
- h~2~
